webpackJsonp([2],{54:function(module,exports,__webpack_require__){eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function (mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(55));else if (typeof define == "function" && define.amd) // AMD\n    define(["../../lib/codemirror"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  "use strict";\n\n  function expressionAllowed(stream, state, backUp) {\n    return (/^(?:operator|sof|keyword c|case|new|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)))\n    );\n  }\n\n  CodeMirror.defineMode("javascript", function (config, parserConfig) {\n    var indentUnit = config.indentUnit;\n    var statementIndent = parserConfig.statementIndent;\n    var jsonldMode = parserConfig.jsonld;\n    var jsonMode = parserConfig.json || jsonldMode;\n    var isTS = parserConfig.typescript;\n    var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n    // Tokenizer\n\n    var keywords = function () {\n      function kw(type) {\n        return { type: type, style: "keyword" };\n      }\n      var A = kw("keyword a"),\n          B = kw("keyword b"),\n          C = kw("keyword c");\n      var operator = kw("operator"),\n          atom = { type: "atom", style: "atom" };\n\n      var jsKeywords = {\n        "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,\n        "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "throw": C, "debugger": C,\n        "var": kw("var"), "const": kw("var"), "let": kw("var"),\n        "function": kw("function"), "catch": kw("catch"),\n        "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),\n        "in": operator, "typeof": operator, "instanceof": operator,\n        "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,\n        "this": kw("this"), "class": kw("class"), "super": kw("atom"),\n        "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,\n        "await": C, "async": kw("async")\n      };\n\n      // Extend the \'normal\' keywords with the TypeScript language extensions\n      if (isTS) {\n        var type = { type: "variable", style: "variable-3" };\n        var tsKeywords = {\n          // object-like things\n          "interface": kw("class"),\n          "implements": C,\n          "namespace": C,\n          "module": kw("module"),\n          "enum": kw("module"),\n          "type": kw("type"),\n\n          // scope modifiers\n          "public": kw("modifier"),\n          "private": kw("modifier"),\n          "protected": kw("modifier"),\n          "abstract": kw("modifier"),\n\n          // operators\n          "as": operator,\n\n          // types\n          "string": type, "number": type, "boolean": type, "any": type\n        };\n\n        for (var attr in tsKeywords) {\n          jsKeywords[attr] = tsKeywords[attr];\n        }\n      }\n\n      return jsKeywords;\n    }();\n\n    var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;\n\n    function readRegexp(stream) {\n      var escaped = false,\n          next,\n          inSet = false;\n      while ((next = stream.next()) != null) {\n        if (!escaped) {\n          if (next == "/" && !inSet) return;\n          if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;\n        }\n        escaped = !escaped && next == "\\\\";\n      }\n    }\n\n    // Used as scratch variables to communicate multiple values without\n    // consing up tons of objects.\n    var type, content;\n    function ret(tp, style, cont) {\n      type = tp;content = cont;\n      return style;\n    }\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n      if (ch == \'"\' || ch == "\'") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } else if (ch == "." && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n        return ret("number", "number");\n      } else if (ch == "." && stream.match("..")) {\n        return ret("spread", "meta");\n      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        return ret(ch);\n      } else if (ch == "=" && stream.eat(">")) {\n        return ret("=>", "operator");\n      } else if (ch == "0" && stream.eat(/x/i)) {\n        stream.eatWhile(/[\\da-f]/i);\n        return ret("number", "number");\n      } else if (ch == "0" && stream.eat(/o/i)) {\n        stream.eatWhile(/[0-7]/i);\n        return ret("number", "number");\n      } else if (ch == "0" && stream.eat(/b/i)) {\n        stream.eatWhile(/[01]/i);\n        return ret("number", "number");\n      } else if (/\\d/.test(ch)) {\n        stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n        return ret("number", "number");\n      } else if (ch == "/") {\n        if (stream.eat("*")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        } else if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ret("comment", "comment");\n        } else if (expressionAllowed(stream, state, 1)) {\n          readRegexp(stream);\n          stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n          return ret("regexp", "string-2");\n        } else {\n          stream.eatWhile(isOperatorChar);\n          return ret("operator", "operator", stream.current());\n        }\n      } else if (ch == "`") {\n        state.tokenize = tokenQuasi;\n        return tokenQuasi(stream, state);\n      } else if (ch == "#") {\n        stream.skipToEnd();\n        return ret("error", "error");\n      } else if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return ret("operator", "operator", stream.current());\n      } else if (wordRE.test(ch)) {\n        stream.eatWhile(wordRE);\n        var word = stream.current(),\n            known = keywords.propertyIsEnumerable(word) && keywords[word];\n        return known && state.lastType != "." ? ret(known.type, known.style, word) : ret("variable", "variable", word);\n      }\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next;\n        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {\n          state.tokenize = tokenBase;\n          return ret("jsonld-keyword", "meta");\n        }\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) break;\n          escaped = !escaped && next == "\\\\";\n        }\n        if (!escaped) state.tokenize = tokenBase;\n        return ret("string", "string");\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n      while (ch = stream.next()) {\n        if (ch == "/" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        maybeEnd = ch == "*";\n      }\n      return ret("comment", "comment");\n    }\n\n    function tokenQuasi(stream, state) {\n      var escaped = false,\n          next;\n      while ((next = stream.next()) != null) {\n        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        escaped = !escaped && next == "\\\\";\n      }\n      return ret("quasi", "string-2", stream.current());\n    }\n\n    var brackets = "([{}])";\n    // This is a crude lookahead trick to try and notice that we\'re\n    // parsing the argument patterns for a fat-arrow function before we\n    // actually hit the arrow token. It only works if the arrow is on\n    // the same line as the arguments and there\'s no strange noise\n    // (comments) in between. Fallback is to only notice when we hit the\n    // arrow, and not declare the arguments as locals for the arrow\n    // body.\n    function findFatArrow(stream, state) {\n      if (state.fatArrowAt) state.fatArrowAt = null;\n      var arrow = stream.string.indexOf("=>", stream.start);\n      if (arrow < 0) return;\n\n      if (isTS) {\n        // Try to skip TypeScript return type declarations after the arguments\n        var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n        if (m) arrow = m.index;\n      }\n\n      var depth = 0,\n          sawSomething = false;\n      for (var pos = arrow - 1; pos >= 0; --pos) {\n        var ch = stream.string.charAt(pos);\n        var bracket = brackets.indexOf(ch);\n        if (bracket >= 0 && bracket < 3) {\n          if (!depth) {\n            ++pos;break;\n          }\n          if (--depth == 0) {\n            if (ch == "(") sawSomething = true;break;\n          }\n        } else if (bracket >= 3 && bracket < 6) {\n          ++depth;\n        } else if (wordRE.test(ch)) {\n          sawSomething = true;\n        } else if (/["\'\\/]/.test(ch)) {\n          return;\n        } else if (sawSomething && !depth) {\n          ++pos;\n          break;\n        }\n      }\n      if (sawSomething && !depth) state.fatArrowAt = pos;\n    }\n\n    // Parser\n\n    var atomicTypes = { "atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true };\n\n    function JSLexical(indented, column, type, align, prev, info) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.prev = prev;\n      this.info = info;\n      if (align != null) this.align = align;\n    }\n\n    function inScope(state, varname) {\n      for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;\n      for (var cx = state.context; cx; cx = cx.prev) {\n        for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true;\n      }\n    }\n\n    function parseJS(state, style, type, content, stream) {\n      var cc = state.cc;\n      // Communicate our context to the combinators.\n      // (Less wasteful than consing up a hundred closures on every call.)\n      cx.state = state;cx.stream = stream;cx.marked = null, cx.cc = cc;cx.style = style;\n\n      if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;\n\n      while (true) {\n        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n        if (combinator(type, content)) {\n          while (cc.length && cc[cc.length - 1].lex) cc.pop()();\n          if (cx.marked) return cx.marked;\n          if (type == "variable" && inScope(state, content)) return "variable-2";\n          return style;\n        }\n      }\n    }\n\n    // Combinator utils\n\n    var cx = { state: null, column: null, marked: null, cc: null };\n    function pass() {\n      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n    }\n    function cont() {\n      pass.apply(null, arguments);\n      return true;\n    }\n    function register(varname) {\n      function inList(list) {\n        for (var v = list; v; v = v.next) if (v.name == varname) return true;\n        return false;\n      }\n      var state = cx.state;\n      cx.marked = "def";\n      if (state.context) {\n        if (inList(state.localVars)) return;\n        state.localVars = { name: varname, next: state.localVars };\n      } else {\n        if (inList(state.globalVars)) return;\n        if (parserConfig.globalVars) state.globalVars = { name: varname, next: state.globalVars };\n      }\n    }\n\n    // Combinators\n\n    var defaultVars = { name: "this", next: { name: "arguments" } };\n    function pushcontext() {\n      cx.state.context = { prev: cx.state.context, vars: cx.state.localVars };\n      cx.state.localVars = defaultVars;\n    }\n    function popcontext() {\n      cx.state.localVars = cx.state.context.vars;\n      cx.state.context = cx.state.context.prev;\n    }\n    function pushlex(type, info) {\n      var result = function () {\n        var state = cx.state,\n            indent = state.indented;\n        if (state.lexical.type == "stat") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) indent = outer.indented;\n        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n      };\n      result.lex = true;\n      return result;\n    }\n    function poplex() {\n      var state = cx.state;\n      if (state.lexical.prev) {\n        if (state.lexical.type == ")") state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n      }\n    }\n    poplex.lex = true;\n\n    function expect(wanted) {\n      function exp(type) {\n        if (type == wanted) return cont();else if (wanted == ";") return pass();else return cont(exp);\n      };\n      return exp;\n    }\n\n    function statement(type, value) {\n      if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);\n      if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);\n      if (type == "keyword b") return cont(pushlex("form"), statement, poplex);\n      if (type == "{") return cont(pushlex("}"), block, poplex);\n      if (type == ";") return cont();\n      if (type == "if") {\n        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();\n        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);\n      }\n      if (type == "function") return cont(functiondef);\n      if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);\n      if (type == "variable") return cont(pushlex("stat"), maybelabel);\n      if (type == "switch") return cont(pushlex("form"), parenExpr, pushlex("}", "switch"), expect("{"), block, poplex, poplex);\n      if (type == "case") return cont(expression, expect(":"));\n      if (type == "default") return cont(expect(":"));\n      if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext);\n      if (type == "class") return cont(pushlex("form"), className, poplex);\n      if (type == "export") return cont(pushlex("stat"), afterExport, poplex);\n      if (type == "import") return cont(pushlex("stat"), afterImport, poplex);\n      if (type == "module") return cont(pushlex("form"), pattern, pushlex("}"), expect("{"), block, poplex, poplex);\n      if (type == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));\n      if (type == "async") return cont(statement);\n      return pass(pushlex("stat"), expression, expect(";"), poplex);\n    }\n    function expression(type) {\n      return expressionInner(type, false);\n    }\n    function expressionNoComma(type) {\n      return expressionInner(type, true);\n    }\n    function parenExpr(type) {\n      if (type != "(") return pass();\n      return cont(pushlex(")"), expression, expect(")"), poplex);\n    }\n    function expressionInner(type, noComma) {\n      if (cx.state.fatArrowAt == cx.stream.start) {\n        var body = noComma ? arrowBodyNoComma : arrowBody;\n        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n      }\n\n      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n      if (type == "function") return cont(functiondef, maybeop);\n      if (type == "class") return cont(pushlex("form"), classExpression, poplex);\n      if (type == "keyword c" || type == "async") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n      if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);\n      if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);\n      if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n      if (type == "{") return contCommasep(objprop, "}", null, maybeop);\n      if (type == "quasi") return pass(quasi, maybeop);\n      if (type == "new") return cont(maybeTarget(noComma));\n      return cont();\n    }\n    function maybeexpression(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expression);\n    }\n    function maybeexpressionNoComma(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expressionNoComma);\n    }\n\n    function maybeoperatorComma(type, value) {\n      if (type == ",") return cont(expression);\n      return maybeoperatorNoComma(type, value, false);\n    }\n    function maybeoperatorNoComma(type, value, noComma) {\n      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n      var expr = noComma == false ? expression : expressionNoComma;\n      if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n      if (type == "operator") {\n        if (/\\+\\+|--/.test(value)) return cont(me);\n        if (value == "?") return cont(expression, expect(":"), expr);\n        return cont(expr);\n      }\n      if (type == "quasi") {\n        return pass(quasi, me);\n      }\n      if (type == ";") return;\n      if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);\n      if (type == ".") return cont(property, me);\n      if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n    }\n    function quasi(type, value) {\n      if (type != "quasi") return pass();\n      if (value.slice(value.length - 2) != "${") return cont(quasi);\n      return cont(expression, continueQuasi);\n    }\n    function continueQuasi(type) {\n      if (type == "}") {\n        cx.marked = "string-2";\n        cx.state.tokenize = tokenQuasi;\n        return cont(quasi);\n      }\n    }\n    function arrowBody(type) {\n      findFatArrow(cx.stream, cx.state);\n      return pass(type == "{" ? statement : expression);\n    }\n    function arrowBodyNoComma(type) {\n      findFatArrow(cx.stream, cx.state);\n      return pass(type == "{" ? statement : expressionNoComma);\n    }\n    function maybeTarget(noComma) {\n      return function (type) {\n        if (type == ".") return cont(noComma ? targetNoComma : target);else return pass(noComma ? expressionNoComma : expression);\n      };\n    }\n    function target(_, value) {\n      if (value == "target") {\n        cx.marked = "keyword";return cont(maybeoperatorComma);\n      }\n    }\n    function targetNoComma(_, value) {\n      if (value == "target") {\n        cx.marked = "keyword";return cont(maybeoperatorNoComma);\n      }\n    }\n    function maybelabel(type) {\n      if (type == ":") return cont(poplex, statement);\n      return pass(maybeoperatorComma, expect(";"), poplex);\n    }\n    function property(type) {\n      if (type == "variable") {\n        cx.marked = "property";return cont();\n      }\n    }\n    function objprop(type, value) {\n      if (type == "async") {\n        cx.marked = "property";\n        return cont(objprop);\n      } else if (type == "variable" || cx.style == "keyword") {\n        cx.marked = "property";\n        if (value == "get" || value == "set") return cont(getterSetter);\n        return cont(afterprop);\n      } else if (type == "number" || type == "string") {\n        cx.marked = jsonldMode ? "property" : cx.style + " property";\n        return cont(afterprop);\n      } else if (type == "jsonld-keyword") {\n        return cont(afterprop);\n      } else if (type == "modifier") {\n        return cont(objprop);\n      } else if (type == "[") {\n        return cont(expression, expect("]"), afterprop);\n      } else if (type == "spread") {\n        return cont(expression);\n      } else if (type == ":") {\n        return pass(afterprop);\n      }\n    }\n    function getterSetter(type) {\n      if (type != "variable") return pass(afterprop);\n      cx.marked = "property";\n      return cont(functiondef);\n    }\n    function afterprop(type) {\n      if (type == ":") return cont(expressionNoComma);\n      if (type == "(") return pass(functiondef);\n    }\n    function commasep(what, end) {\n      function proceed(type, value) {\n        if (type == ",") {\n          var lex = cx.state.lexical;\n          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;\n          return cont(function (type, value) {\n            if (type == end || value == end) return pass();\n            return pass(what);\n          }, proceed);\n        }\n        if (type == end || value == end) return cont();\n        return cont(expect(end));\n      }\n      return function (type, value) {\n        if (type == end || value == end) return cont();\n        return pass(what, proceed);\n      };\n    }\n    function contCommasep(what, end, info) {\n      for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);\n      return cont(pushlex(end, info), commasep(what, end), poplex);\n    }\n    function block(type) {\n      if (type == "}") return cont();\n      return pass(statement, block);\n    }\n    function maybetype(type, value) {\n      if (isTS) {\n        if (type == ":") return cont(typeexpr);\n        if (value == "?") return cont(maybetype);\n      }\n    }\n    function typeexpr(type) {\n      if (type == "variable") {\n        cx.marked = "variable-3";return cont(afterType);\n      }\n      if (type == "{") return cont(commasep(typeprop, "}"));\n      if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType);\n    }\n    function maybeReturnType(type) {\n      if (type == "=>") return cont(typeexpr);\n    }\n    function typeprop(type) {\n      if (type == "variable" || cx.style == "keyword") {\n        cx.marked = "property";\n        return cont(typeprop);\n      } else if (type == ":") {\n        return cont(typeexpr);\n      }\n    }\n    function typearg(type) {\n      if (type == "variable") return cont(typearg);else if (type == ":") return cont(typeexpr);\n    }\n    function afterType(type, value) {\n      if (value == "<") return cont(commasep(typeexpr, ">"), afterType);\n      if (type == "[") return cont(expect("]"), afterType);\n    }\n    function vardef() {\n      return pass(pattern, maybetype, maybeAssign, vardefCont);\n    }\n    function pattern(type, value) {\n      if (type == "modifier") return cont(pattern);\n      if (type == "variable") {\n        register(value);return cont();\n      }\n      if (type == "spread") return cont(pattern);\n      if (type == "[") return contCommasep(pattern, "]");\n      if (type == "{") return contCommasep(proppattern, "}");\n    }\n    function proppattern(type, value) {\n      if (type == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n        register(value);\n        return cont(maybeAssign);\n      }\n      if (type == "variable") cx.marked = "property";\n      if (type == "spread") return cont(pattern);\n      if (type == "}") return pass();\n      return cont(expect(":"), pattern, maybeAssign);\n    }\n    function maybeAssign(_type, value) {\n      if (value == "=") return cont(expressionNoComma);\n    }\n    function vardefCont(type) {\n      if (type == ",") return cont(vardef);\n    }\n    function maybeelse(type, value) {\n      if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);\n    }\n    function forspec(type) {\n      if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);\n    }\n    function forspec1(type) {\n      if (type == "var") return cont(vardef, expect(";"), forspec2);\n      if (type == ";") return cont(forspec2);\n      if (type == "variable") return cont(formaybeinof);\n      return pass(expression, expect(";"), forspec2);\n    }\n    function formaybeinof(_type, value) {\n      if (value == "in" || value == "of") {\n        cx.marked = "keyword";return cont(expression);\n      }\n      return cont(maybeoperatorComma, forspec2);\n    }\n    function forspec2(type, value) {\n      if (type == ";") return cont(forspec3);\n      if (value == "in" || value == "of") {\n        cx.marked = "keyword";return cont(expression);\n      }\n      return pass(expression, expect(";"), forspec3);\n    }\n    function forspec3(type) {\n      if (type != ")") cont(expression);\n    }\n    function functiondef(type, value) {\n      if (value == "*") {\n        cx.marked = "keyword";return cont(functiondef);\n      }\n      if (type == "variable") {\n        register(value);return cont(functiondef);\n      }\n      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext);\n    }\n    function funarg(type) {\n      if (type == "spread") return cont(funarg);\n      return pass(pattern, maybetype, maybeAssign);\n    }\n    function classExpression(type, value) {\n      // Class expressions may have an optional name.\n      if (type == "variable") return className(type, value);\n      return classNameAfter(type, value);\n    }\n    function className(type, value) {\n      if (type == "variable") {\n        register(value);return cont(classNameAfter);\n      }\n    }\n    function classNameAfter(type, value) {\n      if (value == "extends" || value == "implements") return cont(isTS ? typeexpr : expression, classNameAfter);\n      if (type == "{") return cont(pushlex("}"), classBody, poplex);\n    }\n    function classBody(type, value) {\n      if (type == "variable" || cx.style == "keyword") {\n        if ((value == "static" || value == "get" || value == "set" || isTS && (value == "public" || value == "private" || value == "protected" || value == "readonly" || value == "abstract")) && cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false)) {\n          cx.marked = "keyword";\n          return cont(classBody);\n        }\n        cx.marked = "property";\n        return cont(isTS ? classfield : functiondef, classBody);\n      }\n      if (value == "*") {\n        cx.marked = "keyword";\n        return cont(classBody);\n      }\n      if (type == ";") return cont(classBody);\n      if (type == "}") return cont();\n    }\n    function classfield(type, value) {\n      if (value == "?") return cont(classfield);\n      if (type == ":") return cont(typeexpr, maybeAssign);\n      return pass(functiondef);\n    }\n    function afterExport(_type, value) {\n      if (value == "*") {\n        cx.marked = "keyword";return cont(maybeFrom, expect(";"));\n      }\n      if (value == "default") {\n        cx.marked = "keyword";return cont(expression, expect(";"));\n      }\n      return pass(statement);\n    }\n    function afterImport(type) {\n      if (type == "string") return cont();\n      return pass(importSpec, maybeFrom);\n    }\n    function importSpec(type, value) {\n      if (type == "{") return contCommasep(importSpec, "}");\n      if (type == "variable") register(value);\n      if (value == "*") cx.marked = "keyword";\n      return cont(maybeAs);\n    }\n    function maybeAs(_type, value) {\n      if (value == "as") {\n        cx.marked = "keyword";return cont(importSpec);\n      }\n    }\n    function maybeFrom(_type, value) {\n      if (value == "from") {\n        cx.marked = "keyword";return cont(expression);\n      }\n    }\n    function arrayLiteral(type) {\n      if (type == "]") return cont();\n      return pass(commasep(expressionNoComma, "]"));\n    }\n\n    function isContinuedStatement(state, textAfter) {\n      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n    }\n\n    // Interface\n\n    return {\n      startState: function (basecolumn) {\n        var state = {\n          tokenize: tokenBase,\n          lastType: "sof",\n          cc: [],\n          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n          localVars: parserConfig.localVars,\n          context: parserConfig.localVars && { vars: parserConfig.localVars },\n          indented: basecolumn || 0\n        };\n        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object") state.globalVars = parserConfig.globalVars;\n        return state;\n      },\n\n      token: function (stream, state) {\n        if (stream.sol()) {\n          if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;\n          state.indented = stream.indentation();\n          findFatArrow(stream, state);\n        }\n        if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (type == "comment") return style;\n        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n        return parseJS(state, style, type, content, stream);\n      },\n\n      indent: function (state, textAfter) {\n        if (state.tokenize == tokenComment) return CodeMirror.Pass;\n        if (state.tokenize != tokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0),\n            lexical = state.lexical,\n            top;\n        // Kludge to prevent \'maybelse\' from blocking lexical scope pops\n        if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n          var c = state.cc[i];\n          if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;\n        }\n        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))) lexical = lexical.prev;\n        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;\n        var type = lexical.type,\n            closing = firstChar == type;\n\n        if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n      },\n\n      electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n      blockCommentStart: jsonMode ? null : "/*",\n      blockCommentEnd: jsonMode ? null : "*/",\n      lineComment: jsonMode ? null : "//",\n      fold: "brace",\n      closeBrackets: "()[]{}\'\'\\"\\"``",\n\n      helperType: jsonMode ? "json" : "javascript",\n      jsonldMode: jsonldMode,\n      jsonMode: jsonMode,\n\n      expressionAllowed: expressionAllowed,\n      skipExpression: function (state) {\n        var top = state.cc[state.cc.length - 1];\n        if (top == expression || top == expressionNoComma) state.cc.pop();\n      }\n    };\n  });\n\n  CodeMirror.registerHelper("wordChars", "javascript", /[\\w$]/);\n\n  CodeMirror.defineMIME("text/javascript", "javascript");\n  CodeMirror.defineMIME("text/ecmascript", "javascript");\n  CodeMirror.defineMIME("application/javascript", "javascript");\n  CodeMirror.defineMIME("application/x-javascript", "javascript");\n  CodeMirror.defineMIME("application/ecmascript", "javascript");\n  CodeMirror.defineMIME("application/json", { name: "javascript", json: true });\n  CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });\n  CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });\n  CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });\n  CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvZGVtaXJyb3IvbW9kZS9qYXZhc2NyaXB0L2phdmFzY3JpcHQuanM/NGFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHA6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbiAobW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7ZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uIChDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGV4cHJlc3Npb25BbGxvd2VkKHN0cmVhbSwgc3RhdGUsIGJhY2tVcCkge1xuICAgIHJldHVybiAoL14oPzpvcGVyYXRvcnxzb2Z8a2V5d29yZCBjfGNhc2V8bmV3fFtcXFt7fVxcKCw7Ol18PT4pJC8udGVzdChzdGF0ZS5sYXN0VHlwZSkgfHwgc3RhdGUubGFzdFR5cGUgPT0gXCJxdWFzaVwiICYmIC9cXHtcXHMqJC8udGVzdChzdHJlYW0uc3RyaW5nLnNsaWNlKDAsIHN0cmVhbS5wb3MgLSAoYmFja1VwIHx8IDApKSlcbiAgICApO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiamF2YXNjcmlwdFwiLCBmdW5jdGlvbiAoY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0O1xuICAgIHZhciBzdGF0ZW1lbnRJbmRlbnQgPSBwYXJzZXJDb25maWcuc3RhdGVtZW50SW5kZW50O1xuICAgIHZhciBqc29ubGRNb2RlID0gcGFyc2VyQ29uZmlnLmpzb25sZDtcbiAgICB2YXIganNvbk1vZGUgPSBwYXJzZXJDb25maWcuanNvbiB8fCBqc29ubGRNb2RlO1xuICAgIHZhciBpc1RTID0gcGFyc2VyQ29uZmlnLnR5cGVzY3JpcHQ7XG4gICAgdmFyIHdvcmRSRSA9IHBhcnNlckNvbmZpZy53b3JkQ2hhcmFjdGVycyB8fCAvW1xcdyRcXHhhMS1cXHVmZmZmXS87XG5cbiAgICAvLyBUb2tlbml6ZXJcblxuICAgIHZhciBrZXl3b3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGt3KHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgc3R5bGU6IFwia2V5d29yZFwiIH07XG4gICAgICB9XG4gICAgICB2YXIgQSA9IGt3KFwia2V5d29yZCBhXCIpLFxuICAgICAgICAgIEIgPSBrdyhcImtleXdvcmQgYlwiKSxcbiAgICAgICAgICBDID0ga3coXCJrZXl3b3JkIGNcIik7XG4gICAgICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpLFxuICAgICAgICAgIGF0b20gPSB7IHR5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCIgfTtcblxuICAgICAgdmFyIGpzS2V5d29yZHMgPSB7XG4gICAgICAgIFwiaWZcIjoga3coXCJpZlwiKSwgXCJ3aGlsZVwiOiBBLCBcIndpdGhcIjogQSwgXCJlbHNlXCI6IEIsIFwiZG9cIjogQiwgXCJ0cnlcIjogQiwgXCJmaW5hbGx5XCI6IEIsXG4gICAgICAgIFwicmV0dXJuXCI6IEMsIFwiYnJlYWtcIjogQywgXCJjb250aW51ZVwiOiBDLCBcIm5ld1wiOiBrdyhcIm5ld1wiKSwgXCJkZWxldGVcIjogQywgXCJ0aHJvd1wiOiBDLCBcImRlYnVnZ2VyXCI6IEMsXG4gICAgICAgIFwidmFyXCI6IGt3KFwidmFyXCIpLCBcImNvbnN0XCI6IGt3KFwidmFyXCIpLCBcImxldFwiOiBrdyhcInZhclwiKSxcbiAgICAgICAgXCJmdW5jdGlvblwiOiBrdyhcImZ1bmN0aW9uXCIpLCBcImNhdGNoXCI6IGt3KFwiY2F0Y2hcIiksXG4gICAgICAgIFwiZm9yXCI6IGt3KFwiZm9yXCIpLCBcInN3aXRjaFwiOiBrdyhcInN3aXRjaFwiKSwgXCJjYXNlXCI6IGt3KFwiY2FzZVwiKSwgXCJkZWZhdWx0XCI6IGt3KFwiZGVmYXVsdFwiKSxcbiAgICAgICAgXCJpblwiOiBvcGVyYXRvciwgXCJ0eXBlb2ZcIjogb3BlcmF0b3IsIFwiaW5zdGFuY2VvZlwiOiBvcGVyYXRvcixcbiAgICAgICAgXCJ0cnVlXCI6IGF0b20sIFwiZmFsc2VcIjogYXRvbSwgXCJudWxsXCI6IGF0b20sIFwidW5kZWZpbmVkXCI6IGF0b20sIFwiTmFOXCI6IGF0b20sIFwiSW5maW5pdHlcIjogYXRvbSxcbiAgICAgICAgXCJ0aGlzXCI6IGt3KFwidGhpc1wiKSwgXCJjbGFzc1wiOiBrdyhcImNsYXNzXCIpLCBcInN1cGVyXCI6IGt3KFwiYXRvbVwiKSxcbiAgICAgICAgXCJ5aWVsZFwiOiBDLCBcImV4cG9ydFwiOiBrdyhcImV4cG9ydFwiKSwgXCJpbXBvcnRcIjoga3coXCJpbXBvcnRcIiksIFwiZXh0ZW5kc1wiOiBDLFxuICAgICAgICBcImF3YWl0XCI6IEMsIFwiYXN5bmNcIjoga3coXCJhc3luY1wiKVxuICAgICAgfTtcblxuICAgICAgLy8gRXh0ZW5kIHRoZSAnbm9ybWFsJyBrZXl3b3JkcyB3aXRoIHRoZSBUeXBlU2NyaXB0IGxhbmd1YWdlIGV4dGVuc2lvbnNcbiAgICAgIGlmIChpc1RTKSB7XG4gICAgICAgIHZhciB0eXBlID0geyB0eXBlOiBcInZhcmlhYmxlXCIsIHN0eWxlOiBcInZhcmlhYmxlLTNcIiB9O1xuICAgICAgICB2YXIgdHNLZXl3b3JkcyA9IHtcbiAgICAgICAgICAvLyBvYmplY3QtbGlrZSB0aGluZ3NcbiAgICAgICAgICBcImludGVyZmFjZVwiOiBrdyhcImNsYXNzXCIpLFxuICAgICAgICAgIFwiaW1wbGVtZW50c1wiOiBDLFxuICAgICAgICAgIFwibmFtZXNwYWNlXCI6IEMsXG4gICAgICAgICAgXCJtb2R1bGVcIjoga3coXCJtb2R1bGVcIiksXG4gICAgICAgICAgXCJlbnVtXCI6IGt3KFwibW9kdWxlXCIpLFxuICAgICAgICAgIFwidHlwZVwiOiBrdyhcInR5cGVcIiksXG5cbiAgICAgICAgICAvLyBzY29wZSBtb2RpZmllcnNcbiAgICAgICAgICBcInB1YmxpY1wiOiBrdyhcIm1vZGlmaWVyXCIpLFxuICAgICAgICAgIFwicHJpdmF0ZVwiOiBrdyhcIm1vZGlmaWVyXCIpLFxuICAgICAgICAgIFwicHJvdGVjdGVkXCI6IGt3KFwibW9kaWZpZXJcIiksXG4gICAgICAgICAgXCJhYnN0cmFjdFwiOiBrdyhcIm1vZGlmaWVyXCIpLFxuXG4gICAgICAgICAgLy8gb3BlcmF0b3JzXG4gICAgICAgICAgXCJhc1wiOiBvcGVyYXRvcixcblxuICAgICAgICAgIC8vIHR5cGVzXG4gICAgICAgICAgXCJzdHJpbmdcIjogdHlwZSwgXCJudW1iZXJcIjogdHlwZSwgXCJib29sZWFuXCI6IHR5cGUsIFwiYW55XCI6IHR5cGVcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIHRzS2V5d29yZHMpIHtcbiAgICAgICAgICBqc0tleXdvcmRzW2F0dHJdID0gdHNLZXl3b3Jkc1thdHRyXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ganNLZXl3b3JkcztcbiAgICB9KCk7XG5cbiAgICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP3x+Xl0vO1xuICAgIHZhciBpc0pzb25sZEtleXdvcmQgPSAvXkAoY29udGV4dHxpZHx2YWx1ZXxsYW5ndWFnZXx0eXBlfGNvbnRhaW5lcnxsaXN0fHNldHxyZXZlcnNlfGluZGV4fGJhc2V8dm9jYWJ8Z3JhcGgpXCIvO1xuXG4gICAgZnVuY3Rpb24gcmVhZFJlZ2V4cChzdHJlYW0pIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgbmV4dCxcbiAgICAgICAgICBpblNldCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgICBpZiAobmV4dCA9PSBcIi9cIiAmJiAhaW5TZXQpIHJldHVybjtcbiAgICAgICAgICBpZiAobmV4dCA9PSBcIltcIikgaW5TZXQgPSB0cnVlO2Vsc2UgaWYgKGluU2V0ICYmIG5leHQgPT0gXCJdXCIpIGluU2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXNlZCBhcyBzY3JhdGNoIHZhcmlhYmxlcyB0byBjb21tdW5pY2F0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aG91dFxuICAgIC8vIGNvbnNpbmcgdXAgdG9ucyBvZiBvYmplY3RzLlxuICAgIHZhciB0eXBlLCBjb250ZW50O1xuICAgIGZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQpIHtcbiAgICAgIHR5cGUgPSB0cDtjb250ZW50ID0gY29udDtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goL15cXGQrKD86W2VFXVsrXFwtXT9cXGQrKT8vKSkge1xuICAgICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goXCIuLlwiKSkge1xuICAgICAgICByZXR1cm4gcmV0KFwic3ByZWFkXCIsIFwibWV0YVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8udGVzdChjaCkpIHtcbiAgICAgICAgcmV0dXJuIHJldChjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiPVwiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICAgIHJldHVybiByZXQoXCI9PlwiLCBcIm9wZXJhdG9yXCIpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0uZWF0KC94L2kpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZGEtZl0vaSk7XG4gICAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiMFwiICYmIHN0cmVhbS5lYXQoL28vaSkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bMC03XS9pKTtcbiAgICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIwXCIgJiYgc3RyZWFtLmVhdCgvYi9pKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1swMV0vaSk7XG4gICAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlxcZCooPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy8pO1xuICAgICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uQWxsb3dlZChzdHJlYW0sIHN0YXRlLCAxKSkge1xuICAgICAgICAgIHJlYWRSZWdleHAoc3RyZWFtKTtcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL15cXGIoKFtnaW15dV0pKD8hW2dpbXl1XSpcXDIpKStcXGIvKTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwicmVnZXhwXCIsIFwic3RyaW5nLTJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcImBcIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICAgIHJldHVybiB0b2tlblF1YXNpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiByZXQoXCJlcnJvclwiLCBcImVycm9yXCIpO1xuICAgICAgfSBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAod29yZFJFLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSh3b3JkUkUpO1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCksXG4gICAgICAgICAgICBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpICYmIGtleXdvcmRzW3dvcmRdO1xuICAgICAgICByZXR1cm4ga25vd24gJiYgc3RhdGUubGFzdFR5cGUgIT0gXCIuXCIgPyByZXQoa25vd24udHlwZSwga25vd24uc3R5bGUsIHdvcmQpIDogcmV0KFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZVwiLCB3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgICBuZXh0O1xuICAgICAgICBpZiAoanNvbmxkTW9kZSAmJiBzdHJlYW0ucGVlaygpID09IFwiQFwiICYmIHN0cmVhbS5tYXRjaChpc0pzb25sZEtleXdvcmQpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgcmV0dXJuIHJldChcImpzb25sZC1rZXl3b3JkXCIsIFwibWV0YVwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIGJyZWFrO1xuICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXNjYXBlZCkgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSxcbiAgICAgICAgICBjaDtcbiAgICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVFbmQgPSBjaCA9PSBcIipcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQoXCJjb21tZW50XCIsIFwiY29tbWVudFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlblF1YXNpKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgbmV4dDtcbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCFlc2NhcGVkICYmIChuZXh0ID09IFwiYFwiIHx8IG5leHQgPT0gXCIkXCIgJiYgc3RyZWFtLmVhdChcIntcIikpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0KFwicXVhc2lcIiwgXCJzdHJpbmctMlwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICB9XG5cbiAgICB2YXIgYnJhY2tldHMgPSBcIihbe31dKVwiO1xuICAgIC8vIFRoaXMgaXMgYSBjcnVkZSBsb29rYWhlYWQgdHJpY2sgdG8gdHJ5IGFuZCBub3RpY2UgdGhhdCB3ZSdyZVxuICAgIC8vIHBhcnNpbmcgdGhlIGFyZ3VtZW50IHBhdHRlcm5zIGZvciBhIGZhdC1hcnJvdyBmdW5jdGlvbiBiZWZvcmUgd2VcbiAgICAvLyBhY3R1YWxseSBoaXQgdGhlIGFycm93IHRva2VuLiBJdCBvbmx5IHdvcmtzIGlmIHRoZSBhcnJvdyBpcyBvblxuICAgIC8vIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGFyZ3VtZW50cyBhbmQgdGhlcmUncyBubyBzdHJhbmdlIG5vaXNlXG4gICAgLy8gKGNvbW1lbnRzKSBpbiBiZXR3ZWVuLiBGYWxsYmFjayBpcyB0byBvbmx5IG5vdGljZSB3aGVuIHdlIGhpdCB0aGVcbiAgICAvLyBhcnJvdywgYW5kIG5vdCBkZWNsYXJlIHRoZSBhcmd1bWVudHMgYXMgbG9jYWxzIGZvciB0aGUgYXJyb3dcbiAgICAvLyBib2R5LlxuICAgIGZ1bmN0aW9uIGZpbmRGYXRBcnJvdyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuZmF0QXJyb3dBdCkgc3RhdGUuZmF0QXJyb3dBdCA9IG51bGw7XG4gICAgICB2YXIgYXJyb3cgPSBzdHJlYW0uc3RyaW5nLmluZGV4T2YoXCI9PlwiLCBzdHJlYW0uc3RhcnQpO1xuICAgICAgaWYgKGFycm93IDwgMCkgcmV0dXJuO1xuXG4gICAgICBpZiAoaXNUUykge1xuICAgICAgICAvLyBUcnkgdG8gc2tpcCBUeXBlU2NyaXB0IHJldHVybiB0eXBlIGRlY2xhcmF0aW9ucyBhZnRlciB0aGUgYXJndW1lbnRzXG4gICAgICAgIHZhciBtID0gLzpcXHMqKD86XFx3Kyg/OjxbXj5dKj58XFxbXFxdKT98XFx7W159XSpcXH0pXFxzKiQvLmV4ZWMoc3RyZWFtLnN0cmluZy5zbGljZShzdHJlYW0uc3RhcnQsIGFycm93KSk7XG4gICAgICAgIGlmIChtKSBhcnJvdyA9IG0uaW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aCA9IDAsXG4gICAgICAgICAgc2F3U29tZXRoaW5nID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBwb3MgPSBhcnJvdyAtIDE7IHBvcyA+PSAwOyAtLXBvcykge1xuICAgICAgICB2YXIgY2ggPSBzdHJlYW0uc3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICB2YXIgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2YoY2gpO1xuICAgICAgICBpZiAoYnJhY2tldCA+PSAwICYmIGJyYWNrZXQgPCAzKSB7XG4gICAgICAgICAgaWYgKCFkZXB0aCkge1xuICAgICAgICAgICAgKytwb3M7YnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgtLWRlcHRoID09IDApIHtcbiAgICAgICAgICAgIGlmIChjaCA9PSBcIihcIikgc2F3U29tZXRoaW5nID0gdHJ1ZTticmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYnJhY2tldCA+PSAzICYmIGJyYWNrZXQgPCA2KSB7XG4gICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgfSBlbHNlIGlmICh3b3JkUkUudGVzdChjaCkpIHtcbiAgICAgICAgICBzYXdTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKC9bXCInXFwvXS8udGVzdChjaCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoc2F3U29tZXRoaW5nICYmICFkZXB0aCkge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2F3U29tZXRoaW5nICYmICFkZXB0aCkgc3RhdGUuZmF0QXJyb3dBdCA9IHBvcztcbiAgICB9XG5cbiAgICAvLyBQYXJzZXJcblxuICAgIHZhciBhdG9taWNUeXBlcyA9IHsgXCJhdG9tXCI6IHRydWUsIFwibnVtYmVyXCI6IHRydWUsIFwidmFyaWFibGVcIjogdHJ1ZSwgXCJzdHJpbmdcIjogdHJ1ZSwgXCJyZWdleHBcIjogdHJ1ZSwgXCJ0aGlzXCI6IHRydWUsIFwianNvbmxkLWtleXdvcmRcIjogdHJ1ZSB9O1xuXG4gICAgZnVuY3Rpb24gSlNMZXhpY2FsKGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2LCBpbmZvKSB7XG4gICAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICAgIGlmIChhbGlnbiAhPSBudWxsKSB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5TY29wZShzdGF0ZSwgdmFybmFtZSkge1xuICAgICAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dCkgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGN4ID0gc3RhdGUuY29udGV4dDsgY3g7IGN4ID0gY3gucHJldikge1xuICAgICAgICBmb3IgKHZhciB2ID0gY3gudmFyczsgdjsgdiA9IHYubmV4dCkgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUpTKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKSB7XG4gICAgICB2YXIgY2MgPSBzdGF0ZS5jYztcbiAgICAgIC8vIENvbW11bmljYXRlIG91ciBjb250ZXh0IHRvIHRoZSBjb21iaW5hdG9ycy5cbiAgICAgIC8vIChMZXNzIHdhc3RlZnVsIHRoYW4gY29uc2luZyB1cCBhIGh1bmRyZWQgY2xvc3VyZXMgb24gZXZlcnkgY2FsbC4pXG4gICAgICBjeC5zdGF0ZSA9IHN0YXRlO2N4LnN0cmVhbSA9IHN0cmVhbTtjeC5tYXJrZWQgPSBudWxsLCBjeC5jYyA9IGNjO2N4LnN0eWxlID0gc3R5bGU7XG5cbiAgICAgIGlmICghc3RhdGUubGV4aWNhbC5oYXNPd25Qcm9wZXJ0eShcImFsaWduXCIpKSBzdGF0ZS5sZXhpY2FsLmFsaWduID0gdHJ1ZTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGNvbWJpbmF0b3IgPSBjYy5sZW5ndGggPyBjYy5wb3AoKSA6IGpzb25Nb2RlID8gZXhwcmVzc2lvbiA6IHN0YXRlbWVudDtcbiAgICAgICAgaWYgKGNvbWJpbmF0b3IodHlwZSwgY29udGVudCkpIHtcbiAgICAgICAgICB3aGlsZSAoY2MubGVuZ3RoICYmIGNjW2NjLmxlbmd0aCAtIDFdLmxleCkgY2MucG9wKCkoKTtcbiAgICAgICAgICBpZiAoY3gubWFya2VkKSByZXR1cm4gY3gubWFya2VkO1xuICAgICAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpblNjb3BlKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbWJpbmF0b3IgdXRpbHNcblxuICAgIHZhciBjeCA9IHsgc3RhdGU6IG51bGwsIGNvbHVtbjogbnVsbCwgbWFya2VkOiBudWxsLCBjYzogbnVsbCB9O1xuICAgIGZ1bmN0aW9uIHBhc3MoKSB7XG4gICAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnQoKSB7XG4gICAgICBwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIodmFybmFtZSkge1xuICAgICAgZnVuY3Rpb24gaW5MaXN0KGxpc3QpIHtcbiAgICAgICAgZm9yICh2YXIgdiA9IGxpc3Q7IHY7IHYgPSB2Lm5leHQpIGlmICh2Lm5hbWUgPT0gdmFybmFtZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICAgICAgY3gubWFya2VkID0gXCJkZWZcIjtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0KSB7XG4gICAgICAgIGlmIChpbkxpc3Qoc3RhdGUubG9jYWxWYXJzKSkgcmV0dXJuO1xuICAgICAgICBzdGF0ZS5sb2NhbFZhcnMgPSB7IG5hbWU6IHZhcm5hbWUsIG5leHQ6IHN0YXRlLmxvY2FsVmFycyB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluTGlzdChzdGF0ZS5nbG9iYWxWYXJzKSkgcmV0dXJuO1xuICAgICAgICBpZiAocGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMpIHN0YXRlLmdsb2JhbFZhcnMgPSB7IG5hbWU6IHZhcm5hbWUsIG5leHQ6IHN0YXRlLmdsb2JhbFZhcnMgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21iaW5hdG9yc1xuXG4gICAgdmFyIGRlZmF1bHRWYXJzID0geyBuYW1lOiBcInRoaXNcIiwgbmV4dDogeyBuYW1lOiBcImFyZ3VtZW50c1wiIH0gfTtcbiAgICBmdW5jdGlvbiBwdXNoY29udGV4dCgpIHtcbiAgICAgIGN4LnN0YXRlLmNvbnRleHQgPSB7IHByZXY6IGN4LnN0YXRlLmNvbnRleHQsIHZhcnM6IGN4LnN0YXRlLmxvY2FsVmFycyB9O1xuICAgICAgY3guc3RhdGUubG9jYWxWYXJzID0gZGVmYXVsdFZhcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcGNvbnRleHQoKSB7XG4gICAgICBjeC5zdGF0ZS5sb2NhbFZhcnMgPSBjeC5zdGF0ZS5jb250ZXh0LnZhcnM7XG4gICAgICBjeC5zdGF0ZS5jb250ZXh0ID0gY3guc3RhdGUuY29udGV4dC5wcmV2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNobGV4KHR5cGUsIGluZm8pIHtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlLFxuICAgICAgICAgICAgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgICAgIGlmIChzdGF0ZS5sZXhpY2FsLnR5cGUgPT0gXCJzdGF0XCIpIGluZGVudCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7ZWxzZSBmb3IgKHZhciBvdXRlciA9IHN0YXRlLmxleGljYWw7IG91dGVyICYmIG91dGVyLnR5cGUgPT0gXCIpXCIgJiYgb3V0ZXIuYWxpZ247IG91dGVyID0gb3V0ZXIucHJldikgaW5kZW50ID0gb3V0ZXIuaW5kZW50ZWQ7XG4gICAgICAgIHN0YXRlLmxleGljYWwgPSBuZXcgSlNMZXhpY2FsKGluZGVudCwgY3guc3RyZWFtLmNvbHVtbigpLCB0eXBlLCBudWxsLCBzdGF0ZS5sZXhpY2FsLCBpbmZvKTtcbiAgICAgIH07XG4gICAgICByZXN1bHQubGV4ID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICAgICAgaWYgKHN0YXRlLmxleGljYWwucHJldikge1xuICAgICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKSBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7XG4gICAgICAgIHN0YXRlLmxleGljYWwgPSBzdGF0ZS5sZXhpY2FsLnByZXY7XG4gICAgICB9XG4gICAgfVxuICAgIHBvcGxleC5sZXggPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHdhbnRlZCkge1xuICAgICAgZnVuY3Rpb24gZXhwKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gd2FudGVkKSByZXR1cm4gY29udCgpO2Vsc2UgaWYgKHdhbnRlZCA9PSBcIjtcIikgcmV0dXJuIHBhc3MoKTtlbHNlIHJldHVybiBjb250KGV4cCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGV4cDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGF0ZW1lbnQodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09IFwidmFyXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ2YXJkZWZcIiwgdmFsdWUubGVuZ3RoKSwgdmFyZGVmLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGFcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHBhcmVuRXhwciwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGJcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgYmxvY2ssIHBvcGxleCk7XG4gICAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQoKTtcbiAgICAgIGlmICh0eXBlID09IFwiaWZcIikge1xuICAgICAgICBpZiAoY3guc3RhdGUubGV4aWNhbC5pbmZvID09IFwiZWxzZVwiICYmIGN4LnN0YXRlLmNjW2N4LnN0YXRlLmNjLmxlbmd0aCAtIDFdID09IHBvcGxleCkgY3guc3RhdGUuY2MucG9wKCkoKTtcbiAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHBhcmVuRXhwciwgc3RhdGVtZW50LCBwb3BsZXgsIG1heWJlZWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICAgIGlmICh0eXBlID09IFwiZm9yXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBmb3JzcGVjLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBtYXliZWxhYmVsKTtcbiAgICAgIGlmICh0eXBlID09IFwic3dpdGNoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwYXJlbkV4cHIsIHB1c2hsZXgoXCJ9XCIsIFwic3dpdGNoXCIpLCBleHBlY3QoXCJ7XCIpLCBibG9jaywgcG9wbGV4LCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJjYXNlXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIikpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJkZWZhdWx0XCIpIHJldHVybiBjb250KGV4cGVjdChcIjpcIikpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJjYXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcHVzaGNvbnRleHQsIGV4cGVjdChcIihcIiksIGZ1bmFyZywgZXhwZWN0KFwiKVwiKSwgc3RhdGVtZW50LCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJjbGFzc1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgY2xhc3NOYW1lLCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJleHBvcnRcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIGFmdGVyRXhwb3J0LCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJpbXBvcnRcIikgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIGFmdGVySW1wb3J0LCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJtb2R1bGVcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHBhdHRlcm4sIHB1c2hsZXgoXCJ9XCIpLCBleHBlY3QoXCJ7XCIpLCBibG9jaywgcG9wbGV4LCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ0eXBlXCIpIHJldHVybiBjb250KHR5cGVleHByLCBleHBlY3QoXCJvcGVyYXRvclwiKSwgdHlwZWV4cHIsIGV4cGVjdChcIjtcIikpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJhc3luY1wiKSByZXR1cm4gY29udChzdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIHBhc3MocHVzaGxleChcInN0YXRcIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4cHJlc3Npb24odHlwZSkge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb25Jbm5lcih0eXBlLCBmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4cHJlc3Npb25Ob0NvbW1hKHR5cGUpIHtcbiAgICAgIHJldHVybiBleHByZXNzaW9uSW5uZXIodHlwZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcmVuRXhwcih0eXBlKSB7XG4gICAgICBpZiAodHlwZSAhPSBcIihcIikgcmV0dXJuIHBhc3MoKTtcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBleHByZXNzaW9uLCBleHBlY3QoXCIpXCIpLCBwb3BsZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHByZXNzaW9uSW5uZXIodHlwZSwgbm9Db21tYSkge1xuICAgICAgaWYgKGN4LnN0YXRlLmZhdEFycm93QXQgPT0gY3guc3RyZWFtLnN0YXJ0KSB7XG4gICAgICAgIHZhciBib2R5ID0gbm9Db21tYSA/IGFycm93Qm9keU5vQ29tbWEgOiBhcnJvd0JvZHk7XG4gICAgICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKHBhdHRlcm4sIFwiKVwiKSwgcG9wbGV4LCBleHBlY3QoXCI9PlwiKSwgYm9keSwgcG9wY29udGV4dCk7ZWxzZSBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBwYXNzKHB1c2hjb250ZXh0LCBwYXR0ZXJuLCBleHBlY3QoXCI9PlwiKSwgYm9keSwgcG9wY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXliZW9wID0gbm9Db21tYSA/IG1heWJlb3BlcmF0b3JOb0NvbW1hIDogbWF5YmVvcGVyYXRvckNvbW1hO1xuICAgICAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChtYXliZW9wKTtcbiAgICAgIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYsIG1heWJlb3ApO1xuICAgICAgaWYgKHR5cGUgPT0gXCJjbGFzc1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgY2xhc3NFeHByZXNzaW9uLCBwb3BsZXgpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGNcIiB8fCB0eXBlID09IFwiYXN5bmNcIikgcmV0dXJuIGNvbnQobm9Db21tYSA/IG1heWJlZXhwcmVzc2lvbk5vQ29tbWEgOiBtYXliZWV4cHJlc3Npb24pO1xuICAgICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIilcIiksIHBvcGxleCwgbWF5YmVvcCk7XG4gICAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgYXJyYXlMaXRlcmFsLCBwb3BsZXgsIG1heWJlb3ApO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAob2JqcHJvcCwgXCJ9XCIsIG51bGwsIG1heWJlb3ApO1xuICAgICAgaWYgKHR5cGUgPT0gXCJxdWFzaVwiKSByZXR1cm4gcGFzcyhxdWFzaSwgbWF5YmVvcCk7XG4gICAgICBpZiAodHlwZSA9PSBcIm5ld1wiKSByZXR1cm4gY29udChtYXliZVRhcmdldChub0NvbW1hKSk7XG4gICAgICByZXR1cm4gY29udCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZWV4cHJlc3Npb24odHlwZSkge1xuICAgICAgaWYgKHR5cGUubWF0Y2goL1s7XFx9XFwpXFxdLF0vKSkgcmV0dXJuIHBhc3MoKTtcbiAgICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZWV4cHJlc3Npb25Ob0NvbW1hKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHJldHVybiBwYXNzKCk7XG4gICAgICByZXR1cm4gcGFzcyhleHByZXNzaW9uTm9Db21tYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvckNvbW1hKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gbWF5YmVvcGVyYXRvck5vQ29tbWEodHlwZSwgdmFsdWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvck5vQ29tbWEodHlwZSwgdmFsdWUsIG5vQ29tbWEpIHtcbiAgICAgIHZhciBtZSA9IG5vQ29tbWEgPT0gZmFsc2UgPyBtYXliZW9wZXJhdG9yQ29tbWEgOiBtYXliZW9wZXJhdG9yTm9Db21tYTtcbiAgICAgIHZhciBleHByID0gbm9Db21tYSA9PSBmYWxzZSA/IGV4cHJlc3Npb24gOiBleHByZXNzaW9uTm9Db21tYTtcbiAgICAgIGlmICh0eXBlID09IFwiPT5cIikgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIG5vQ29tbWEgPyBhcnJvd0JvZHlOb0NvbW1hIDogYXJyb3dCb2R5LCBwb3Bjb250ZXh0KTtcbiAgICAgIGlmICh0eXBlID09IFwib3BlcmF0b3JcIikge1xuICAgICAgICBpZiAoL1xcK1xcK3wtLS8udGVzdCh2YWx1ZSkpIHJldHVybiBjb250KG1lKTtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiP1wiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI6XCIpLCBleHByKTtcbiAgICAgICAgcmV0dXJuIGNvbnQoZXhwcik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcInF1YXNpXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhc3MocXVhc2ksIG1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm47XG4gICAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnRDb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCIpXCIsIFwiY2FsbFwiLCBtZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIi5cIikgcmV0dXJuIGNvbnQocHJvcGVydHksIG1lKTtcbiAgICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udChwdXNobGV4KFwiXVwiKSwgbWF5YmVleHByZXNzaW9uLCBleHBlY3QoXCJdXCIpLCBwb3BsZXgsIG1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVhc2kodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlICE9IFwicXVhc2lcIikgcmV0dXJuIHBhc3MoKTtcbiAgICAgIGlmICh2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSAyKSAhPSBcIiR7XCIpIHJldHVybiBjb250KHF1YXNpKTtcbiAgICAgIHJldHVybiBjb250KGV4cHJlc3Npb24sIGNvbnRpbnVlUXVhc2kpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250aW51ZVF1YXNpKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwifVwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwic3RyaW5nLTJcIjtcbiAgICAgICAgY3guc3RhdGUudG9rZW5pemUgPSB0b2tlblF1YXNpO1xuICAgICAgICByZXR1cm4gY29udChxdWFzaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycm93Qm9keSh0eXBlKSB7XG4gICAgICBmaW5kRmF0QXJyb3coY3guc3RyZWFtLCBjeC5zdGF0ZSk7XG4gICAgICByZXR1cm4gcGFzcyh0eXBlID09IFwie1wiID8gc3RhdGVtZW50IDogZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycm93Qm9keU5vQ29tbWEodHlwZSkge1xuICAgICAgZmluZEZhdEFycm93KGN4LnN0cmVhbSwgY3guc3RhdGUpO1xuICAgICAgcmV0dXJuIHBhc3ModHlwZSA9PSBcIntcIiA/IHN0YXRlbWVudCA6IGV4cHJlc3Npb25Ob0NvbW1hKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF5YmVUYXJnZXQobm9Db21tYSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiLlwiKSByZXR1cm4gY29udChub0NvbW1hID8gdGFyZ2V0Tm9Db21tYSA6IHRhcmdldCk7ZWxzZSByZXR1cm4gcGFzcyhub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhcmdldChfLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IFwidGFyZ2V0XCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7cmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvckNvbW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGFyZ2V0Tm9Db21tYShfLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IFwidGFyZ2V0XCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7cmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvck5vQ29tbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZWxhYmVsKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChwb3BsZXgsIHN0YXRlbWVudCk7XG4gICAgICByZXR1cm4gcGFzcyhtYXliZW9wZXJhdG9yQ29tbWEsIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7cmV0dXJuIGNvbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb2JqcHJvcCh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJhc3luY1wiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgcmV0dXJuIGNvbnQob2JqcHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IGN4LnN0eWxlID09IFwia2V5d29yZFwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiZ2V0XCIgfHwgdmFsdWUgPT0gXCJzZXRcIikgcmV0dXJuIGNvbnQoZ2V0dGVyU2V0dGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnQoYWZ0ZXJwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjeC5tYXJrZWQgPSBqc29ubGRNb2RlID8gXCJwcm9wZXJ0eVwiIDogY3guc3R5bGUgKyBcIiBwcm9wZXJ0eVwiO1xuICAgICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwianNvbmxkLWtleXdvcmRcIikge1xuICAgICAgICByZXR1cm4gY29udChhZnRlcnByb3ApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwibW9kaWZpZXJcIikge1xuICAgICAgICByZXR1cm4gY29udChvYmpwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIltcIikge1xuICAgICAgICByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCJdXCIpLCBhZnRlcnByb3ApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwic3ByZWFkXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCI6XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhc3MoYWZ0ZXJwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0dGVyU2V0dGVyKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICE9IFwidmFyaWFibGVcIikgcmV0dXJuIHBhc3MoYWZ0ZXJwcm9wKTtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWZ0ZXJwcm9wKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udChleHByZXNzaW9uTm9Db21tYSk7XG4gICAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHBhc3MoZnVuY3Rpb25kZWYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21tYXNlcCh3aGF0LCBlbmQpIHtcbiAgICAgIGZ1bmN0aW9uIHByb2NlZWQodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCIsXCIpIHtcbiAgICAgICAgICB2YXIgbGV4ID0gY3guc3RhdGUubGV4aWNhbDtcbiAgICAgICAgICBpZiAobGV4LmluZm8gPT0gXCJjYWxsXCIpIGxleC5wb3MgPSAobGV4LnBvcyB8fCAwKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBlbmQgfHwgdmFsdWUgPT0gZW5kKSByZXR1cm4gcGFzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHBhc3Mod2hhdCk7XG4gICAgICAgICAgfSwgcHJvY2VlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT0gZW5kIHx8IHZhbHVlID09IGVuZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KGVuZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZSA9PSBlbmQgfHwgdmFsdWUgPT0gZW5kKSByZXR1cm4gY29udCgpO1xuICAgICAgICByZXR1cm4gcGFzcyh3aGF0LCBwcm9jZWVkKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRDb21tYXNlcCh3aGF0LCBlbmQsIGluZm8pIHtcbiAgICAgIGZvciAodmFyIGkgPSAzOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICByZXR1cm4gY29udChwdXNobGV4KGVuZCwgaW5mbyksIGNvbW1hc2VwKHdoYXQsIGVuZCksIHBvcGxleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJsb2NrKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICAgICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50LCBibG9jayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heWJldHlwZSh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKGlzVFMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICAgICAgaWYgKHZhbHVlID09IFwiP1wiKSByZXR1cm4gY29udChtYXliZXR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZXhwcih0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJ2YXJpYWJsZS0zXCI7cmV0dXJuIGNvbnQoYWZ0ZXJUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChjb21tYXNlcCh0eXBlcHJvcCwgXCJ9XCIpKTtcbiAgICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChjb21tYXNlcCh0eXBlYXJnLCBcIilcIiksIG1heWJlUmV0dXJuVHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heWJlUmV0dXJuVHlwZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIj0+XCIpIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZXByb3AodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IGN4LnN0eWxlID09IFwia2V5d29yZFwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgcmV0dXJuIGNvbnQodHlwZXByb3ApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZWFyZyh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KHR5cGVhcmcpO2Vsc2UgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVleHByKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWZ0ZXJUeXBlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KGNvbW1hc2VwKHR5cGVleHByLCBcIj5cIiksIGFmdGVyVHlwZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQoZXhwZWN0KFwiXVwiKSwgYWZ0ZXJUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFyZGVmKCkge1xuICAgICAgcmV0dXJuIHBhc3MocGF0dGVybiwgbWF5YmV0eXBlLCBtYXliZUFzc2lnbiwgdmFyZGVmQ29udCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdHRlcm4odHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09IFwibW9kaWZpZXJcIikgcmV0dXJuIGNvbnQocGF0dGVybik7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgcmVnaXN0ZXIodmFsdWUpO3JldHVybiBjb250KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChwYXR0ZXJuKTtcbiAgICAgIGlmICh0eXBlID09IFwiW1wiKSByZXR1cm4gY29udENvbW1hc2VwKHBhdHRlcm4sIFwiXVwiKTtcbiAgICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udENvbW1hc2VwKHByb3BwYXR0ZXJuLCBcIn1cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb3BwYXR0ZXJuKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgIWN4LnN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKSB7XG4gICAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNvbnQobWF5YmVBc3NpZ24pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChwYXR0ZXJuKTtcbiAgICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gcGFzcygpO1xuICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KFwiOlwiKSwgcGF0dGVybiwgbWF5YmVBc3NpZ24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZUFzc2lnbihfdHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YXJkZWZDb250KHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh2YXJkZWYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZWVsc2UodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09IFwia2V5d29yZCBiXCIgJiYgdmFsdWUgPT0gXCJlbHNlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIsIFwiZWxzZVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JzcGVjKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgZm9yc3BlYzEsIGV4cGVjdChcIilcIiksIHBvcGxleCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcnNwZWMxKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwidmFyXCIpIHJldHVybiBjb250KHZhcmRlZiwgZXhwZWN0KFwiO1wiKSwgZm9yc3BlYzIpO1xuICAgICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KGZvcnNwZWMyKTtcbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNvbnQoZm9ybWF5YmVpbm9mKTtcbiAgICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIGZvcnNwZWMyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF5YmVpbm9mKF90eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IFwiaW5cIiB8fCB2YWx1ZSA9PSBcIm9mXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7cmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udChtYXliZW9wZXJhdG9yQ29tbWEsIGZvcnNwZWMyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yc3BlYzIodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gY29udChmb3JzcGVjMyk7XG4gICAgICBpZiAodmFsdWUgPT0gXCJpblwiIHx8IHZhbHVlID09IFwib2ZcIikge1xuICAgICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtyZXR1cm4gY29udChleHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIGZvcnNwZWMzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yc3BlYzModHlwZSkge1xuICAgICAgaWYgKHR5cGUgIT0gXCIpXCIpIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uZGVmKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7cmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICAgIHJlZ2lzdGVyKHZhbHVlKTtyZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChmdW5hcmcsIFwiKVwiKSwgcG9wbGV4LCBtYXliZXR5cGUsIHN0YXRlbWVudCwgcG9wY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ1bmFyZyh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChmdW5hcmcpO1xuICAgICAgcmV0dXJuIHBhc3MocGF0dGVybiwgbWF5YmV0eXBlLCBtYXliZUFzc2lnbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYXNzRXhwcmVzc2lvbih0eXBlLCB2YWx1ZSkge1xuICAgICAgLy8gQ2xhc3MgZXhwcmVzc2lvbnMgbWF5IGhhdmUgYW4gb3B0aW9uYWwgbmFtZS5cbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIGNsYXNzTmFtZSh0eXBlLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lQWZ0ZXIodHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFzc05hbWUodHlwZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgICAgICByZWdpc3Rlcih2YWx1ZSk7cmV0dXJuIGNvbnQoY2xhc3NOYW1lQWZ0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFzc05hbWVBZnRlcih0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IFwiZXh0ZW5kc1wiIHx8IHZhbHVlID09IFwiaW1wbGVtZW50c1wiKSByZXR1cm4gY29udChpc1RTID8gdHlwZWV4cHIgOiBleHByZXNzaW9uLCBjbGFzc05hbWVBZnRlcik7XG4gICAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIGNsYXNzQm9keSwgcG9wbGV4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhc3NCb2R5KHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgICAgaWYgKCh2YWx1ZSA9PSBcInN0YXRpY1wiIHx8IHZhbHVlID09IFwiZ2V0XCIgfHwgdmFsdWUgPT0gXCJzZXRcIiB8fCBpc1RTICYmICh2YWx1ZSA9PSBcInB1YmxpY1wiIHx8IHZhbHVlID09IFwicHJpdmF0ZVwiIHx8IHZhbHVlID09IFwicHJvdGVjdGVkXCIgfHwgdmFsdWUgPT0gXCJyZWFkb25seVwiIHx8IHZhbHVlID09IFwiYWJzdHJhY3RcIikpICYmIGN4LnN0cmVhbS5tYXRjaCgvXlxccytbXFx3JFxceGExLVxcdWZmZmZdLywgZmFsc2UpKSB7XG4gICAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoY2xhc3NCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgICAgIHJldHVybiBjb250KGlzVFMgPyBjbGFzc2ZpZWxkIDogZnVuY3Rpb25kZWYsIGNsYXNzQm9keSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICAgIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQoY2xhc3NCb2R5KTtcbiAgICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gY29udCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFzc2ZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gXCI/XCIpIHJldHVybiBjb250KGNsYXNzZmllbGQpO1xuICAgICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVleHByLCBtYXliZUFzc2lnbik7XG4gICAgICByZXR1cm4gcGFzcyhmdW5jdGlvbmRlZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFmdGVyRXhwb3J0KF90eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IFwiKlwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO3JldHVybiBjb250KG1heWJlRnJvbSwgZXhwZWN0KFwiO1wiKSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7cmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFzcyhzdGF0ZW1lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZnRlckltcG9ydCh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udCgpO1xuICAgICAgcmV0dXJuIHBhc3MoaW1wb3J0U3BlYywgbWF5YmVGcm9tKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW1wb3J0U3BlYyh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAoaW1wb3J0U3BlYywgXCJ9XCIpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZWdpc3Rlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT0gXCIqXCIpIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO1xuICAgICAgcmV0dXJuIGNvbnQobWF5YmVBcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heWJlQXMoX3R5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gXCJhc1wiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiO3JldHVybiBjb250KGltcG9ydFNwZWMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYXliZUZyb20oX3R5cGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gXCJmcm9tXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7cmV0dXJuIGNvbnQoZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5TGl0ZXJhbCh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIl1cIikgcmV0dXJuIGNvbnQoKTtcbiAgICAgIHJldHVybiBwYXNzKGNvbW1hc2VwKGV4cHJlc3Npb25Ob0NvbW1hLCBcIl1cIikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ29udGludWVkU3RhdGVtZW50KHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sYXN0VHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgc3RhdGUubGFzdFR5cGUgPT0gXCIsXCIgfHwgaXNPcGVyYXRvckNoYXIudGVzdCh0ZXh0QWZ0ZXIuY2hhckF0KDApKSB8fCAvWywuXS8udGVzdCh0ZXh0QWZ0ZXIuY2hhckF0KDApKTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmZhY2VcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoYmFzZWNvbHVtbikge1xuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICBsYXN0VHlwZTogXCJzb2ZcIixcbiAgICAgICAgICBjYzogW10sXG4gICAgICAgICAgbGV4aWNhbDogbmV3IEpTTGV4aWNhbCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwiYmxvY2tcIiwgZmFsc2UpLFxuICAgICAgICAgIGxvY2FsVmFyczogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyxcbiAgICAgICAgICBjb250ZXh0OiBwYXJzZXJDb25maWcubG9jYWxWYXJzICYmIHsgdmFyczogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyB9LFxuICAgICAgICAgIGluZGVudGVkOiBiYXNlY29sdW1uIHx8IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzICYmIHR5cGVvZiBwYXJzZXJDb25maWcuZ2xvYmFsVmFycyA9PSBcIm9iamVjdFwiKSBzdGF0ZS5nbG9iYWxWYXJzID0gcGFyc2VyQ29uZmlnLmdsb2JhbFZhcnM7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpIHN0YXRlLmxleGljYWwuYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICAgIGZpbmRGYXRBcnJvdyhzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5Db21tZW50ICYmIHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmICh0eXBlID09IFwiY29tbWVudFwiKSByZXR1cm4gc3R5bGU7XG4gICAgICAgIHN0YXRlLmxhc3RUeXBlID0gdHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgKGNvbnRlbnQgPT0gXCIrK1wiIHx8IGNvbnRlbnQgPT0gXCItLVwiKSA/IFwiaW5jZGVjXCIgOiB0eXBlO1xuICAgICAgICByZXR1cm4gcGFyc2VKUyhzdGF0ZSwgc3R5bGUsIHR5cGUsIGNvbnRlbnQsIHN0cmVhbSk7XG4gICAgICB9LFxuXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSA9PSB0b2tlbkNvbW1lbnQpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UpIHJldHVybiAwO1xuICAgICAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCksXG4gICAgICAgICAgICBsZXhpY2FsID0gc3RhdGUubGV4aWNhbCxcbiAgICAgICAgICAgIHRvcDtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIHByZXZlbnQgJ21heWJlbHNlJyBmcm9tIGJsb2NraW5nIGxleGljYWwgc2NvcGUgcG9wc1xuICAgICAgICBpZiAoIS9eXFxzKmVsc2VcXGIvLnRlc3QodGV4dEFmdGVyKSkgZm9yICh2YXIgaSA9IHN0YXRlLmNjLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgdmFyIGMgPSBzdGF0ZS5jY1tpXTtcbiAgICAgICAgICBpZiAoYyA9PSBwb3BsZXgpIGxleGljYWwgPSBsZXhpY2FsLnByZXY7ZWxzZSBpZiAoYyAhPSBtYXliZWVsc2UpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgobGV4aWNhbC50eXBlID09IFwic3RhdFwiIHx8IGxleGljYWwudHlwZSA9PSBcImZvcm1cIikgJiYgKGZpcnN0Q2hhciA9PSBcIn1cIiB8fCAodG9wID0gc3RhdGUuY2Nbc3RhdGUuY2MubGVuZ3RoIC0gMV0pICYmICh0b3AgPT0gbWF5YmVvcGVyYXRvckNvbW1hIHx8IHRvcCA9PSBtYXliZW9wZXJhdG9yTm9Db21tYSkgJiYgIS9eWyxcXC49K1xcLSo6P1tcXChdLy50ZXN0KHRleHRBZnRlcikpKSBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgICBpZiAoc3RhdGVtZW50SW5kZW50ICYmIGxleGljYWwudHlwZSA9PSBcIilcIiAmJiBsZXhpY2FsLnByZXYudHlwZSA9PSBcInN0YXRcIikgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgICAgdmFyIHR5cGUgPSBsZXhpY2FsLnR5cGUsXG4gICAgICAgICAgICBjbG9zaW5nID0gZmlyc3RDaGFyID09IHR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJkZWZcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiID8gbGV4aWNhbC5pbmZvICsgMSA6IDApO2Vsc2UgaWYgKHR5cGUgPT0gXCJmb3JtXCIgJiYgZmlyc3RDaGFyID09IFwie1wiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZDtlbHNlIGlmICh0eXBlID09IFwiZm9ybVwiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIGluZGVudFVuaXQ7ZWxzZSBpZiAodHlwZSA9PSBcInN0YXRcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoaXNDb250aW51ZWRTdGF0ZW1lbnQoc3RhdGUsIHRleHRBZnRlcikgPyBzdGF0ZW1lbnRJbmRlbnQgfHwgaW5kZW50VW5pdCA6IDApO2Vsc2UgaWYgKGxleGljYWwuaW5mbyA9PSBcInN3aXRjaFwiICYmICFjbG9zaW5nICYmIHBhcnNlckNvbmZpZy5kb3VibGVJbmRlbnRTd2l0Y2ggIT0gZmFsc2UpIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKC9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gaW5kZW50VW5pdCA6IDIgKiBpbmRlbnRVbml0KTtlbHNlIGlmIChsZXhpY2FsLmFsaWduKSByZXR1cm4gbGV4aWNhbC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtlbHNlIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgICB9LFxuXG4gICAgICBlbGVjdHJpY0lucHV0OiAvXlxccyooPzpjYXNlIC4qPzp8ZGVmYXVsdDp8XFx7fFxcfSkkLyxcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBqc29uTW9kZSA/IG51bGwgOiBcIi8qXCIsXG4gICAgICBibG9ja0NvbW1lbnRFbmQ6IGpzb25Nb2RlID8gbnVsbCA6IFwiKi9cIixcbiAgICAgIGxpbmVDb21tZW50OiBqc29uTW9kZSA/IG51bGwgOiBcIi8vXCIsXG4gICAgICBmb2xkOiBcImJyYWNlXCIsXG4gICAgICBjbG9zZUJyYWNrZXRzOiBcIigpW117fScnXFxcIlxcXCJgYFwiLFxuXG4gICAgICBoZWxwZXJUeXBlOiBqc29uTW9kZSA/IFwianNvblwiIDogXCJqYXZhc2NyaXB0XCIsXG4gICAgICBqc29ubGRNb2RlOiBqc29ubGRNb2RlLFxuICAgICAganNvbk1vZGU6IGpzb25Nb2RlLFxuXG4gICAgICBleHByZXNzaW9uQWxsb3dlZDogZXhwcmVzc2lvbkFsbG93ZWQsXG4gICAgICBza2lwRXhwcmVzc2lvbjogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciB0b3AgPSBzdGF0ZS5jY1tzdGF0ZS5jYy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRvcCA9PSBleHByZXNzaW9uIHx8IHRvcCA9PSBleHByZXNzaW9uTm9Db21tYSkgc3RhdGUuY2MucG9wKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcIndvcmRDaGFyc1wiLCBcImphdmFzY3JpcHRcIiwgL1tcXHckXS8pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvamF2YXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvZWNtYXNjcmlwdFwiLCBcImphdmFzY3JpcHRcIik7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vanNvblwiLCB7IG5hbWU6IFwiamF2YXNjcmlwdFwiLCBqc29uOiB0cnVlIH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWpzb25cIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbjogdHJ1ZSB9KTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vbGQranNvblwiLCB7IG5hbWU6IFwiamF2YXNjcmlwdFwiLCBqc29ubGQ6IHRydWUgfSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvdHlwZXNjcmlwdFwiLCB7IG5hbWU6IFwiamF2YXNjcmlwdFwiLCB0eXBlc2NyaXB0OiB0cnVlIH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29kZW1pcnJvci9tb2RlL2phdmFzY3JpcHQvamF2YXNjcmlwdC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=');
},55:function(module,exports,__webpack_require__){eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser\'s DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n(function(global,factory){ true?module.exports=factory():typeof define===\'function\'&&define.amd?define(factory):global.CodeMirror=factory();})(this,function(){\'use strict\';// Kludges for bugs and behavior differences that can\'t be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent=navigator.userAgent;var platform=navigator.platform;var gecko=/gecko\\/\\d/i.test(userAgent);var ie_upto10=/MSIE \\d/.test(userAgent);var ie_11up=/Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);var ie=ie_upto10||ie_11up;var ie_version=ie&&(ie_upto10?document.documentMode||6:ie_11up[1]);var webkit=/WebKit\\//.test(userAgent);var qtwebkit=webkit&&/Qt\\/\\d+\\.\\d+/.test(userAgent);var chrome=/Chrome\\//.test(userAgent);var presto=/Opera\\//.test(userAgent);var safari=/Apple Computer/.test(navigator.vendor);var mac_geMountainLion=/Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);var phantom=/PhantomJS/.test(userAgent);var ios=/AppleWebKit/.test(userAgent)&&/Mobile\\/\\w+/.test(userAgent);// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile=ios||/Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);var mac=ios||/Mac/.test(platform);var chromeOS=/\\bCrOS\\b/.test(userAgent);var windows=/win/i.test(platform);var presto_version=presto&&userAgent.match(/Version\\/(\\d*\\.\\d*)/);if(presto_version){presto_version=Number(presto_version[1]);}if(presto_version&&presto_version>=15){presto=false;webkit=true;}// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd=mac&&(qtwebkit||presto&&(presto_version==null||presto_version<12.11));var captureRightClick=gecko||ie&&ie_version>=9;function classTest(cls){return new RegExp("(^|\\\\s)"+cls+"(?:$|\\\\s)\\\\s*");}var rmClass=function(node,cls){var current=node.className;var match=classTest(cls).exec(current);if(match){var after=current.slice(match.index+match[0].length);node.className=current.slice(0,match.index)+(after?match[1]+after:"");}};function removeChildren(e){for(var count=e.childNodes.length;count>0;--count){e.removeChild(e.firstChild);}return e;}function removeChildrenAndAdd(parent,e){return removeChildren(parent).appendChild(e);}function elt(tag,content,className,style){var e=document.createElement(tag);if(className){e.className=className;}if(style){e.style.cssText=style;}if(typeof content=="string"){e.appendChild(document.createTextNode(content));}else if(content){for(var i=0;i<content.length;++i){e.appendChild(content[i]);}}return e;}var range;if(document.createRange){range=function(node,start,end,endNode){var r=document.createRange();r.setEnd(endNode||node,end);r.setStart(node,start);return r;};}else{range=function(node,start,end){var r=document.body.createTextRange();try{r.moveToElementText(node.parentNode);}catch(e){return r;}r.collapse(true);r.moveEnd("character",end);r.moveStart("character",start);return r;};}function contains(parent,child){if(child.nodeType==3)// Android browser always returns false when child is a textnode\n{child=child.parentNode;}if(parent.contains){return parent.contains(child);}do{if(child.nodeType==11){child=child.host;}if(child==parent){return true;}}while(child=child.parentNode);}var activeElt=function(){var activeElement=document.activeElement;while(activeElement&&activeElement.root&&activeElement.root.activeElement){activeElement=activeElement.root.activeElement;}return activeElement;};// Older versions of IE throws unspecified error when touching\n// document.activeElement in some cases (during loading, in iframe)\nif(ie&&ie_version<11){activeElt=function(){try{return document.activeElement;}catch(e){return document.body;}};}function addClass(node,cls){var current=node.className;if(!classTest(cls).test(current)){node.className+=(current?" ":"")+cls;}}function joinClasses(a,b){var as=a.split(" ");for(var i=0;i<as.length;i++){if(as[i]&&!classTest(as[i]).test(b)){b+=" "+as[i];}}return b;}var selectInput=function(node){node.select();};if(ios)// Mobile Safari apparently has a bug where select() is broken.\n{selectInput=function(node){node.selectionStart=0;node.selectionEnd=node.value.length;};}else if(ie)// Suppress mysterious IE10 errors\n{selectInput=function(node){try{node.select();}catch(_e){}};}function bind(f){var args=Array.prototype.slice.call(arguments,1);return function(){return f.apply(null,args);};}function copyObj(obj,target,overwrite){if(!target){target={};}for(var prop in obj){if(obj.hasOwnProperty(prop)&&(overwrite!==false||!target.hasOwnProperty(prop))){target[prop]=obj[prop];}}return target;}// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string,end,tabSize,startIndex,startValue){if(end==null){end=string.search(/[^\\s\\u00a0]/);if(end==-1){end=string.length;}}for(var i=startIndex||0,n=startValue||0;;){var nextTab=string.indexOf("\\t",i);if(nextTab<0||nextTab>=end){return n+(end-i);}n+=nextTab-i;n+=tabSize-n%tabSize;i=nextTab+1;}}function Delayed(){this.id=null;}Delayed.prototype.set=function(ms,f){clearTimeout(this.id);this.id=setTimeout(f,ms);};function indexOf(array,elt){for(var i=0;i<array.length;++i){if(array[i]==elt){return i;}}return-1;}// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap=30;// Returned or thrown by various protocols to signal \'I\'m not\n// handling this\'.\nvar Pass={toString:function(){return"CodeMirror.Pass";}};// Reused option objects for setSelection & friends\nvar sel_dontScroll={scroll:false};var sel_mouse={origin:"*mouse"};var sel_move={origin:"+move"};// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string,goal,tabSize){for(var pos=0,col=0;;){var nextTab=string.indexOf("\\t",pos);if(nextTab==-1){nextTab=string.length;}var skipped=nextTab-pos;if(nextTab==string.length||col+skipped>=goal){return pos+Math.min(skipped,goal-col);}col+=nextTab-pos;col+=tabSize-col%tabSize;pos=nextTab+1;if(col>=goal){return pos;}}}var spaceStrs=[""];function spaceStr(n){while(spaceStrs.length<=n){spaceStrs.push(lst(spaceStrs)+" ");}return spaceStrs[n];}function lst(arr){return arr[arr.length-1];}function map(array,f){var out=[];for(var i=0;i<array.length;i++){out[i]=f(array[i],i);}return out;}function insertSorted(array,value,score){var pos=0,priority=score(value);while(pos<array.length&&score(array[pos])<=priority){pos++;}array.splice(pos,0,value);}function nothing(){}function createObj(base,props){var inst;if(Object.create){inst=Object.create(base);}else{nothing.prototype=base;inst=new nothing();}if(props){copyObj(props,inst);}return inst;}var nonASCIISingleCaseWordChar=/[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;function isWordCharBasic(ch){return /\\w/.test(ch)||ch>"\\x80"&&(ch.toUpperCase()!=ch.toLowerCase()||nonASCIISingleCaseWordChar.test(ch));}function isWordChar(ch,helper){if(!helper){return isWordCharBasic(ch);}if(helper.source.indexOf("\\\\w")>-1&&isWordCharBasic(ch)){return true;}return helper.test(ch);}function isEmpty(obj){for(var n in obj){if(obj.hasOwnProperty(n)&&obj[n]){return false;}}return true;}// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars=/[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;function isExtendingChar(ch){return ch.charCodeAt(0)>=768&&extendingChars.test(ch);}// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\nfunction Display(place,doc,input){var d=this;this.input=input;// Covers bottom-right square when both scrollbars are present.\nd.scrollbarFiller=elt("div",null,"CodeMirror-scrollbar-filler");d.scrollbarFiller.setAttribute("cm-not-content","true");// Covers bottom of gutter when coverGutterNextToScrollbar is on\n// and h scrollbar is present.\nd.gutterFiller=elt("div",null,"CodeMirror-gutter-filler");d.gutterFiller.setAttribute("cm-not-content","true");// Will contain the actual code, positioned to cover the viewport.\nd.lineDiv=elt("div",null,"CodeMirror-code");// Elements are added to these to represent selection and cursors.\nd.selectionDiv=elt("div",null,null,"position: relative; z-index: 1");d.cursorDiv=elt("div",null,"CodeMirror-cursors");// A visibility: hidden element used to find the size of things.\nd.measure=elt("div",null,"CodeMirror-measure");// When lines outside of the viewport are measured, they are drawn in this.\nd.lineMeasure=elt("div",null,"CodeMirror-measure");// Wraps everything that needs to exist inside the vertically-padded coordinate system\nd.lineSpace=elt("div",[d.measure,d.lineMeasure,d.selectionDiv,d.cursorDiv,d.lineDiv],null,"position: relative; outline: none");// Moved around its parent to cover visible view.\nd.mover=elt("div",[elt("div",[d.lineSpace],"CodeMirror-lines")],null,"position: relative");// Set to the height of the document, allowing scrolling.\nd.sizer=elt("div",[d.mover],"CodeMirror-sizer");d.sizerWidth=null;// Behavior of elts with overflow: auto and padding is\n// inconsistent across browsers. This is used to ensure the\n// scrollable area is big enough.\nd.heightForcer=elt("div",null,null,"position: absolute; height: "+scrollerGap+"px; width: 1px;");// Will contain the gutters, if any.\nd.gutters=elt("div",null,"CodeMirror-gutters");d.lineGutter=null;// Actual scrollable element.\nd.scroller=elt("div",[d.sizer,d.heightForcer,d.gutters],"CodeMirror-scroll");d.scroller.setAttribute("tabIndex","-1");// The element in which the editor lives.\nd.wrapper=elt("div",[d.scrollbarFiller,d.gutterFiller,d.scroller],"CodeMirror");// Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\nif(ie&&ie_version<8){d.gutters.style.zIndex=-1;d.scroller.style.paddingRight=0;}if(!webkit&&!(gecko&&mobile)){d.scroller.draggable=true;}if(place){if(place.appendChild){place.appendChild(d.wrapper);}else{place(d.wrapper);}}// Current rendered range (may be bigger than the view window).\nd.viewFrom=d.viewTo=doc.first;d.reportedViewFrom=d.reportedViewTo=doc.first;// Information about the rendered lines.\nd.view=[];d.renderedView=null;// Holds info about a single rendered line when it was rendered\n// for measurement, while not in view.\nd.externalMeasured=null;// Empty space (in pixels) above the view\nd.viewOffset=0;d.lastWrapHeight=d.lastWrapWidth=0;d.updateLineNumbers=null;d.nativeBarWidth=d.barHeight=d.barWidth=0;d.scrollbarsClipped=false;// Used to only resize the line number gutter when necessary (when\n// the amount of lines crosses a boundary that makes its width change)\nd.lineNumWidth=d.lineNumInnerWidth=d.lineNumChars=null;// Set to true when a non-horizontal-scrolling line widget is\n// added. As an optimization, line widget aligning is skipped when\n// this is false.\nd.alignWidgets=false;d.cachedCharWidth=d.cachedTextHeight=d.cachedPaddingH=null;// Tracks the maximum line length so that the horizontal scrollbar\n// can be kept static when scrolling.\nd.maxLine=null;d.maxLineLength=0;d.maxLineChanged=false;// Used for measuring wheel scrolling granularity\nd.wheelDX=d.wheelDY=d.wheelStartX=d.wheelStartY=null;// True when shift is held down.\nd.shift=false;// Used to track whether anything happened since the context menu\n// was opened.\nd.selForContextMenu=null;d.activeTouch=null;input.init(d);}// Find the line object corresponding to the given line number.\nfunction getLine(doc,n){n-=doc.first;if(n<0||n>=doc.size){throw new Error("There is no line "+(n+doc.first)+" in the document.");}var chunk=doc;while(!chunk.lines){for(var i=0;;++i){var child=chunk.children[i],sz=child.chunkSize();if(n<sz){chunk=child;break;}n-=sz;}}return chunk.lines[n];}// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc,start,end){var out=[],n=start.line;doc.iter(start.line,end.line+1,function(line){var text=line.text;if(n==end.line){text=text.slice(0,end.ch);}if(n==start.line){text=text.slice(start.ch);}out.push(text);++n;});return out;}// Get the lines between from and to, as array of strings.\nfunction getLines(doc,from,to){var out=[];doc.iter(from,to,function(line){out.push(line.text);});// iter aborts when callback returns truthy value\nreturn out;}// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line,height){var diff=height-line.height;if(diff){for(var n=line;n;n=n.parent){n.height+=diff;}}}// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line){if(line.parent==null){return null;}var cur=line.parent,no=indexOf(cur.lines,line);for(var chunk=cur.parent;chunk;cur=chunk,chunk=chunk.parent){for(var i=0;;++i){if(chunk.children[i]==cur){break;}no+=chunk.children[i].chunkSize();}}return no+cur.first;}// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk,h){var n=chunk.first;outer:do{for(var i$1=0;i$1<chunk.children.length;++i$1){var child=chunk.children[i$1],ch=child.height;if(h<ch){chunk=child;continue outer;}h-=ch;n+=child.chunkSize();}return n;}while(!chunk.lines);var i=0;for(;i<chunk.lines.length;++i){var line=chunk.lines[i],lh=line.height;if(h<lh){break;}h-=lh;}return n+i;}function isLine(doc,l){return l>=doc.first&&l<doc.first+doc.size;}function lineNumberFor(options,i){return String(options.lineNumberFormatter(i+options.firstLineNumber));}// A Pos instance represents a position within the text.\nfunction Pos(line,ch){if(!(this instanceof Pos)){return new Pos(line,ch);}this.line=line;this.ch=ch;}// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a,b){return a.line-b.line||a.ch-b.ch;}function copyPos(x){return Pos(x.line,x.ch);}function maxPos(a,b){return cmp(a,b)<0?b:a;}function minPos(a,b){return cmp(a,b)<0?a:b;}// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc,n){return Math.max(doc.first,Math.min(n,doc.first+doc.size-1));}function clipPos(doc,pos){if(pos.line<doc.first){return Pos(doc.first,0);}var last=doc.first+doc.size-1;if(pos.line>last){return Pos(last,getLine(doc,last).text.length);}return clipToLen(pos,getLine(doc,pos.line).text.length);}function clipToLen(pos,linelen){var ch=pos.ch;if(ch==null||ch>linelen){return Pos(pos.line,linelen);}else if(ch<0){return Pos(pos.line,0);}else{return pos;}}function clipPosArray(doc,array){var out=[];for(var i=0;i<array.length;i++){out[i]=clipPos(doc,array[i]);}return out;}// Optimize some code when these features are not used.\nvar sawReadOnlySpans=false;var sawCollapsedSpans=false;function seeReadOnlySpans(){sawReadOnlySpans=true;}function seeCollapsedSpans(){sawCollapsedSpans=true;}// TEXTMARKER SPANS\nfunction MarkedSpan(marker,from,to){this.marker=marker;this.from=from;this.to=to;}// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans,marker){if(spans){for(var i=0;i<spans.length;++i){var span=spans[i];if(span.marker==marker){return span;}}}}// Remove a span from an array, returning undefined if no spans are\n// left (we don\'t store arrays for lines without spans).\nfunction removeMarkedSpan(spans,span){var r;for(var i=0;i<spans.length;++i){if(spans[i]!=span){(r||(r=[])).push(spans[i]);}}return r;}// Add a span to a line.\nfunction addMarkedSpan(line,span){line.markedSpans=line.markedSpans?line.markedSpans.concat([span]):[span];span.marker.attachLine(line);}// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old,startCh,isInsert){var nw;if(old){for(var i=0;i<old.length;++i){var span=old[i],marker=span.marker;var startsBefore=span.from==null||(marker.inclusiveLeft?span.from<=startCh:span.from<startCh);if(startsBefore||span.from==startCh&&marker.type=="bookmark"&&(!isInsert||!span.marker.insertLeft)){var endsAfter=span.to==null||(marker.inclusiveRight?span.to>=startCh:span.to>startCh);(nw||(nw=[])).push(new MarkedSpan(marker,span.from,endsAfter?null:span.to));}}}return nw;}function markedSpansAfter(old,endCh,isInsert){var nw;if(old){for(var i=0;i<old.length;++i){var span=old[i],marker=span.marker;var endsAfter=span.to==null||(marker.inclusiveRight?span.to>=endCh:span.to>endCh);if(endsAfter||span.from==endCh&&marker.type=="bookmark"&&(!isInsert||span.marker.insertLeft)){var startsBefore=span.from==null||(marker.inclusiveLeft?span.from<=endCh:span.from<endCh);(nw||(nw=[])).push(new MarkedSpan(marker,startsBefore?null:span.from-endCh,span.to==null?null:span.to-endCh));}}}return nw;}// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc,change){if(change.full){return null;}var oldFirst=isLine(doc,change.from.line)&&getLine(doc,change.from.line).markedSpans;var oldLast=isLine(doc,change.to.line)&&getLine(doc,change.to.line).markedSpans;if(!oldFirst&&!oldLast){return null;}var startCh=change.from.ch,endCh=change.to.ch,isInsert=cmp(change.from,change.to)==0;// Get the spans that \'stick out\' on both sides\nvar first=markedSpansBefore(oldFirst,startCh,isInsert);var last=markedSpansAfter(oldLast,endCh,isInsert);// Next, merge those two ends\nvar sameLine=change.text.length==1,offset=lst(change.text).length+(sameLine?startCh:0);if(first){// Fix up .to properties of first\nfor(var i=0;i<first.length;++i){var span=first[i];if(span.to==null){var found=getMarkedSpanFor(last,span.marker);if(!found){span.to=startCh;}else if(sameLine){span.to=found.to==null?null:found.to+offset;}}}}if(last){// Fix up .from in last (or move them into first in case of sameLine)\nfor(var i$1=0;i$1<last.length;++i$1){var span$1=last[i$1];if(span$1.to!=null){span$1.to+=offset;}if(span$1.from==null){var found$1=getMarkedSpanFor(first,span$1.marker);if(!found$1){span$1.from=offset;if(sameLine){(first||(first=[])).push(span$1);}}}else{span$1.from+=offset;if(sameLine){(first||(first=[])).push(span$1);}}}}// Make sure we didn\'t create any zero-length spans\nif(first){first=clearEmptySpans(first);}if(last&&last!=first){last=clearEmptySpans(last);}var newMarkers=[first];if(!sameLine){// Fill gap with whole-line-spans\nvar gap=change.text.length-2,gapMarkers;if(gap>0&&first){for(var i$2=0;i$2<first.length;++i$2){if(first[i$2].to==null){(gapMarkers||(gapMarkers=[])).push(new MarkedSpan(first[i$2].marker,null,null));}}}for(var i$3=0;i$3<gap;++i$3){newMarkers.push(gapMarkers);}newMarkers.push(last);}return newMarkers;}// Remove spans that are empty and don\'t have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans){for(var i=0;i<spans.length;++i){var span=spans[i];if(span.from!=null&&span.from==span.to&&span.marker.clearWhenEmpty!==false){spans.splice(i--,1);}}if(!spans.length){return null;}return spans;}// Used to \'clip\' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc,from,to){var markers=null;doc.iter(from.line,to.line+1,function(line){if(line.markedSpans){for(var i=0;i<line.markedSpans.length;++i){var mark=line.markedSpans[i].marker;if(mark.readOnly&&(!markers||indexOf(markers,mark)==-1)){(markers||(markers=[])).push(mark);}}}});if(!markers){return null;}var parts=[{from:from,to:to}];for(var i=0;i<markers.length;++i){var mk=markers[i],m=mk.find(0);for(var j=0;j<parts.length;++j){var p=parts[j];if(cmp(p.to,m.from)<0||cmp(p.from,m.to)>0){continue;}var newParts=[j,1],dfrom=cmp(p.from,m.from),dto=cmp(p.to,m.to);if(dfrom<0||!mk.inclusiveLeft&&!dfrom){newParts.push({from:p.from,to:m.from});}if(dto>0||!mk.inclusiveRight&&!dto){newParts.push({from:m.to,to:p.to});}parts.splice.apply(parts,newParts);j+=newParts.length-1;}}return parts;}// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line){var spans=line.markedSpans;if(!spans){return;}for(var i=0;i<spans.length;++i){spans[i].marker.detachLine(line);}line.markedSpans=null;}function attachMarkedSpans(line,spans){if(!spans){return;}for(var i=0;i<spans.length;++i){spans[i].marker.attachLine(line);}line.markedSpans=spans;}// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker){return marker.inclusiveLeft?-1:0;}function extraRight(marker){return marker.inclusiveRight?1:0;}// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a,b){var lenDiff=a.lines.length-b.lines.length;if(lenDiff!=0){return lenDiff;}var aPos=a.find(),bPos=b.find();var fromCmp=cmp(aPos.from,bPos.from)||extraLeft(a)-extraLeft(b);if(fromCmp){return-fromCmp;}var toCmp=cmp(aPos.to,bPos.to)||extraRight(a)-extraRight(b);if(toCmp){return toCmp;}return b.id-a.id;}// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line,start){var sps=sawCollapsedSpans&&line.markedSpans,found;if(sps){for(var sp=void 0,i=0;i<sps.length;++i){sp=sps[i];if(sp.marker.collapsed&&(start?sp.from:sp.to)==null&&(!found||compareCollapsedMarkers(found,sp.marker)<0)){found=sp.marker;}}}return found;}function collapsedSpanAtStart(line){return collapsedSpanAtSide(line,true);}function collapsedSpanAtEnd(line){return collapsedSpanAtSide(line,false);}// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc,lineNo,from,to,marker){var line=getLine(doc,lineNo);var sps=sawCollapsedSpans&&line.markedSpans;if(sps){for(var i=0;i<sps.length;++i){var sp=sps[i];if(!sp.marker.collapsed){continue;}var found=sp.marker.find(0);var fromCmp=cmp(found.from,from)||extraLeft(sp.marker)-extraLeft(marker);var toCmp=cmp(found.to,to)||extraRight(sp.marker)-extraRight(marker);if(fromCmp>=0&&toCmp<=0||fromCmp<=0&&toCmp>=0){continue;}if(fromCmp<=0&&(sp.marker.inclusiveRight&&marker.inclusiveLeft?cmp(found.to,from)>=0:cmp(found.to,from)>0)||fromCmp>=0&&(sp.marker.inclusiveRight&&marker.inclusiveLeft?cmp(found.from,to)<=0:cmp(found.from,to)<0)){return true;}}}}// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line){var merged;while(merged=collapsedSpanAtStart(line)){line=merged.find(-1,true).line;}return line;}// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line){var merged,lines;while(merged=collapsedSpanAtEnd(line)){line=merged.find(1,true).line;(lines||(lines=[])).push(line);}return lines;}// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc,lineN){var line=getLine(doc,lineN),vis=visualLine(line);if(line==vis){return lineN;}return lineNo(vis);}// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc,lineN){if(lineN>doc.lastLine()){return lineN;}var line=getLine(doc,lineN),merged;if(!lineIsHidden(doc,line)){return lineN;}while(merged=collapsedSpanAtEnd(line)){line=merged.find(1,true).line;}return lineNo(line)+1;}// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc,line){var sps=sawCollapsedSpans&&line.markedSpans;if(sps){for(var sp=void 0,i=0;i<sps.length;++i){sp=sps[i];if(!sp.marker.collapsed){continue;}if(sp.from==null){return true;}if(sp.marker.widgetNode){continue;}if(sp.from==0&&sp.marker.inclusiveLeft&&lineIsHiddenInner(doc,line,sp)){return true;}}}}function lineIsHiddenInner(doc,line,span){if(span.to==null){var end=span.marker.find(1,true);return lineIsHiddenInner(doc,end.line,getMarkedSpanFor(end.line.markedSpans,span.marker));}if(span.marker.inclusiveRight&&span.to==line.text.length){return true;}for(var sp=void 0,i=0;i<line.markedSpans.length;++i){sp=line.markedSpans[i];if(sp.marker.collapsed&&!sp.marker.widgetNode&&sp.from==span.to&&(sp.to==null||sp.to!=span.from)&&(sp.marker.inclusiveLeft||span.marker.inclusiveRight)&&lineIsHiddenInner(doc,line,sp)){return true;}}}// Find the height above the given line.\nfunction heightAtLine(lineObj){lineObj=visualLine(lineObj);var h=0,chunk=lineObj.parent;for(var i=0;i<chunk.lines.length;++i){var line=chunk.lines[i];if(line==lineObj){break;}else{h+=line.height;}}for(var p=chunk.parent;p;chunk=p,p=chunk.parent){for(var i$1=0;i$1<p.children.length;++i$1){var cur=p.children[i$1];if(cur==chunk){break;}else{h+=cur.height;}}}return h;}// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line){if(line.height==0){return 0;}var len=line.text.length,merged,cur=line;while(merged=collapsedSpanAtStart(cur)){var found=merged.find(0,true);cur=found.from.line;len+=found.from.ch-found.to.ch;}cur=line;while(merged=collapsedSpanAtEnd(cur)){var found$1=merged.find(0,true);len-=cur.text.length-found$1.from.ch;cur=found$1.to.line;len+=cur.text.length-found$1.to.ch;}return len;}// Find the longest line in the document.\nfunction findMaxLine(cm){var d=cm.display,doc=cm.doc;d.maxLine=getLine(doc,doc.first);d.maxLineLength=lineLength(d.maxLine);d.maxLineChanged=true;doc.iter(function(line){var len=lineLength(line);if(len>d.maxLineLength){d.maxLineLength=len;d.maxLine=line;}});}// BIDI HELPERS\nfunction iterateBidiSections(order,from,to,f){if(!order){return f(from,to,"ltr");}var found=false;for(var i=0;i<order.length;++i){var part=order[i];if(part.from<to&&part.to>from||from==to&&part.to==from){f(Math.max(part.from,from),Math.min(part.to,to),part.level==1?"rtl":"ltr");found=true;}}if(!found){f(from,to,"ltr");}}function bidiLeft(part){return part.level%2?part.to:part.from;}function bidiRight(part){return part.level%2?part.from:part.to;}function lineLeft(line){var order=getOrder(line);return order?bidiLeft(order[0]):0;}function lineRight(line){var order=getOrder(line);if(!order){return line.text.length;}return bidiRight(lst(order));}function compareBidiLevel(order,a,b){var linedir=order[0].level;if(a==linedir){return true;}if(b==linedir){return false;}return a<b;}var bidiOther=null;function getBidiPartAt(order,pos){var found;bidiOther=null;for(var i=0;i<order.length;++i){var cur=order[i];if(cur.from<pos&&cur.to>pos){return i;}if(cur.from==pos||cur.to==pos){if(found==null){found=i;}else if(compareBidiLevel(order,cur.level,order[found].level)){if(cur.from!=cur.to){bidiOther=found;}return i;}else{if(cur.from!=cur.to){bidiOther=i;}return found;}}}return found;}function moveInLine(line,pos,dir,byUnit){if(!byUnit){return pos+dir;}do{pos+=dir;}while(pos>0&&isExtendingChar(line.text.charAt(pos)));return pos;}// This is needed in order to move \'visually\' through bi-directional\n// text -- i.e., pressing left should make the cursor go left, even\n// when in RTL text. The tricky part is the \'jumps\', where RTL and\n// LTR text touch each other. This often requires the cursor offset\n// to move more than one unit, in order to visually move one unit.\nfunction moveVisually(line,start,dir,byUnit){var bidi=getOrder(line);if(!bidi){return moveLogically(line,start,dir,byUnit);}var pos=getBidiPartAt(bidi,start),part=bidi[pos];var target=moveInLine(line,start,part.level%2?-dir:dir,byUnit);for(;;){if(target>part.from&&target<part.to){return target;}if(target==part.from||target==part.to){if(getBidiPartAt(bidi,target)==pos){return target;}part=bidi[pos+=dir];return dir>0==part.level%2?part.to:part.from;}else{part=bidi[pos+=dir];if(!part){return null;}if(dir>0==part.level%2){target=moveInLine(line,part.to,-1,byUnit);}else{target=moveInLine(line,part.from,1,byUnit);}}}}function moveLogically(line,start,dir,byUnit){var target=start+dir;if(byUnit){while(target>0&&isExtendingChar(line.text.charAt(target))){target+=dir;}}return target<0||target>line.text.length?null:target;}// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering=function(){// Character types for codepoints 0 to 0xff\nvar lowTypes="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";// Character types for codepoints 0x600 to 0x6ff\nvar arabicTypes="rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";function charType(code){if(code<=0xf7){return lowTypes.charAt(code);}else if(0x590<=code&&code<=0x5f4){return"R";}else if(0x600<=code&&code<=0x6ed){return arabicTypes.charAt(code-0x600);}else if(0x6ee<=code&&code<=0x8ac){return"r";}else if(0x2000<=code&&code<=0x200b){return"w";}else if(code==0x200c){return"b";}else{return"L";}}var bidiRE=/[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;var isNeutral=/[stwN]/,isStrong=/[LRr]/,countsAsLeft=/[Lb1n]/,countsAsNum=/[1n]/;// Browsers seem to always treat the boundaries of block elements as being L.\nvar outerType="L";function BidiSpan(level,from,to){this.level=level;this.from=from;this.to=to;}return function(str){if(!bidiRE.test(str)){return false;}var len=str.length,types=[];for(var i=0;i<len;++i){types.push(charType(str.charCodeAt(i)));}// W1. Examine each non-spacing mark (NSM) in the level run, and\n// change the type of the NSM to the type of the previous\n// character. If the NSM is at the start of the level run, it will\n// get the type of sor.\nfor(var i$1=0,prev=outerType;i$1<len;++i$1){var type=types[i$1];if(type=="m"){types[i$1]=prev;}else{prev=type;}}// W2. Search backwards from each instance of a European number\n// until the first strong type (R, L, AL, or sor) is found. If an\n// AL is found, change the type of the European number to Arabic\n// number.\n// W3. Change all ALs to R.\nfor(var i$2=0,cur=outerType;i$2<len;++i$2){var type$1=types[i$2];if(type$1=="1"&&cur=="r"){types[i$2]="n";}else if(isStrong.test(type$1)){cur=type$1;if(type$1=="r"){types[i$2]="R";}}}// W4. A single European separator between two European numbers\n// changes to a European number. A single common separator between\n// two numbers of the same type changes to that type.\nfor(var i$3=1,prev$1=types[0];i$3<len-1;++i$3){var type$2=types[i$3];if(type$2=="+"&&prev$1=="1"&&types[i$3+1]=="1"){types[i$3]="1";}else if(type$2==","&&prev$1==types[i$3+1]&&(prev$1=="1"||prev$1=="n")){types[i$3]=prev$1;}prev$1=type$2;}// W5. A sequence of European terminators adjacent to European\n// numbers changes to all European numbers.\n// W6. Otherwise, separators and terminators change to Other\n// Neutral.\nfor(var i$4=0;i$4<len;++i$4){var type$3=types[i$4];if(type$3==","){types[i$4]="N";}else if(type$3=="%"){var end=void 0;for(end=i$4+1;end<len&&types[end]=="%";++end){}var replace=i$4&&types[i$4-1]=="!"||end<len&&types[end]=="1"?"1":"N";for(var j=i$4;j<end;++j){types[j]=replace;}i$4=end-1;}}// W7. Search backwards from each instance of a European number\n// until the first strong type (R, L, or sor) is found. If an L is\n// found, then change the type of the European number to L.\nfor(var i$5=0,cur$1=outerType;i$5<len;++i$5){var type$4=types[i$5];if(cur$1=="L"&&type$4=="1"){types[i$5]="L";}else if(isStrong.test(type$4)){cur$1=type$4;}}// N1. A sequence of neutrals takes the direction of the\n// surrounding strong text if the text on both sides has the same\n// direction. European and Arabic numbers act as if they were R in\n// terms of their influence on neutrals. Start-of-level-run (sor)\n// and end-of-level-run (eor) are used at level run boundaries.\n// N2. Any remaining neutrals take the embedding direction.\nfor(var i$6=0;i$6<len;++i$6){if(isNeutral.test(types[i$6])){var end$1=void 0;for(end$1=i$6+1;end$1<len&&isNeutral.test(types[end$1]);++end$1){}var before=(i$6?types[i$6-1]:outerType)=="L";var after=(end$1<len?types[end$1]:outerType)=="L";var replace$1=before||after?"L":"R";for(var j$1=i$6;j$1<end$1;++j$1){types[j$1]=replace$1;}i$6=end$1-1;}}// Here we depart from the documented algorithm, in order to avoid\n// building up an actual levels array. Since there are only three\n// levels (0, 1, 2) in an implementation that doesn\'t take\n// explicit embedding into account, we can build up the order on\n// the fly, without following the level-based algorithm.\nvar order=[],m;for(var i$7=0;i$7<len;){if(countsAsLeft.test(types[i$7])){var start=i$7;for(++i$7;i$7<len&&countsAsLeft.test(types[i$7]);++i$7){}order.push(new BidiSpan(0,start,i$7));}else{var pos=i$7,at=order.length;for(++i$7;i$7<len&&types[i$7]!="L";++i$7){}for(var j$2=pos;j$2<i$7;){if(countsAsNum.test(types[j$2])){if(pos<j$2){order.splice(at,0,new BidiSpan(1,pos,j$2));}var nstart=j$2;for(++j$2;j$2<i$7&&countsAsNum.test(types[j$2]);++j$2){}order.splice(at,0,new BidiSpan(2,nstart,j$2));pos=j$2;}else{++j$2;}}if(pos<i$7){order.splice(at,0,new BidiSpan(1,pos,i$7));}}}if(order[0].level==1&&(m=str.match(/^\\s+/))){order[0].from=m[0].length;order.unshift(new BidiSpan(0,0,m[0].length));}if(lst(order).level==1&&(m=str.match(/\\s+$/))){lst(order).to-=m[0].length;order.push(new BidiSpan(0,len-m[0].length,len));}if(order[0].level==2){order.unshift(new BidiSpan(1,order[0].to,order[0].to));}if(order[0].level!=lst(order).level){order.push(new BidiSpan(order[0].level,len,len));}return order;};}();// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line){var order=line.order;if(order==null){order=line.order=bidiOrdering(line.text);}return order;}// EVENT HANDLING\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\nvar on=function(emitter,type,f){if(emitter.addEventListener){emitter.addEventListener(type,f,false);}else if(emitter.attachEvent){emitter.attachEvent("on"+type,f);}else{var map=emitter._handlers||(emitter._handlers={});var arr=map[type]||(map[type]=[]);arr.push(f);}};var noHandlers=[];function getHandlers(emitter,type,copy){var arr=emitter._handlers&&emitter._handlers[type];if(copy){return arr&&arr.length>0?arr.slice():noHandlers;}else{return arr||noHandlers;}}function off(emitter,type,f){if(emitter.removeEventListener){emitter.removeEventListener(type,f,false);}else if(emitter.detachEvent){emitter.detachEvent("on"+type,f);}else{var handlers=getHandlers(emitter,type,false);for(var i=0;i<handlers.length;++i){if(handlers[i]==f){handlers.splice(i,1);break;}}}}function signal(emitter,type/*, values...*/){var handlers=getHandlers(emitter,type,true);if(!handlers.length){return;}var args=Array.prototype.slice.call(arguments,2);for(var i=0;i<handlers.length;++i){handlers[i].apply(null,args);}}// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm,e,override){if(typeof e=="string"){e={type:e,preventDefault:function(){this.defaultPrevented=true;}};}signal(cm,override||e.type,cm,e);return e_defaultPrevented(e)||e.codemirrorIgnore;}function signalCursorActivity(cm){var arr=cm._handlers&&cm._handlers.cursorActivity;if(!arr){return;}var set=cm.curOp.cursorActivityHandlers||(cm.curOp.cursorActivityHandlers=[]);for(var i=0;i<arr.length;++i){if(indexOf(set,arr[i])==-1){set.push(arr[i]);}}}function hasHandler(emitter,type){return getHandlers(emitter,type).length>0;}// Add on and off methods to a constructor\'s prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor){ctor.prototype.on=function(type,f){on(this,type,f);};ctor.prototype.off=function(type,f){off(this,type,f);};}// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\nfunction e_preventDefault(e){if(e.preventDefault){e.preventDefault();}else{e.returnValue=false;}}function e_stopPropagation(e){if(e.stopPropagation){e.stopPropagation();}else{e.cancelBubble=true;}}function e_defaultPrevented(e){return e.defaultPrevented!=null?e.defaultPrevented:e.returnValue==false;}function e_stop(e){e_preventDefault(e);e_stopPropagation(e);}function e_target(e){return e.target||e.srcElement;}function e_button(e){var b=e.which;if(b==null){if(e.button&1){b=1;}else if(e.button&2){b=3;}else if(e.button&4){b=2;}}if(mac&&e.ctrlKey&&b==1){b=3;}return b;}// Detect drag-and-drop\nvar dragAndDrop=function(){// There is *some* kind of drag-and-drop support in IE6-8, but I\n// couldn\'t get it to work yet.\nif(ie&&ie_version<9){return false;}var div=elt(\'div\');return"draggable"in div||"dragDrop"in div;}();var zwspSupported;function zeroWidthElement(measure){if(zwspSupported==null){var test=elt("span","\\u200b");removeChildrenAndAdd(measure,elt("span",[test,document.createTextNode("x")]));if(measure.firstChild.offsetHeight!=0){zwspSupported=test.offsetWidth<=1&&test.offsetHeight>2&&!(ie&&ie_version<8);}}var node=zwspSupported?elt("span","\\u200b"):elt("span","\\u00a0",null,"display: inline-block; width: 1px; margin-right: -1px");node.setAttribute("cm-text","");return node;}// Feature-detect IE\'s crummy client rect reporting for bidi text\nvar badBidiRects;function hasBadBidiRects(measure){if(badBidiRects!=null){return badBidiRects;}var txt=removeChildrenAndAdd(measure,document.createTextNode("A\\u062eA"));var r0=range(txt,0,1).getBoundingClientRect();var r1=range(txt,1,2).getBoundingClientRect();removeChildren(measure);if(!r0||r0.left==r0.right){return false;}// Safari returns null in some cases (#2780)\nreturn badBidiRects=r1.right-r0.right<3;}// See if "".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto="\\n\\nb".split(/\\n/).length!=3?function(string){var pos=0,result=[],l=string.length;while(pos<=l){var nl=string.indexOf("\\n",pos);if(nl==-1){nl=string.length;}var line=string.slice(pos,string.charAt(nl-1)=="\\r"?nl-1:nl);var rt=line.indexOf("\\r");if(rt!=-1){result.push(line.slice(0,rt));pos+=rt+1;}else{result.push(line);pos=nl+1;}}return result;}:function(string){return string.split(/\\r\\n?|\\n/);};var hasSelection=window.getSelection?function(te){try{return te.selectionStart!=te.selectionEnd;}catch(e){return false;}}:function(te){var range;try{range=te.ownerDocument.selection.createRange();}catch(e){}if(!range||range.parentElement()!=te){return false;}return range.compareEndPoints("StartToEnd",range)!=0;};var hasCopyEvent=function(){var e=elt("div");if("oncopy"in e){return true;}e.setAttribute("oncopy","return;");return typeof e.oncopy=="function";}();var badZoomedRects=null;function hasBadZoomedRects(measure){if(badZoomedRects!=null){return badZoomedRects;}var node=removeChildrenAndAdd(measure,elt("span","x"));var normal=node.getBoundingClientRect();var fromRange=range(node,0,1).getBoundingClientRect();return badZoomedRects=Math.abs(normal.left-fromRange.left)>1;}var modes={};var mimeModes={};// Extra arguments are stored as the mode\'s dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name,mode){if(arguments.length>2){mode.dependencies=Array.prototype.slice.call(arguments,2);}modes[name]=mode;}function defineMIME(mime,spec){mimeModes[mime]=spec;}// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec){if(typeof spec=="string"&&mimeModes.hasOwnProperty(spec)){spec=mimeModes[spec];}else if(spec&&typeof spec.name=="string"&&mimeModes.hasOwnProperty(spec.name)){var found=mimeModes[spec.name];if(typeof found=="string"){found={name:found};}spec=createObj(found,spec);spec.name=found.name;}else if(typeof spec=="string"&&/^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)){return resolveMode("application/xml");}else if(typeof spec=="string"&&/^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)){return resolveMode("application/json");}if(typeof spec=="string"){return{name:spec};}else{return spec||{name:"null"};}}// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options,spec){spec=resolveMode(spec);var mfactory=modes[spec.name];if(!mfactory){return getMode(options,"text/plain");}var modeObj=mfactory(options,spec);if(modeExtensions.hasOwnProperty(spec.name)){var exts=modeExtensions[spec.name];for(var prop in exts){if(!exts.hasOwnProperty(prop)){continue;}if(modeObj.hasOwnProperty(prop)){modeObj["_"+prop]=modeObj[prop];}modeObj[prop]=exts[prop];}}modeObj.name=spec.name;if(spec.helperType){modeObj.helperType=spec.helperType;}if(spec.modeProps){for(var prop$1 in spec.modeProps){modeObj[prop$1]=spec.modeProps[prop$1];}}return modeObj;}// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions={};function extendMode(mode,properties){var exts=modeExtensions.hasOwnProperty(mode)?modeExtensions[mode]:modeExtensions[mode]={};copyObj(properties,exts);}function copyState(mode,state){if(state===true){return state;}if(mode.copyState){return mode.copyState(state);}var nstate={};for(var n in state){var val=state[n];if(val instanceof Array){val=val.concat([]);}nstate[n]=val;}return nstate;}// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode,state){var info;while(mode.innerMode){info=mode.innerMode(state);if(!info||info.mode==mode){break;}state=info.state;mode=info.mode;}return info||{mode:mode,state:state};}function startState(mode,a1,a2){return mode.startState?mode.startState(a1,a2):true;}// STRING STREAM\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\nvar StringStream=function(string,tabSize){this.pos=this.start=0;this.string=string;this.tabSize=tabSize||8;this.lastColumnPos=this.lastColumnValue=0;this.lineStart=0;};StringStream.prototype={eol:function(){return this.pos>=this.string.length;},sol:function(){return this.pos==this.lineStart;},peek:function(){return this.string.charAt(this.pos)||undefined;},next:function(){if(this.pos<this.string.length){return this.string.charAt(this.pos++);}},eat:function(match){var ch=this.string.charAt(this.pos);var ok;if(typeof match=="string"){ok=ch==match;}else{ok=ch&&(match.test?match.test(ch):match(ch));}if(ok){++this.pos;return ch;}},eatWhile:function(match){var start=this.pos;while(this.eat(match)){}return this.pos>start;},eatSpace:function(){var this$1=this;var start=this.pos;while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos))){++this$1.pos;}return this.pos>start;},skipToEnd:function(){this.pos=this.string.length;},skipTo:function(ch){var found=this.string.indexOf(ch,this.pos);if(found>-1){this.pos=found;return true;}},backUp:function(n){this.pos-=n;},column:function(){if(this.lastColumnPos<this.start){this.lastColumnValue=countColumn(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue);this.lastColumnPos=this.start;}return this.lastColumnValue-(this.lineStart?countColumn(this.string,this.lineStart,this.tabSize):0);},indentation:function(){return countColumn(this.string,null,this.tabSize)-(this.lineStart?countColumn(this.string,this.lineStart,this.tabSize):0);},match:function(pattern,consume,caseInsensitive){if(typeof pattern=="string"){var cased=function(str){return caseInsensitive?str.toLowerCase():str;};var substr=this.string.substr(this.pos,pattern.length);if(cased(substr)==cased(pattern)){if(consume!==false){this.pos+=pattern.length;}return true;}}else{var match=this.string.slice(this.pos).match(pattern);if(match&&match.index>0){return null;}if(match&&consume!==false){this.pos+=match[0].length;}return match;}},current:function(){return this.string.slice(this.start,this.pos);},hideFirstChars:function(n,inner){this.lineStart+=n;try{return inner();}finally{this.lineStart-=n;}}};// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm,line,state,forceToEnd){// A styles array always starts with a number identifying the\n// mode/overlays that it is based on (for easy invalidation).\nvar st=[cm.state.modeGen],lineClasses={};// Compute the base array of styles\nrunMode(cm,line.text,cm.doc.mode,state,function(end,style){return st.push(end,style);},lineClasses,forceToEnd);// Run overlays, adjust style array.\nvar loop=function(o){var overlay=cm.state.overlays[o],i=1,at=0;runMode(cm,line.text,overlay.mode,true,function(end,style){var start=i;// Ensure there\'s a token end at the current position, and that i points at it\nwhile(at<end){var i_end=st[i];if(i_end>end){st.splice(i,1,end,st[i+1],i_end);}i+=2;at=Math.min(end,i_end);}if(!style){return;}if(overlay.opaque){st.splice(start,i-start,end,"overlay "+style);i=start+2;}else{for(;start<i;start+=2){var cur=st[start+1];st[start+1]=(cur?cur+" ":"")+"overlay "+style;}}},lineClasses);};for(var o=0;o<cm.state.overlays.length;++o)loop(o);return{styles:st,classes:lineClasses.bgClass||lineClasses.textClass?lineClasses:null};}function getLineStyles(cm,line,updateFrontier){if(!line.styles||line.styles[0]!=cm.state.modeGen){var state=getStateBefore(cm,lineNo(line));var result=highlightLine(cm,line,line.text.length>cm.options.maxHighlightLength?copyState(cm.doc.mode,state):state);line.stateAfter=state;line.styles=result.styles;if(result.classes){line.styleClasses=result.classes;}else if(line.styleClasses){line.styleClasses=null;}if(updateFrontier===cm.doc.frontier){cm.doc.frontier++;}}return line.styles;}function getStateBefore(cm,n,precise){var doc=cm.doc,display=cm.display;if(!doc.mode.startState){return true;}var pos=findStartLine(cm,n,precise),state=pos>doc.first&&getLine(doc,pos-1).stateAfter;if(!state){state=startState(doc.mode);}else{state=copyState(doc.mode,state);}doc.iter(pos,n,function(line){processLine(cm,line.text,state);var save=pos==n-1||pos%5==0||pos>=display.viewFrom&&pos<display.viewTo;line.stateAfter=save?copyState(doc.mode,state):null;++pos;});if(precise){doc.frontier=pos;}return state;}// Lightweight form of highlight -- proceed over this line and\n// update state, but don\'t save a style array. Used for lines that\n// aren\'t currently visible.\nfunction processLine(cm,text,state,startAt){var mode=cm.doc.mode;var stream=new StringStream(text,cm.options.tabSize);stream.start=stream.pos=startAt||0;if(text==""){callBlankLine(mode,state);}while(!stream.eol()){readToken(mode,stream,state);stream.start=stream.pos;}}function callBlankLine(mode,state){if(mode.blankLine){return mode.blankLine(state);}if(!mode.innerMode){return;}var inner=innerMode(mode,state);if(inner.mode.blankLine){return inner.mode.blankLine(inner.state);}}function readToken(mode,stream,state,inner){for(var i=0;i<10;i++){if(inner){inner[0]=innerMode(mode,state).mode;}var style=mode.token(stream,state);if(stream.pos>stream.start){return style;}}throw new Error("Mode "+mode.name+" failed to advance stream.");}// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm,pos,precise,asArray){var getObj=function(copy){return{start:stream.start,end:stream.pos,string:stream.current(),type:style||null,state:copy?copyState(doc.mode,state):state};};var doc=cm.doc,mode=doc.mode,style;pos=clipPos(doc,pos);var line=getLine(doc,pos.line),state=getStateBefore(cm,pos.line,precise);var stream=new StringStream(line.text,cm.options.tabSize),tokens;if(asArray){tokens=[];}while((asArray||stream.pos<pos.ch)&&!stream.eol()){stream.start=stream.pos;style=readToken(mode,stream,state);if(asArray){tokens.push(getObj(true));}}return asArray?tokens:getObj();}function extractLineClasses(type,output){if(type){for(;;){var lineClass=type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);if(!lineClass){break;}type=type.slice(0,lineClass.index)+type.slice(lineClass.index+lineClass[0].length);var prop=lineClass[1]?"bgClass":"textClass";if(output[prop]==null){output[prop]=lineClass[2];}else if(!new RegExp("(?:^|\\s)"+lineClass[2]+"(?:$|\\s)").test(output[prop])){output[prop]+=" "+lineClass[2];}}}return type;}// Run the given mode\'s parser over a line, calling f for each token.\nfunction runMode(cm,text,mode,state,f,lineClasses,forceToEnd){var flattenSpans=mode.flattenSpans;if(flattenSpans==null){flattenSpans=cm.options.flattenSpans;}var curStart=0,curStyle=null;var stream=new StringStream(text,cm.options.tabSize),style;var inner=cm.options.addModeClass&&[null];if(text==""){extractLineClasses(callBlankLine(mode,state),lineClasses);}while(!stream.eol()){if(stream.pos>cm.options.maxHighlightLength){flattenSpans=false;if(forceToEnd){processLine(cm,text,state,stream.pos);}stream.pos=text.length;style=null;}else{style=extractLineClasses(readToken(mode,stream,state,inner),lineClasses);}if(inner){var mName=inner[0].name;if(mName){style="m-"+(style?mName+" "+style:mName);}}if(!flattenSpans||curStyle!=style){while(curStart<stream.start){curStart=Math.min(stream.start,curStart+5000);f(curStart,curStyle);}curStyle=style;}stream.start=stream.pos;}while(curStart<stream.pos){// Webkit seems to refuse to render text nodes longer than 57444\n// characters, and returns inaccurate measurements in nodes\n// starting around 5000 chars.\nvar pos=Math.min(stream.pos,curStart+5000);f(pos,curStyle);curStart=pos;}}// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm,n,precise){var minindent,minline,doc=cm.doc;var lim=precise?-1:n-(cm.doc.mode.innerMode?1000:100);for(var search=n;search>lim;--search){if(search<=doc.first){return doc.first;}var line=getLine(doc,search-1);if(line.stateAfter&&(!precise||search<=doc.frontier)){return search;}var indented=countColumn(line.text,null,cm.options.tabSize);if(minline==null||minindent>indented){minline=search-1;minindent=indented;}}return minline;}// LINE DATA STRUCTURE\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nfunction Line(text,markedSpans,estimateHeight){this.text=text;attachMarkedSpans(this,markedSpans);this.height=estimateHeight?estimateHeight(this):1;}eventMixin(Line);Line.prototype.lineNo=function(){return lineNo(this);};// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line\'s height.\nfunction updateLine(line,text,markedSpans,estimateHeight){line.text=text;if(line.stateAfter){line.stateAfter=null;}if(line.styles){line.styles=null;}if(line.order!=null){line.order=null;}detachMarkedSpans(line);attachMarkedSpans(line,markedSpans);var estHeight=estimateHeight?estimateHeight(line):1;if(estHeight!=line.height){updateLineHeight(line,estHeight);}}// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line){line.parent=null;detachMarkedSpans(line);}// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache={};var styleToClassCacheWithMode={};function interpretTokenStyle(style,options){if(!style||/^\\s*$/.test(style)){return null;}var cache=options.addModeClass?styleToClassCacheWithMode:styleToClassCache;return cache[style]||(cache[style]=style.replace(/\\S+/g,"cm-$&"));}// Render the DOM representation of the text of a line. Also builds\n// up a \'line map\', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm,lineView){// The padding-right forces the element to have a \'border\', which\n// is needed on Webkit to be able to get line-level bounding\n// rectangles for it (in measureChar).\nvar content=elt("span",null,null,webkit?"padding-right: .1px":null);var builder={pre:elt("pre",[content],"CodeMirror-line"),content:content,col:0,pos:0,cm:cm,trailingSpace:false,splitSpaces:(ie||webkit)&&cm.getOption("lineWrapping")};lineView.measure={};// Iterate over the logical lines that make up this visual line.\nfor(var i=0;i<=(lineView.rest?lineView.rest.length:0);i++){var line=i?lineView.rest[i-1]:lineView.line,order=void 0;builder.pos=0;builder.addToken=buildToken;// Optionally wire in some hacks into the token-rendering\n// algorithm, to deal with browser quirks.\nif(hasBadBidiRects(cm.display.measure)&&(order=getOrder(line))){builder.addToken=buildTokenBadBidi(builder.addToken,order);}builder.map=[];var allowFrontierUpdate=lineView!=cm.display.externalMeasured&&lineNo(line);insertLineContent(line,builder,getLineStyles(cm,line,allowFrontierUpdate));if(line.styleClasses){if(line.styleClasses.bgClass){builder.bgClass=joinClasses(line.styleClasses.bgClass,builder.bgClass||"");}if(line.styleClasses.textClass){builder.textClass=joinClasses(line.styleClasses.textClass,builder.textClass||"");}}// Ensure at least a single node is present, for measuring.\nif(builder.map.length==0){builder.map.push(0,0,builder.content.appendChild(zeroWidthElement(cm.display.measure)));}// Store the map and a cache object for the current logical line\nif(i==0){lineView.measure.map=builder.map;lineView.measure.cache={};}else{;(lineView.measure.maps||(lineView.measure.maps=[])).push(builder.map);(lineView.measure.caches||(lineView.measure.caches=[])).push({});}}// See issue #2901\nif(webkit){var last=builder.content.lastChild;if(/\\bcm-tab\\b/.test(last.className)||last.querySelector&&last.querySelector(".cm-tab")){builder.content.className="cm-tab-wrap-hack";}}signal(cm,"renderLine",cm,lineView.line,builder.pre);if(builder.pre.className){builder.textClass=joinClasses(builder.pre.className,builder.textClass||"");}return builder;}function defaultSpecialCharPlaceholder(ch){var token=elt("span","\\u2022","cm-invalidchar");token.title="\\\\u"+ch.charCodeAt(0).toString(16);token.setAttribute("aria-label",token.title);return token;}// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder,text,style,startStyle,endStyle,title,css){if(!text){return;}var displayText=builder.splitSpaces?splitSpaces(text,builder.trailingSpace):text;var special=builder.cm.state.specialChars,mustWrap=false;var content;if(!special.test(text)){builder.col+=text.length;content=document.createTextNode(displayText);builder.map.push(builder.pos,builder.pos+text.length,content);if(ie&&ie_version<9){mustWrap=true;}builder.pos+=text.length;}else{content=document.createDocumentFragment();var pos=0;while(true){special.lastIndex=pos;var m=special.exec(text);var skipped=m?m.index-pos:text.length-pos;if(skipped){var txt=document.createTextNode(displayText.slice(pos,pos+skipped));if(ie&&ie_version<9){content.appendChild(elt("span",[txt]));}else{content.appendChild(txt);}builder.map.push(builder.pos,builder.pos+skipped,txt);builder.col+=skipped;builder.pos+=skipped;}if(!m){break;}pos+=skipped+1;var txt$1=void 0;if(m[0]=="\\t"){var tabSize=builder.cm.options.tabSize,tabWidth=tabSize-builder.col%tabSize;txt$1=content.appendChild(elt("span",spaceStr(tabWidth),"cm-tab"));txt$1.setAttribute("role","presentation");txt$1.setAttribute("cm-text","\\t");builder.col+=tabWidth;}else if(m[0]=="\\r"||m[0]=="\\n"){txt$1=content.appendChild(elt("span",m[0]=="\\r"?"\\u240d":"\\u2424","cm-invalidchar"));txt$1.setAttribute("cm-text",m[0]);builder.col+=1;}else{txt$1=builder.cm.options.specialCharPlaceholder(m[0]);txt$1.setAttribute("cm-text",m[0]);if(ie&&ie_version<9){content.appendChild(elt("span",[txt$1]));}else{content.appendChild(txt$1);}builder.col+=1;}builder.map.push(builder.pos,builder.pos+1,txt$1);builder.pos++;}}builder.trailingSpace=displayText.charCodeAt(text.length-1)==32;if(style||startStyle||endStyle||mustWrap||css){var fullStyle=style||"";if(startStyle){fullStyle+=startStyle;}if(endStyle){fullStyle+=endStyle;}var token=elt("span",[content],fullStyle,css);if(title){token.title=title;}return builder.content.appendChild(token);}builder.content.appendChild(content);}function splitSpaces(text,trailingBefore){if(text.length>1&&!/  /.test(text)){return text;}var spaceBefore=trailingBefore,result="";for(var i=0;i<text.length;i++){var ch=text.charAt(i);if(ch==" "&&spaceBefore&&(i==text.length-1||text.charCodeAt(i+1)==32)){ch="\\u00a0";}result+=ch;spaceBefore=ch==" ";}return result;}// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner,order){return function(builder,text,style,startStyle,endStyle,title,css){style=style?style+" cm-force-border":"cm-force-border";var start=builder.pos,end=start+text.length;for(;;){// Find the part that overlaps with the start of this text\nvar part=void 0;for(var i=0;i<order.length;i++){part=order[i];if(part.to>start&&part.from<=start){break;}}if(part.to>=end){return inner(builder,text,style,startStyle,endStyle,title,css);}inner(builder,text.slice(0,part.to-start),style,startStyle,null,title,css);startStyle=null;text=text.slice(part.to-start);start=part.to;}};}function buildCollapsedSpan(builder,size,marker,ignoreWidget){var widget=!ignoreWidget&&marker.widgetNode;if(widget){builder.map.push(builder.pos,builder.pos+size,widget);}if(!ignoreWidget&&builder.cm.display.input.needsContentAttribute){if(!widget){widget=builder.content.appendChild(document.createElement("span"));}widget.setAttribute("cm-marker",marker.id);}if(widget){builder.cm.display.input.setUneditable(widget);builder.content.appendChild(widget);}builder.pos+=size;builder.trailingSpace=false;}// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line,builder,styles){var spans=line.markedSpans,allText=line.text,at=0;if(!spans){for(var i$1=1;i$1<styles.length;i$1+=2){builder.addToken(builder,allText.slice(at,at=styles[i$1]),interpretTokenStyle(styles[i$1+1],builder.cm.options));}return;}var len=allText.length,pos=0,i=1,text="",style,css;var nextChange=0,spanStyle,spanEndStyle,spanStartStyle,title,collapsed;for(;;){if(nextChange==pos){// Update current marker set\nspanStyle=spanEndStyle=spanStartStyle=title=css="";collapsed=null;nextChange=Infinity;var foundBookmarks=[],endStyles=void 0;for(var j=0;j<spans.length;++j){var sp=spans[j],m=sp.marker;if(m.type=="bookmark"&&sp.from==pos&&m.widgetNode){foundBookmarks.push(m);}else if(sp.from<=pos&&(sp.to==null||sp.to>pos||m.collapsed&&sp.to==pos&&sp.from==pos)){if(sp.to!=null&&sp.to!=pos&&nextChange>sp.to){nextChange=sp.to;spanEndStyle="";}if(m.className){spanStyle+=" "+m.className;}if(m.css){css=(css?css+";":"")+m.css;}if(m.startStyle&&sp.from==pos){spanStartStyle+=" "+m.startStyle;}if(m.endStyle&&sp.to==nextChange){(endStyles||(endStyles=[])).push(m.endStyle,sp.to);}if(m.title&&!title){title=m.title;}if(m.collapsed&&(!collapsed||compareCollapsedMarkers(collapsed.marker,m)<0)){collapsed=sp;}}else if(sp.from>pos&&nextChange>sp.from){nextChange=sp.from;}}if(endStyles){for(var j$1=0;j$1<endStyles.length;j$1+=2){if(endStyles[j$1+1]==nextChange){spanEndStyle+=" "+endStyles[j$1];}}}if(!collapsed||collapsed.from==pos){for(var j$2=0;j$2<foundBookmarks.length;++j$2){buildCollapsedSpan(builder,0,foundBookmarks[j$2]);}}if(collapsed&&(collapsed.from||0)==pos){buildCollapsedSpan(builder,(collapsed.to==null?len+1:collapsed.to)-pos,collapsed.marker,collapsed.from==null);if(collapsed.to==null){return;}if(collapsed.to==pos){collapsed=false;}}}if(pos>=len){break;}var upto=Math.min(len,nextChange);while(true){if(text){var end=pos+text.length;if(!collapsed){var tokenText=end>upto?text.slice(0,upto-pos):text;builder.addToken(builder,tokenText,style?style+spanStyle:spanStyle,spanStartStyle,pos+tokenText.length==nextChange?spanEndStyle:"",title,css);}if(end>=upto){text=text.slice(upto-pos);pos=upto;break;}pos=end;spanStartStyle="";}text=allText.slice(at,at=styles[i++]);style=interpretTokenStyle(styles[i++],builder.cm.options);}}}// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc,line,lineN){// The starting line\nthis.line=line;// Continuing lines, if any\nthis.rest=visualLineContinued(line);// Number of logical lines in this visual line\nthis.size=this.rest?lineNo(lst(this.rest))-lineN+1:1;this.node=this.text=null;this.hidden=lineIsHidden(doc,line);}// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm,from,to){var array=[],nextPos;for(var pos=from;pos<to;pos=nextPos){var view=new LineView(cm.doc,getLine(cm.doc,pos),pos);nextPos=pos+view.size;array.push(view);}return array;}var operationGroup=null;function pushOperation(op){if(operationGroup){operationGroup.ops.push(op);}else{op.ownsGroup=operationGroup={ops:[op],delayedCallbacks:[]};}}function fireCallbacksForOps(group){// Calls delayed callbacks and cursorActivity handlers until no\n// new ones appear\nvar callbacks=group.delayedCallbacks,i=0;do{for(;i<callbacks.length;i++){callbacks[i].call(null);}for(var j=0;j<group.ops.length;j++){var op=group.ops[j];if(op.cursorActivityHandlers){while(op.cursorActivityCalled<op.cursorActivityHandlers.length){op.cursorActivityHandlers[op.cursorActivityCalled++].call(null,op.cm);}}}}while(i<callbacks.length);}function finishOperation(op,endCb){var group=op.ownsGroup;if(!group){return;}try{fireCallbacksForOps(group);}finally{operationGroup=null;endCb(group);}}var orphanDelayedCallbacks=null;// Often, we want to signal events at a point where we are in the\n// middle of some work, but don\'t want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter,type/*, values...*/){var arr=getHandlers(emitter,type,false);if(!arr.length){return;}var args=Array.prototype.slice.call(arguments,2),list;if(operationGroup){list=operationGroup.delayedCallbacks;}else if(orphanDelayedCallbacks){list=orphanDelayedCallbacks;}else{list=orphanDelayedCallbacks=[];setTimeout(fireOrphanDelayed,0);}var loop=function(i){list.push(function(){return arr[i].apply(null,args);});};for(var i=0;i<arr.length;++i)loop(i);}function fireOrphanDelayed(){var delayed=orphanDelayedCallbacks;orphanDelayedCallbacks=null;for(var i=0;i<delayed.length;++i){delayed[i]();}}// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line\'s\n// DOM structure.\nfunction updateLineForChanges(cm,lineView,lineN,dims){for(var j=0;j<lineView.changes.length;j++){var type=lineView.changes[j];if(type=="text"){updateLineText(cm,lineView);}else if(type=="gutter"){updateLineGutter(cm,lineView,lineN,dims);}else if(type=="class"){updateLineClasses(lineView);}else if(type=="widget"){updateLineWidgets(cm,lineView,dims);}}lineView.changes=null;}// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView){if(lineView.node==lineView.text){lineView.node=elt("div",null,null,"position: relative");if(lineView.text.parentNode){lineView.text.parentNode.replaceChild(lineView.node,lineView.text);}lineView.node.appendChild(lineView.text);if(ie&&ie_version<8){lineView.node.style.zIndex=2;}}return lineView.node;}function updateLineBackground(lineView){var cls=lineView.bgClass?lineView.bgClass+" "+(lineView.line.bgClass||""):lineView.line.bgClass;if(cls){cls+=" CodeMirror-linebackground";}if(lineView.background){if(cls){lineView.background.className=cls;}else{lineView.background.parentNode.removeChild(lineView.background);lineView.background=null;}}else if(cls){var wrap=ensureLineWrapped(lineView);lineView.background=wrap.insertBefore(elt("div",null,cls),wrap.firstChild);}}// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm,lineView){var ext=cm.display.externalMeasured;if(ext&&ext.line==lineView.line){cm.display.externalMeasured=null;lineView.measure=ext.measure;return ext.built;}return buildLineContent(cm,lineView);}// Redraw the line\'s text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm,lineView){var cls=lineView.text.className;var built=getLineContent(cm,lineView);if(lineView.text==lineView.node){lineView.node=built.pre;}lineView.text.parentNode.replaceChild(built.pre,lineView.text);lineView.text=built.pre;if(built.bgClass!=lineView.bgClass||built.textClass!=lineView.textClass){lineView.bgClass=built.bgClass;lineView.textClass=built.textClass;updateLineClasses(lineView);}else if(cls){lineView.text.className=cls;}}function updateLineClasses(lineView){updateLineBackground(lineView);if(lineView.line.wrapClass){ensureLineWrapped(lineView).className=lineView.line.wrapClass;}else if(lineView.node!=lineView.text){lineView.node.className="";}var textClass=lineView.textClass?lineView.textClass+" "+(lineView.line.textClass||""):lineView.line.textClass;lineView.text.className=textClass||"";}function updateLineGutter(cm,lineView,lineN,dims){if(lineView.gutter){lineView.node.removeChild(lineView.gutter);lineView.gutter=null;}if(lineView.gutterBackground){lineView.node.removeChild(lineView.gutterBackground);lineView.gutterBackground=null;}if(lineView.line.gutterClass){var wrap=ensureLineWrapped(lineView);lineView.gutterBackground=elt("div",null,"CodeMirror-gutter-background "+lineView.line.gutterClass,"left: "+(cm.options.fixedGutter?dims.fixedPos:-dims.gutterTotalWidth)+"px; width: "+dims.gutterTotalWidth+"px");wrap.insertBefore(lineView.gutterBackground,lineView.text);}var markers=lineView.line.gutterMarkers;if(cm.options.lineNumbers||markers){var wrap$1=ensureLineWrapped(lineView);var gutterWrap=lineView.gutter=elt("div",null,"CodeMirror-gutter-wrapper","left: "+(cm.options.fixedGutter?dims.fixedPos:-dims.gutterTotalWidth)+"px");cm.display.input.setUneditable(gutterWrap);wrap$1.insertBefore(gutterWrap,lineView.text);if(lineView.line.gutterClass){gutterWrap.className+=" "+lineView.line.gutterClass;}if(cm.options.lineNumbers&&(!markers||!markers["CodeMirror-linenumbers"])){lineView.lineNumber=gutterWrap.appendChild(elt("div",lineNumberFor(cm.options,lineN),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+dims.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+cm.display.lineNumInnerWidth+"px"));}if(markers){for(var k=0;k<cm.options.gutters.length;++k){var id=cm.options.gutters[k],found=markers.hasOwnProperty(id)&&markers[id];if(found){gutterWrap.appendChild(elt("div",[found],"CodeMirror-gutter-elt","left: "+dims.gutterLeft[id]+"px; width: "+dims.gutterWidth[id]+"px"));}}}}}function updateLineWidgets(cm,lineView,dims){if(lineView.alignable){lineView.alignable=null;}for(var node=lineView.node.firstChild,next=void 0;node;node=next){next=node.nextSibling;if(node.className=="CodeMirror-linewidget"){lineView.node.removeChild(node);}}insertLineWidgets(cm,lineView,dims);}// Build a line\'s DOM representation from scratch\nfunction buildLineElement(cm,lineView,lineN,dims){var built=getLineContent(cm,lineView);lineView.text=lineView.node=built.pre;if(built.bgClass){lineView.bgClass=built.bgClass;}if(built.textClass){lineView.textClass=built.textClass;}updateLineClasses(lineView);updateLineGutter(cm,lineView,lineN,dims);insertLineWidgets(cm,lineView,dims);return lineView.node;}// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm,lineView,dims){insertLineWidgetsFor(cm,lineView.line,lineView,dims,true);if(lineView.rest){for(var i=0;i<lineView.rest.length;i++){insertLineWidgetsFor(cm,lineView.rest[i],lineView,dims,false);}}}function insertLineWidgetsFor(cm,line,lineView,dims,allowAbove){if(!line.widgets){return;}var wrap=ensureLineWrapped(lineView);for(var i=0,ws=line.widgets;i<ws.length;++i){var widget=ws[i],node=elt("div",[widget.node],"CodeMirror-linewidget");if(!widget.handleMouseEvents){node.setAttribute("cm-ignore-events","true");}positionLineWidget(widget,node,lineView,dims);cm.display.input.setUneditable(node);if(allowAbove&&widget.above){wrap.insertBefore(node,lineView.gutter||lineView.text);}else{wrap.appendChild(node);}signalLater(widget,"redraw");}}function positionLineWidget(widget,node,lineView,dims){if(widget.noHScroll){;(lineView.alignable||(lineView.alignable=[])).push(node);var width=dims.wrapperWidth;node.style.left=dims.fixedPos+"px";if(!widget.coverGutter){width-=dims.gutterTotalWidth;node.style.paddingLeft=dims.gutterTotalWidth+"px";}node.style.width=width+"px";}if(widget.coverGutter){node.style.zIndex=5;node.style.position="relative";if(!widget.noHScroll){node.style.marginLeft=-dims.gutterTotalWidth+"px";}}}function widgetHeight(widget){if(widget.height!=null){return widget.height;}var cm=widget.doc.cm;if(!cm){return 0;}if(!contains(document.body,widget.node)){var parentStyle="position: relative;";if(widget.coverGutter){parentStyle+="margin-left: -"+cm.display.gutters.offsetWidth+"px;";}if(widget.noHScroll){parentStyle+="width: "+cm.display.wrapper.clientWidth+"px;";}removeChildrenAndAdd(cm.display.measure,elt("div",[widget.node],null,parentStyle));}return widget.height=widget.node.parentNode.offsetHeight;}// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display,e){for(var n=e_target(e);n!=display.wrapper;n=n.parentNode){if(!n||n.nodeType==1&&n.getAttribute("cm-ignore-events")=="true"||n.parentNode==display.sizer&&n!=display.mover){return true;}}}// POSITION MEASUREMENT\nfunction paddingTop(display){return display.lineSpace.offsetTop;}function paddingVert(display){return display.mover.offsetHeight-display.lineSpace.offsetHeight;}function paddingH(display){if(display.cachedPaddingH){return display.cachedPaddingH;}var e=removeChildrenAndAdd(display.measure,elt("pre","x"));var style=window.getComputedStyle?window.getComputedStyle(e):e.currentStyle;var data={left:parseInt(style.paddingLeft),right:parseInt(style.paddingRight)};if(!isNaN(data.left)&&!isNaN(data.right)){display.cachedPaddingH=data;}return data;}function scrollGap(cm){return scrollerGap-cm.display.nativeBarWidth;}function displayWidth(cm){return cm.display.scroller.clientWidth-scrollGap(cm)-cm.display.barWidth;}function displayHeight(cm){return cm.display.scroller.clientHeight-scrollGap(cm)-cm.display.barHeight;}// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm,lineView,rect){var wrapping=cm.options.lineWrapping;var curWidth=wrapping&&displayWidth(cm);if(!lineView.measure.heights||wrapping&&lineView.measure.width!=curWidth){var heights=lineView.measure.heights=[];if(wrapping){lineView.measure.width=curWidth;var rects=lineView.text.firstChild.getClientRects();for(var i=0;i<rects.length-1;i++){var cur=rects[i],next=rects[i+1];if(Math.abs(cur.bottom-next.bottom)>2){heights.push((cur.bottom+next.top)/2-rect.top);}}}heights.push(rect.bottom-rect.top);}}// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView,line,lineN){if(lineView.line==line){return{map:lineView.measure.map,cache:lineView.measure.cache};}for(var i=0;i<lineView.rest.length;i++){if(lineView.rest[i]==line){return{map:lineView.measure.maps[i],cache:lineView.measure.caches[i]};}}for(var i$1=0;i$1<lineView.rest.length;i$1++){if(lineNo(lineView.rest[i$1])>lineN){return{map:lineView.measure.maps[i$1],cache:lineView.measure.caches[i$1],before:true};}}}// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that\'s not in the viewport.\nfunction updateExternalMeasurement(cm,line){line=visualLine(line);var lineN=lineNo(line);var view=cm.display.externalMeasured=new LineView(cm.doc,line,lineN);view.lineN=lineN;var built=view.built=buildLineContent(cm,view);view.text=built.pre;removeChildrenAndAdd(cm.display.lineMeasure,built.pre);return view;}// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm,line,ch,bias){return measureCharPrepared(cm,prepareMeasureForLine(cm,line),ch,bias);}// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm,lineN){if(lineN>=cm.display.viewFrom&&lineN<cm.display.viewTo){return cm.display.view[findViewIndex(cm,lineN)];}var ext=cm.display.externalMeasured;if(ext&&lineN>=ext.lineN&&lineN<ext.lineN+ext.size){return ext;}}// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm,line){var lineN=lineNo(line);var view=findViewForLine(cm,lineN);if(view&&!view.text){view=null;}else if(view&&view.changes){updateLineForChanges(cm,view,lineN,getDimensions(cm));cm.curOp.forceUpdate=true;}if(!view){view=updateExternalMeasurement(cm,line);}var info=mapFromLineView(view,line,lineN);return{line:line,view:view,rect:null,map:info.map,cache:info.cache,before:info.before,hasHeights:false};}// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm,prepared,ch,bias,varHeight){if(prepared.before){ch=-1;}var key=ch+(bias||""),found;if(prepared.cache.hasOwnProperty(key)){found=prepared.cache[key];}else{if(!prepared.rect){prepared.rect=prepared.view.text.getBoundingClientRect();}if(!prepared.hasHeights){ensureLineHeights(cm,prepared.view,prepared.rect);prepared.hasHeights=true;}found=measureCharInner(cm,prepared,ch,bias);if(!found.bogus){prepared.cache[key]=found;}}return{left:found.left,right:found.right,top:varHeight?found.rtop:found.top,bottom:varHeight?found.rbottom:found.bottom};}var nullRect={left:0,right:0,top:0,bottom:0};function nodeAndOffsetInLineMap(map,ch,bias){var node,start,end,collapse,mStart,mEnd;// First, search the line map for the text node corresponding to,\n// or closest to, the target character.\nfor(var i=0;i<map.length;i+=3){mStart=map[i];mEnd=map[i+1];if(ch<mStart){start=0;end=1;collapse="left";}else if(ch<mEnd){start=ch-mStart;end=start+1;}else if(i==map.length-3||ch==mEnd&&map[i+3]>ch){end=mEnd-mStart;start=end-1;if(ch>=mEnd){collapse="right";}}if(start!=null){node=map[i+2];if(mStart==mEnd&&bias==(node.insertLeft?"left":"right")){collapse=bias;}if(bias=="left"&&start==0){while(i&&map[i-2]==map[i-3]&&map[i-1].insertLeft){node=map[(i-=3)+2];collapse="left";}}if(bias=="right"&&start==mEnd-mStart){while(i<map.length-3&&map[i+3]==map[i+4]&&!map[i+5].insertLeft){node=map[(i+=3)+2];collapse="right";}}break;}}return{node:node,start:start,end:end,collapse:collapse,coverStart:mStart,coverEnd:mEnd};}function getUsefulRect(rects,bias){var rect=nullRect;if(bias=="left"){for(var i=0;i<rects.length;i++){if((rect=rects[i]).left!=rect.right){break;}}}else{for(var i$1=rects.length-1;i$1>=0;i$1--){if((rect=rects[i$1]).left!=rect.right){break;}}}return rect;}function measureCharInner(cm,prepared,ch,bias){var place=nodeAndOffsetInLineMap(prepared.map,ch,bias);var node=place.node,start=place.start,end=place.end,collapse=place.collapse;var rect;if(node.nodeType==3){// If it is a text node, use a range to retrieve the coordinates.\nfor(var i$1=0;i$1<4;i$1++){// Retry a maximum of 4 times when nonsense rectangles are returned\nwhile(start&&isExtendingChar(prepared.line.text.charAt(place.coverStart+start))){--start;}while(place.coverStart+end<place.coverEnd&&isExtendingChar(prepared.line.text.charAt(place.coverStart+end))){++end;}if(ie&&ie_version<9&&start==0&&end==place.coverEnd-place.coverStart){rect=node.parentNode.getBoundingClientRect();}else{rect=getUsefulRect(range(node,start,end).getClientRects(),bias);}if(rect.left||rect.right||start==0){break;}end=start;start=start-1;collapse="right";}if(ie&&ie_version<11){rect=maybeUpdateRectForZooming(cm.display.measure,rect);}}else{// If it is a widget, simply get the box for the whole widget.\nif(start>0){collapse=bias="right";}var rects;if(cm.options.lineWrapping&&(rects=node.getClientRects()).length>1){rect=rects[bias=="right"?rects.length-1:0];}else{rect=node.getBoundingClientRect();}}if(ie&&ie_version<9&&!start&&(!rect||!rect.left&&!rect.right)){var rSpan=node.parentNode.getClientRects()[0];if(rSpan){rect={left:rSpan.left,right:rSpan.left+charWidth(cm.display),top:rSpan.top,bottom:rSpan.bottom};}else{rect=nullRect;}}var rtop=rect.top-prepared.rect.top,rbot=rect.bottom-prepared.rect.top;var mid=(rtop+rbot)/2;var heights=prepared.view.measure.heights;var i=0;for(;i<heights.length-1;i++){if(mid<heights[i]){break;}}var top=i?heights[i-1]:0,bot=heights[i];var result={left:(collapse=="right"?rect.right:rect.left)-prepared.rect.left,right:(collapse=="left"?rect.left:rect.right)-prepared.rect.left,top:top,bottom:bot};if(!rect.left&&!rect.right){result.bogus=true;}if(!cm.options.singleCursorHeightPerLine){result.rtop=rtop;result.rbottom=rbot;}return result;}// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure,rect){if(!window.screen||screen.logicalXDPI==null||screen.logicalXDPI==screen.deviceXDPI||!hasBadZoomedRects(measure)){return rect;}var scaleX=screen.logicalXDPI/screen.deviceXDPI;var scaleY=screen.logicalYDPI/screen.deviceYDPI;return{left:rect.left*scaleX,right:rect.right*scaleX,top:rect.top*scaleY,bottom:rect.bottom*scaleY};}function clearLineMeasurementCacheFor(lineView){if(lineView.measure){lineView.measure.cache={};lineView.measure.heights=null;if(lineView.rest){for(var i=0;i<lineView.rest.length;i++){lineView.measure.caches[i]={};}}}}function clearLineMeasurementCache(cm){cm.display.externalMeasure=null;removeChildren(cm.display.lineMeasure);for(var i=0;i<cm.display.view.length;i++){clearLineMeasurementCacheFor(cm.display.view[i]);}}function clearCaches(cm){clearLineMeasurementCache(cm);cm.display.cachedCharWidth=cm.display.cachedTextHeight=cm.display.cachedPaddingH=null;if(!cm.options.lineWrapping){cm.display.maxLineChanged=true;}cm.display.lineNumChars=null;}function pageScrollX(){return window.pageXOffset||(document.documentElement||document.body).scrollLeft;}function pageScrollY(){return window.pageYOffset||(document.documentElement||document.body).scrollTop;}// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// "line", "div" (display.lineDiv), "local"./null (editor), "window",\n// or "page".\nfunction intoCoordSystem(cm,lineObj,rect,context){if(lineObj.widgets){for(var i=0;i<lineObj.widgets.length;++i){if(lineObj.widgets[i].above){var size=widgetHeight(lineObj.widgets[i]);rect.top+=size;rect.bottom+=size;}}}if(context=="line"){return rect;}if(!context){context="local";}var yOff=heightAtLine(lineObj);if(context=="local"){yOff+=paddingTop(cm.display);}else{yOff-=cm.display.viewOffset;}if(context=="page"||context=="window"){var lOff=cm.display.lineSpace.getBoundingClientRect();yOff+=lOff.top+(context=="window"?0:pageScrollY());var xOff=lOff.left+(context=="window"?0:pageScrollX());rect.left+=xOff;rect.right+=xOff;}rect.top+=yOff;rect.bottom+=yOff;return rect;}// Coverts a box from "div" coords to another coordinate system.\n// Context may be "window", "page", "div", or "local"./null.\nfunction fromCoordSystem(cm,coords,context){if(context=="div"){return coords;}var left=coords.left,top=coords.top;// First move into "page" coordinate system\nif(context=="page"){left-=pageScrollX();top-=pageScrollY();}else if(context=="local"||!context){var localBox=cm.display.sizer.getBoundingClientRect();left+=localBox.left;top+=localBox.top;}var lineSpaceBox=cm.display.lineSpace.getBoundingClientRect();return{left:left-lineSpaceBox.left,top:top-lineSpaceBox.top};}function charCoords(cm,pos,context,lineObj,bias){if(!lineObj){lineObj=getLine(cm.doc,pos.line);}return intoCoordSystem(cm,lineObj,measureChar(cm,lineObj,pos.ch,bias),context);}// Returns a box for a given cursor position, which may have an\n// \'other\' property containing the position of the secondary cursor\n// on a bidi boundary.\nfunction cursorCoords(cm,pos,context,lineObj,preparedMeasure,varHeight){lineObj=lineObj||getLine(cm.doc,pos.line);if(!preparedMeasure){preparedMeasure=prepareMeasureForLine(cm,lineObj);}function get(ch,right){var m=measureCharPrepared(cm,preparedMeasure,ch,right?"right":"left",varHeight);if(right){m.left=m.right;}else{m.right=m.left;}return intoCoordSystem(cm,lineObj,m,context);}function getBidi(ch,partPos){var part=order[partPos],right=part.level%2;if(ch==bidiLeft(part)&&partPos&&part.level<order[partPos-1].level){part=order[--partPos];ch=bidiRight(part)-(part.level%2?0:1);right=true;}else if(ch==bidiRight(part)&&partPos<order.length-1&&part.level<order[partPos+1].level){part=order[++partPos];ch=bidiLeft(part)-part.level%2;right=false;}if(right&&ch==part.to&&ch>part.from){return get(ch-1);}return get(ch,right);}var order=getOrder(lineObj),ch=pos.ch;if(!order){return get(ch);}var partPos=getBidiPartAt(order,ch);var val=getBidi(ch,partPos);if(bidiOther!=null){val.other=getBidi(ch,bidiOther);}return val;}// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm,pos){var left=0;pos=clipPos(cm.doc,pos);if(!cm.options.lineWrapping){left=charWidth(cm.display)*pos.ch;}var lineObj=getLine(cm.doc,pos.line);var top=heightAtLine(lineObj)+paddingTop(cm.display);return{left:left,right:left,top:top,bottom:top+lineObj.height};}// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line\'s\n// vertical range.\nfunction PosWithInfo(line,ch,outside,xRel){var pos=Pos(line,ch);pos.xRel=xRel;if(outside){pos.outside=true;}return pos;}// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local ("div" coordinate system).\nfunction coordsChar(cm,x,y){var doc=cm.doc;y+=cm.display.viewOffset;if(y<0){return PosWithInfo(doc.first,0,true,-1);}var lineN=lineAtHeight(doc,y),last=doc.first+doc.size-1;if(lineN>last){return PosWithInfo(doc.first+doc.size-1,getLine(doc,last).text.length,true,1);}if(x<0){x=0;}var lineObj=getLine(doc,lineN);for(;;){var found=coordsCharInner(cm,lineObj,lineN,x,y);var merged=collapsedSpanAtEnd(lineObj);var mergedPos=merged&&merged.find(0,true);if(merged&&(found.ch>mergedPos.from.ch||found.ch==mergedPos.from.ch&&found.xRel>0)){lineN=lineNo(lineObj=mergedPos.to.line);}else{return found;}}}function coordsCharInner(cm,lineObj,lineNo,x,y){var innerOff=y-heightAtLine(lineObj);var wrongLine=false,adjust=2*cm.display.wrapper.clientWidth;var preparedMeasure=prepareMeasureForLine(cm,lineObj);function getX(ch){var sp=cursorCoords(cm,Pos(lineNo,ch),"line",lineObj,preparedMeasure);wrongLine=true;if(innerOff>sp.bottom){return sp.left-adjust;}else if(innerOff<sp.top){return sp.left+adjust;}else{wrongLine=false;}return sp.left;}var bidi=getOrder(lineObj),dist=lineObj.text.length;var from=lineLeft(lineObj),to=lineRight(lineObj);var fromX=getX(from),fromOutside=wrongLine,toX=getX(to),toOutside=wrongLine;if(x>toX){return PosWithInfo(lineNo,to,toOutside,1);}// Do a binary search between these bounds.\nfor(;;){if(bidi?to==from||to==moveVisually(lineObj,from,1):to-from<=1){var ch=x<fromX||x-fromX<=toX-x?from:to;var outside=ch==from?fromOutside:toOutside;var xDiff=x-(ch==from?fromX:toX);// This is a kludge to handle the case where the coordinates\n// are after a line-wrapped line. We should replace it with a\n// more general handling of cursor positions around line\n// breaks. (Issue #4078)\nif(toOutside&&!bidi&&!/\\s/.test(lineObj.text.charAt(ch))&&xDiff>0&&ch<lineObj.text.length&&preparedMeasure.view.measure.heights.length>1){var charSize=measureCharPrepared(cm,preparedMeasure,ch,"right");if(innerOff<=charSize.bottom&&innerOff>=charSize.top&&Math.abs(x-charSize.right)<xDiff){outside=false;ch++;xDiff=x-charSize.right;}}while(isExtendingChar(lineObj.text.charAt(ch))){++ch;}var pos=PosWithInfo(lineNo,ch,outside,xDiff<-1?-1:xDiff>1?1:0);return pos;}var step=Math.ceil(dist/2),middle=from+step;if(bidi){middle=from;for(var i=0;i<step;++i){middle=moveVisually(lineObj,middle,1);}}var middleX=getX(middle);if(middleX>x){to=middle;toX=middleX;if(toOutside=wrongLine){toX+=1000;}dist=step;}else{from=middle;fromX=middleX;fromOutside=wrongLine;dist-=step;}}}var measureText;// Compute the default text height.\nfunction textHeight(display){if(display.cachedTextHeight!=null){return display.cachedTextHeight;}if(measureText==null){measureText=elt("pre");// Measure a bunch of lines, for browsers that compute\n// fractional heights.\nfor(var i=0;i<49;++i){measureText.appendChild(document.createTextNode("x"));measureText.appendChild(elt("br"));}measureText.appendChild(document.createTextNode("x"));}removeChildrenAndAdd(display.measure,measureText);var height=measureText.offsetHeight/50;if(height>3){display.cachedTextHeight=height;}removeChildren(display.measure);return height||1;}// Compute the default character width.\nfunction charWidth(display){if(display.cachedCharWidth!=null){return display.cachedCharWidth;}var anchor=elt("span","xxxxxxxxxx");var pre=elt("pre",[anchor]);removeChildrenAndAdd(display.measure,pre);var rect=anchor.getBoundingClientRect(),width=(rect.right-rect.left)/10;if(width>2){display.cachedCharWidth=width;}return width||10;}// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don\'t interleave reading and writing to the DOM.\nfunction getDimensions(cm){var d=cm.display,left={},width={};var gutterLeft=d.gutters.clientLeft;for(var n=d.gutters.firstChild,i=0;n;n=n.nextSibling,++i){left[cm.options.gutters[i]]=n.offsetLeft+n.clientLeft+gutterLeft;width[cm.options.gutters[i]]=n.clientWidth;}return{fixedPos:compensateForHScroll(d),gutterTotalWidth:d.gutters.offsetWidth,gutterLeft:left,gutterWidth:width,wrapperWidth:d.wrapper.clientWidth};}// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display){return display.scroller.getBoundingClientRect().left-display.sizer.getBoundingClientRect().left;}// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm){var th=textHeight(cm.display),wrapping=cm.options.lineWrapping;var perLine=wrapping&&Math.max(5,cm.display.scroller.clientWidth/charWidth(cm.display)-3);return function(line){if(lineIsHidden(cm.doc,line)){return 0;}var widgetsHeight=0;if(line.widgets){for(var i=0;i<line.widgets.length;i++){if(line.widgets[i].height){widgetsHeight+=line.widgets[i].height;}}}if(wrapping){return widgetsHeight+(Math.ceil(line.text.length/perLine)||1)*th;}else{return widgetsHeight+th;}};}function estimateLineHeights(cm){var doc=cm.doc,est=estimateHeight(cm);doc.iter(function(line){var estHeight=est(line);if(estHeight!=line.height){updateLineHeight(line,estHeight);}});}// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm,e,liberal,forRect){var display=cm.display;if(!liberal&&e_target(e).getAttribute("cm-not-content")=="true"){return null;}var x,y,space=display.lineSpace.getBoundingClientRect();// Fails unpredictably on IE[67] when mouse is dragged around quickly.\ntry{x=e.clientX-space.left;y=e.clientY-space.top;}catch(e){return null;}var coords=coordsChar(cm,x,y),line;if(forRect&&coords.xRel==1&&(line=getLine(cm.doc,coords.line).text).length==coords.ch){var colDiff=countColumn(line,line.length,cm.options.tabSize)-line.length;coords=Pos(coords.line,Math.max(0,Math.round((x-paddingH(cm.display).left)/charWidth(cm.display))-colDiff));}return coords;}// Find the view element corresponding to a given line. Return null\n// when the line isn\'t visible.\nfunction findViewIndex(cm,n){if(n>=cm.display.viewTo){return null;}n-=cm.display.viewFrom;if(n<0){return null;}var view=cm.display.view;for(var i=0;i<view.length;i++){n-=view[i].size;if(n<0){return i;}}}function updateSelection(cm){cm.display.input.showSelection(cm.display.input.prepareSelection());}function prepareSelection(cm,primary){var doc=cm.doc,result={};var curFragment=result.cursors=document.createDocumentFragment();var selFragment=result.selection=document.createDocumentFragment();for(var i=0;i<doc.sel.ranges.length;i++){if(primary===false&&i==doc.sel.primIndex){continue;}var range=doc.sel.ranges[i];if(range.from().line>=cm.display.viewTo||range.to().line<cm.display.viewFrom){continue;}var collapsed=range.empty();if(collapsed||cm.options.showCursorWhenSelecting){drawSelectionCursor(cm,range.head,curFragment);}if(!collapsed){drawSelectionRange(cm,range,selFragment);}}return result;}// Draws a cursor for the given range\nfunction drawSelectionCursor(cm,head,output){var pos=cursorCoords(cm,head,"div",null,null,!cm.options.singleCursorHeightPerLine);var cursor=output.appendChild(elt("div","\\u00a0","CodeMirror-cursor"));cursor.style.left=pos.left+"px";cursor.style.top=pos.top+"px";cursor.style.height=Math.max(0,pos.bottom-pos.top)*cm.options.cursorHeight+"px";if(pos.other){// Secondary cursor, shown when on a \'jump\' in bi-directional text\nvar otherCursor=output.appendChild(elt("div","\\u00a0","CodeMirror-cursor CodeMirror-secondarycursor"));otherCursor.style.display="";otherCursor.style.left=pos.other.left+"px";otherCursor.style.top=pos.other.top+"px";otherCursor.style.height=(pos.other.bottom-pos.other.top)*.85+"px";}}// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm,range,output){var display=cm.display,doc=cm.doc;var fragment=document.createDocumentFragment();var padding=paddingH(cm.display),leftSide=padding.left;var rightSide=Math.max(display.sizerWidth,displayWidth(cm)-display.sizer.offsetLeft)-padding.right;function add(left,top,width,bottom){if(top<0){top=0;}top=Math.round(top);bottom=Math.round(bottom);fragment.appendChild(elt("div",null,"CodeMirror-selected","position: absolute; left: "+left+"px;\\n                             top: "+top+"px; width: "+(width==null?rightSide-left:width)+"px;\\n                             height: "+(bottom-top)+"px"));}function drawForLine(line,fromArg,toArg){var lineObj=getLine(doc,line);var lineLen=lineObj.text.length;var start,end;function coords(ch,bias){return charCoords(cm,Pos(line,ch),"div",lineObj,bias);}iterateBidiSections(getOrder(lineObj),fromArg||0,toArg==null?lineLen:toArg,function(from,to,dir){var leftPos=coords(from,"left"),rightPos,left,right;if(from==to){rightPos=leftPos;left=right=leftPos.left;}else{rightPos=coords(to-1,"right");if(dir=="rtl"){var tmp=leftPos;leftPos=rightPos;rightPos=tmp;}left=leftPos.left;right=rightPos.right;}if(fromArg==null&&from==0){left=leftSide;}if(rightPos.top-leftPos.top>3){// Different lines, draw top part\nadd(left,leftPos.top,null,leftPos.bottom);left=leftSide;if(leftPos.bottom<rightPos.top){add(left,leftPos.bottom,null,rightPos.top);}}if(toArg==null&&to==lineLen){right=rightSide;}if(!start||leftPos.top<start.top||leftPos.top==start.top&&leftPos.left<start.left){start=leftPos;}if(!end||rightPos.bottom>end.bottom||rightPos.bottom==end.bottom&&rightPos.right>end.right){end=rightPos;}if(left<leftSide+1){left=leftSide;}add(left,rightPos.top,right-left,rightPos.bottom);});return{start:start,end:end};}var sFrom=range.from(),sTo=range.to();if(sFrom.line==sTo.line){drawForLine(sFrom.line,sFrom.ch,sTo.ch);}else{var fromLine=getLine(doc,sFrom.line),toLine=getLine(doc,sTo.line);var singleVLine=visualLine(fromLine)==visualLine(toLine);var leftEnd=drawForLine(sFrom.line,sFrom.ch,singleVLine?fromLine.text.length+1:null).end;var rightStart=drawForLine(sTo.line,singleVLine?0:null,sTo.ch).start;if(singleVLine){if(leftEnd.top<rightStart.top-2){add(leftEnd.right,leftEnd.top,null,leftEnd.bottom);add(leftSide,rightStart.top,rightStart.left,rightStart.bottom);}else{add(leftEnd.right,leftEnd.top,rightStart.left-leftEnd.right,leftEnd.bottom);}}if(leftEnd.bottom<rightStart.top){add(leftSide,leftEnd.bottom,null,rightStart.top);}}output.appendChild(fragment);}// Cursor-blinking\nfunction restartBlink(cm){if(!cm.state.focused){return;}var display=cm.display;clearInterval(display.blinker);var on=true;display.cursorDiv.style.visibility="";if(cm.options.cursorBlinkRate>0){display.blinker=setInterval(function(){return display.cursorDiv.style.visibility=(on=!on)?"":"hidden";},cm.options.cursorBlinkRate);}else if(cm.options.cursorBlinkRate<0){display.cursorDiv.style.visibility="hidden";}}function ensureFocus(cm){if(!cm.state.focused){cm.display.input.focus();onFocus(cm);}}function delayBlurEvent(cm){cm.state.delayingBlurEvent=true;setTimeout(function(){if(cm.state.delayingBlurEvent){cm.state.delayingBlurEvent=false;onBlur(cm);}},100);}function onFocus(cm,e){if(cm.state.delayingBlurEvent){cm.state.delayingBlurEvent=false;}if(cm.options.readOnly=="nocursor"){return;}if(!cm.state.focused){signal(cm,"focus",cm,e);cm.state.focused=true;addClass(cm.display.wrapper,"CodeMirror-focused");// This test prevents this from firing when a context\n// menu is closed (since the input reset would kill the\n// select-all detection hack)\nif(!cm.curOp&&cm.display.selForContextMenu!=cm.doc.sel){cm.display.input.reset();if(webkit){setTimeout(function(){return cm.display.input.reset(true);},20);}// Issue #1730\n}cm.display.input.receivedFocus();}restartBlink(cm);}function onBlur(cm,e){if(cm.state.delayingBlurEvent){return;}if(cm.state.focused){signal(cm,"blur",cm,e);cm.state.focused=false;rmClass(cm.display.wrapper,"CodeMirror-focused");}clearInterval(cm.display.blinker);setTimeout(function(){if(!cm.state.focused){cm.display.shift=false;}},150);}// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm){var display=cm.display,view=display.view;if(!display.alignWidgets&&(!display.gutters.firstChild||!cm.options.fixedGutter)){return;}var comp=compensateForHScroll(display)-display.scroller.scrollLeft+cm.doc.scrollLeft;var gutterW=display.gutters.offsetWidth,left=comp+"px";for(var i=0;i<view.length;i++){if(!view[i].hidden){if(cm.options.fixedGutter){if(view[i].gutter){view[i].gutter.style.left=left;}if(view[i].gutterBackground){view[i].gutterBackground.style.left=left;}}var align=view[i].alignable;if(align){for(var j=0;j<align.length;j++){align[j].style.left=left;}}}}if(cm.options.fixedGutter){display.gutters.style.left=comp+gutterW+"px";}}// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm){if(!cm.options.lineNumbers){return false;}var doc=cm.doc,last=lineNumberFor(cm.options,doc.first+doc.size-1),display=cm.display;if(last.length!=display.lineNumChars){var test=display.measure.appendChild(elt("div",[elt("div",last)],"CodeMirror-linenumber CodeMirror-gutter-elt"));var innerW=test.firstChild.offsetWidth,padding=test.offsetWidth-innerW;display.lineGutter.style.width="";display.lineNumInnerWidth=Math.max(innerW,display.lineGutter.offsetWidth-padding)+1;display.lineNumWidth=display.lineNumInnerWidth+padding;display.lineNumChars=display.lineNumInnerWidth?last.length:-1;display.lineGutter.style.width=display.lineNumWidth+"px";updateGutterSpace(cm);return true;}return false;}// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm){var display=cm.display;var prevBottom=display.lineDiv.offsetTop;for(var i=0;i<display.view.length;i++){var cur=display.view[i],height=void 0;if(cur.hidden){continue;}if(ie&&ie_version<8){var bot=cur.node.offsetTop+cur.node.offsetHeight;height=bot-prevBottom;prevBottom=bot;}else{var box=cur.node.getBoundingClientRect();height=box.bottom-box.top;}var diff=cur.line.height-height;if(height<2){height=textHeight(display);}if(diff>.001||diff<-.001){updateLineHeight(cur.line,height);updateWidgetHeight(cur.line);if(cur.rest){for(var j=0;j<cur.rest.length;j++){updateWidgetHeight(cur.rest[j]);}}}}}// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line){if(line.widgets){for(var i=0;i<line.widgets.length;++i){line.widgets[i].height=line.widgets[i].node.parentNode.offsetHeight;}}}// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display,doc,viewport){var top=viewport&&viewport.top!=null?Math.max(0,viewport.top):display.scroller.scrollTop;top=Math.floor(top-paddingTop(display));var bottom=viewport&&viewport.bottom!=null?viewport.bottom:top+display.wrapper.clientHeight;var from=lineAtHeight(doc,top),to=lineAtHeight(doc,bottom);// Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n// forces those lines into the viewport (if possible).\nif(viewport&&viewport.ensure){var ensureFrom=viewport.ensure.from.line,ensureTo=viewport.ensure.to.line;if(ensureFrom<from){from=ensureFrom;to=lineAtHeight(doc,heightAtLine(getLine(doc,ensureFrom))+display.wrapper.clientHeight);}else if(Math.min(ensureTo,doc.lastLine())>=to){from=lineAtHeight(doc,heightAtLine(getLine(doc,ensureTo))-display.wrapper.clientHeight);to=ensureTo;}}return{from:from,to:Math.max(to,from+1)};}// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction setScrollTop(cm,val){if(Math.abs(cm.doc.scrollTop-val)<2){return;}cm.doc.scrollTop=val;if(!gecko){updateDisplaySimple(cm,{top:val});}if(cm.display.scroller.scrollTop!=val){cm.display.scroller.scrollTop=val;}cm.display.scrollbars.setScrollTop(val);if(gecko){updateDisplaySimple(cm);}startWorker(cm,100);}// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm,val,isScroller){if(isScroller?val==cm.doc.scrollLeft:Math.abs(cm.doc.scrollLeft-val)<2){return;}val=Math.min(val,cm.display.scroller.scrollWidth-cm.display.scroller.clientWidth);cm.doc.scrollLeft=val;alignHorizontally(cm);if(cm.display.scroller.scrollLeft!=val){cm.display.scroller.scrollLeft=val;}cm.display.scrollbars.setScrollLeft(val);}// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\nvar wheelSamples=0;var wheelPixelsPerUnit=null;// Fill in a browser-detected starting value on browsers where we\n// know one. These don\'t have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif(ie){wheelPixelsPerUnit=-.53;}else if(gecko){wheelPixelsPerUnit=15;}else if(chrome){wheelPixelsPerUnit=-.7;}else if(safari){wheelPixelsPerUnit=-1/3;}function wheelEventDelta(e){var dx=e.wheelDeltaX,dy=e.wheelDeltaY;if(dx==null&&e.detail&&e.axis==e.HORIZONTAL_AXIS){dx=e.detail;}if(dy==null&&e.detail&&e.axis==e.VERTICAL_AXIS){dy=e.detail;}else if(dy==null){dy=e.wheelDelta;}return{x:dx,y:dy};}function wheelEventPixels(e){var delta=wheelEventDelta(e);delta.x*=wheelPixelsPerUnit;delta.y*=wheelPixelsPerUnit;return delta;}function onScrollWheel(cm,e){var delta=wheelEventDelta(e),dx=delta.x,dy=delta.y;var display=cm.display,scroll=display.scroller;// Quit if there\'s nothing to scroll here\nvar canScrollX=scroll.scrollWidth>scroll.clientWidth;var canScrollY=scroll.scrollHeight>scroll.clientHeight;if(!(dx&&canScrollX||dy&&canScrollY)){return;}// Webkit browsers on OS X abort momentum scrolls when the target\n// of the scroll event is removed from the scrollable element.\n// This hack (see related code in patchDisplay) makes sure the\n// element is kept around.\nif(dy&&mac&&webkit){outer:for(var cur=e.target,view=display.view;cur!=scroll;cur=cur.parentNode){for(var i=0;i<view.length;i++){if(view[i].node==cur){cm.display.currentWheelTarget=cur;break outer;}}}}// On some browsers, horizontal scrolling will cause redraws to\n// happen before the gutter has been realigned, causing it to\n// wriggle around in a most unseemly way. When we have an\n// estimated pixels/delta value, we just handle horizontal\n// scrolling entirely here. It\'ll be slightly off from native, but\n// better than glitching out.\nif(dx&&!gecko&&!presto&&wheelPixelsPerUnit!=null){if(dy&&canScrollY){setScrollTop(cm,Math.max(0,Math.min(scroll.scrollTop+dy*wheelPixelsPerUnit,scroll.scrollHeight-scroll.clientHeight)));}setScrollLeft(cm,Math.max(0,Math.min(scroll.scrollLeft+dx*wheelPixelsPerUnit,scroll.scrollWidth-scroll.clientWidth)));// Only prevent default scrolling if vertical scrolling is\n// actually possible. Otherwise, it causes vertical scroll\n// jitter on OSX trackpads when deltaX is small and deltaY\n// is large (issue #3579)\nif(!dy||dy&&canScrollY){e_preventDefault(e);}display.wheelStartX=null;// Abort measurement, if in progress\nreturn;}// \'Project\' the visible viewport to cover the area that is being\n// scrolled into view (if we know enough to estimate it).\nif(dy&&wheelPixelsPerUnit!=null){var pixels=dy*wheelPixelsPerUnit;var top=cm.doc.scrollTop,bot=top+display.wrapper.clientHeight;if(pixels<0){top=Math.max(0,top+pixels-50);}else{bot=Math.min(cm.doc.height,bot+pixels+50);}updateDisplaySimple(cm,{top:top,bottom:bot});}if(wheelSamples<20){if(display.wheelStartX==null){display.wheelStartX=scroll.scrollLeft;display.wheelStartY=scroll.scrollTop;display.wheelDX=dx;display.wheelDY=dy;setTimeout(function(){if(display.wheelStartX==null){return;}var movedX=scroll.scrollLeft-display.wheelStartX;var movedY=scroll.scrollTop-display.wheelStartY;var sample=movedY&&display.wheelDY&&movedY/display.wheelDY||movedX&&display.wheelDX&&movedX/display.wheelDX;display.wheelStartX=display.wheelStartY=null;if(!sample){return;}wheelPixelsPerUnit=(wheelPixelsPerUnit*wheelSamples+sample)/(wheelSamples+1);++wheelSamples;},200);}else{display.wheelDX+=dx;display.wheelDY+=dy;}}}// SCROLLBARS\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm){var d=cm.display,gutterW=d.gutters.offsetWidth;var docH=Math.round(cm.doc.height+paddingVert(cm.display));return{clientHeight:d.scroller.clientHeight,viewHeight:d.wrapper.clientHeight,scrollWidth:d.scroller.scrollWidth,clientWidth:d.scroller.clientWidth,viewWidth:d.wrapper.clientWidth,barLeft:cm.options.fixedGutter?gutterW:0,docHeight:docH,scrollHeight:docH+scrollGap(cm)+d.barHeight,nativeBarWidth:d.nativeBarWidth,gutterWidth:gutterW};}function NativeScrollbars(place,scroll,cm){this.cm=cm;var vert=this.vert=elt("div",[elt("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar");var horiz=this.horiz=elt("div",[elt("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");place(vert);place(horiz);on(vert,"scroll",function(){if(vert.clientHeight){scroll(vert.scrollTop,"vertical");}});on(horiz,"scroll",function(){if(horiz.clientWidth){scroll(horiz.scrollLeft,"horizontal");}});this.checkedZeroWidth=false;// Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\nif(ie&&ie_version<8){this.horiz.style.minHeight=this.vert.style.minWidth="18px";}}NativeScrollbars.prototype=copyObj({update:function(measure){var needsH=measure.scrollWidth>measure.clientWidth+1;var needsV=measure.scrollHeight>measure.clientHeight+1;var sWidth=measure.nativeBarWidth;if(needsV){this.vert.style.display="block";this.vert.style.bottom=needsH?sWidth+"px":"0";var totalHeight=measure.viewHeight-(needsH?sWidth:0);// A bug in IE8 can cause this value to be negative, so guard it.\nthis.vert.firstChild.style.height=Math.max(0,measure.scrollHeight-measure.clientHeight+totalHeight)+"px";}else{this.vert.style.display="";this.vert.firstChild.style.height="0";}if(needsH){this.horiz.style.display="block";this.horiz.style.right=needsV?sWidth+"px":"0";this.horiz.style.left=measure.barLeft+"px";var totalWidth=measure.viewWidth-measure.barLeft-(needsV?sWidth:0);this.horiz.firstChild.style.width=measure.scrollWidth-measure.clientWidth+totalWidth+"px";}else{this.horiz.style.display="";this.horiz.firstChild.style.width="0";}if(!this.checkedZeroWidth&&measure.clientHeight>0){if(sWidth==0){this.zeroWidthHack();}this.checkedZeroWidth=true;}return{right:needsV?sWidth:0,bottom:needsH?sWidth:0};},setScrollLeft:function(pos){if(this.horiz.scrollLeft!=pos){this.horiz.scrollLeft=pos;}if(this.disableHoriz){this.enableZeroWidthBar(this.horiz,this.disableHoriz);}},setScrollTop:function(pos){if(this.vert.scrollTop!=pos){this.vert.scrollTop=pos;}if(this.disableVert){this.enableZeroWidthBar(this.vert,this.disableVert);}},zeroWidthHack:function(){var w=mac&&!mac_geMountainLion?"12px":"18px";this.horiz.style.height=this.vert.style.width=w;this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none";this.disableHoriz=new Delayed();this.disableVert=new Delayed();},enableZeroWidthBar:function(bar,delay){bar.style.pointerEvents="auto";function maybeDisable(){// To find out whether the scrollbar is still visible, we\n// check whether the element under the pixel in the bottom\n// left corner of the scrollbar box is the scrollbar box\n// itself (when the bar is still visible) or its filler child\n// (when the bar is hidden). If it is still visible, we keep\n// it enabled, if it\'s hidden, we disable pointer events.\nvar box=bar.getBoundingClientRect();var elt=document.elementFromPoint(box.left+1,box.bottom-1);if(elt!=bar){bar.style.pointerEvents="none";}else{delay.set(1000,maybeDisable);}}delay.set(1000,maybeDisable);},clear:function(){var parent=this.horiz.parentNode;parent.removeChild(this.horiz);parent.removeChild(this.vert);}},NativeScrollbars.prototype);function NullScrollbars(){}NullScrollbars.prototype=copyObj({update:function(){return{bottom:0,right:0};},setScrollLeft:function(){},setScrollTop:function(){},clear:function(){}},NullScrollbars.prototype);function updateScrollbars(cm,measure){if(!measure){measure=measureForScrollbars(cm);}var startWidth=cm.display.barWidth,startHeight=cm.display.barHeight;updateScrollbarsInner(cm,measure);for(var i=0;i<4&&startWidth!=cm.display.barWidth||startHeight!=cm.display.barHeight;i++){if(startWidth!=cm.display.barWidth&&cm.options.lineWrapping){updateHeightsInViewport(cm);}updateScrollbarsInner(cm,measureForScrollbars(cm));startWidth=cm.display.barWidth;startHeight=cm.display.barHeight;}}// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm,measure){var d=cm.display;var sizes=d.scrollbars.update(measure);d.sizer.style.paddingRight=(d.barWidth=sizes.right)+"px";d.sizer.style.paddingBottom=(d.barHeight=sizes.bottom)+"px";d.heightForcer.style.borderBottom=sizes.bottom+"px solid transparent";if(sizes.right&&sizes.bottom){d.scrollbarFiller.style.display="block";d.scrollbarFiller.style.height=sizes.bottom+"px";d.scrollbarFiller.style.width=sizes.right+"px";}else{d.scrollbarFiller.style.display="";}if(sizes.bottom&&cm.options.coverGutterNextToScrollbar&&cm.options.fixedGutter){d.gutterFiller.style.display="block";d.gutterFiller.style.height=sizes.bottom+"px";d.gutterFiller.style.width=measure.gutterWidth+"px";}else{d.gutterFiller.style.display="";}}var scrollbarModel={"native":NativeScrollbars,"null":NullScrollbars};function initScrollbars(cm){if(cm.display.scrollbars){cm.display.scrollbars.clear();if(cm.display.scrollbars.addClass){rmClass(cm.display.wrapper,cm.display.scrollbars.addClass);}}cm.display.scrollbars=new scrollbarModel[cm.options.scrollbarStyle](function(node){cm.display.wrapper.insertBefore(node,cm.display.scrollbarFiller);// Prevent clicks in the scrollbars from killing focus\non(node,"mousedown",function(){if(cm.state.focused){setTimeout(function(){return cm.display.input.focus();},0);}});node.setAttribute("cm-not-content","true");},function(pos,axis){if(axis=="horizontal"){setScrollLeft(cm,pos);}else{setScrollTop(cm,pos);}},cm);if(cm.display.scrollbars.addClass){addClass(cm.display.wrapper,cm.display.scrollbars.addClass);}}// SCROLLING THINGS INTO VIEW\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm,coords){if(signalDOMEvent(cm,"scrollCursorIntoView")){return;}var display=cm.display,box=display.sizer.getBoundingClientRect(),doScroll=null;if(coords.top+box.top<0){doScroll=true;}else if(coords.bottom+box.top>(window.innerHeight||document.documentElement.clientHeight)){doScroll=false;}if(doScroll!=null&&!phantom){var scrollNode=elt("div","\\u200b",null,"position: absolute;\\n                         top: "+(coords.top-display.viewOffset-paddingTop(cm.display))+"px;\\n                         height: "+(coords.bottom-coords.top+scrollGap(cm)+display.barHeight)+"px;\\n                         left: "+coords.left+"px; width: 2px;");cm.display.lineSpace.appendChild(scrollNode);scrollNode.scrollIntoView(doScroll);cm.display.lineSpace.removeChild(scrollNode);}}// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may \'drift\' during drawing).\nfunction scrollPosIntoView(cm,pos,end,margin){if(margin==null){margin=0;}var coords;for(var limit=0;limit<5;limit++){var changed=false;coords=cursorCoords(cm,pos);var endCoords=!end||end==pos?coords:cursorCoords(cm,end);var scrollPos=calculateScrollPos(cm,Math.min(coords.left,endCoords.left),Math.min(coords.top,endCoords.top)-margin,Math.max(coords.left,endCoords.left),Math.max(coords.bottom,endCoords.bottom)+margin);var startTop=cm.doc.scrollTop,startLeft=cm.doc.scrollLeft;if(scrollPos.scrollTop!=null){setScrollTop(cm,scrollPos.scrollTop);if(Math.abs(cm.doc.scrollTop-startTop)>1){changed=true;}}if(scrollPos.scrollLeft!=null){setScrollLeft(cm,scrollPos.scrollLeft);if(Math.abs(cm.doc.scrollLeft-startLeft)>1){changed=true;}}if(!changed){break;}}return coords;}// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm,x1,y1,x2,y2){var scrollPos=calculateScrollPos(cm,x1,y1,x2,y2);if(scrollPos.scrollTop!=null){setScrollTop(cm,scrollPos.scrollTop);}if(scrollPos.scrollLeft!=null){setScrollLeft(cm,scrollPos.scrollLeft);}}// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm,x1,y1,x2,y2){var display=cm.display,snapMargin=textHeight(cm.display);if(y1<0){y1=0;}var screentop=cm.curOp&&cm.curOp.scrollTop!=null?cm.curOp.scrollTop:display.scroller.scrollTop;var screen=displayHeight(cm),result={};if(y2-y1>screen){y2=y1+screen;}var docBottom=cm.doc.height+paddingVert(display);var atTop=y1<snapMargin,atBottom=y2>docBottom-snapMargin;if(y1<screentop){result.scrollTop=atTop?0:y1;}else if(y2>screentop+screen){var newTop=Math.min(y1,(atBottom?docBottom:y2)-screen);if(newTop!=screentop){result.scrollTop=newTop;}}var screenleft=cm.curOp&&cm.curOp.scrollLeft!=null?cm.curOp.scrollLeft:display.scroller.scrollLeft;var screenw=displayWidth(cm)-(cm.options.fixedGutter?display.gutters.offsetWidth:0);var tooWide=x2-x1>screenw;if(tooWide){x2=x1+screenw;}if(x1<10){result.scrollLeft=0;}else if(x1<screenleft){result.scrollLeft=Math.max(0,x1-(tooWide?0:10));}else if(x2>screenw+screenleft-3){result.scrollLeft=x2+(tooWide?0:10)-screenw;}return result;}// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollPos(cm,left,top){if(left!=null||top!=null){resolveScrollToPos(cm);}if(left!=null){cm.curOp.scrollLeft=(cm.curOp.scrollLeft==null?cm.doc.scrollLeft:cm.curOp.scrollLeft)+left;}if(top!=null){cm.curOp.scrollTop=(cm.curOp.scrollTop==null?cm.doc.scrollTop:cm.curOp.scrollTop)+top;}}// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm){resolveScrollToPos(cm);var cur=cm.getCursor(),from=cur,to=cur;if(!cm.options.lineWrapping){from=cur.ch?Pos(cur.line,cur.ch-1):cur;to=Pos(cur.line,cur.ch+1);}cm.curOp.scrollToPos={from:from,to:to,margin:cm.options.cursorScrollMargin,isCursor:true};}// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// \'simulates\' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm){var range=cm.curOp.scrollToPos;if(range){cm.curOp.scrollToPos=null;var from=estimateCoords(cm,range.from),to=estimateCoords(cm,range.to);var sPos=calculateScrollPos(cm,Math.min(from.left,to.left),Math.min(from.top,to.top)-range.margin,Math.max(from.right,to.right),Math.max(from.bottom,to.bottom)+range.margin);cm.scrollTo(sPos.scrollLeft,sPos.scrollTop);}}// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won\'t have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\nvar nextOpId=0;// Start a new operation.\nfunction startOperation(cm){cm.curOp={cm:cm,viewChanged:false,// Flag that indicates that lines might need to be redrawn\nstartHeight:cm.doc.height,// Used to detect need to update scrollbar\nforceUpdate:false,// Used to force a redraw\nupdateInput:null,// Whether to reset the input textarea\ntyping:false,// Whether this reset should be careful to leave existing text (for compositing)\nchangeObjs:null,// Accumulated changes, for firing change events\ncursorActivityHandlers:null,// Set of handlers to fire cursorActivity on\ncursorActivityCalled:0,// Tracks which cursorActivity handlers have been called already\nselectionChanged:false,// Whether the selection needs to be redrawn\nupdateMaxLine:false,// Set when the widest line needs to be determined anew\nscrollLeft:null,scrollTop:null,// Intermediate scroll position, not pushed to DOM yet\nscrollToPos:null,// Used to scroll to a specific position\nfocus:false,id:++nextOpId// Unique ID\n};pushOperation(cm.curOp);}// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm){var op=cm.curOp;finishOperation(op,function(group){for(var i=0;i<group.ops.length;i++){group.ops[i].cm.curOp=null;}endOperations(group);});}// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group){var ops=group.ops;for(var i=0;i<ops.length;i++)// Read DOM\n{endOperation_R1(ops[i]);}for(var i$1=0;i$1<ops.length;i$1++)// Write DOM (maybe)\n{endOperation_W1(ops[i$1]);}for(var i$2=0;i$2<ops.length;i$2++)// Read DOM\n{endOperation_R2(ops[i$2]);}for(var i$3=0;i$3<ops.length;i$3++)// Write DOM (maybe)\n{endOperation_W2(ops[i$3]);}for(var i$4=0;i$4<ops.length;i$4++)// Read DOM\n{endOperation_finish(ops[i$4]);}}function endOperation_R1(op){var cm=op.cm,display=cm.display;maybeClipScrollbars(cm);if(op.updateMaxLine){findMaxLine(cm);}op.mustUpdate=op.viewChanged||op.forceUpdate||op.scrollTop!=null||op.scrollToPos&&(op.scrollToPos.from.line<display.viewFrom||op.scrollToPos.to.line>=display.viewTo)||display.maxLineChanged&&cm.options.lineWrapping;op.update=op.mustUpdate&&new DisplayUpdate(cm,op.mustUpdate&&{top:op.scrollTop,ensure:op.scrollToPos},op.forceUpdate);}function endOperation_W1(op){op.updatedDisplay=op.mustUpdate&&updateDisplayIfNeeded(op.cm,op.update);}function endOperation_R2(op){var cm=op.cm,display=cm.display;if(op.updatedDisplay){updateHeightsInViewport(cm);}op.barMeasure=measureForScrollbars(cm);// If the max line changed since it was last measured, measure it,\n// and ensure the document\'s width matches it.\n// updateDisplay_W2 will use these properties to do the actual resizing\nif(display.maxLineChanged&&!cm.options.lineWrapping){op.adjustWidthTo=measureChar(cm,display.maxLine,display.maxLine.text.length).left+3;cm.display.sizerWidth=op.adjustWidthTo;op.barMeasure.scrollWidth=Math.max(display.scroller.clientWidth,display.sizer.offsetLeft+op.adjustWidthTo+scrollGap(cm)+cm.display.barWidth);op.maxScrollLeft=Math.max(0,display.sizer.offsetLeft+op.adjustWidthTo-displayWidth(cm));}if(op.updatedDisplay||op.selectionChanged){op.preparedSelection=display.input.prepareSelection(op.focus);}}function endOperation_W2(op){var cm=op.cm;if(op.adjustWidthTo!=null){cm.display.sizer.style.minWidth=op.adjustWidthTo+"px";if(op.maxScrollLeft<cm.doc.scrollLeft){setScrollLeft(cm,Math.min(cm.display.scroller.scrollLeft,op.maxScrollLeft),true);}cm.display.maxLineChanged=false;}var takeFocus=op.focus&&op.focus==activeElt()&&(!document.hasFocus||document.hasFocus());if(op.preparedSelection){cm.display.input.showSelection(op.preparedSelection,takeFocus);}if(op.updatedDisplay||op.startHeight!=cm.doc.height){updateScrollbars(cm,op.barMeasure);}if(op.updatedDisplay){setDocumentHeight(cm,op.barMeasure);}if(op.selectionChanged){restartBlink(cm);}if(cm.state.focused&&op.updateInput){cm.display.input.reset(op.typing);}if(takeFocus){ensureFocus(op.cm);}}function endOperation_finish(op){var cm=op.cm,display=cm.display,doc=cm.doc;if(op.updatedDisplay){postUpdateDisplay(cm,op.update);}// Abort mouse wheel delta measurement, when scrolling explicitly\nif(display.wheelStartX!=null&&(op.scrollTop!=null||op.scrollLeft!=null||op.scrollToPos)){display.wheelStartX=display.wheelStartY=null;}// Propagate the scroll position to the actual DOM scroller\nif(op.scrollTop!=null&&(display.scroller.scrollTop!=op.scrollTop||op.forceScroll)){doc.scrollTop=Math.max(0,Math.min(display.scroller.scrollHeight-display.scroller.clientHeight,op.scrollTop));display.scrollbars.setScrollTop(doc.scrollTop);display.scroller.scrollTop=doc.scrollTop;}if(op.scrollLeft!=null&&(display.scroller.scrollLeft!=op.scrollLeft||op.forceScroll)){doc.scrollLeft=Math.max(0,Math.min(display.scroller.scrollWidth-display.scroller.clientWidth,op.scrollLeft));display.scrollbars.setScrollLeft(doc.scrollLeft);display.scroller.scrollLeft=doc.scrollLeft;alignHorizontally(cm);}// If we need to scroll a specific position into view, do so.\nif(op.scrollToPos){var coords=scrollPosIntoView(cm,clipPos(doc,op.scrollToPos.from),clipPos(doc,op.scrollToPos.to),op.scrollToPos.margin);if(op.scrollToPos.isCursor&&cm.state.focused){maybeScrollWindow(cm,coords);}}// Fire events for markers that are hidden/unidden by editing or\n// undoing\nvar hidden=op.maybeHiddenMarkers,unhidden=op.maybeUnhiddenMarkers;if(hidden){for(var i=0;i<hidden.length;++i){if(!hidden[i].lines.length){signal(hidden[i],"hide");}}}if(unhidden){for(var i$1=0;i$1<unhidden.length;++i$1){if(unhidden[i$1].lines.length){signal(unhidden[i$1],"unhide");}}}if(display.wrapper.offsetHeight){doc.scrollTop=cm.display.scroller.scrollTop;}// Fire change events, and delayed event handlers\nif(op.changeObjs){signal(cm,"changes",cm,op.changeObjs);}if(op.update){op.update.finish();}}// Run the given function in an operation\nfunction runInOp(cm,f){if(cm.curOp){return f();}startOperation(cm);try{return f();}finally{endOperation(cm);}}// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm,f){return function(){if(cm.curOp){return f.apply(cm,arguments);}startOperation(cm);try{return f.apply(cm,arguments);}finally{endOperation(cm);}};}// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f){return function(){if(this.curOp){return f.apply(this,arguments);}startOperation(this);try{return f.apply(this,arguments);}finally{endOperation(this);}};}function docMethodOp(f){return function(){var cm=this.cm;if(!cm||cm.curOp){return f.apply(this,arguments);}startOperation(cm);try{return f.apply(this,arguments);}finally{endOperation(cm);}};}// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm,from,to,lendiff){if(from==null){from=cm.doc.first;}if(to==null){to=cm.doc.first+cm.doc.size;}if(!lendiff){lendiff=0;}var display=cm.display;if(lendiff&&to<display.viewTo&&(display.updateLineNumbers==null||display.updateLineNumbers>from)){display.updateLineNumbers=from;}cm.curOp.viewChanged=true;if(from>=display.viewTo){// Change after\nif(sawCollapsedSpans&&visualLineNo(cm.doc,from)<display.viewTo){resetView(cm);}}else if(to<=display.viewFrom){// Change before\nif(sawCollapsedSpans&&visualLineEndNo(cm.doc,to+lendiff)>display.viewFrom){resetView(cm);}else{display.viewFrom+=lendiff;display.viewTo+=lendiff;}}else if(from<=display.viewFrom&&to>=display.viewTo){// Full overlap\nresetView(cm);}else if(from<=display.viewFrom){// Top overlap\nvar cut=viewCuttingPoint(cm,to,to+lendiff,1);if(cut){display.view=display.view.slice(cut.index);display.viewFrom=cut.lineN;display.viewTo+=lendiff;}else{resetView(cm);}}else if(to>=display.viewTo){// Bottom overlap\nvar cut$1=viewCuttingPoint(cm,from,from,-1);if(cut$1){display.view=display.view.slice(0,cut$1.index);display.viewTo=cut$1.lineN;}else{resetView(cm);}}else{// Gap in the middle\nvar cutTop=viewCuttingPoint(cm,from,from,-1);var cutBot=viewCuttingPoint(cm,to,to+lendiff,1);if(cutTop&&cutBot){display.view=display.view.slice(0,cutTop.index).concat(buildViewArray(cm,cutTop.lineN,cutBot.lineN)).concat(display.view.slice(cutBot.index));display.viewTo+=lendiff;}else{resetView(cm);}}var ext=display.externalMeasured;if(ext){if(to<ext.lineN){ext.lineN+=lendiff;}else if(from<ext.lineN+ext.size){display.externalMeasured=null;}}}// Register a change to a single line. Type must be one of "text",\n// "gutter", "class", "widget"\nfunction regLineChange(cm,line,type){cm.curOp.viewChanged=true;var display=cm.display,ext=cm.display.externalMeasured;if(ext&&line>=ext.lineN&&line<ext.lineN+ext.size){display.externalMeasured=null;}if(line<display.viewFrom||line>=display.viewTo){return;}var lineView=display.view[findViewIndex(cm,line)];if(lineView.node==null){return;}var arr=lineView.changes||(lineView.changes=[]);if(indexOf(arr,type)==-1){arr.push(type);}}// Clear the view.\nfunction resetView(cm){cm.display.viewFrom=cm.display.viewTo=cm.doc.first;cm.display.view=[];cm.display.viewOffset=0;}function viewCuttingPoint(cm,oldN,newN,dir){var index=findViewIndex(cm,oldN),diff,view=cm.display.view;if(!sawCollapsedSpans||newN==cm.doc.first+cm.doc.size){return{index:index,lineN:newN};}var n=cm.display.viewFrom;for(var i=0;i<index;i++){n+=view[i].size;}if(n!=oldN){if(dir>0){if(index==view.length-1){return null;}diff=n+view[index].size-oldN;index++;}else{diff=n-oldN;}oldN+=diff;newN+=diff;}while(visualLineNo(cm.doc,newN)!=newN){if(index==(dir<0?0:view.length-1)){return null;}newN+=dir*view[index-(dir<0?1:0)].size;index+=dir;}return{index:index,lineN:newN};}// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm,from,to){var display=cm.display,view=display.view;if(view.length==0||from>=display.viewTo||to<=display.viewFrom){display.view=buildViewArray(cm,from,to);display.viewFrom=from;}else{if(display.viewFrom>from){display.view=buildViewArray(cm,from,display.viewFrom).concat(display.view);}else if(display.viewFrom<from){display.view=display.view.slice(findViewIndex(cm,from));}display.viewFrom=from;if(display.viewTo<to){display.view=display.view.concat(buildViewArray(cm,display.viewTo,to));}else if(display.viewTo>to){display.view=display.view.slice(0,findViewIndex(cm,to));}}display.viewTo=to;}// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm){var view=cm.display.view,dirty=0;for(var i=0;i<view.length;i++){var lineView=view[i];if(!lineView.hidden&&(!lineView.node||lineView.changes)){++dirty;}}return dirty;}// HIGHLIGHT WORKER\nfunction startWorker(cm,time){if(cm.doc.mode.startState&&cm.doc.frontier<cm.display.viewTo){cm.state.highlight.set(time,bind(highlightWorker,cm));}}function highlightWorker(cm){var doc=cm.doc;if(doc.frontier<doc.first){doc.frontier=doc.first;}if(doc.frontier>=cm.display.viewTo){return;}var end=+new Date()+cm.options.workTime;var state=copyState(doc.mode,getStateBefore(cm,doc.frontier));var changedLines=[];doc.iter(doc.frontier,Math.min(doc.first+doc.size,cm.display.viewTo+500),function(line){if(doc.frontier>=cm.display.viewFrom){// Visible\nvar oldStyles=line.styles,tooLong=line.text.length>cm.options.maxHighlightLength;var highlighted=highlightLine(cm,line,tooLong?copyState(doc.mode,state):state,true);line.styles=highlighted.styles;var oldCls=line.styleClasses,newCls=highlighted.classes;if(newCls){line.styleClasses=newCls;}else if(oldCls){line.styleClasses=null;}var ischange=!oldStyles||oldStyles.length!=line.styles.length||oldCls!=newCls&&(!oldCls||!newCls||oldCls.bgClass!=newCls.bgClass||oldCls.textClass!=newCls.textClass);for(var i=0;!ischange&&i<oldStyles.length;++i){ischange=oldStyles[i]!=line.styles[i];}if(ischange){changedLines.push(doc.frontier);}line.stateAfter=tooLong?state:copyState(doc.mode,state);}else{if(line.text.length<=cm.options.maxHighlightLength){processLine(cm,line.text,state);}line.stateAfter=doc.frontier%5==0?copyState(doc.mode,state):null;}++doc.frontier;if(+new Date()>end){startWorker(cm,cm.options.workDelay);return true;}});if(changedLines.length){runInOp(cm,function(){for(var i=0;i<changedLines.length;i++){regLineChange(cm,changedLines[i],"text");}});}}// DISPLAY DRAWING\nfunction DisplayUpdate(cm,viewport,force){var display=cm.display;this.viewport=viewport;// Store some values that we\'ll need later (but don\'t want to force a relayout for)\nthis.visible=visibleLines(display,cm.doc,viewport);this.editorIsHidden=!display.wrapper.offsetWidth;this.wrapperHeight=display.wrapper.clientHeight;this.wrapperWidth=display.wrapper.clientWidth;this.oldDisplayWidth=displayWidth(cm);this.force=force;this.dims=getDimensions(cm);this.events=[];}DisplayUpdate.prototype.signal=function(emitter,type){if(hasHandler(emitter,type)){this.events.push(arguments);}};DisplayUpdate.prototype.finish=function(){var this$1=this;for(var i=0;i<this.events.length;i++){signal.apply(null,this$1.events[i]);}};function maybeClipScrollbars(cm){var display=cm.display;if(!display.scrollbarsClipped&&display.scroller.offsetWidth){display.nativeBarWidth=display.scroller.offsetWidth-display.scroller.clientWidth;display.heightForcer.style.height=scrollGap(cm)+"px";display.sizer.style.marginBottom=-display.nativeBarWidth+"px";display.sizer.style.borderRightWidth=scrollGap(cm)+"px";display.scrollbarsClipped=true;}}// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm,update){var display=cm.display,doc=cm.doc;if(update.editorIsHidden){resetView(cm);return false;}// Bail out if the visible area is already rendered and nothing changed.\nif(!update.force&&update.visible.from>=display.viewFrom&&update.visible.to<=display.viewTo&&(display.updateLineNumbers==null||display.updateLineNumbers>=display.viewTo)&&display.renderedView==display.view&&countDirtyView(cm)==0){return false;}if(maybeUpdateLineNumberWidth(cm)){resetView(cm);update.dims=getDimensions(cm);}// Compute a suitable new viewport (from & to)\nvar end=doc.first+doc.size;var from=Math.max(update.visible.from-cm.options.viewportMargin,doc.first);var to=Math.min(end,update.visible.to+cm.options.viewportMargin);if(display.viewFrom<from&&from-display.viewFrom<20){from=Math.max(doc.first,display.viewFrom);}if(display.viewTo>to&&display.viewTo-to<20){to=Math.min(end,display.viewTo);}if(sawCollapsedSpans){from=visualLineNo(cm.doc,from);to=visualLineEndNo(cm.doc,to);}var different=from!=display.viewFrom||to!=display.viewTo||display.lastWrapHeight!=update.wrapperHeight||display.lastWrapWidth!=update.wrapperWidth;adjustView(cm,from,to);display.viewOffset=heightAtLine(getLine(cm.doc,display.viewFrom));// Position the mover div to align with the current scroll position\ncm.display.mover.style.top=display.viewOffset+"px";var toUpdate=countDirtyView(cm);if(!different&&toUpdate==0&&!update.force&&display.renderedView==display.view&&(display.updateLineNumbers==null||display.updateLineNumbers>=display.viewTo)){return false;}// For big changes, we hide the enclosing element during the\n// update, since that speeds up the operations on most browsers.\nvar focused=activeElt();if(toUpdate>4){display.lineDiv.style.display="none";}patchDisplay(cm,display.updateLineNumbers,update.dims);if(toUpdate>4){display.lineDiv.style.display="";}display.renderedView=display.view;// There might have been a widget with a focused element that got\n// hidden or updated, if so re-focus it.\nif(focused&&activeElt()!=focused&&focused.offsetHeight){focused.focus();}// Prevent selection and cursors from interfering with the scroll\n// width and height.\nremoveChildren(display.cursorDiv);removeChildren(display.selectionDiv);display.gutters.style.height=display.sizer.style.minHeight=0;if(different){display.lastWrapHeight=update.wrapperHeight;display.lastWrapWidth=update.wrapperWidth;startWorker(cm,400);}display.updateLineNumbers=null;return true;}function postUpdateDisplay(cm,update){var viewport=update.viewport;for(var first=true;;first=false){if(!first||!cm.options.lineWrapping||update.oldDisplayWidth==displayWidth(cm)){// Clip forced viewport to actual scrollable area.\nif(viewport&&viewport.top!=null){viewport={top:Math.min(cm.doc.height+paddingVert(cm.display)-displayHeight(cm),viewport.top)};}// Updated line heights might result in the drawn area not\n// actually covering the viewport. Keep looping until it does.\nupdate.visible=visibleLines(cm.display,cm.doc,viewport);if(update.visible.from>=cm.display.viewFrom&&update.visible.to<=cm.display.viewTo){break;}}if(!updateDisplayIfNeeded(cm,update)){break;}updateHeightsInViewport(cm);var barMeasure=measureForScrollbars(cm);updateSelection(cm);updateScrollbars(cm,barMeasure);setDocumentHeight(cm,barMeasure);}update.signal(cm,"update",cm);if(cm.display.viewFrom!=cm.display.reportedViewFrom||cm.display.viewTo!=cm.display.reportedViewTo){update.signal(cm,"viewportChange",cm,cm.display.viewFrom,cm.display.viewTo);cm.display.reportedViewFrom=cm.display.viewFrom;cm.display.reportedViewTo=cm.display.viewTo;}}function updateDisplaySimple(cm,viewport){var update=new DisplayUpdate(cm,viewport);if(updateDisplayIfNeeded(cm,update)){updateHeightsInViewport(cm);postUpdateDisplay(cm,update);var barMeasure=measureForScrollbars(cm);updateSelection(cm);updateScrollbars(cm,barMeasure);setDocumentHeight(cm,barMeasure);update.finish();}}// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm,updateNumbersFrom,dims){var display=cm.display,lineNumbers=cm.options.lineNumbers;var container=display.lineDiv,cur=container.firstChild;function rm(node){var next=node.nextSibling;// Works around a throw-scroll bug in OS X Webkit\nif(webkit&&mac&&cm.display.currentWheelTarget==node){node.style.display="none";}else{node.parentNode.removeChild(node);}return next;}var view=display.view,lineN=display.viewFrom;// Loop over the elements in the view, syncing cur (the DOM nodes\n// in display.lineDiv) with the view as we go.\nfor(var i=0;i<view.length;i++){var lineView=view[i];if(lineView.hidden){}else if(!lineView.node||lineView.node.parentNode!=container){// Not drawn yet\nvar node=buildLineElement(cm,lineView,lineN,dims);container.insertBefore(node,cur);}else{// Already drawn\nwhile(cur!=lineView.node){cur=rm(cur);}var updateNumber=lineNumbers&&updateNumbersFrom!=null&&updateNumbersFrom<=lineN&&lineView.lineNumber;if(lineView.changes){if(indexOf(lineView.changes,"gutter")>-1){updateNumber=false;}updateLineForChanges(cm,lineView,lineN,dims);}if(updateNumber){removeChildren(lineView.lineNumber);lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options,lineN)));}cur=lineView.node.nextSibling;}lineN+=lineView.size;}while(cur){cur=rm(cur);}}function updateGutterSpace(cm){var width=cm.display.gutters.offsetWidth;cm.display.sizer.style.marginLeft=width+"px";}function setDocumentHeight(cm,measure){cm.display.sizer.style.minHeight=measure.docHeight+"px";cm.display.heightForcer.style.top=measure.docHeight+"px";cm.display.gutters.style.height=measure.docHeight+cm.display.barHeight+scrollGap(cm)+"px";}// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm){var gutters=cm.display.gutters,specs=cm.options.gutters;removeChildren(gutters);var i=0;for(;i<specs.length;++i){var gutterClass=specs[i];var gElt=gutters.appendChild(elt("div",null,"CodeMirror-gutter "+gutterClass));if(gutterClass=="CodeMirror-linenumbers"){cm.display.lineGutter=gElt;gElt.style.width=(cm.display.lineNumWidth||1)+"px";}}gutters.style.display=i?"":"none";updateGutterSpace(cm);}// Make sure the gutters options contains the element\n// "CodeMirror-linenumbers" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options){var found=indexOf(options.gutters,"CodeMirror-linenumbers");if(found==-1&&options.lineNumbers){options.gutters=options.gutters.concat(["CodeMirror-linenumbers"]);}else if(found>-1&&!options.lineNumbers){options.gutters=options.gutters.slice(0);options.gutters.splice(found,1);}}// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that\'s scrolled into\n// view, that getCursor returns, etc).\nfunction Selection(ranges,primIndex){this.ranges=ranges;this.primIndex=primIndex;}Selection.prototype={primary:function(){return this.ranges[this.primIndex];},equals:function(other){var this$1=this;if(other==this){return true;}if(other.primIndex!=this.primIndex||other.ranges.length!=this.ranges.length){return false;}for(var i=0;i<this.ranges.length;i++){var here=this$1.ranges[i],there=other.ranges[i];if(cmp(here.anchor,there.anchor)!=0||cmp(here.head,there.head)!=0){return false;}}return true;},deepCopy:function(){var this$1=this;var out=[];for(var i=0;i<this.ranges.length;i++){out[i]=new Range(copyPos(this$1.ranges[i].anchor),copyPos(this$1.ranges[i].head));}return new Selection(out,this.primIndex);},somethingSelected:function(){var this$1=this;for(var i=0;i<this.ranges.length;i++){if(!this$1.ranges[i].empty()){return true;}}return false;},contains:function(pos,end){var this$1=this;if(!end){end=pos;}for(var i=0;i<this.ranges.length;i++){var range=this$1.ranges[i];if(cmp(end,range.from())>=0&&cmp(pos,range.to())<=0){return i;}}return-1;}};function Range(anchor,head){this.anchor=anchor;this.head=head;}Range.prototype={from:function(){return minPos(this.anchor,this.head);},to:function(){return maxPos(this.anchor,this.head);},empty:function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch;}};// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. \'Consumes\' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges,primIndex){var prim=ranges[primIndex];ranges.sort(function(a,b){return cmp(a.from(),b.from());});primIndex=indexOf(ranges,prim);for(var i=1;i<ranges.length;i++){var cur=ranges[i],prev=ranges[i-1];if(cmp(prev.to(),cur.from())>=0){var from=minPos(prev.from(),cur.from()),to=maxPos(prev.to(),cur.to());var inv=prev.empty()?cur.from()==cur.head:prev.from()==prev.head;if(i<=primIndex){--primIndex;}ranges.splice(--i,2,new Range(inv?to:from,inv?from:to));}}return new Selection(ranges,primIndex);}function simpleSelection(anchor,head){return new Selection([new Range(anchor,head||anchor)],0);}// Compute the position of the end of a change (its \'to\' property\n// refers to the pre-change end).\nfunction changeEnd(change){if(!change.text){return change.to;}return Pos(change.from.line+change.text.length-1,lst(change.text).length+(change.text.length==1?change.from.ch:0));}// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos,change){if(cmp(pos,change.from)<0){return pos;}if(cmp(pos,change.to)<=0){return changeEnd(change);}var line=pos.line+change.text.length-(change.to.line-change.from.line)-1,ch=pos.ch;if(pos.line==change.to.line){ch+=changeEnd(change).ch-change.to.ch;}return Pos(line,ch);}function computeSelAfterChange(doc,change){var out=[];for(var i=0;i<doc.sel.ranges.length;i++){var range=doc.sel.ranges[i];out.push(new Range(adjustForChange(range.anchor,change),adjustForChange(range.head,change)));}return normalizeSelection(out,doc.sel.primIndex);}function offsetPos(pos,old,nw){if(pos.line==old.line){return Pos(nw.line,pos.ch-old.ch+nw.ch);}else{return Pos(nw.line+(pos.line-old.line),pos.ch);}}// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be "start" or "around".\nfunction computeReplacedSel(doc,changes,hint){var out=[];var oldPrev=Pos(doc.first,0),newPrev=oldPrev;for(var i=0;i<changes.length;i++){var change=changes[i];var from=offsetPos(change.from,oldPrev,newPrev);var to=offsetPos(changeEnd(change),oldPrev,newPrev);oldPrev=change.to;newPrev=to;if(hint=="around"){var range=doc.sel.ranges[i],inv=cmp(range.head,range.anchor)<0;out[i]=new Range(inv?to:from,inv?from:to);}else{out[i]=new Range(from,from);}}return new Selection(out,doc.sel.primIndex);}// Used to get the editor into a consistent state again when options change.\nfunction loadMode(cm){cm.doc.mode=getMode(cm.options,cm.doc.modeOption);resetModeState(cm);}function resetModeState(cm){cm.doc.iter(function(line){if(line.stateAfter){line.stateAfter=null;}if(line.styles){line.styles=null;}});cm.doc.frontier=cm.doc.first;startWorker(cm,100);cm.state.modeGen++;if(cm.curOp){regChange(cm);}}// DOCUMENT DATA STRUCTURE\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc,change){return change.from.ch==0&&change.to.ch==0&&lst(change.text)==""&&(!doc.cm||doc.cm.options.wholeLineUpdateBefore);}// Perform a change on the document data structure.\nfunction updateDoc(doc,change,markedSpans,estimateHeight){function spansFor(n){return markedSpans?markedSpans[n]:null;}function update(line,text,spans){updateLine(line,text,spans,estimateHeight);signalLater(line,"change",line,change);}function linesFor(start,end){var result=[];for(var i=start;i<end;++i){result.push(new Line(text[i],spansFor(i),estimateHeight));}return result;}var from=change.from,to=change.to,text=change.text;var firstLine=getLine(doc,from.line),lastLine=getLine(doc,to.line);var lastText=lst(text),lastSpans=spansFor(text.length-1),nlines=to.line-from.line;// Adjust the line structure\nif(change.full){doc.insert(0,linesFor(0,text.length));doc.remove(text.length,doc.size-text.length);}else if(isWholeLineUpdate(doc,change)){// This is a whole-line replace. Treated specially to make\n// sure line objects move the way they are supposed to.\nvar added=linesFor(0,text.length-1);update(lastLine,lastLine.text,lastSpans);if(nlines){doc.remove(from.line,nlines);}if(added.length){doc.insert(from.line,added);}}else if(firstLine==lastLine){if(text.length==1){update(firstLine,firstLine.text.slice(0,from.ch)+lastText+firstLine.text.slice(to.ch),lastSpans);}else{var added$1=linesFor(1,text.length-1);added$1.push(new Line(lastText+firstLine.text.slice(to.ch),lastSpans,estimateHeight));update(firstLine,firstLine.text.slice(0,from.ch)+text[0],spansFor(0));doc.insert(from.line+1,added$1);}}else if(text.length==1){update(firstLine,firstLine.text.slice(0,from.ch)+text[0]+lastLine.text.slice(to.ch),spansFor(0));doc.remove(from.line+1,nlines);}else{update(firstLine,firstLine.text.slice(0,from.ch)+text[0],spansFor(0));update(lastLine,lastText+lastLine.text.slice(to.ch),lastSpans);var added$2=linesFor(1,text.length-1);if(nlines>1){doc.remove(from.line+1,nlines-1);}doc.insert(from.line+1,added$2);}signalLater(doc,"change",doc,change);}// Call f for all linked documents.\nfunction linkedDocs(doc,f,sharedHistOnly){function propagate(doc,skip,sharedHist){if(doc.linked){for(var i=0;i<doc.linked.length;++i){var rel=doc.linked[i];if(rel.doc==skip){continue;}var shared=sharedHist&&rel.sharedHist;if(sharedHistOnly&&!shared){continue;}f(rel.doc,shared);propagate(rel.doc,doc,shared);}}}propagate(doc,null,true);}// Attach a document to an editor.\nfunction attachDoc(cm,doc){if(doc.cm){throw new Error("This document is already in use.");}cm.doc=doc;doc.cm=cm;estimateLineHeights(cm);loadMode(cm);if(!cm.options.lineWrapping){findMaxLine(cm);}cm.options.mode=doc.modeOption;regChange(cm);}function History(startGen){// Arrays of change events and selections. Doing something adds an\n// event to done and clears undo. Undoing moves events from done\n// to undone, redoing moves them in the other direction.\nthis.done=[];this.undone=[];this.undoDepth=Infinity;// Used to track when changes can be merged into a single undo\n// event\nthis.lastModTime=this.lastSelTime=0;this.lastOp=this.lastSelOp=null;this.lastOrigin=this.lastSelOrigin=null;// Used by the isClean() method\nthis.generation=this.maxGeneration=startGen||1;}// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc,change){var histChange={from:copyPos(change.from),to:changeEnd(change),text:getBetween(doc,change.from,change.to)};attachLocalSpans(doc,histChange,change.from.line,change.to.line+1);linkedDocs(doc,function(doc){return attachLocalSpans(doc,histChange,change.from.line,change.to.line+1);},true);return histChange;}// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array){while(array.length){var last=lst(array);if(last.ranges){array.pop();}else{break;}}}// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist,force){if(force){clearSelectionEvents(hist.done);return lst(hist.done);}else if(hist.done.length&&!lst(hist.done).ranges){return lst(hist.done);}else if(hist.done.length>1&&!hist.done[hist.done.length-2].ranges){hist.done.pop();return lst(hist.done);}}// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with "+") into a single event.\nfunction addChangeToHistory(doc,change,selAfter,opId){var hist=doc.history;hist.undone.length=0;var time=+new Date(),cur;var last;if((hist.lastOp==opId||hist.lastOrigin==change.origin&&change.origin&&(change.origin.charAt(0)=="+"&&doc.cm&&hist.lastModTime>time-doc.cm.options.historyEventDelay||change.origin.charAt(0)=="*"))&&(cur=lastChangeEvent(hist,hist.lastOp==opId))){// Merge this change into the last event\nlast=lst(cur.changes);if(cmp(change.from,change.to)==0&&cmp(change.from,last.to)==0){// Optimized case for simple insertion -- don\'t want to add\n// new changesets for every character typed\nlast.to=changeEnd(change);}else{// Add new sub-event\ncur.changes.push(historyChangeFromChange(doc,change));}}else{// Can not be merged, start a new event.\nvar before=lst(hist.done);if(!before||!before.ranges){pushSelectionToHistory(doc.sel,hist.done);}cur={changes:[historyChangeFromChange(doc,change)],generation:hist.generation};hist.done.push(cur);while(hist.done.length>hist.undoDepth){hist.done.shift();if(!hist.done[0].ranges){hist.done.shift();}}}hist.done.push(selAfter);hist.generation=++hist.maxGeneration;hist.lastModTime=hist.lastSelTime=time;hist.lastOp=hist.lastSelOp=opId;hist.lastOrigin=hist.lastSelOrigin=change.origin;if(!last){signal(doc,"historyAdded");}}function selectionEventCanBeMerged(doc,origin,prev,sel){var ch=origin.charAt(0);return ch=="*"||ch=="+"&&prev.ranges.length==sel.ranges.length&&prev.somethingSelected()==sel.somethingSelected()&&new Date()-doc.history.lastSelTime<=(doc.cm?doc.cm.options.historyEventDelay:500);}// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the \'done\' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc,sel,opId,options){var hist=doc.history,origin=options&&options.origin;// A new event is started when the previous origin does not match\n// the current, or the origins don\'t allow matching. Origins\n// starting with * are always merged, those starting with + are\n// merged when similar and close together in time.\nif(opId==hist.lastSelOp||origin&&hist.lastSelOrigin==origin&&(hist.lastModTime==hist.lastSelTime&&hist.lastOrigin==origin||selectionEventCanBeMerged(doc,origin,lst(hist.done),sel))){hist.done[hist.done.length-1]=sel;}else{pushSelectionToHistory(sel,hist.done);}hist.lastSelTime=+new Date();hist.lastSelOrigin=origin;hist.lastSelOp=opId;if(options&&options.clearRedo!==false){clearSelectionEvents(hist.undone);}}function pushSelectionToHistory(sel,dest){var top=lst(dest);if(!(top&&top.ranges&&top.equals(sel))){dest.push(sel);}}// Used to store marked span information in the history.\nfunction attachLocalSpans(doc,change,from,to){var existing=change["spans_"+doc.id],n=0;doc.iter(Math.max(doc.first,from),Math.min(doc.first+doc.size,to),function(line){if(line.markedSpans){(existing||(existing=change["spans_"+doc.id]={}))[n]=line.markedSpans;}++n;});}// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans){if(!spans){return null;}var out;for(var i=0;i<spans.length;++i){if(spans[i].marker.explicitlyCleared){if(!out){out=spans.slice(0,i);}}else if(out){out.push(spans[i]);}}return!out?spans:out.length?out:null;}// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc,change){var found=change["spans_"+doc.id];if(!found){return null;}var nw=[];for(var i=0;i<change.text.length;++i){nw.push(removeClearedSpans(found[i]));}return nw;}// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc,change){var old=getOldSpans(doc,change);var stretched=stretchSpansOverChange(doc,change);if(!old){return stretched;}if(!stretched){return old;}for(var i=0;i<old.length;++i){var oldCur=old[i],stretchCur=stretched[i];if(oldCur&&stretchCur){spans:for(var j=0;j<stretchCur.length;++j){var span=stretchCur[j];for(var k=0;k<oldCur.length;++k){if(oldCur[k].marker==span.marker){continue spans;}}oldCur.push(span);}}else if(stretchCur){old[i]=stretchCur;}}return old;}// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events,newGroup,instantiateSel){var copy=[];for(var i=0;i<events.length;++i){var event=events[i];if(event.ranges){copy.push(instantiateSel?Selection.prototype.deepCopy.call(event):event);continue;}var changes=event.changes,newChanges=[];copy.push({changes:newChanges});for(var j=0;j<changes.length;++j){var change=changes[j],m=void 0;newChanges.push({from:change.from,to:change.to,text:change.text});if(newGroup){for(var prop in change){if(m=prop.match(/^spans_(\\d+)$/)){if(indexOf(newGroup,Number(m[1]))>-1){lst(newChanges)[prop]=change[prop];delete change[prop];}}}}}}return copy;}// The \'scroll\' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(doc,range,head,other){if(doc.cm&&doc.cm.display.shift||doc.extend){var anchor=range.anchor;if(other){var posBefore=cmp(head,anchor)<0;if(posBefore!=cmp(other,anchor)<0){anchor=head;head=other;}else if(posBefore!=cmp(head,other)<0){head=other;}}return new Range(anchor,head);}else{return new Range(other||head,head);}}// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc,head,other,options){setSelection(doc,new Selection([extendRange(doc,doc.sel.primary(),head,other)],0),options);}// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc,heads,options){var out=[];for(var i=0;i<doc.sel.ranges.length;i++){out[i]=extendRange(doc,doc.sel.ranges[i],heads[i],null);}var newSel=normalizeSelection(out,doc.sel.primIndex);setSelection(doc,newSel,options);}// Updates a single range in the selection.\nfunction replaceOneSelection(doc,i,range,options){var ranges=doc.sel.ranges.slice(0);ranges[i]=range;setSelection(doc,normalizeSelection(ranges,doc.sel.primIndex),options);}// Reset the selection to a single range.\nfunction setSimpleSelection(doc,anchor,head,options){setSelection(doc,simpleSelection(anchor,head),options);}// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc,sel,options){var obj={ranges:sel.ranges,update:function(ranges){var this$1=this;this.ranges=[];for(var i=0;i<ranges.length;i++){this$1.ranges[i]=new Range(clipPos(doc,ranges[i].anchor),clipPos(doc,ranges[i].head));}},origin:options&&options.origin};signal(doc,"beforeSelectionChange",doc,obj);if(doc.cm){signal(doc.cm,"beforeSelectionChange",doc.cm,obj);}if(obj.ranges!=sel.ranges){return normalizeSelection(obj.ranges,obj.ranges.length-1);}else{return sel;}}function setSelectionReplaceHistory(doc,sel,options){var done=doc.history.done,last=lst(done);if(last&&last.ranges){done[done.length-1]=sel;setSelectionNoUndo(doc,sel,options);}else{setSelection(doc,sel,options);}}// Set a new selection.\nfunction setSelection(doc,sel,options){setSelectionNoUndo(doc,sel,options);addSelectionToHistory(doc,doc.sel,doc.cm?doc.cm.curOp.id:NaN,options);}function setSelectionNoUndo(doc,sel,options){if(hasHandler(doc,"beforeSelectionChange")||doc.cm&&hasHandler(doc.cm,"beforeSelectionChange")){sel=filterSelectionChange(doc,sel,options);}var bias=options&&options.bias||(cmp(sel.primary().head,doc.sel.primary().head)<0?-1:1);setSelectionInner(doc,skipAtomicInSelection(doc,sel,bias,true));if(!(options&&options.scroll===false)&&doc.cm){ensureCursorVisible(doc.cm);}}function setSelectionInner(doc,sel){if(sel.equals(doc.sel)){return;}doc.sel=sel;if(doc.cm){doc.cm.curOp.updateInput=doc.cm.curOp.selectionChanged=true;signalCursorActivity(doc.cm);}signalLater(doc,"cursorActivity",doc);}// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc){setSelectionInner(doc,skipAtomicInSelection(doc,doc.sel,null,false),sel_dontScroll);}// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc,sel,bias,mayClear){var out;for(var i=0;i<sel.ranges.length;i++){var range=sel.ranges[i];var old=sel.ranges.length==doc.sel.ranges.length&&doc.sel.ranges[i];var newAnchor=skipAtomic(doc,range.anchor,old&&old.anchor,bias,mayClear);var newHead=skipAtomic(doc,range.head,old&&old.head,bias,mayClear);if(out||newAnchor!=range.anchor||newHead!=range.head){if(!out){out=sel.ranges.slice(0,i);}out[i]=new Range(newAnchor,newHead);}}return out?normalizeSelection(out,sel.primIndex):sel;}function skipAtomicInner(doc,pos,oldPos,dir,mayClear){var line=getLine(doc,pos.line);if(line.markedSpans){for(var i=0;i<line.markedSpans.length;++i){var sp=line.markedSpans[i],m=sp.marker;if((sp.from==null||(m.inclusiveLeft?sp.from<=pos.ch:sp.from<pos.ch))&&(sp.to==null||(m.inclusiveRight?sp.to>=pos.ch:sp.to>pos.ch))){if(mayClear){signal(m,"beforeCursorEnter");if(m.explicitlyCleared){if(!line.markedSpans){break;}else{--i;continue;}}}if(!m.atomic){continue;}if(oldPos){var near=m.find(dir<0?1:-1),diff=void 0;if(dir<0?m.inclusiveRight:m.inclusiveLeft){near=movePos(doc,near,-dir,near&&near.line==pos.line?line:null);}if(near&&near.line==pos.line&&(diff=cmp(near,oldPos))&&(dir<0?diff<0:diff>0)){return skipAtomicInner(doc,near,pos,dir,mayClear);}}var far=m.find(dir<0?-1:1);if(dir<0?m.inclusiveLeft:m.inclusiveRight){far=movePos(doc,far,dir,far.line==pos.line?line:null);}return far?skipAtomicInner(doc,far,pos,dir,mayClear):null;}}}return pos;}// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc,pos,oldPos,bias,mayClear){var dir=bias||1;var found=skipAtomicInner(doc,pos,oldPos,dir,mayClear)||!mayClear&&skipAtomicInner(doc,pos,oldPos,dir,true)||skipAtomicInner(doc,pos,oldPos,-dir,mayClear)||!mayClear&&skipAtomicInner(doc,pos,oldPos,-dir,true);if(!found){doc.cantEdit=true;return Pos(doc.first,0);}return found;}function movePos(doc,pos,dir,line){if(dir<0&&pos.ch==0){if(pos.line>doc.first){return clipPos(doc,Pos(pos.line-1));}else{return null;}}else if(dir>0&&pos.ch==(line||getLine(doc,pos.line)).text.length){if(pos.line<doc.first+doc.size-1){return Pos(pos.line+1,0);}else{return null;}}else{return new Pos(pos.line,pos.ch+dir);}}function selectAll(cm){cm.setSelection(Pos(cm.firstLine(),0),Pos(cm.lastLine()),sel_dontScroll);}// UPDATING\n// Allow "beforeChange" event handlers to influence a change\nfunction filterChange(doc,change,update){var obj={canceled:false,from:change.from,to:change.to,text:change.text,origin:change.origin,cancel:function(){return obj.canceled=true;}};if(update){obj.update=function(from,to,text,origin){if(from){obj.from=clipPos(doc,from);}if(to){obj.to=clipPos(doc,to);}if(text){obj.text=text;}if(origin!==undefined){obj.origin=origin;}};}signal(doc,"beforeChange",doc,obj);if(doc.cm){signal(doc.cm,"beforeChange",doc.cm,obj);}if(obj.canceled){return null;}return{from:obj.from,to:obj.to,text:obj.text,origin:obj.origin};}// Apply a change to a document, and add it to the document\'s\n// history, and propagating it to all linked documents.\nfunction makeChange(doc,change,ignoreReadOnly){if(doc.cm){if(!doc.cm.curOp){return operation(doc.cm,makeChange)(doc,change,ignoreReadOnly);}if(doc.cm.state.suppressEdits){return;}}if(hasHandler(doc,"beforeChange")||doc.cm&&hasHandler(doc.cm,"beforeChange")){change=filterChange(doc,change,true);if(!change){return;}}// Possibly split or suppress the update based on the presence\n// of read-only spans in its range.\nvar split=sawReadOnlySpans&&!ignoreReadOnly&&removeReadOnlyRanges(doc,change.from,change.to);if(split){for(var i=split.length-1;i>=0;--i){makeChangeInner(doc,{from:split[i].from,to:split[i].to,text:i?[""]:change.text});}}else{makeChangeInner(doc,change);}}function makeChangeInner(doc,change){if(change.text.length==1&&change.text[0]==""&&cmp(change.from,change.to)==0){return;}var selAfter=computeSelAfterChange(doc,change);addChangeToHistory(doc,change,selAfter,doc.cm?doc.cm.curOp.id:NaN);makeChangeSingleDoc(doc,change,selAfter,stretchSpansOverChange(doc,change));var rebased=[];linkedDocs(doc,function(doc,sharedHist){if(!sharedHist&&indexOf(rebased,doc.history)==-1){rebaseHist(doc.history,change);rebased.push(doc.history);}makeChangeSingleDoc(doc,change,null,stretchSpansOverChange(doc,change));});}// Revert a change stored in a document\'s history.\nfunction makeChangeFromHistory(doc,type,allowSelectionOnly){if(doc.cm&&doc.cm.state.suppressEdits&&!allowSelectionOnly){return;}var hist=doc.history,event,selAfter=doc.sel;var source=type=="undo"?hist.done:hist.undone,dest=type=="undo"?hist.undone:hist.done;// Verify that there is a useable event (so that ctrl-z won\'t\n// needlessly clear selection events)\nvar i=0;for(;i<source.length;i++){event=source[i];if(allowSelectionOnly?event.ranges&&!event.equals(doc.sel):!event.ranges){break;}}if(i==source.length){return;}hist.lastOrigin=hist.lastSelOrigin=null;for(;;){event=source.pop();if(event.ranges){pushSelectionToHistory(event,dest);if(allowSelectionOnly&&!event.equals(doc.sel)){setSelection(doc,event,{clearRedo:false});return;}selAfter=event;}else{break;}}// Build up a reverse change object to add to the opposite history\n// stack (redo when undoing, and vice versa).\nvar antiChanges=[];pushSelectionToHistory(selAfter,dest);dest.push({changes:antiChanges,generation:hist.generation});hist.generation=event.generation||++hist.maxGeneration;var filter=hasHandler(doc,"beforeChange")||doc.cm&&hasHandler(doc.cm,"beforeChange");var loop=function(i){var change=event.changes[i];change.origin=type;if(filter&&!filterChange(doc,change,false)){source.length=0;return{};}antiChanges.push(historyChangeFromChange(doc,change));var after=i?computeSelAfterChange(doc,change):lst(source);makeChangeSingleDoc(doc,change,after,mergeOldSpans(doc,change));if(!i&&doc.cm){doc.cm.scrollIntoView({from:change.from,to:changeEnd(change)});}var rebased=[];// Propagate to the linked documents\nlinkedDocs(doc,function(doc,sharedHist){if(!sharedHist&&indexOf(rebased,doc.history)==-1){rebaseHist(doc.history,change);rebased.push(doc.history);}makeChangeSingleDoc(doc,change,null,mergeOldSpans(doc,change));});};for(var i$1=event.changes.length-1;i$1>=0;--i$1){var returned=loop(i$1);if(returned)return returned.v;}}// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc,distance){if(distance==0){return;}doc.first+=distance;doc.sel=new Selection(map(doc.sel.ranges,function(range){return new Range(Pos(range.anchor.line+distance,range.anchor.ch),Pos(range.head.line+distance,range.head.ch));}),doc.sel.primIndex);if(doc.cm){regChange(doc.cm,doc.first,doc.first-distance,distance);for(var d=doc.cm.display,l=d.viewFrom;l<d.viewTo;l++){regLineChange(doc.cm,l,"gutter");}}}// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc,change,selAfter,spans){if(doc.cm&&!doc.cm.curOp){return operation(doc.cm,makeChangeSingleDoc)(doc,change,selAfter,spans);}if(change.to.line<doc.first){shiftDoc(doc,change.text.length-1-(change.to.line-change.from.line));return;}if(change.from.line>doc.lastLine()){return;}// Clip the change to the size of this doc\nif(change.from.line<doc.first){var shift=change.text.length-1-(doc.first-change.from.line);shiftDoc(doc,shift);change={from:Pos(doc.first,0),to:Pos(change.to.line+shift,change.to.ch),text:[lst(change.text)],origin:change.origin};}var last=doc.lastLine();if(change.to.line>last){change={from:change.from,to:Pos(last,getLine(doc,last).text.length),text:[change.text[0]],origin:change.origin};}change.removed=getBetween(doc,change.from,change.to);if(!selAfter){selAfter=computeSelAfterChange(doc,change);}if(doc.cm){makeChangeSingleDocInEditor(doc.cm,change,spans);}else{updateDoc(doc,change,spans);}setSelectionNoUndo(doc,selAfter,sel_dontScroll);}// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm,change,spans){var doc=cm.doc,display=cm.display,from=change.from,to=change.to;var recomputeMaxLength=false,checkWidthStart=from.line;if(!cm.options.lineWrapping){checkWidthStart=lineNo(visualLine(getLine(doc,from.line)));doc.iter(checkWidthStart,to.line+1,function(line){if(line==display.maxLine){recomputeMaxLength=true;return true;}});}if(doc.sel.contains(change.from,change.to)>-1){signalCursorActivity(cm);}updateDoc(doc,change,spans,estimateHeight(cm));if(!cm.options.lineWrapping){doc.iter(checkWidthStart,from.line+change.text.length,function(line){var len=lineLength(line);if(len>display.maxLineLength){display.maxLine=line;display.maxLineLength=len;display.maxLineChanged=true;recomputeMaxLength=false;}});if(recomputeMaxLength){cm.curOp.updateMaxLine=true;}}// Adjust frontier, schedule worker\ndoc.frontier=Math.min(doc.frontier,from.line);startWorker(cm,400);var lendiff=change.text.length-(to.line-from.line)-1;// Remember that these lines changed, for updating the display\nif(change.full){regChange(cm);}else if(from.line==to.line&&change.text.length==1&&!isWholeLineUpdate(cm.doc,change)){regLineChange(cm,from.line,"text");}else{regChange(cm,from.line,to.line+1,lendiff);}var changesHandler=hasHandler(cm,"changes"),changeHandler=hasHandler(cm,"change");if(changeHandler||changesHandler){var obj={from:from,to:to,text:change.text,removed:change.removed,origin:change.origin};if(changeHandler){signalLater(cm,"change",cm,obj);}if(changesHandler){(cm.curOp.changeObjs||(cm.curOp.changeObjs=[])).push(obj);}}cm.display.selForContextMenu=null;}function replaceRange(doc,code,from,to,origin){if(!to){to=from;}if(cmp(to,from)<0){var tmp=to;to=from;from=tmp;}if(typeof code=="string"){code=doc.splitLines(code);}makeChange(doc,{from:from,to:to,text:code,origin:origin});}// Rebasing/resetting history to deal with externally-sourced changes\nfunction rebaseHistSelSingle(pos,from,to,diff){if(to<pos.line){pos.line+=diff;}else if(from<pos.line){pos.line=from;pos.ch=0;}}// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything \'behind\' it, is discarded. If the change is\n// before the event, the event\'s positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array,from,to,diff){for(var i=0;i<array.length;++i){var sub=array[i],ok=true;if(sub.ranges){if(!sub.copied){sub=array[i]=sub.deepCopy();sub.copied=true;}for(var j=0;j<sub.ranges.length;j++){rebaseHistSelSingle(sub.ranges[j].anchor,from,to,diff);rebaseHistSelSingle(sub.ranges[j].head,from,to,diff);}continue;}for(var j$1=0;j$1<sub.changes.length;++j$1){var cur=sub.changes[j$1];if(to<cur.from.line){cur.from=Pos(cur.from.line+diff,cur.from.ch);cur.to=Pos(cur.to.line+diff,cur.to.ch);}else if(from<=cur.to.line){ok=false;break;}}if(!ok){array.splice(0,i+1);i=0;}}}function rebaseHist(hist,change){var from=change.from.line,to=change.to.line,diff=change.text.length-(to-from)-1;rebaseHistArray(hist.done,from,to,diff);rebaseHistArray(hist.undone,from,to,diff);}// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc,handle,changeType,op){var no=handle,line=handle;if(typeof handle=="number"){line=getLine(doc,clipLine(doc,handle));}else{no=lineNo(handle);}if(no==null){return null;}if(op(line,no)&&doc.cm){regLineChange(doc.cm,no,changeType);}return line;}// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\nfunction LeafChunk(lines){var this$1=this;this.lines=lines;this.parent=null;var height=0;for(var i=0;i<lines.length;++i){lines[i].parent=this$1;height+=lines[i].height;}this.height=height;}LeafChunk.prototype={chunkSize:function(){return this.lines.length;},// Remove the n lines at offset \'at\'.\nremoveInner:function(at,n){var this$1=this;for(var i=at,e=at+n;i<e;++i){var line=this$1.lines[i];this$1.height-=line.height;cleanUpLine(line);signalLater(line,"delete");}this.lines.splice(at,n);},// Helper used to collapse a small branch into a single leaf.\ncollapse:function(lines){lines.push.apply(lines,this.lines);},// Insert the given array of lines at offset \'at\', count them as\n// having the given height.\ninsertInner:function(at,lines,height){var this$1=this;this.height+=height;this.lines=this.lines.slice(0,at).concat(lines).concat(this.lines.slice(at));for(var i=0;i<lines.length;++i){lines[i].parent=this$1;}},// Used to iterate over a part of the tree.\niterN:function(at,n,op){var this$1=this;for(var e=at+n;at<e;++at){if(op(this$1.lines[at])){return true;}}}};function BranchChunk(children){var this$1=this;this.children=children;var size=0,height=0;for(var i=0;i<children.length;++i){var ch=children[i];size+=ch.chunkSize();height+=ch.height;ch.parent=this$1;}this.size=size;this.height=height;this.parent=null;}BranchChunk.prototype={chunkSize:function(){return this.size;},removeInner:function(at,n){var this$1=this;this.size-=n;for(var i=0;i<this.children.length;++i){var child=this$1.children[i],sz=child.chunkSize();if(at<sz){var rm=Math.min(n,sz-at),oldHeight=child.height;child.removeInner(at,rm);this$1.height-=oldHeight-child.height;if(sz==rm){this$1.children.splice(i--,1);child.parent=null;}if((n-=rm)==0){break;}at=0;}else{at-=sz;}}// If the result is smaller than 25 lines, ensure that it is a\n// single leaf node.\nif(this.size-n<25&&(this.children.length>1||!(this.children[0]instanceof LeafChunk))){var lines=[];this.collapse(lines);this.children=[new LeafChunk(lines)];this.children[0].parent=this;}},collapse:function(lines){var this$1=this;for(var i=0;i<this.children.length;++i){this$1.children[i].collapse(lines);}},insertInner:function(at,lines,height){var this$1=this;this.size+=lines.length;this.height+=height;for(var i=0;i<this.children.length;++i){var child=this$1.children[i],sz=child.chunkSize();if(at<=sz){child.insertInner(at,lines,height);if(child.lines&&child.lines.length>50){// To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it\'s never spliced.\n// Instead, small slices are taken. They\'re taken in order because sequential memory accesses are fastest.\nvar remaining=child.lines.length%25+25;for(var pos=remaining;pos<child.lines.length;){var leaf=new LeafChunk(child.lines.slice(pos,pos+=25));child.height-=leaf.height;this$1.children.splice(++i,0,leaf);leaf.parent=this$1;}child.lines=child.lines.slice(0,remaining);this$1.maybeSpill();}break;}at-=sz;}},// When a node has grown, check whether it should be split.\nmaybeSpill:function(){if(this.children.length<=10){return;}var me=this;do{var spilled=me.children.splice(me.children.length-5,5);var sibling=new BranchChunk(spilled);if(!me.parent){// Become the parent node\nvar copy=new BranchChunk(me.children);copy.parent=me;me.children=[copy,sibling];me=copy;}else{me.size-=sibling.size;me.height-=sibling.height;var myIndex=indexOf(me.parent.children,me);me.parent.children.splice(myIndex+1,0,sibling);}sibling.parent=me.parent;}while(me.children.length>10);me.parent.maybeSpill();},iterN:function(at,n,op){var this$1=this;for(var i=0;i<this.children.length;++i){var child=this$1.children[i],sz=child.chunkSize();if(at<sz){var used=Math.min(n,sz-at);if(child.iterN(at,used,op)){return true;}if((n-=used)==0){break;}at=0;}else{at-=sz;}}}};// Line widgets are block elements displayed above or below a line.\nfunction LineWidget(doc,node,options){var this$1=this;if(options){for(var opt in options){if(options.hasOwnProperty(opt)){this$1[opt]=options[opt];}}}this.doc=doc;this.node=node;}eventMixin(LineWidget);function adjustScrollWhenAboveVisible(cm,line,diff){if(heightAtLine(line)<(cm.curOp&&cm.curOp.scrollTop||cm.doc.scrollTop)){addToScrollPos(cm,null,diff);}}LineWidget.prototype.clear=function(){var this$1=this;var cm=this.doc.cm,ws=this.line.widgets,line=this.line,no=lineNo(line);if(no==null||!ws){return;}for(var i=0;i<ws.length;++i){if(ws[i]==this$1){ws.splice(i--,1);}}if(!ws.length){line.widgets=null;}var height=widgetHeight(this);updateLineHeight(line,Math.max(0,line.height-height));if(cm){runInOp(cm,function(){adjustScrollWhenAboveVisible(cm,line,-height);regLineChange(cm,no,"widget");});}};LineWidget.prototype.changed=function(){var oldH=this.height,cm=this.doc.cm,line=this.line;this.height=null;var diff=widgetHeight(this)-oldH;if(!diff){return;}updateLineHeight(line,line.height+diff);if(cm){runInOp(cm,function(){cm.curOp.forceUpdate=true;adjustScrollWhenAboveVisible(cm,line,diff);});}};function addLineWidget(doc,handle,node,options){var widget=new LineWidget(doc,node,options);var cm=doc.cm;if(cm&&widget.noHScroll){cm.display.alignWidgets=true;}changeLine(doc,handle,"widget",function(line){var widgets=line.widgets||(line.widgets=[]);if(widget.insertAt==null){widgets.push(widget);}else{widgets.splice(Math.min(widgets.length-1,Math.max(0,widget.insertAt)),0,widget);}widget.line=line;if(cm&&!lineIsHidden(doc,line)){var aboveVisible=heightAtLine(line)<doc.scrollTop;updateLineHeight(line,line.height+widgetHeight(widget));if(aboveVisible){addToScrollPos(cm,null,widget.height);}cm.curOp.forceUpdate=true;}return true;});return widget;}// TEXTMARKERS\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId=0;function TextMarker(doc,type){this.lines=[];this.type=type;this.doc=doc;this.id=++nextMarkerId;}eventMixin(TextMarker);// Clear the marker.\nTextMarker.prototype.clear=function(){var this$1=this;if(this.explicitlyCleared){return;}var cm=this.doc.cm,withOp=cm&&!cm.curOp;if(withOp){startOperation(cm);}if(hasHandler(this,"clear")){var found=this.find();if(found){signalLater(this,"clear",found.from,found.to);}}var min=null,max=null;for(var i=0;i<this.lines.length;++i){var line=this$1.lines[i];var span=getMarkedSpanFor(line.markedSpans,this$1);if(cm&&!this$1.collapsed){regLineChange(cm,lineNo(line),"text");}else if(cm){if(span.to!=null){max=lineNo(line);}if(span.from!=null){min=lineNo(line);}}line.markedSpans=removeMarkedSpan(line.markedSpans,span);if(span.from==null&&this$1.collapsed&&!lineIsHidden(this$1.doc,line)&&cm){updateLineHeight(line,textHeight(cm.display));}}if(cm&&this.collapsed&&!cm.options.lineWrapping){for(var i$1=0;i$1<this.lines.length;++i$1){var visual=visualLine(this$1.lines[i$1]),len=lineLength(visual);if(len>cm.display.maxLineLength){cm.display.maxLine=visual;cm.display.maxLineLength=len;cm.display.maxLineChanged=true;}}}if(min!=null&&cm&&this.collapsed){regChange(cm,min,max+1);}this.lines.length=0;this.explicitlyCleared=true;if(this.atomic&&this.doc.cantEdit){this.doc.cantEdit=false;if(cm){reCheckSelection(cm.doc);}}if(cm){signalLater(cm,"markerCleared",cm,this);}if(withOp){endOperation(cm);}if(this.parent){this.parent.clear();}};// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find=function(side,lineObj){var this$1=this;if(side==null&&this.type=="bookmark"){side=1;}var from,to;for(var i=0;i<this.lines.length;++i){var line=this$1.lines[i];var span=getMarkedSpanFor(line.markedSpans,this$1);if(span.from!=null){from=Pos(lineObj?line:lineNo(line),span.from);if(side==-1){return from;}}if(span.to!=null){to=Pos(lineObj?line:lineNo(line),span.to);if(side==1){return to;}}}return from&&{from:from,to:to};};// Signals that the marker\'s widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed=function(){var pos=this.find(-1,true),widget=this,cm=this.doc.cm;if(!pos||!cm){return;}runInOp(cm,function(){var line=pos.line,lineN=lineNo(pos.line);var view=findViewForLine(cm,lineN);if(view){clearLineMeasurementCacheFor(view);cm.curOp.selectionChanged=cm.curOp.forceUpdate=true;}cm.curOp.updateMaxLine=true;if(!lineIsHidden(widget.doc,line)&&widget.height!=null){var oldHeight=widget.height;widget.height=null;var dHeight=widgetHeight(widget)-oldHeight;if(dHeight){updateLineHeight(line,line.height+dHeight);}}});};TextMarker.prototype.attachLine=function(line){if(!this.lines.length&&this.doc.cm){var op=this.doc.cm.curOp;if(!op.maybeHiddenMarkers||indexOf(op.maybeHiddenMarkers,this)==-1){(op.maybeUnhiddenMarkers||(op.maybeUnhiddenMarkers=[])).push(this);}}this.lines.push(line);};TextMarker.prototype.detachLine=function(line){this.lines.splice(indexOf(this.lines,line),1);if(!this.lines.length&&this.doc.cm){var op=this.doc.cm.curOp;(op.maybeHiddenMarkers||(op.maybeHiddenMarkers=[])).push(this);}};// Create a marker, wire it up to the right lines, and\nfunction markText(doc,from,to,options,type){// Shared markers (across linked documents) are handled separately\n// (markTextShared will call out to this again, once per\n// document).\nif(options&&options.shared){return markTextShared(doc,from,to,options,type);}// Ensure we are in an operation.\nif(doc.cm&&!doc.cm.curOp){return operation(doc.cm,markText)(doc,from,to,options,type);}var marker=new TextMarker(doc,type),diff=cmp(from,to);if(options){copyObj(options,marker,false);}// Don\'t connect empty markers unless clearWhenEmpty is false\nif(diff>0||diff==0&&marker.clearWhenEmpty!==false){return marker;}if(marker.replacedWith){// Showing up as a widget implies collapsed (widget replaces text)\nmarker.collapsed=true;marker.widgetNode=elt("span",[marker.replacedWith],"CodeMirror-widget");if(!options.handleMouseEvents){marker.widgetNode.setAttribute("cm-ignore-events","true");}if(options.insertLeft){marker.widgetNode.insertLeft=true;}}if(marker.collapsed){if(conflictingCollapsedRange(doc,from.line,from,to,marker)||from.line!=to.line&&conflictingCollapsedRange(doc,to.line,from,to,marker)){throw new Error("Inserting collapsed marker partially overlapping an existing one");}seeCollapsedSpans();}if(marker.addToHistory){addChangeToHistory(doc,{from:from,to:to,origin:"markText"},doc.sel,NaN);}var curLine=from.line,cm=doc.cm,updateMaxLine;doc.iter(curLine,to.line+1,function(line){if(cm&&marker.collapsed&&!cm.options.lineWrapping&&visualLine(line)==cm.display.maxLine){updateMaxLine=true;}if(marker.collapsed&&curLine!=from.line){updateLineHeight(line,0);}addMarkedSpan(line,new MarkedSpan(marker,curLine==from.line?from.ch:null,curLine==to.line?to.ch:null));++curLine;});// lineIsHidden depends on the presence of the spans, so needs a second pass\nif(marker.collapsed){doc.iter(from.line,to.line+1,function(line){if(lineIsHidden(doc,line)){updateLineHeight(line,0);}});}if(marker.clearOnEnter){on(marker,"beforeCursorEnter",function(){return marker.clear();});}if(marker.readOnly){seeReadOnlySpans();if(doc.history.done.length||doc.history.undone.length){doc.clearHistory();}}if(marker.collapsed){marker.id=++nextMarkerId;marker.atomic=true;}if(cm){// Sync editor state\nif(updateMaxLine){cm.curOp.updateMaxLine=true;}if(marker.collapsed){regChange(cm,from.line,to.line+1);}else if(marker.className||marker.title||marker.startStyle||marker.endStyle||marker.css){for(var i=from.line;i<=to.line;i++){regLineChange(cm,i,"text");}}if(marker.atomic){reCheckSelection(cm.doc);}signalLater(cm,"markerAdded",cm,marker);}return marker;}// SHARED TEXTMARKERS\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nfunction SharedTextMarker(markers,primary){var this$1=this;this.markers=markers;this.primary=primary;for(var i=0;i<markers.length;++i){markers[i].parent=this$1;}}eventMixin(SharedTextMarker);SharedTextMarker.prototype.clear=function(){var this$1=this;if(this.explicitlyCleared){return;}this.explicitlyCleared=true;for(var i=0;i<this.markers.length;++i){this$1.markers[i].clear();}signalLater(this,"clear");};SharedTextMarker.prototype.find=function(side,lineObj){return this.primary.find(side,lineObj);};function markTextShared(doc,from,to,options,type){options=copyObj(options);options.shared=false;var markers=[markText(doc,from,to,options,type)],primary=markers[0];var widget=options.widgetNode;linkedDocs(doc,function(doc){if(widget){options.widgetNode=widget.cloneNode(true);}markers.push(markText(doc,clipPos(doc,from),clipPos(doc,to),options,type));for(var i=0;i<doc.linked.length;++i){if(doc.linked[i].isParent){return;}}primary=lst(markers);});return new SharedTextMarker(markers,primary);}function findSharedMarkers(doc){return doc.findMarks(Pos(doc.first,0),doc.clipPos(Pos(doc.lastLine())),function(m){return m.parent;});}function copySharedMarkers(doc,markers){for(var i=0;i<markers.length;i++){var marker=markers[i],pos=marker.find();var mFrom=doc.clipPos(pos.from),mTo=doc.clipPos(pos.to);if(cmp(mFrom,mTo)){var subMark=markText(doc,mFrom,mTo,marker.primary,marker.primary.type);marker.markers.push(subMark);subMark.parent=marker;}}}function detachSharedMarkers(markers){var loop=function(i){var marker=markers[i],linked=[marker.primary.doc];linkedDocs(marker.primary.doc,function(d){return linked.push(d);});for(var j=0;j<marker.markers.length;j++){var subMarker=marker.markers[j];if(indexOf(linked,subMarker.doc)==-1){subMarker.parent=null;marker.markers.splice(j--,1);}}};for(var i=0;i<markers.length;i++)loop(i);}var nextDocId=0;var Doc=function(text,mode,firstLine,lineSep){if(!(this instanceof Doc)){return new Doc(text,mode,firstLine,lineSep);}if(firstLine==null){firstLine=0;}BranchChunk.call(this,[new LeafChunk([new Line("",null)])]);this.first=firstLine;this.scrollTop=this.scrollLeft=0;this.cantEdit=false;this.cleanGeneration=1;this.frontier=firstLine;var start=Pos(firstLine,0);this.sel=simpleSelection(start);this.history=new History(null);this.id=++nextDocId;this.modeOption=mode;this.lineSep=lineSep;this.extend=false;if(typeof text=="string"){text=this.splitLines(text);}updateDoc(this,{from:start,to:start,text:text});setSelection(this,simpleSelection(start),sel_dontScroll);};Doc.prototype=createObj(BranchChunk.prototype,{constructor:Doc,// Iterate over the document. Supports two forms -- with only one\n// argument, it calls that for each line in the document. With\n// three, it iterates over the range given by the first two (with\n// the second being non-inclusive).\niter:function(from,to,op){if(op){this.iterN(from-this.first,to-from,op);}else{this.iterN(this.first,this.first+this.size,from);}},// Non-public interface for adding and removing lines.\ninsert:function(at,lines){var height=0;for(var i=0;i<lines.length;++i){height+=lines[i].height;}this.insertInner(at-this.first,lines,height);},remove:function(at,n){this.removeInner(at-this.first,n);},// From here, the methods are part of the public interface. Most\n// are also available from CodeMirror (editor) instances.\ngetValue:function(lineSep){var lines=getLines(this,this.first,this.first+this.size);if(lineSep===false){return lines;}return lines.join(lineSep||this.lineSeparator());},setValue:docMethodOp(function(code){var top=Pos(this.first,0),last=this.first+this.size-1;makeChange(this,{from:top,to:Pos(last,getLine(this,last).text.length),text:this.splitLines(code),origin:"setValue",full:true},true);setSelection(this,simpleSelection(top));}),replaceRange:function(code,from,to,origin){from=clipPos(this,from);to=to?clipPos(this,to):from;replaceRange(this,code,from,to,origin);},getRange:function(from,to,lineSep){var lines=getBetween(this,clipPos(this,from),clipPos(this,to));if(lineSep===false){return lines;}return lines.join(lineSep||this.lineSeparator());},getLine:function(line){var l=this.getLineHandle(line);return l&&l.text;},getLineHandle:function(line){if(isLine(this,line)){return getLine(this,line);}},getLineNumber:function(line){return lineNo(line);},getLineHandleVisualStart:function(line){if(typeof line=="number"){line=getLine(this,line);}return visualLine(line);},lineCount:function(){return this.size;},firstLine:function(){return this.first;},lastLine:function(){return this.first+this.size-1;},clipPos:function(pos){return clipPos(this,pos);},getCursor:function(start){var range=this.sel.primary(),pos;if(start==null||start=="head"){pos=range.head;}else if(start=="anchor"){pos=range.anchor;}else if(start=="end"||start=="to"||start===false){pos=range.to();}else{pos=range.from();}return pos;},listSelections:function(){return this.sel.ranges;},somethingSelected:function(){return this.sel.somethingSelected();},setCursor:docMethodOp(function(line,ch,options){setSimpleSelection(this,clipPos(this,typeof line=="number"?Pos(line,ch||0):line),null,options);}),setSelection:docMethodOp(function(anchor,head,options){setSimpleSelection(this,clipPos(this,anchor),clipPos(this,head||anchor),options);}),extendSelection:docMethodOp(function(head,other,options){extendSelection(this,clipPos(this,head),other&&clipPos(this,other),options);}),extendSelections:docMethodOp(function(heads,options){extendSelections(this,clipPosArray(this,heads),options);}),extendSelectionsBy:docMethodOp(function(f,options){var heads=map(this.sel.ranges,f);extendSelections(this,clipPosArray(this,heads),options);}),setSelections:docMethodOp(function(ranges,primary,options){var this$1=this;if(!ranges.length){return;}var out=[];for(var i=0;i<ranges.length;i++){out[i]=new Range(clipPos(this$1,ranges[i].anchor),clipPos(this$1,ranges[i].head));}if(primary==null){primary=Math.min(ranges.length-1,this.sel.primIndex);}setSelection(this,normalizeSelection(out,primary),options);}),addSelection:docMethodOp(function(anchor,head,options){var ranges=this.sel.ranges.slice(0);ranges.push(new Range(clipPos(this,anchor),clipPos(this,head||anchor)));setSelection(this,normalizeSelection(ranges,ranges.length-1),options);}),getSelection:function(lineSep){var this$1=this;var ranges=this.sel.ranges,lines;for(var i=0;i<ranges.length;i++){var sel=getBetween(this$1,ranges[i].from(),ranges[i].to());lines=lines?lines.concat(sel):sel;}if(lineSep===false){return lines;}else{return lines.join(lineSep||this.lineSeparator());}},getSelections:function(lineSep){var this$1=this;var parts=[],ranges=this.sel.ranges;for(var i=0;i<ranges.length;i++){var sel=getBetween(this$1,ranges[i].from(),ranges[i].to());if(lineSep!==false){sel=sel.join(lineSep||this$1.lineSeparator());}parts[i]=sel;}return parts;},replaceSelection:function(code,collapse,origin){var dup=[];for(var i=0;i<this.sel.ranges.length;i++){dup[i]=code;}this.replaceSelections(dup,collapse,origin||"+input");},replaceSelections:docMethodOp(function(code,collapse,origin){var this$1=this;var changes=[],sel=this.sel;for(var i=0;i<sel.ranges.length;i++){var range=sel.ranges[i];changes[i]={from:range.from(),to:range.to(),text:this$1.splitLines(code[i]),origin:origin};}var newSel=collapse&&collapse!="end"&&computeReplacedSel(this,changes,collapse);for(var i$1=changes.length-1;i$1>=0;i$1--){makeChange(this$1,changes[i$1]);}if(newSel){setSelectionReplaceHistory(this,newSel);}else if(this.cm){ensureCursorVisible(this.cm);}}),undo:docMethodOp(function(){makeChangeFromHistory(this,"undo");}),redo:docMethodOp(function(){makeChangeFromHistory(this,"redo");}),undoSelection:docMethodOp(function(){makeChangeFromHistory(this,"undo",true);}),redoSelection:docMethodOp(function(){makeChangeFromHistory(this,"redo",true);}),setExtending:function(val){this.extend=val;},getExtending:function(){return this.extend;},historySize:function(){var hist=this.history,done=0,undone=0;for(var i=0;i<hist.done.length;i++){if(!hist.done[i].ranges){++done;}}for(var i$1=0;i$1<hist.undone.length;i$1++){if(!hist.undone[i$1].ranges){++undone;}}return{undo:done,redo:undone};},clearHistory:function(){this.history=new History(this.history.maxGeneration);},markClean:function(){this.cleanGeneration=this.changeGeneration(true);},changeGeneration:function(forceSplit){if(forceSplit){this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null;}return this.history.generation;},isClean:function(gen){return this.history.generation==(gen||this.cleanGeneration);},getHistory:function(){return{done:copyHistoryArray(this.history.done),undone:copyHistoryArray(this.history.undone)};},setHistory:function(histData){var hist=this.history=new History(this.history.maxGeneration);hist.done=copyHistoryArray(histData.done.slice(0),null,true);hist.undone=copyHistoryArray(histData.undone.slice(0),null,true);},addLineClass:docMethodOp(function(handle,where,cls){return changeLine(this,handle,where=="gutter"?"gutter":"class",function(line){var prop=where=="text"?"textClass":where=="background"?"bgClass":where=="gutter"?"gutterClass":"wrapClass";if(!line[prop]){line[prop]=cls;}else if(classTest(cls).test(line[prop])){return false;}else{line[prop]+=" "+cls;}return true;});}),removeLineClass:docMethodOp(function(handle,where,cls){return changeLine(this,handle,where=="gutter"?"gutter":"class",function(line){var prop=where=="text"?"textClass":where=="background"?"bgClass":where=="gutter"?"gutterClass":"wrapClass";var cur=line[prop];if(!cur){return false;}else if(cls==null){line[prop]=null;}else{var found=cur.match(classTest(cls));if(!found){return false;}var end=found.index+found[0].length;line[prop]=cur.slice(0,found.index)+(!found.index||end==cur.length?"":" ")+cur.slice(end)||null;}return true;});}),addLineWidget:docMethodOp(function(handle,node,options){return addLineWidget(this,handle,node,options);}),removeLineWidget:function(widget){widget.clear();},markText:function(from,to,options){return markText(this,clipPos(this,from),clipPos(this,to),options,options&&options.type||"range");},setBookmark:function(pos,options){var realOpts={replacedWith:options&&(options.nodeType==null?options.widget:options),insertLeft:options&&options.insertLeft,clearWhenEmpty:false,shared:options&&options.shared,handleMouseEvents:options&&options.handleMouseEvents};pos=clipPos(this,pos);return markText(this,pos,pos,realOpts,"bookmark");},findMarksAt:function(pos){pos=clipPos(this,pos);var markers=[],spans=getLine(this,pos.line).markedSpans;if(spans){for(var i=0;i<spans.length;++i){var span=spans[i];if((span.from==null||span.from<=pos.ch)&&(span.to==null||span.to>=pos.ch)){markers.push(span.marker.parent||span.marker);}}}return markers;},findMarks:function(from,to,filter){from=clipPos(this,from);to=clipPos(this,to);var found=[],lineNo=from.line;this.iter(from.line,to.line+1,function(line){var spans=line.markedSpans;if(spans){for(var i=0;i<spans.length;i++){var span=spans[i];if(!(span.to!=null&&lineNo==from.line&&from.ch>=span.to||span.from==null&&lineNo!=from.line||span.from!=null&&lineNo==to.line&&span.from>=to.ch)&&(!filter||filter(span.marker))){found.push(span.marker.parent||span.marker);}}}++lineNo;});return found;},getAllMarks:function(){var markers=[];this.iter(function(line){var sps=line.markedSpans;if(sps){for(var i=0;i<sps.length;++i){if(sps[i].from!=null){markers.push(sps[i].marker);}}}});return markers;},posFromIndex:function(off){var ch,lineNo=this.first,sepSize=this.lineSeparator().length;this.iter(function(line){var sz=line.text.length+sepSize;if(sz>off){ch=off;return true;}off-=sz;++lineNo;});return clipPos(this,Pos(lineNo,ch));},indexFromPos:function(coords){coords=clipPos(this,coords);var index=coords.ch;if(coords.line<this.first||coords.ch<0){return 0;}var sepSize=this.lineSeparator().length;this.iter(this.first,coords.line,function(line){// iter aborts when callback returns a truthy value\nindex+=line.text.length+sepSize;});return index;},copy:function(copyHistory){var doc=new Doc(getLines(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep);doc.scrollTop=this.scrollTop;doc.scrollLeft=this.scrollLeft;doc.sel=this.sel;doc.extend=false;if(copyHistory){doc.history.undoDepth=this.history.undoDepth;doc.setHistory(this.getHistory());}return doc;},linkedDoc:function(options){if(!options){options={};}var from=this.first,to=this.first+this.size;if(options.from!=null&&options.from>from){from=options.from;}if(options.to!=null&&options.to<to){to=options.to;}var copy=new Doc(getLines(this,from,to),options.mode||this.modeOption,from,this.lineSep);if(options.sharedHist){copy.history=this.history;}(this.linked||(this.linked=[])).push({doc:copy,sharedHist:options.sharedHist});copy.linked=[{doc:this,isParent:true,sharedHist:options.sharedHist}];copySharedMarkers(copy,findSharedMarkers(this));return copy;},unlinkDoc:function(other){var this$1=this;if(other instanceof CodeMirror){other=other.doc;}if(this.linked){for(var i=0;i<this.linked.length;++i){var link=this$1.linked[i];if(link.doc!=other){continue;}this$1.linked.splice(i,1);other.unlinkDoc(this$1);detachSharedMarkers(findSharedMarkers(this$1));break;}}// If the histories were shared, split them again\nif(other.history==this.history){var splitIds=[other.id];linkedDocs(other,function(doc){return splitIds.push(doc.id);},true);other.history=new History(null);other.history.done=copyHistoryArray(this.history.done,splitIds);other.history.undone=copyHistoryArray(this.history.undone,splitIds);}},iterLinkedDocs:function(f){linkedDocs(this,f);},getMode:function(){return this.mode;},getEditor:function(){return this.cm;},splitLines:function(str){if(this.lineSep){return str.split(this.lineSep);}return splitLinesAuto(str);},lineSeparator:function(){return this.lineSep||"\\n";}});// Public alias.\nDoc.prototype.eachLine=Doc.prototype.iter;// Kludge to work around strange IE behavior where it\'ll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop=0;function onDrop(e){var cm=this;clearDragCursor(cm);if(signalDOMEvent(cm,e)||eventInWidget(cm.display,e)){return;}e_preventDefault(e);if(ie){lastDrop=+new Date();}var pos=posFromMouse(cm,e,true),files=e.dataTransfer.files;if(!pos||cm.isReadOnly()){return;}// Might be a file drop, in which case we simply extract the text\n// and insert it.\nif(files&&files.length&&window.FileReader&&window.File){var n=files.length,text=Array(n),read=0;var loadFile=function(file,i){if(cm.options.allowDropFileTypes&&indexOf(cm.options.allowDropFileTypes,file.type)==-1){return;}var reader=new FileReader();reader.onload=operation(cm,function(){var content=reader.result;if(/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)){content="";}text[i]=content;if(++read==n){pos=clipPos(cm.doc,pos);var change={from:pos,to:pos,text:cm.doc.splitLines(text.join(cm.doc.lineSeparator())),origin:"paste"};makeChange(cm.doc,change);setSelectionReplaceHistory(cm.doc,simpleSelection(pos,changeEnd(change)));}});reader.readAsText(file);};for(var i=0;i<n;++i){loadFile(files[i],i);}}else{// Normal drop\n// Don\'t do a replace if the drop happened inside of the selected text.\nif(cm.state.draggingText&&cm.doc.sel.contains(pos)>-1){cm.state.draggingText(e);// Ensure the editor is re-focused\nsetTimeout(function(){return cm.display.input.focus();},20);return;}try{var text$1=e.dataTransfer.getData("Text");if(text$1){var selected;if(cm.state.draggingText&&!cm.state.draggingText.copy){selected=cm.listSelections();}setSelectionNoUndo(cm.doc,simpleSelection(pos,pos));if(selected){for(var i$1=0;i$1<selected.length;++i$1){replaceRange(cm.doc,"",selected[i$1].anchor,selected[i$1].head,"drag");}}cm.replaceSelection(text$1,"around","paste");cm.display.input.focus();}}catch(e){}}}function onDragStart(cm,e){if(ie&&(!cm.state.draggingText||+new Date()-lastDrop<100)){e_stop(e);return;}if(signalDOMEvent(cm,e)||eventInWidget(cm.display,e)){return;}e.dataTransfer.setData("Text",cm.getSelection());e.dataTransfer.effectAllowed="copyMove";// Use dummy image instead of default browsers image.\n// Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don\'t do it there.\nif(e.dataTransfer.setDragImage&&!safari){var img=elt("img",null,null,"position: fixed; left: 0; top: 0;");img.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";if(presto){img.width=img.height=1;cm.display.wrapper.appendChild(img);// Force a relayout, or Opera won\'t use our image for some obscure reason\nimg._top=img.offsetTop;}e.dataTransfer.setDragImage(img,0,0);if(presto){img.parentNode.removeChild(img);}}}function onDragOver(cm,e){var pos=posFromMouse(cm,e);if(!pos){return;}var frag=document.createDocumentFragment();drawSelectionCursor(cm,pos,frag);if(!cm.display.dragCursor){cm.display.dragCursor=elt("div",null,"CodeMirror-cursors CodeMirror-dragcursors");cm.display.lineSpace.insertBefore(cm.display.dragCursor,cm.display.cursorDiv);}removeChildrenAndAdd(cm.display.dragCursor,frag);}function clearDragCursor(cm){if(cm.display.dragCursor){cm.display.lineSpace.removeChild(cm.display.dragCursor);cm.display.dragCursor=null;}}// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\nfunction forEachCodeMirror(f){if(!document.body.getElementsByClassName){return;}var byClass=document.body.getElementsByClassName("CodeMirror");for(var i=0;i<byClass.length;i++){var cm=byClass[i].CodeMirror;if(cm){f(cm);}}}var globalsRegistered=false;function ensureGlobalHandlers(){if(globalsRegistered){return;}registerGlobalHandlers();globalsRegistered=true;}function registerGlobalHandlers(){// When the window resizes, we need to refresh active editors.\nvar resizeTimer;on(window,"resize",function(){if(resizeTimer==null){resizeTimer=setTimeout(function(){resizeTimer=null;forEachCodeMirror(onResize);},100);}});// When the window loses focus, we want to show the editor as blurred\non(window,"blur",function(){return forEachCodeMirror(onBlur);});}// Called when the window resizes\nfunction onResize(cm){var d=cm.display;if(d.lastWrapHeight==d.wrapper.clientHeight&&d.lastWrapWidth==d.wrapper.clientWidth){return;}// Might be a text scaling operation, clear size caches.\nd.cachedCharWidth=d.cachedTextHeight=d.cachedPaddingH=null;d.scrollbarsClipped=false;cm.setSize();}var keyNames={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\\\",221:"]",222:"\'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"};// Number keys\nfor(var i=0;i<10;i++){keyNames[i+48]=keyNames[i+96]=String(i);}// Alphabetic keys\nfor(var i$1=65;i$1<=90;i$1++){keyNames[i$1]=String.fromCharCode(i$1);}// Function keys\nfor(var i$2=1;i$2<=12;i$2++){keyNames[i$2+111]=keyNames[i$2+63235]="F"+i$2;}var keyMap={};keyMap.basic={"Left":"goCharLeft","Right":"goCharRight","Up":"goLineUp","Down":"goLineDown","End":"goLineEnd","Home":"goLineStartSmart","PageUp":"goPageUp","PageDown":"goPageDown","Delete":"delCharAfter","Backspace":"delCharBefore","Shift-Backspace":"delCharBefore","Tab":"defaultTab","Shift-Tab":"indentAuto","Enter":"newlineAndIndent","Insert":"toggleOverwrite","Esc":"singleSelection"};// Note that the save and find-related commands aren\'t defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"};// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"};keyMap.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]};keyMap["default"]=mac?keyMap.macDefault:keyMap.pcDefault;// KEYMAP DISPATCH\nfunction normalizeKeyName(name){var parts=name.split(/-(?!$)/);name=parts[parts.length-1];var alt,ctrl,shift,cmd;for(var i=0;i<parts.length-1;i++){var mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod)){cmd=true;}else if(/^a(lt)?$/i.test(mod)){alt=true;}else if(/^(c|ctrl|control)$/i.test(mod)){ctrl=true;}else if(/^s(hift)?$/i.test(mod)){shift=true;}else{throw new Error("Unrecognized modifier name: "+mod);}}if(alt){name="Alt-"+name;}if(ctrl){name="Ctrl-"+name;}if(cmd){name="Cmd-"+name;}if(shift){name="Shift-"+name;}return name;}// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap){var copy={};for(var keyname in keymap){if(keymap.hasOwnProperty(keyname)){var value=keymap[keyname];if(/^(name|fallthrough|(de|at)tach)$/.test(keyname)){continue;}if(value=="..."){delete keymap[keyname];continue;}var keys=map(keyname.split(" "),normalizeKeyName);for(var i=0;i<keys.length;i++){var val=void 0,name=void 0;if(i==keys.length-1){name=keys.join(" ");val=value;}else{name=keys.slice(0,i+1).join(" ");val="...";}var prev=copy[name];if(!prev){copy[name]=val;}else if(prev!=val){throw new Error("Inconsistent bindings for "+name);}}delete keymap[keyname];}}for(var prop in copy){keymap[prop]=copy[prop];}return keymap;}function lookupKey(key,map,handle,context){map=getKeyMap(map);var found=map.call?map.call(key,context):map[key];if(found===false){return"nothing";}if(found==="..."){return"multi";}if(found!=null&&handle(found)){return"handled";}if(map.fallthrough){if(Object.prototype.toString.call(map.fallthrough)!="[object Array]"){return lookupKey(key,map.fallthrough,handle,context);}for(var i=0;i<map.fallthrough.length;i++){var result=lookupKey(key,map.fallthrough[i],handle,context);if(result){return result;}}}}// Modifier key presses don\'t count as \'real\' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value){var name=typeof value=="string"?value:keyNames[value.keyCode];return name=="Ctrl"||name=="Alt"||name=="Shift"||name=="Mod";}// Look up the name of a key as indicated by an event object.\nfunction keyName(event,noShift){if(presto&&event.keyCode==34&&event["char"]){return false;}var base=keyNames[event.keyCode],name=base;if(name==null||event.altGraphKey){return false;}if(event.altKey&&base!="Alt"){name="Alt-"+name;}if((flipCtrlCmd?event.metaKey:event.ctrlKey)&&base!="Ctrl"){name="Ctrl-"+name;}if((flipCtrlCmd?event.ctrlKey:event.metaKey)&&base!="Cmd"){name="Cmd-"+name;}if(!noShift&&event.shiftKey&&base!="Shift"){name="Shift-"+name;}return name;}function getKeyMap(val){return typeof val=="string"?keyMap[val]:val;}// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm,compute){var ranges=cm.doc.sel.ranges,kill=[];// Build up a set of ranges to kill first, merging overlapping\n// ranges.\nfor(var i=0;i<ranges.length;i++){var toKill=compute(ranges[i]);while(kill.length&&cmp(toKill.from,lst(kill).to)<=0){var replaced=kill.pop();if(cmp(replaced.from,toKill.from)<0){toKill.from=replaced.from;break;}}kill.push(toKill);}// Next, remove those actual ranges.\nrunInOp(cm,function(){for(var i=kill.length-1;i>=0;i--){replaceRange(cm.doc,"",kill[i].from,kill[i].to,"+delete");}ensureCursorVisible(cm);});}// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands={selectAll:selectAll,singleSelection:function(cm){return cm.setSelection(cm.getCursor("anchor"),cm.getCursor("head"),sel_dontScroll);},killLine:function(cm){return deleteNearSelection(cm,function(range){if(range.empty()){var len=getLine(cm.doc,range.head.line).text.length;if(range.head.ch==len&&range.head.line<cm.lastLine()){return{from:range.head,to:Pos(range.head.line+1,0)};}else{return{from:range.head,to:Pos(range.head.line,len)};}}else{return{from:range.from(),to:range.to()};}});},deleteLine:function(cm){return deleteNearSelection(cm,function(range){return{from:Pos(range.from().line,0),to:clipPos(cm.doc,Pos(range.to().line+1,0))};});},delLineLeft:function(cm){return deleteNearSelection(cm,function(range){return{from:Pos(range.from().line,0),to:range.from()};});},delWrappedLineLeft:function(cm){return deleteNearSelection(cm,function(range){var top=cm.charCoords(range.head,"div").top+5;var leftPos=cm.coordsChar({left:0,top:top},"div");return{from:leftPos,to:range.from()};});},delWrappedLineRight:function(cm){return deleteNearSelection(cm,function(range){var top=cm.charCoords(range.head,"div").top+5;var rightPos=cm.coordsChar({left:cm.display.lineDiv.offsetWidth+100,top:top},"div");return{from:range.from(),to:rightPos};});},undo:function(cm){return cm.undo();},redo:function(cm){return cm.redo();},undoSelection:function(cm){return cm.undoSelection();},redoSelection:function(cm){return cm.redoSelection();},goDocStart:function(cm){return cm.extendSelection(Pos(cm.firstLine(),0));},goDocEnd:function(cm){return cm.extendSelection(Pos(cm.lastLine()));},goLineStart:function(cm){return cm.extendSelectionsBy(function(range){return lineStart(cm,range.head.line);},{origin:"+move",bias:1});},goLineStartSmart:function(cm){return cm.extendSelectionsBy(function(range){return lineStartSmart(cm,range.head);},{origin:"+move",bias:1});},goLineEnd:function(cm){return cm.extendSelectionsBy(function(range){return lineEnd(cm,range.head.line);},{origin:"+move",bias:-1});},goLineRight:function(cm){return cm.extendSelectionsBy(function(range){var top=cm.charCoords(range.head,"div").top+5;return cm.coordsChar({left:cm.display.lineDiv.offsetWidth+100,top:top},"div");},sel_move);},goLineLeft:function(cm){return cm.extendSelectionsBy(function(range){var top=cm.charCoords(range.head,"div").top+5;return cm.coordsChar({left:0,top:top},"div");},sel_move);},goLineLeftSmart:function(cm){return cm.extendSelectionsBy(function(range){var top=cm.charCoords(range.head,"div").top+5;var pos=cm.coordsChar({left:0,top:top},"div");if(pos.ch<cm.getLine(pos.line).search(/\\S/)){return lineStartSmart(cm,range.head);}return pos;},sel_move);},goLineUp:function(cm){return cm.moveV(-1,"line");},goLineDown:function(cm){return cm.moveV(1,"line");},goPageUp:function(cm){return cm.moveV(-1,"page");},goPageDown:function(cm){return cm.moveV(1,"page");},goCharLeft:function(cm){return cm.moveH(-1,"char");},goCharRight:function(cm){return cm.moveH(1,"char");},goColumnLeft:function(cm){return cm.moveH(-1,"column");},goColumnRight:function(cm){return cm.moveH(1,"column");},goWordLeft:function(cm){return cm.moveH(-1,"word");},goGroupRight:function(cm){return cm.moveH(1,"group");},goGroupLeft:function(cm){return cm.moveH(-1,"group");},goWordRight:function(cm){return cm.moveH(1,"word");},delCharBefore:function(cm){return cm.deleteH(-1,"char");},delCharAfter:function(cm){return cm.deleteH(1,"char");},delWordBefore:function(cm){return cm.deleteH(-1,"word");},delWordAfter:function(cm){return cm.deleteH(1,"word");},delGroupBefore:function(cm){return cm.deleteH(-1,"group");},delGroupAfter:function(cm){return cm.deleteH(1,"group");},indentAuto:function(cm){return cm.indentSelection("smart");},indentMore:function(cm){return cm.indentSelection("add");},indentLess:function(cm){return cm.indentSelection("subtract");},insertTab:function(cm){return cm.replaceSelection("\\t");},insertSoftTab:function(cm){var spaces=[],ranges=cm.listSelections(),tabSize=cm.options.tabSize;for(var i=0;i<ranges.length;i++){var pos=ranges[i].from();var col=countColumn(cm.getLine(pos.line),pos.ch,tabSize);spaces.push(spaceStr(tabSize-col%tabSize));}cm.replaceSelections(spaces);},defaultTab:function(cm){if(cm.somethingSelected()){cm.indentSelection("add");}else{cm.execCommand("insertTab");}},// Swap the two chars left and right of each selection\'s head.\n// Move cursor behind the two swapped characters afterwards.\n//\n// Doesn\'t consider line feeds a character.\n// Doesn\'t scan more than one line above to find a character.\n// Doesn\'t do anything on an empty line.\n// Doesn\'t do anything with non-empty selections.\ntransposeChars:function(cm){return runInOp(cm,function(){var ranges=cm.listSelections(),newSel=[];for(var i=0;i<ranges.length;i++){if(!ranges[i].empty()){continue;}var cur=ranges[i].head,line=getLine(cm.doc,cur.line).text;if(line){if(cur.ch==line.length){cur=new Pos(cur.line,cur.ch-1);}if(cur.ch>0){cur=new Pos(cur.line,cur.ch+1);cm.replaceRange(line.charAt(cur.ch-1)+line.charAt(cur.ch-2),Pos(cur.line,cur.ch-2),cur,"+transpose");}else if(cur.line>cm.doc.first){var prev=getLine(cm.doc,cur.line-1).text;if(prev){cur=new Pos(cur.line,1);cm.replaceRange(line.charAt(0)+cm.doc.lineSeparator()+prev.charAt(prev.length-1),Pos(cur.line-1,prev.length-1),cur,"+transpose");}}}newSel.push(new Range(cur,cur));}cm.setSelections(newSel);});},newlineAndIndent:function(cm){return runInOp(cm,function(){var sels=cm.listSelections();for(var i=sels.length-1;i>=0;i--){cm.replaceRange(cm.doc.lineSeparator(),sels[i].anchor,sels[i].head,"+input");}sels=cm.listSelections();for(var i$1=0;i$1<sels.length;i$1++){cm.indentLine(sels[i$1].from().line,null,true);}ensureCursorVisible(cm);});},openLine:function(cm){return cm.replaceSelection("\\n","start");},toggleOverwrite:function(cm){return cm.toggleOverwrite();}};function lineStart(cm,lineN){var line=getLine(cm.doc,lineN);var visual=visualLine(line);if(visual!=line){lineN=lineNo(visual);}var order=getOrder(visual);var ch=!order?0:order[0].level%2?lineRight(visual):lineLeft(visual);return Pos(lineN,ch);}function lineEnd(cm,lineN){var merged,line=getLine(cm.doc,lineN);while(merged=collapsedSpanAtEnd(line)){line=merged.find(1,true).line;lineN=null;}var order=getOrder(line);var ch=!order?line.text.length:order[0].level%2?lineLeft(line):lineRight(line);return Pos(lineN==null?lineNo(line):lineN,ch);}function lineStartSmart(cm,pos){var start=lineStart(cm,pos.line);var line=getLine(cm.doc,start.line);var order=getOrder(line);if(!order||order[0].level==0){var firstNonWS=Math.max(0,line.text.search(/\\S/));var inWS=pos.line==start.line&&pos.ch<=firstNonWS&&pos.ch;return Pos(start.line,inWS?0:firstNonWS);}return start;}// Run a handler that was bound to a key.\nfunction doHandleBinding(cm,bound,dropShift){if(typeof bound=="string"){bound=commands[bound];if(!bound){return false;}}// Ensure previous input has been read, so that the handler sees a\n// consistent view of the document\ncm.display.input.ensurePolled();var prevShift=cm.display.shift,done=false;try{if(cm.isReadOnly()){cm.state.suppressEdits=true;}if(dropShift){cm.display.shift=false;}done=bound(cm)!=Pass;}finally{cm.display.shift=prevShift;cm.state.suppressEdits=false;}return done;}function lookupKeyForEditor(cm,name,handle){for(var i=0;i<cm.state.keyMaps.length;i++){var result=lookupKey(name,cm.state.keyMaps[i],handle,cm);if(result){return result;}}return cm.options.extraKeys&&lookupKey(name,cm.options.extraKeys,handle,cm)||lookupKey(name,cm.options.keyMap,handle,cm);}var stopSeq=new Delayed();function dispatchKey(cm,name,e,handle){var seq=cm.state.keySeq;if(seq){if(isModifierKey(name)){return"handled";}stopSeq.set(50,function(){if(cm.state.keySeq==seq){cm.state.keySeq=null;cm.display.input.reset();}});name=seq+" "+name;}var result=lookupKeyForEditor(cm,name,handle);if(result=="multi"){cm.state.keySeq=name;}if(result=="handled"){signalLater(cm,"keyHandled",cm,name,e);}if(result=="handled"||result=="multi"){e_preventDefault(e);restartBlink(cm);}if(seq&&!result&&/\\\'$/.test(name)){e_preventDefault(e);return true;}return!!result;}// Handle a key from the keydown event.\nfunction handleKeyBinding(cm,e){var name=keyName(e,true);if(!name){return false;}if(e.shiftKey&&!cm.state.keySeq){// First try to resolve full name (including \'Shift-\'). Failing\n// that, see if there is a cursor-motion command (starting with\n// \'go\') bound to the keyname without \'Shift-\'.\nreturn dispatchKey(cm,"Shift-"+name,e,function(b){return doHandleBinding(cm,b,true);})||dispatchKey(cm,name,e,function(b){if(typeof b=="string"?/^go[A-Z]/.test(b):b.motion){return doHandleBinding(cm,b);}});}else{return dispatchKey(cm,name,e,function(b){return doHandleBinding(cm,b);});}}// Handle a key from the keypress event\nfunction handleCharBinding(cm,e,ch){return dispatchKey(cm,"\'"+ch+"\'",e,function(b){return doHandleBinding(cm,b,true);});}var lastStoppedKey=null;function onKeyDown(e){var cm=this;cm.curOp.focus=activeElt();if(signalDOMEvent(cm,e)){return;}// IE does strange things with escape.\nif(ie&&ie_version<11&&e.keyCode==27){e.returnValue=false;}var code=e.keyCode;cm.display.shift=code==16||e.shiftKey;var handled=handleKeyBinding(cm,e);if(presto){lastStoppedKey=handled?code:null;// Opera has no cut event... we try to at least catch the key combo\nif(!handled&&code==88&&!hasCopyEvent&&(mac?e.metaKey:e.ctrlKey)){cm.replaceSelection("",null,"cut");}}// Turn mouse into crosshair when Alt is held on Mac.\nif(code==18&&!/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)){showCrossHair(cm);}}function showCrossHair(cm){var lineDiv=cm.display.lineDiv;addClass(lineDiv,"CodeMirror-crosshair");function up(e){if(e.keyCode==18||!e.altKey){rmClass(lineDiv,"CodeMirror-crosshair");off(document,"keyup",up);off(document,"mouseover",up);}}on(document,"keyup",up);on(document,"mouseover",up);}function onKeyUp(e){if(e.keyCode==16){this.doc.sel.shift=false;}signalDOMEvent(this,e);}function onKeyPress(e){var cm=this;if(eventInWidget(cm.display,e)||signalDOMEvent(cm,e)||e.ctrlKey&&!e.altKey||mac&&e.metaKey){return;}var keyCode=e.keyCode,charCode=e.charCode;if(presto&&keyCode==lastStoppedKey){lastStoppedKey=null;e_preventDefault(e);return;}if(presto&&(!e.which||e.which<10)&&handleKeyBinding(cm,e)){return;}var ch=String.fromCharCode(charCode==null?keyCode:charCode);// Some browsers fire keypress events for backspace\nif(ch=="\\x08"){return;}if(handleCharBinding(cm,e,ch)){return;}cm.display.input.onKeyPress(e);}// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e){var cm=this,display=cm.display;if(signalDOMEvent(cm,e)||display.activeTouch&&display.input.supportsTouch()){return;}display.shift=e.shiftKey;if(eventInWidget(display,e)){if(!webkit){// Briefly turn off draggability, to allow widgets to do\n// normal dragging things.\ndisplay.scroller.draggable=false;setTimeout(function(){return display.scroller.draggable=true;},100);}return;}if(clickInGutter(cm,e)){return;}var start=posFromMouse(cm,e);window.focus();switch(e_button(e)){case 1:// #3261: make sure, that we\'re not starting a second selection\nif(cm.state.selectingText){cm.state.selectingText(e);}else if(start){leftButtonDown(cm,e,start);}else if(e_target(e)==display.scroller){e_preventDefault(e);}break;case 2:if(webkit){cm.state.lastMiddleDown=+new Date();}if(start){extendSelection(cm.doc,start);}setTimeout(function(){return display.input.focus();},20);e_preventDefault(e);break;case 3:if(captureRightClick){onContextMenu(cm,e);}else{delayBlurEvent(cm);}break;}}var lastClick;var lastDoubleClick;function leftButtonDown(cm,e,start){if(ie){setTimeout(bind(ensureFocus,cm),0);}else{cm.curOp.focus=activeElt();}var now=+new Date(),type;if(lastDoubleClick&&lastDoubleClick.time>now-400&&cmp(lastDoubleClick.pos,start)==0){type="triple";}else if(lastClick&&lastClick.time>now-400&&cmp(lastClick.pos,start)==0){type="double";lastDoubleClick={time:now,pos:start};}else{type="single";lastClick={time:now,pos:start};}var sel=cm.doc.sel,modifier=mac?e.metaKey:e.ctrlKey,contained;if(cm.options.dragDrop&&dragAndDrop&&!cm.isReadOnly()&&type=="single"&&(contained=sel.contains(start))>-1&&(cmp((contained=sel.ranges[contained]).from(),start)<0||start.xRel>0)&&(cmp(contained.to(),start)>0||start.xRel<0)){leftButtonStartDrag(cm,e,start,modifier);}else{leftButtonSelect(cm,e,start,type,modifier);}}// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn\'t.\nfunction leftButtonStartDrag(cm,e,start,modifier){var display=cm.display,startTime=+new Date();var dragEnd=operation(cm,function(e2){if(webkit){display.scroller.draggable=false;}cm.state.draggingText=false;off(document,"mouseup",dragEnd);off(display.scroller,"drop",dragEnd);if(Math.abs(e.clientX-e2.clientX)+Math.abs(e.clientY-e2.clientY)<10){e_preventDefault(e2);if(!modifier&&+new Date()-200<startTime){extendSelection(cm.doc,start);}// Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\nif(webkit||ie&&ie_version==9){setTimeout(function(){document.body.focus();display.input.focus();},20);}else{display.input.focus();}}});// Let the drag handler handle this.\nif(webkit){display.scroller.draggable=true;}cm.state.draggingText=dragEnd;dragEnd.copy=mac?e.altKey:e.ctrlKey;// IE\'s approach to draggable\nif(display.scroller.dragDrop){display.scroller.dragDrop();}on(document,"mouseup",dragEnd);on(display.scroller,"drop",dragEnd);}// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm,e,start,type,addNew){var display=cm.display,doc=cm.doc;e_preventDefault(e);var ourRange,ourIndex,startSel=doc.sel,ranges=startSel.ranges;if(addNew&&!e.shiftKey){ourIndex=doc.sel.contains(start);if(ourIndex>-1){ourRange=ranges[ourIndex];}else{ourRange=new Range(start,start);}}else{ourRange=doc.sel.primary();ourIndex=doc.sel.primIndex;}if(chromeOS?e.shiftKey&&e.metaKey:e.altKey){type="rect";if(!addNew){ourRange=new Range(start,start);}start=posFromMouse(cm,e,true,true);ourIndex=-1;}else if(type=="double"){var word=cm.findWordAt(start);if(cm.display.shift||doc.extend){ourRange=extendRange(doc,ourRange,word.anchor,word.head);}else{ourRange=word;}}else if(type=="triple"){var line=new Range(Pos(start.line,0),clipPos(doc,Pos(start.line+1,0)));if(cm.display.shift||doc.extend){ourRange=extendRange(doc,ourRange,line.anchor,line.head);}else{ourRange=line;}}else{ourRange=extendRange(doc,ourRange,start);}if(!addNew){ourIndex=0;setSelection(doc,new Selection([ourRange],0),sel_mouse);startSel=doc.sel;}else if(ourIndex==-1){ourIndex=ranges.length;setSelection(doc,normalizeSelection(ranges.concat([ourRange]),ourIndex),{scroll:false,origin:"*mouse"});}else if(ranges.length>1&&ranges[ourIndex].empty()&&type=="single"&&!e.shiftKey){setSelection(doc,normalizeSelection(ranges.slice(0,ourIndex).concat(ranges.slice(ourIndex+1)),0),{scroll:false,origin:"*mouse"});startSel=doc.sel;}else{replaceOneSelection(doc,ourIndex,ourRange,sel_mouse);}var lastPos=start;function extendTo(pos){if(cmp(lastPos,pos)==0){return;}lastPos=pos;if(type=="rect"){var ranges=[],tabSize=cm.options.tabSize;var startCol=countColumn(getLine(doc,start.line).text,start.ch,tabSize);var posCol=countColumn(getLine(doc,pos.line).text,pos.ch,tabSize);var left=Math.min(startCol,posCol),right=Math.max(startCol,posCol);for(var line=Math.min(start.line,pos.line),end=Math.min(cm.lastLine(),Math.max(start.line,pos.line));line<=end;line++){var text=getLine(doc,line).text,leftPos=findColumn(text,left,tabSize);if(left==right){ranges.push(new Range(Pos(line,leftPos),Pos(line,leftPos)));}else if(text.length>leftPos){ranges.push(new Range(Pos(line,leftPos),Pos(line,findColumn(text,right,tabSize))));}}if(!ranges.length){ranges.push(new Range(start,start));}setSelection(doc,normalizeSelection(startSel.ranges.slice(0,ourIndex).concat(ranges),ourIndex),{origin:"*mouse",scroll:false});cm.scrollIntoView(pos);}else{var oldRange=ourRange;var anchor=oldRange.anchor,head=pos;if(type!="single"){var range;if(type=="double"){range=cm.findWordAt(pos);}else{range=new Range(Pos(pos.line,0),clipPos(doc,Pos(pos.line+1,0)));}if(cmp(range.anchor,anchor)>0){head=range.head;anchor=minPos(oldRange.from(),range.anchor);}else{head=range.anchor;anchor=maxPos(oldRange.to(),range.head);}}var ranges$1=startSel.ranges.slice(0);ranges$1[ourIndex]=new Range(clipPos(doc,anchor),head);setSelection(doc,normalizeSelection(ranges$1,ourIndex),sel_mouse);}}var editorSize=display.wrapper.getBoundingClientRect();// Used to ensure timeout re-tries don\'t fire when another extend\n// happened in the meantime (clearTimeout isn\'t reliable -- at\n// least on Chrome, the timeouts still happen even when cleared,\n// if the clear happens after their scheduled firing time).\nvar counter=0;function extend(e){var curCount=++counter;var cur=posFromMouse(cm,e,true,type=="rect");if(!cur){return;}if(cmp(cur,lastPos)!=0){cm.curOp.focus=activeElt();extendTo(cur);var visible=visibleLines(display,doc);if(cur.line>=visible.to||cur.line<visible.from){setTimeout(operation(cm,function(){if(counter==curCount){extend(e);}}),150);}}else{var outside=e.clientY<editorSize.top?-20:e.clientY>editorSize.bottom?20:0;if(outside){setTimeout(operation(cm,function(){if(counter!=curCount){return;}display.scroller.scrollTop+=outside;extend(e);}),50);}}}function done(e){cm.state.selectingText=false;counter=Infinity;e_preventDefault(e);display.input.focus();off(document,"mousemove",move);off(document,"mouseup",up);doc.history.lastSelOrigin=null;}var move=operation(cm,function(e){if(!e_button(e)){done(e);}else{extend(e);}});var up=operation(cm,done);cm.state.selectingText=up;on(document,"mousemove",move);on(document,"mouseup",up);}// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm,e,type,prevent){var mX,mY;try{mX=e.clientX;mY=e.clientY;}catch(e){return false;}if(mX>=Math.floor(cm.display.gutters.getBoundingClientRect().right)){return false;}if(prevent){e_preventDefault(e);}var display=cm.display;var lineBox=display.lineDiv.getBoundingClientRect();if(mY>lineBox.bottom||!hasHandler(cm,type)){return e_defaultPrevented(e);}mY-=lineBox.top-display.viewOffset;for(var i=0;i<cm.options.gutters.length;++i){var g=display.gutters.childNodes[i];if(g&&g.getBoundingClientRect().right>=mX){var line=lineAtHeight(cm.doc,mY);var gutter=cm.options.gutters[i];signal(cm,type,cm,line,gutter,e);return e_defaultPrevented(e);}}}function clickInGutter(cm,e){return gutterEvent(cm,e,"gutterClick",true);}// CONTEXT MENU HANDLING\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm,e){if(eventInWidget(cm.display,e)||contextMenuInGutter(cm,e)){return;}if(signalDOMEvent(cm,e,"contextmenu")){return;}cm.display.input.onContextMenu(e);}function contextMenuInGutter(cm,e){if(!hasHandler(cm,"gutterContextMenu")){return false;}return gutterEvent(cm,e,"gutterContextMenu",false);}function themeChanged(cm){cm.display.wrapper.className=cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g,"")+cm.options.theme.replace(/(^|\\s)\\s*/g," cm-s-");clearCaches(cm);}var Init={toString:function(){return"CodeMirror.Init";}};var defaults={};var optionHandlers={};function defineOptions(CodeMirror){var optionHandlers=CodeMirror.optionHandlers;function option(name,deflt,handle,notOnInit){CodeMirror.defaults[name]=deflt;if(handle){optionHandlers[name]=notOnInit?function(cm,val,old){if(old!=Init){handle(cm,val,old);}}:handle;}}CodeMirror.defineOption=option;// Passed to option handlers when there is no old value.\nCodeMirror.Init=Init;// These two are, on init, called from the constructor because they\n// have to be initialized before the editor can start at all.\noption("value","",function(cm,val){return cm.setValue(val);},true);option("mode",null,function(cm,val){cm.doc.modeOption=val;loadMode(cm);},true);option("indentUnit",2,loadMode,true);option("indentWithTabs",false);option("smartIndent",true);option("tabSize",4,function(cm){resetModeState(cm);clearCaches(cm);regChange(cm);},true);option("lineSeparator",null,function(cm,val){cm.doc.lineSep=val;if(!val){return;}var newBreaks=[],lineNo=cm.doc.first;cm.doc.iter(function(line){for(var pos=0;;){var found=line.text.indexOf(val,pos);if(found==-1){break;}pos=found+val.length;newBreaks.push(Pos(lineNo,found));}lineNo++;});for(var i=newBreaks.length-1;i>=0;i--){replaceRange(cm.doc,val,newBreaks[i],Pos(newBreaks[i].line,newBreaks[i].ch+val.length));}});option("specialChars",/[\\u0000-\\u001f\\u007f\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g,function(cm,val,old){cm.state.specialChars=new RegExp(val.source+(val.test("\\t")?"":"|\\t"),"g");if(old!=Init){cm.refresh();}});option("specialCharPlaceholder",defaultSpecialCharPlaceholder,function(cm){return cm.refresh();},true);option("electricChars",true);option("inputStyle",mobile?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor");// FIXME\n},true);option("spellcheck",false,function(cm,val){return cm.getInputField().spellcheck=val;},true);option("rtlMoveVisually",!windows);option("wholeLineUpdateBefore",true);option("theme","default",function(cm){themeChanged(cm);guttersChanged(cm);},true);option("keyMap","default",function(cm,val,old){var next=getKeyMap(val);var prev=old!=Init&&getKeyMap(old);if(prev&&prev.detach){prev.detach(cm,next);}if(next.attach){next.attach(cm,prev||null);}});option("extraKeys",null);option("lineWrapping",false,wrappingChanged,true);option("gutters",[],function(cm){setGuttersForLineNumbers(cm.options);guttersChanged(cm);},true);option("fixedGutter",true,function(cm,val){cm.display.gutters.style.left=val?compensateForHScroll(cm.display)+"px":"0";cm.refresh();},true);option("coverGutterNextToScrollbar",false,function(cm){return updateScrollbars(cm);},true);option("scrollbarStyle","native",function(cm){initScrollbars(cm);updateScrollbars(cm);cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);},true);option("lineNumbers",false,function(cm){setGuttersForLineNumbers(cm.options);guttersChanged(cm);},true);option("firstLineNumber",1,guttersChanged,true);option("lineNumberFormatter",function(integer){return integer;},guttersChanged,true);option("showCursorWhenSelecting",false,updateSelection,true);option("resetSelectionOnContextMenu",true);option("lineWiseCopyCut",true);option("readOnly",false,function(cm,val){if(val=="nocursor"){onBlur(cm);cm.display.input.blur();cm.display.disabled=true;}else{cm.display.disabled=false;}cm.display.input.readOnlyChanged(val);});option("disableInput",false,function(cm,val){if(!val){cm.display.input.reset();}},true);option("dragDrop",true,dragDropChanged);option("allowDropFileTypes",null);option("cursorBlinkRate",530);option("cursorScrollMargin",0);option("cursorHeight",1,updateSelection,true);option("singleCursorHeightPerLine",true,updateSelection,true);option("workTime",100);option("workDelay",100);option("flattenSpans",true,resetModeState,true);option("addModeClass",false,resetModeState,true);option("pollInterval",100);option("undoDepth",200,function(cm,val){return cm.doc.history.undoDepth=val;});option("historyEventDelay",1250);option("viewportMargin",10,function(cm){return cm.refresh();},true);option("maxHighlightLength",10000,resetModeState,true);option("moveInputWithCursor",true,function(cm,val){if(!val){cm.display.input.resetPosition();}});option("tabindex",null,function(cm,val){return cm.display.input.getField().tabIndex=val||"";});option("autofocus",null);}function guttersChanged(cm){updateGutters(cm);regChange(cm);setTimeout(function(){return alignHorizontally(cm);},20);}function dragDropChanged(cm,value,old){var wasOn=old&&old!=Init;if(!value!=!wasOn){var funcs=cm.display.dragFunctions;var toggle=value?on:off;toggle(cm.display.scroller,"dragstart",funcs.start);toggle(cm.display.scroller,"dragenter",funcs.enter);toggle(cm.display.scroller,"dragover",funcs.over);toggle(cm.display.scroller,"dragleave",funcs.leave);toggle(cm.display.scroller,"drop",funcs.drop);}}function wrappingChanged(cm){if(cm.options.lineWrapping){addClass(cm.display.wrapper,"CodeMirror-wrap");cm.display.sizer.style.minWidth="";cm.display.sizerWidth=null;}else{rmClass(cm.display.wrapper,"CodeMirror-wrap");findMaxLine(cm);}estimateLineHeights(cm);regChange(cm);clearCaches(cm);setTimeout(function(){return updateScrollbars(cm);},100);}// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\nfunction CodeMirror(place,options){var this$1=this;if(!(this instanceof CodeMirror)){return new CodeMirror(place,options);}this.options=options=options?copyObj(options):{};// Determine effective options based on given values and defaults.\ncopyObj(defaults,options,false);setGuttersForLineNumbers(options);var doc=options.value;if(typeof doc=="string"){doc=new Doc(doc,options.mode,null,options.lineSeparator);}this.doc=doc;var input=new CodeMirror.inputStyles[options.inputStyle](this);var display=this.display=new Display(place,doc,input);display.wrapper.CodeMirror=this;updateGutters(this);themeChanged(this);if(options.lineWrapping){this.display.wrapper.className+=" CodeMirror-wrap";}if(options.autofocus&&!mobile){display.input.focus();}initScrollbars(this);this.state={keyMaps:[],// stores maps added by addKeyMap\noverlays:[],// highlighting overlays, as added by addOverlay\nmodeGen:0,// bumped when mode/overlay changes, used to invalidate highlighting info\noverwrite:false,delayingBlurEvent:false,focused:false,suppressEdits:false,// used to disable editing during key handlers when in readOnly mode\npasteIncoming:false,cutIncoming:false,// help recognize paste/cut edits in input.poll\nselectingText:false,draggingText:false,highlight:new Delayed(),// stores highlight worker timeout\nkeySeq:null,// Unfinished key sequence\nspecialChars:null};// Override magic textarea content restore that IE sometimes does\n// on our hidden textarea on reload\nif(ie&&ie_version<11){setTimeout(function(){return this$1.display.input.reset(true);},20);}registerEventHandlers(this);ensureGlobalHandlers();startOperation(this);this.curOp.forceUpdate=true;attachDoc(this,doc);if(options.autofocus&&!mobile||this.hasFocus()){setTimeout(bind(onFocus,this),20);}else{onBlur(this);}for(var opt in optionHandlers){if(optionHandlers.hasOwnProperty(opt)){optionHandlers[opt](this$1,options[opt],Init);}}maybeUpdateLineNumberWidth(this);if(options.finishInit){options.finishInit(this);}for(var i=0;i<initHooks.length;++i){initHooks[i](this$1);}endOperation(this);// Suppress optimizelegibility in Webkit, since it breaks text\n// measuring on line wrapping boundaries.\nif(webkit&&options.lineWrapping&&getComputedStyle(display.lineDiv).textRendering=="optimizelegibility"){display.lineDiv.style.textRendering="auto";}}// The default configuration options.\nCodeMirror.defaults=defaults;// Functions to run when options are changed.\nCodeMirror.optionHandlers=optionHandlers;// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm){var d=cm.display;on(d.scroller,"mousedown",operation(cm,onMouseDown));// Older IE\'s will not fire a second mousedown for a double click\nif(ie&&ie_version<11){on(d.scroller,"dblclick",operation(cm,function(e){if(signalDOMEvent(cm,e)){return;}var pos=posFromMouse(cm,e);if(!pos||clickInGutter(cm,e)||eventInWidget(cm.display,e)){return;}e_preventDefault(e);var word=cm.findWordAt(pos);extendSelection(cm.doc,word.anchor,word.head);}));}else{on(d.scroller,"dblclick",function(e){return signalDOMEvent(cm,e)||e_preventDefault(e);});}// Some browsers fire contextmenu *after* opening the menu, at\n// which point we can\'t mess with it anymore. Context menu is\n// handled in onMouseDown for these browsers.\nif(!captureRightClick){on(d.scroller,"contextmenu",function(e){return onContextMenu(cm,e);});}// Used to suppress mouse event handling when a touch happens\nvar touchFinished,prevTouch={end:0};function finishTouch(){if(d.activeTouch){touchFinished=setTimeout(function(){return d.activeTouch=null;},1000);prevTouch=d.activeTouch;prevTouch.end=+new Date();}}function isMouseLikeTouchEvent(e){if(e.touches.length!=1){return false;}var touch=e.touches[0];return touch.radiusX<=1&&touch.radiusY<=1;}function farAway(touch,other){if(other.left==null){return true;}var dx=other.left-touch.left,dy=other.top-touch.top;return dx*dx+dy*dy>20*20;}on(d.scroller,"touchstart",function(e){if(!signalDOMEvent(cm,e)&&!isMouseLikeTouchEvent(e)){clearTimeout(touchFinished);var now=+new Date();d.activeTouch={start:now,moved:false,prev:now-prevTouch.end<=300?prevTouch:null};if(e.touches.length==1){d.activeTouch.left=e.touches[0].pageX;d.activeTouch.top=e.touches[0].pageY;}}});on(d.scroller,"touchmove",function(){if(d.activeTouch){d.activeTouch.moved=true;}});on(d.scroller,"touchend",function(e){var touch=d.activeTouch;if(touch&&!eventInWidget(d,e)&&touch.left!=null&&!touch.moved&&new Date()-touch.start<300){var pos=cm.coordsChar(d.activeTouch,"page"),range;if(!touch.prev||farAway(touch,touch.prev))// Single tap\n{range=new Range(pos,pos);}else if(!touch.prev.prev||farAway(touch,touch.prev.prev))// Double tap\n{range=cm.findWordAt(pos);}else// Triple tap\n{range=new Range(Pos(pos.line,0),clipPos(cm.doc,Pos(pos.line+1,0)));}cm.setSelection(range.anchor,range.head);cm.focus();e_preventDefault(e);}finishTouch();});on(d.scroller,"touchcancel",finishTouch);// Sync scrolling between fake scrollbars and real scrollable\n// area, ensure viewport is updated when scrolling.\non(d.scroller,"scroll",function(){if(d.scroller.clientHeight){setScrollTop(cm,d.scroller.scrollTop);setScrollLeft(cm,d.scroller.scrollLeft,true);signal(cm,"scroll",cm);}});// Listen to wheel events in order to try and update the viewport on time.\non(d.scroller,"mousewheel",function(e){return onScrollWheel(cm,e);});on(d.scroller,"DOMMouseScroll",function(e){return onScrollWheel(cm,e);});// Prevent wrapper from ever scrolling\non(d.wrapper,"scroll",function(){return d.wrapper.scrollTop=d.wrapper.scrollLeft=0;});d.dragFunctions={enter:function(e){if(!signalDOMEvent(cm,e)){e_stop(e);}},over:function(e){if(!signalDOMEvent(cm,e)){onDragOver(cm,e);e_stop(e);}},start:function(e){return onDragStart(cm,e);},drop:operation(cm,onDrop),leave:function(e){if(!signalDOMEvent(cm,e)){clearDragCursor(cm);}}};var inp=d.input.getField();on(inp,"keyup",function(e){return onKeyUp.call(cm,e);});on(inp,"keydown",operation(cm,onKeyDown));on(inp,"keypress",operation(cm,onKeyPress));on(inp,"focus",function(e){return onFocus(cm,e);});on(inp,"blur",function(e){return onBlur(cm,e);});}var initHooks=[];CodeMirror.defineInitHook=function(f){return initHooks.push(f);};// Indent the given line. The how parameter can be "smart",\n// "add"/null, "subtract", or "prev". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm,n,how,aggressive){var doc=cm.doc,state;if(how==null){how="add";}if(how=="smart"){// Fall back to "prev" when the mode doesn\'t have an indentation\n// method.\nif(!doc.mode.indent){how="prev";}else{state=getStateBefore(cm,n);}}var tabSize=cm.options.tabSize;var line=getLine(doc,n),curSpace=countColumn(line.text,null,tabSize);if(line.stateAfter){line.stateAfter=null;}var curSpaceString=line.text.match(/^\\s*/)[0],indentation;if(!aggressive&&!/\\S/.test(line.text)){indentation=0;how="not";}else if(how=="smart"){indentation=doc.mode.indent(state,line.text.slice(curSpaceString.length),line.text);if(indentation==Pass||indentation>150){if(!aggressive){return;}how="prev";}}if(how=="prev"){if(n>doc.first){indentation=countColumn(getLine(doc,n-1).text,null,tabSize);}else{indentation=0;}}else if(how=="add"){indentation=curSpace+cm.options.indentUnit;}else if(how=="subtract"){indentation=curSpace-cm.options.indentUnit;}else if(typeof how=="number"){indentation=curSpace+how;}indentation=Math.max(0,indentation);var indentString="",pos=0;if(cm.options.indentWithTabs){for(var i=Math.floor(indentation/tabSize);i;--i){pos+=tabSize;indentString+="\\t";}}if(pos<indentation){indentString+=spaceStr(indentation-pos);}if(indentString!=curSpaceString){replaceRange(doc,indentString,Pos(n,0),Pos(n,curSpaceString.length),"+input");line.stateAfter=null;return true;}else{// Ensure that, if the cursor was in the whitespace at the start\n// of the line, it is moved to the end of that space.\nfor(var i$1=0;i$1<doc.sel.ranges.length;i$1++){var range=doc.sel.ranges[i$1];if(range.head.line==n&&range.head.ch<curSpaceString.length){var pos$1=Pos(n,curSpaceString.length);replaceOneSelection(doc,i$1,new Range(pos$1,pos$1));break;}}}}// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied=null;function setLastCopied(newLastCopied){lastCopied=newLastCopied;}function applyTextInput(cm,inserted,deleted,sel,origin){var doc=cm.doc;cm.display.shift=false;if(!sel){sel=doc.sel;}var paste=cm.state.pasteIncoming||origin=="paste";var textLines=splitLinesAuto(inserted),multiPaste=null;// When pasing N lines into N selections, insert one line per selection\nif(paste&&sel.ranges.length>1){if(lastCopied&&lastCopied.text.join("\\n")==inserted){if(sel.ranges.length%lastCopied.text.length==0){multiPaste=[];for(var i=0;i<lastCopied.text.length;i++){multiPaste.push(doc.splitLines(lastCopied.text[i]));}}}else if(textLines.length==sel.ranges.length){multiPaste=map(textLines,function(l){return[l];});}}var updateInput;// Normal behavior is to insert the new text into every selection\nfor(var i$1=sel.ranges.length-1;i$1>=0;i$1--){var range=sel.ranges[i$1];var from=range.from(),to=range.to();if(range.empty()){if(deleted&&deleted>0)// Handle deletion\n{from=Pos(from.line,from.ch-deleted);}else if(cm.state.overwrite&&!paste)// Handle overwrite\n{to=Pos(to.line,Math.min(getLine(doc,to.line).text.length,to.ch+lst(textLines).length));}else if(lastCopied&&lastCopied.lineWise&&lastCopied.text.join("\\n")==inserted){from=to=Pos(from.line,0);}}updateInput=cm.curOp.updateInput;var changeEvent={from:from,to:to,text:multiPaste?multiPaste[i$1%multiPaste.length]:textLines,origin:origin||(paste?"paste":cm.state.cutIncoming?"cut":"+input")};makeChange(cm.doc,changeEvent);signalLater(cm,"inputRead",cm,changeEvent);}if(inserted&&!paste){triggerElectric(cm,inserted);}ensureCursorVisible(cm);cm.curOp.updateInput=updateInput;cm.curOp.typing=true;cm.state.pasteIncoming=cm.state.cutIncoming=false;}function handlePaste(e,cm){var pasted=e.clipboardData&&e.clipboardData.getData("Text");if(pasted){e.preventDefault();if(!cm.isReadOnly()&&!cm.options.disableInput){runInOp(cm,function(){return applyTextInput(cm,pasted,0,null,"paste");});}return true;}}function triggerElectric(cm,inserted){// When an \'electric\' character is inserted, immediately trigger a reindent\nif(!cm.options.electricChars||!cm.options.smartIndent){return;}var sel=cm.doc.sel;for(var i=sel.ranges.length-1;i>=0;i--){var range=sel.ranges[i];if(range.head.ch>100||i&&sel.ranges[i-1].head.line==range.head.line){continue;}var mode=cm.getModeAt(range.head);var indented=false;if(mode.electricChars){for(var j=0;j<mode.electricChars.length;j++){if(inserted.indexOf(mode.electricChars.charAt(j))>-1){indented=indentLine(cm,range.head.line,"smart");break;}}}else if(mode.electricInput){if(mode.electricInput.test(getLine(cm.doc,range.head.line).text.slice(0,range.head.ch))){indented=indentLine(cm,range.head.line,"smart");}}if(indented){signalLater(cm,"electricInput",cm,range.head.line);}}}function copyableRanges(cm){var text=[],ranges=[];for(var i=0;i<cm.doc.sel.ranges.length;i++){var line=cm.doc.sel.ranges[i].head.line;var lineRange={anchor:Pos(line,0),head:Pos(line+1,0)};ranges.push(lineRange);text.push(cm.getRange(lineRange.anchor,lineRange.head));}return{text:text,ranges:ranges};}function disableBrowserMagic(field,spellcheck){field.setAttribute("autocorrect","off");field.setAttribute("autocapitalize","off");field.setAttribute("spellcheck",!!spellcheck);}function hiddenTextarea(){var te=elt("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");var div=elt("div",[te],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");// The textarea is kept positioned near the cursor to prevent the\n// fact that it\'ll be scrolled into view on input from scrolling\n// our fake cursor out of view. On webkit, when wrap=off, paste is\n// very slow. So make the area wide instead.\nif(webkit){te.style.width="1000px";}else{te.setAttribute("wrap","off");}// If border: 0; -- iOS fails to open keyboard (issue #1287)\nif(ios){te.style.border="1px solid black";}disableBrowserMagic(te);return div;}// The publicly visible API. Note that methodOp(f) means\n// \'wrap f in an operation, performed on its `this` parameter\'.\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\nfunction addEditorMethods(CodeMirror){var optionHandlers=CodeMirror.optionHandlers;var helpers=CodeMirror.helpers={};CodeMirror.prototype={constructor:CodeMirror,focus:function(){window.focus();this.display.input.focus();},setOption:function(option,value){var options=this.options,old=options[option];if(options[option]==value&&option!="mode"){return;}options[option]=value;if(optionHandlers.hasOwnProperty(option)){operation(this,optionHandlers[option])(this,value,old);}},getOption:function(option){return this.options[option];},getDoc:function(){return this.doc;},addKeyMap:function(map,bottom){this.state.keyMaps[bottom?"push":"unshift"](getKeyMap(map));},removeKeyMap:function(map){var maps=this.state.keyMaps;for(var i=0;i<maps.length;++i){if(maps[i]==map||maps[i].name==map){maps.splice(i,1);return true;}}},addOverlay:methodOp(function(spec,options){var mode=spec.token?spec:CodeMirror.getMode(this.options,spec);if(mode.startState){throw new Error("Overlays may not be stateful.");}insertSorted(this.state.overlays,{mode:mode,modeSpec:spec,opaque:options&&options.opaque,priority:options&&options.priority||0},function(overlay){return overlay.priority;});this.state.modeGen++;regChange(this);}),removeOverlay:methodOp(function(spec){var this$1=this;var overlays=this.state.overlays;for(var i=0;i<overlays.length;++i){var cur=overlays[i].modeSpec;if(cur==spec||typeof spec=="string"&&cur.name==spec){overlays.splice(i,1);this$1.state.modeGen++;regChange(this$1);return;}}}),indentLine:methodOp(function(n,dir,aggressive){if(typeof dir!="string"&&typeof dir!="number"){if(dir==null){dir=this.options.smartIndent?"smart":"prev";}else{dir=dir?"add":"subtract";}}if(isLine(this.doc,n)){indentLine(this,n,dir,aggressive);}}),indentSelection:methodOp(function(how){var this$1=this;var ranges=this.doc.sel.ranges,end=-1;for(var i=0;i<ranges.length;i++){var range=ranges[i];if(!range.empty()){var from=range.from(),to=range.to();var start=Math.max(end,from.line);end=Math.min(this$1.lastLine(),to.line-(to.ch?0:1))+1;for(var j=start;j<end;++j){indentLine(this$1,j,how);}var newRanges=this$1.doc.sel.ranges;if(from.ch==0&&ranges.length==newRanges.length&&newRanges[i].from().ch>0){replaceOneSelection(this$1.doc,i,new Range(from,newRanges[i].to()),sel_dontScroll);}}else if(range.head.line>end){indentLine(this$1,range.head.line,how,true);end=range.head.line;if(i==this$1.doc.sel.primIndex){ensureCursorVisible(this$1);}}}}),// Fetch the parser token for a given character. Useful for hacks\n// that want to inspect the mode state (say, for completion).\ngetTokenAt:function(pos,precise){return takeToken(this,pos,precise);},getLineTokens:function(line,precise){return takeToken(this,Pos(line),precise,true);},getTokenTypeAt:function(pos){pos=clipPos(this.doc,pos);var styles=getLineStyles(this,getLine(this.doc,pos.line));var before=0,after=(styles.length-1)/2,ch=pos.ch;var type;if(ch==0){type=styles[2];}else{for(;;){var mid=before+after>>1;if((mid?styles[mid*2-1]:0)>=ch){after=mid;}else if(styles[mid*2+1]<ch){before=mid+1;}else{type=styles[mid*2+2];break;}}}var cut=type?type.indexOf("overlay "):-1;return cut<0?type:cut==0?null:type.slice(0,cut-1);},getModeAt:function(pos){var mode=this.doc.mode;if(!mode.innerMode){return mode;}return CodeMirror.innerMode(mode,this.getTokenAt(pos).state).mode;},getHelper:function(pos,type){return this.getHelpers(pos,type)[0];},getHelpers:function(pos,type){var this$1=this;var found=[];if(!helpers.hasOwnProperty(type)){return found;}var help=helpers[type],mode=this.getModeAt(pos);if(typeof mode[type]=="string"){if(help[mode[type]]){found.push(help[mode[type]]);}}else if(mode[type]){for(var i=0;i<mode[type].length;i++){var val=help[mode[type][i]];if(val){found.push(val);}}}else if(mode.helperType&&help[mode.helperType]){found.push(help[mode.helperType]);}else if(help[mode.name]){found.push(help[mode.name]);}for(var i$1=0;i$1<help._global.length;i$1++){var cur=help._global[i$1];if(cur.pred(mode,this$1)&&indexOf(found,cur.val)==-1){found.push(cur.val);}}return found;},getStateAfter:function(line,precise){var doc=this.doc;line=clipLine(doc,line==null?doc.first+doc.size-1:line);return getStateBefore(this,line+1,precise);},cursorCoords:function(start,mode){var pos,range=this.doc.sel.primary();if(start==null){pos=range.head;}else if(typeof start=="object"){pos=clipPos(this.doc,start);}else{pos=start?range.from():range.to();}return cursorCoords(this,pos,mode||"page");},charCoords:function(pos,mode){return charCoords(this,clipPos(this.doc,pos),mode||"page");},coordsChar:function(coords,mode){coords=fromCoordSystem(this,coords,mode||"page");return coordsChar(this,coords.left,coords.top);},lineAtHeight:function(height,mode){height=fromCoordSystem(this,{top:height,left:0},mode||"page").top;return lineAtHeight(this.doc,height+this.display.viewOffset);},heightAtLine:function(line,mode){var end=false,lineObj;if(typeof line=="number"){var last=this.doc.first+this.doc.size-1;if(line<this.doc.first){line=this.doc.first;}else if(line>last){line=last;end=true;}lineObj=getLine(this.doc,line);}else{lineObj=line;}return intoCoordSystem(this,lineObj,{top:0,left:0},mode||"page").top+(end?this.doc.height-heightAtLine(lineObj):0);},defaultTextHeight:function(){return textHeight(this.display);},defaultCharWidth:function(){return charWidth(this.display);},setGutterMarker:methodOp(function(line,gutterID,value){return changeLine(this.doc,line,"gutter",function(line){var markers=line.gutterMarkers||(line.gutterMarkers={});markers[gutterID]=value;if(!value&&isEmpty(markers)){line.gutterMarkers=null;}return true;});}),clearGutter:methodOp(function(gutterID){var this$1=this;var doc=this.doc,i=doc.first;doc.iter(function(line){if(line.gutterMarkers&&line.gutterMarkers[gutterID]){line.gutterMarkers[gutterID]=null;regLineChange(this$1,i,"gutter");if(isEmpty(line.gutterMarkers)){line.gutterMarkers=null;}}++i;});}),lineInfo:function(line){var n;if(typeof line=="number"){if(!isLine(this.doc,line)){return null;}n=line;line=getLine(this.doc,line);if(!line){return null;}}else{n=lineNo(line);if(n==null){return null;}}return{line:n,handle:line,text:line.text,gutterMarkers:line.gutterMarkers,textClass:line.textClass,bgClass:line.bgClass,wrapClass:line.wrapClass,widgets:line.widgets};},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo};},addWidget:function(pos,node,scroll,vert,horiz){var display=this.display;pos=cursorCoords(this,clipPos(this.doc,pos));var top=pos.bottom,left=pos.left;node.style.position="absolute";node.setAttribute("cm-ignore-events","true");this.display.input.setUneditable(node);display.sizer.appendChild(node);if(vert=="over"){top=pos.top;}else if(vert=="above"||vert=="near"){var vspace=Math.max(display.wrapper.clientHeight,this.doc.height),hspace=Math.max(display.sizer.clientWidth,display.lineSpace.clientWidth);// Default to positioning above (if specified and possible); otherwise default to positioning below\nif((vert==\'above\'||pos.bottom+node.offsetHeight>vspace)&&pos.top>node.offsetHeight){top=pos.top-node.offsetHeight;}else if(pos.bottom+node.offsetHeight<=vspace){top=pos.bottom;}if(left+node.offsetWidth>hspace){left=hspace-node.offsetWidth;}}node.style.top=top+"px";node.style.left=node.style.right="";if(horiz=="right"){left=display.sizer.clientWidth-node.offsetWidth;node.style.right="0px";}else{if(horiz=="left"){left=0;}else if(horiz=="middle"){left=(display.sizer.clientWidth-node.offsetWidth)/2;}node.style.left=left+"px";}if(scroll){scrollIntoView(this,left,top,left+node.offsetWidth,top+node.offsetHeight);}},triggerOnKeyDown:methodOp(onKeyDown),triggerOnKeyPress:methodOp(onKeyPress),triggerOnKeyUp:onKeyUp,execCommand:function(cmd){if(commands.hasOwnProperty(cmd)){return commands[cmd].call(null,this);}},triggerElectric:methodOp(function(text){triggerElectric(this,text);}),findPosH:function(from,amount,unit,visually){var this$1=this;var dir=1;if(amount<0){dir=-1;amount=-amount;}var cur=clipPos(this.doc,from);for(var i=0;i<amount;++i){cur=findPosH(this$1.doc,cur,dir,unit,visually);if(cur.hitSide){break;}}return cur;},moveH:methodOp(function(dir,unit){var this$1=this;this.extendSelectionsBy(function(range){if(this$1.display.shift||this$1.doc.extend||range.empty()){return findPosH(this$1.doc,range.head,dir,unit,this$1.options.rtlMoveVisually);}else{return dir<0?range.from():range.to();}},sel_move);}),deleteH:methodOp(function(dir,unit){var sel=this.doc.sel,doc=this.doc;if(sel.somethingSelected()){doc.replaceSelection("",null,"+delete");}else{deleteNearSelection(this,function(range){var other=findPosH(doc,range.head,dir,unit,false);return dir<0?{from:other,to:range.head}:{from:range.head,to:other};});}}),findPosV:function(from,amount,unit,goalColumn){var this$1=this;var dir=1,x=goalColumn;if(amount<0){dir=-1;amount=-amount;}var cur=clipPos(this.doc,from);for(var i=0;i<amount;++i){var coords=cursorCoords(this$1,cur,"div");if(x==null){x=coords.left;}else{coords.left=x;}cur=findPosV(this$1,coords,dir,unit);if(cur.hitSide){break;}}return cur;},moveV:methodOp(function(dir,unit){var this$1=this;var doc=this.doc,goals=[];var collapse=!this.display.shift&&!doc.extend&&doc.sel.somethingSelected();doc.extendSelectionsBy(function(range){if(collapse){return dir<0?range.from():range.to();}var headPos=cursorCoords(this$1,range.head,"div");if(range.goalColumn!=null){headPos.left=range.goalColumn;}goals.push(headPos.left);var pos=findPosV(this$1,headPos,dir,unit);if(unit=="page"&&range==doc.sel.primary()){addToScrollPos(this$1,null,charCoords(this$1,pos,"div").top-headPos.top);}return pos;},sel_move);if(goals.length){for(var i=0;i<doc.sel.ranges.length;i++){doc.sel.ranges[i].goalColumn=goals[i];}}}),// Find the word at the given position (as returned by coordsChar).\nfindWordAt:function(pos){var doc=this.doc,line=getLine(doc,pos.line).text;var start=pos.ch,end=pos.ch;if(line){var helper=this.getHelper(pos,"wordChars");if((pos.xRel<0||end==line.length)&&start){--start;}else{++end;}var startChar=line.charAt(start);var check=isWordChar(startChar,helper)?function(ch){return isWordChar(ch,helper);}:/\\s/.test(startChar)?function(ch){return /\\s/.test(ch);}:function(ch){return!/\\s/.test(ch)&&!isWordChar(ch);};while(start>0&&check(line.charAt(start-1))){--start;}while(end<line.length&&check(line.charAt(end))){++end;}}return new Range(Pos(pos.line,start),Pos(pos.line,end));},toggleOverwrite:function(value){if(value!=null&&value==this.state.overwrite){return;}if(this.state.overwrite=!this.state.overwrite){addClass(this.display.cursorDiv,"CodeMirror-overwrite");}else{rmClass(this.display.cursorDiv,"CodeMirror-overwrite");}signal(this,"overwriteToggle",this,this.state.overwrite);},hasFocus:function(){return this.display.input.getField()==activeElt();},isReadOnly:function(){return!!(this.options.readOnly||this.doc.cantEdit);},scrollTo:methodOp(function(x,y){if(x!=null||y!=null){resolveScrollToPos(this);}if(x!=null){this.curOp.scrollLeft=x;}if(y!=null){this.curOp.scrollTop=y;}}),getScrollInfo:function(){var scroller=this.display.scroller;return{left:scroller.scrollLeft,top:scroller.scrollTop,height:scroller.scrollHeight-scrollGap(this)-this.display.barHeight,width:scroller.scrollWidth-scrollGap(this)-this.display.barWidth,clientHeight:displayHeight(this),clientWidth:displayWidth(this)};},scrollIntoView:methodOp(function(range,margin){if(range==null){range={from:this.doc.sel.primary().head,to:null};if(margin==null){margin=this.options.cursorScrollMargin;}}else if(typeof range=="number"){range={from:Pos(range,0),to:null};}else if(range.from==null){range={from:range,to:null};}if(!range.to){range.to=range.from;}range.margin=margin||0;if(range.from.line!=null){resolveScrollToPos(this);this.curOp.scrollToPos=range;}else{var sPos=calculateScrollPos(this,Math.min(range.from.left,range.to.left),Math.min(range.from.top,range.to.top)-range.margin,Math.max(range.from.right,range.to.right),Math.max(range.from.bottom,range.to.bottom)+range.margin);this.scrollTo(sPos.scrollLeft,sPos.scrollTop);}}),setSize:methodOp(function(width,height){var this$1=this;var interpret=function(val){return typeof val=="number"||/^\\d+$/.test(String(val))?val+"px":val;};if(width!=null){this.display.wrapper.style.width=interpret(width);}if(height!=null){this.display.wrapper.style.height=interpret(height);}if(this.options.lineWrapping){clearLineMeasurementCache(this);}var lineNo=this.display.viewFrom;this.doc.iter(lineNo,this.display.viewTo,function(line){if(line.widgets){for(var i=0;i<line.widgets.length;i++){if(line.widgets[i].noHScroll){regLineChange(this$1,lineNo,"widget");break;}}}++lineNo;});this.curOp.forceUpdate=true;signal(this,"refresh",this);}),operation:function(f){return runInOp(this,f);},refresh:methodOp(function(){var oldHeight=this.display.cachedTextHeight;regChange(this);this.curOp.forceUpdate=true;clearCaches(this);this.scrollTo(this.doc.scrollLeft,this.doc.scrollTop);updateGutterSpace(this);if(oldHeight==null||Math.abs(oldHeight-textHeight(this.display))>.5){estimateLineHeights(this);}signal(this,"refresh",this);}),swapDoc:methodOp(function(doc){var old=this.doc;old.cm=null;attachDoc(this,doc);clearCaches(this);this.display.input.reset();this.scrollTo(doc.scrollLeft,doc.scrollTop);this.curOp.forceScroll=true;signalLater(this,"swapDoc",this,old);return old;}),getInputField:function(){return this.display.input.getField();},getWrapperElement:function(){return this.display.wrapper;},getScrollerElement:function(){return this.display.scroller;},getGutterElement:function(){return this.display.gutters;}};eventMixin(CodeMirror);CodeMirror.registerHelper=function(type,name,value){if(!helpers.hasOwnProperty(type)){helpers[type]=CodeMirror[type]={_global:[]};}helpers[type][name]=value;};CodeMirror.registerGlobalHelper=function(type,name,predicate,value){CodeMirror.registerHelper(type,name,value);helpers[type]._global.push({pred:predicate,val:value});};}// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be "char", "column" (like char, but doesn\'t\n// cross line boundaries), "word" (across next word), or "group" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc,pos,dir,unit,visually){var line=pos.line,ch=pos.ch,origDir=dir;var lineObj=getLine(doc,line);function findNextLine(){var l=line+dir;if(l<doc.first||l>=doc.first+doc.size){return false;}line=l;return lineObj=getLine(doc,l);}function moveOnce(boundToLine){var next=(visually?moveVisually:moveLogically)(lineObj,ch,dir,true);if(next==null){if(!boundToLine&&findNextLine()){if(visually){ch=(dir<0?lineRight:lineLeft)(lineObj);}else{ch=dir<0?lineObj.text.length:0;}}else{return false;}}else{ch=next;}return true;}if(unit=="char"){moveOnce();}else if(unit=="column"){moveOnce(true);}else if(unit=="word"||unit=="group"){var sawType=null,group=unit=="group";var helper=doc.cm&&doc.cm.getHelper(pos,"wordChars");for(var first=true;;first=false){if(dir<0&&!moveOnce(!first)){break;}var cur=lineObj.text.charAt(ch)||"\\n";var type=isWordChar(cur,helper)?"w":group&&cur=="\\n"?"n":!group||/\\s/.test(cur)?null:"p";if(group&&!first&&!type){type="s";}if(sawType&&sawType!=type){if(dir<0){dir=1;moveOnce();}break;}if(type){sawType=type;}if(dir>0&&!moveOnce(!first)){break;}}}var result=skipAtomic(doc,Pos(line,ch),pos,origDir,true);if(!cmp(pos,result)){result.hitSide=true;}return result;}// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// "page" or "line". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm,pos,dir,unit){var doc=cm.doc,x=pos.left,y;if(unit=="page"){var pageSize=Math.min(cm.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight);var moveAmount=Math.max(pageSize-.5*textHeight(cm.display),3);y=(dir>0?pos.bottom:pos.top)+dir*moveAmount;}else if(unit=="line"){y=dir>0?pos.bottom+3:pos.top-3;}var target;for(;;){target=coordsChar(cm,x,y);if(!target.outside){break;}if(dir<0?y<=0:y>=doc.height){target.hitSide=true;break;}y+=dir*5;}return target;}// CONTENTEDITABLE INPUT STYLE\nfunction ContentEditableInput(cm){this.cm=cm;this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null;this.polling=new Delayed();this.gracePeriod=false;}ContentEditableInput.prototype=copyObj({init:function(display){var input=this,cm=input.cm;var div=input.div=display.lineDiv;disableBrowserMagic(div,cm.options.spellcheck);on(div,"paste",function(e){if(signalDOMEvent(cm,e)||handlePaste(e,cm)){return;}// IE doesn\'t fire input events, so we schedule a read for the pasted content in this way\nif(ie_version<=11){setTimeout(operation(cm,function(){if(!input.pollContent()){regChange(cm);}}),20);}});on(div,"compositionstart",function(e){var data=e.data;input.composing={sel:cm.doc.sel,data:data,startData:data};if(!data){return;}var prim=cm.doc.sel.primary();var line=cm.getLine(prim.head.line);var found=line.indexOf(data,Math.max(0,prim.head.ch-data.length));if(found>-1&&found<=prim.head.ch){input.composing.sel=simpleSelection(Pos(prim.head.line,found),Pos(prim.head.line,found+data.length));}});on(div,"compositionupdate",function(e){return input.composing.data=e.data;});on(div,"compositionend",function(e){var ours=input.composing;if(!ours){return;}if(e.data!=ours.startData&&!/\\u200b/.test(e.data)){ours.data=e.data;}// Need a small delay to prevent other code (input event,\n// selection polling) from doing damage when fired right after\n// compositionend.\nsetTimeout(function(){if(!ours.handled){input.applyComposition(ours);}if(input.composing==ours){input.composing=null;}},50);});on(div,"touchstart",function(){return input.forceCompositionEnd();});on(div,"input",function(){if(input.composing){return;}if(cm.isReadOnly()||!input.pollContent()){runInOp(input.cm,function(){return regChange(cm);});}});function onCopyCut(e){if(signalDOMEvent(cm,e)){return;}if(cm.somethingSelected()){setLastCopied({lineWise:false,text:cm.getSelections()});if(e.type=="cut"){cm.replaceSelection("",null,"cut");}}else if(!cm.options.lineWiseCopyCut){return;}else{var ranges=copyableRanges(cm);setLastCopied({lineWise:true,text:ranges.text});if(e.type=="cut"){cm.operation(function(){cm.setSelections(ranges.ranges,0,sel_dontScroll);cm.replaceSelection("",null,"cut");});}}if(e.clipboardData){e.clipboardData.clearData();var content=lastCopied.text.join("\\n");// iOS exposes the clipboard API, but seems to discard content inserted into it\ne.clipboardData.setData("Text",content);if(e.clipboardData.getData("Text")==content){e.preventDefault();return;}}// Old-fashioned briefly-focus-a-textarea hack\nvar kludge=hiddenTextarea(),te=kludge.firstChild;cm.display.lineSpace.insertBefore(kludge,cm.display.lineSpace.firstChild);te.value=lastCopied.text.join("\\n");var hadFocus=document.activeElement;selectInput(te);setTimeout(function(){cm.display.lineSpace.removeChild(kludge);hadFocus.focus();if(hadFocus==div){input.showPrimarySelection();}},50);}on(div,"copy",onCopyCut);on(div,"cut",onCopyCut);},prepareSelection:function(){var result=prepareSelection(this.cm,false);result.focus=this.cm.state.focused;return result;},showSelection:function(info,takeFocus){if(!info||!this.cm.display.view.length){return;}if(info.focus||takeFocus){this.showPrimarySelection();}this.showMultipleSelections(info);},showPrimarySelection:function(){var sel=window.getSelection(),prim=this.cm.doc.sel.primary();var curAnchor=domToPos(this.cm,sel.anchorNode,sel.anchorOffset);var curFocus=domToPos(this.cm,sel.focusNode,sel.focusOffset);if(curAnchor&&!curAnchor.bad&&curFocus&&!curFocus.bad&&cmp(minPos(curAnchor,curFocus),prim.from())==0&&cmp(maxPos(curAnchor,curFocus),prim.to())==0){return;}var start=posToDOM(this.cm,prim.from());var end=posToDOM(this.cm,prim.to());if(!start&&!end){return;}var view=this.cm.display.view;var old=sel.rangeCount&&sel.getRangeAt(0);if(!start){start={node:view[0].measure.map[2],offset:0};}else if(!end){// FIXME dangerously hacky\nvar measure=view[view.length-1].measure;var map=measure.maps?measure.maps[measure.maps.length-1]:measure.map;end={node:map[map.length-1],offset:map[map.length-2]-map[map.length-3]};}var rng;try{rng=range(start.node,start.offset,end.offset,end.node);}catch(e){}// Our model of the DOM might be outdated, in which case the range we try to set can be impossible\nif(rng){if(!gecko&&this.cm.state.focused){sel.collapse(start.node,start.offset);if(!rng.collapsed){sel.removeAllRanges();sel.addRange(rng);}}else{sel.removeAllRanges();sel.addRange(rng);}if(old&&sel.anchorNode==null){sel.addRange(old);}else if(gecko){this.startGracePeriod();}}this.rememberSelection();},startGracePeriod:function(){var this$1=this;clearTimeout(this.gracePeriod);this.gracePeriod=setTimeout(function(){this$1.gracePeriod=false;if(this$1.selectionChanged()){this$1.cm.operation(function(){return this$1.cm.curOp.selectionChanged=true;});}},20);},showMultipleSelections:function(info){removeChildrenAndAdd(this.cm.display.cursorDiv,info.cursors);removeChildrenAndAdd(this.cm.display.selectionDiv,info.selection);},rememberSelection:function(){var sel=window.getSelection();this.lastAnchorNode=sel.anchorNode;this.lastAnchorOffset=sel.anchorOffset;this.lastFocusNode=sel.focusNode;this.lastFocusOffset=sel.focusOffset;},selectionInEditor:function(){var sel=window.getSelection();if(!sel.rangeCount){return false;}var node=sel.getRangeAt(0).commonAncestorContainer;return contains(this.div,node);},focus:function(){if(this.cm.options.readOnly!="nocursor"){this.div.focus();}},blur:function(){this.div.blur();},getField:function(){return this.div;},supportsTouch:function(){return true;},receivedFocus:function(){var input=this;if(this.selectionInEditor()){this.pollSelection();}else{runInOp(this.cm,function(){return input.cm.curOp.selectionChanged=true;});}function poll(){if(input.cm.state.focused){input.pollSelection();input.polling.set(input.cm.options.pollInterval,poll);}}this.polling.set(this.cm.options.pollInterval,poll);},selectionChanged:function(){var sel=window.getSelection();return sel.anchorNode!=this.lastAnchorNode||sel.anchorOffset!=this.lastAnchorOffset||sel.focusNode!=this.lastFocusNode||sel.focusOffset!=this.lastFocusOffset;},pollSelection:function(){if(!this.composing&&!this.gracePeriod&&this.selectionChanged()){var sel=window.getSelection(),cm=this.cm;this.rememberSelection();var anchor=domToPos(cm,sel.anchorNode,sel.anchorOffset);var head=domToPos(cm,sel.focusNode,sel.focusOffset);if(anchor&&head){runInOp(cm,function(){setSelection(cm.doc,simpleSelection(anchor,head),sel_dontScroll);if(anchor.bad||head.bad){cm.curOp.selectionChanged=true;}});}}},pollContent:function(){var cm=this.cm,display=cm.display,sel=cm.doc.sel.primary();var from=sel.from(),to=sel.to();if(from.line<display.viewFrom||to.line>display.viewTo-1){return false;}var fromIndex,fromLine,fromNode;if(from.line==display.viewFrom||(fromIndex=findViewIndex(cm,from.line))==0){fromLine=lineNo(display.view[0].line);fromNode=display.view[0].node;}else{fromLine=lineNo(display.view[fromIndex].line);fromNode=display.view[fromIndex-1].node.nextSibling;}var toIndex=findViewIndex(cm,to.line);var toLine,toNode;if(toIndex==display.view.length-1){toLine=display.viewTo-1;toNode=display.lineDiv.lastChild;}else{toLine=lineNo(display.view[toIndex+1].line)-1;toNode=display.view[toIndex+1].node.previousSibling;}var newText=cm.doc.splitLines(domTextBetween(cm,fromNode,toNode,fromLine,toLine));var oldText=getBetween(cm.doc,Pos(fromLine,0),Pos(toLine,getLine(cm.doc,toLine).text.length));while(newText.length>1&&oldText.length>1){if(lst(newText)==lst(oldText)){newText.pop();oldText.pop();toLine--;}else if(newText[0]==oldText[0]){newText.shift();oldText.shift();fromLine++;}else{break;}}var cutFront=0,cutEnd=0;var newTop=newText[0],oldTop=oldText[0],maxCutFront=Math.min(newTop.length,oldTop.length);while(cutFront<maxCutFront&&newTop.charCodeAt(cutFront)==oldTop.charCodeAt(cutFront)){++cutFront;}var newBot=lst(newText),oldBot=lst(oldText);var maxCutEnd=Math.min(newBot.length-(newText.length==1?cutFront:0),oldBot.length-(oldText.length==1?cutFront:0));while(cutEnd<maxCutEnd&&newBot.charCodeAt(newBot.length-cutEnd-1)==oldBot.charCodeAt(oldBot.length-cutEnd-1)){++cutEnd;}newText[newText.length-1]=newBot.slice(0,newBot.length-cutEnd);newText[0]=newText[0].slice(cutFront);var chFrom=Pos(fromLine,cutFront);var chTo=Pos(toLine,oldText.length?lst(oldText).length-cutEnd:0);if(newText.length>1||newText[0]||cmp(chFrom,chTo)){replaceRange(cm.doc,newText,chFrom,chTo,"+input");return true;}},ensurePolled:function(){this.forceCompositionEnd();},reset:function(){this.forceCompositionEnd();},forceCompositionEnd:function(){if(!this.composing||this.composing.handled){return;}this.applyComposition(this.composing);this.composing.handled=true;this.div.blur();this.div.focus();},applyComposition:function(composing){if(this.cm.isReadOnly()){operation(this.cm,regChange)(this.cm);}else if(composing.data&&composing.data!=composing.startData){operation(this.cm,applyTextInput)(this.cm,composing.data,0,composing.sel);}},setUneditable:function(node){node.contentEditable="false";},onKeyPress:function(e){e.preventDefault();if(!this.cm.isReadOnly()){operation(this.cm,applyTextInput)(this.cm,String.fromCharCode(e.charCode==null?e.keyCode:e.charCode),0);}},readOnlyChanged:function(val){this.div.contentEditable=String(val!="nocursor");},onContextMenu:nothing,resetPosition:nothing,needsContentAttribute:true},ContentEditableInput.prototype);function posToDOM(cm,pos){var view=findViewForLine(cm,pos.line);if(!view||view.hidden){return null;}var line=getLine(cm.doc,pos.line);var info=mapFromLineView(view,line,pos.line);var order=getOrder(line),side="left";if(order){var partPos=getBidiPartAt(order,pos.ch);side=partPos%2?"right":"left";}var result=nodeAndOffsetInLineMap(info.map,pos.ch,side);result.offset=result.collapse=="right"?result.end:result.start;return result;}function badPos(pos,bad){if(bad){pos.bad=true;}return pos;}function domTextBetween(cm,from,to,fromLine,toLine){var text="",closing=false,lineSep=cm.doc.lineSeparator();function recognizeMarker(id){return function(marker){return marker.id==id;};}function walk(node){if(node.nodeType==1){var cmText=node.getAttribute("cm-text");if(cmText!=null){if(cmText==""){cmText=node.textContent.replace(/\\u200b/g,"");}text+=cmText;return;}var markerID=node.getAttribute("cm-marker"),range;if(markerID){var found=cm.findMarks(Pos(fromLine,0),Pos(toLine+1,0),recognizeMarker(+markerID));if(found.length&&(range=found[0].find())){text+=getBetween(cm.doc,range.from,range.to).join(lineSep);}return;}if(node.getAttribute("contenteditable")=="false"){return;}for(var i=0;i<node.childNodes.length;i++){walk(node.childNodes[i]);}if(/^(pre|div|p)$/i.test(node.nodeName)){closing=true;}}else if(node.nodeType==3){var val=node.nodeValue;if(!val){return;}if(closing){text+=lineSep;closing=false;}text+=val;}}for(;;){walk(from);if(from==to){break;}from=from.nextSibling;}return text;}function domToPos(cm,node,offset){var lineNode;if(node==cm.display.lineDiv){lineNode=cm.display.lineDiv.childNodes[offset];if(!lineNode){return badPos(cm.clipPos(Pos(cm.display.viewTo-1)),true);}node=null;offset=0;}else{for(lineNode=node;;lineNode=lineNode.parentNode){if(!lineNode||lineNode==cm.display.lineDiv){return null;}if(lineNode.parentNode&&lineNode.parentNode==cm.display.lineDiv){break;}}}for(var i=0;i<cm.display.view.length;i++){var lineView=cm.display.view[i];if(lineView.node==lineNode){return locateNodeInLineView(lineView,node,offset);}}}function locateNodeInLineView(lineView,node,offset){var wrapper=lineView.text.firstChild,bad=false;if(!node||!contains(wrapper,node)){return badPos(Pos(lineNo(lineView.line),0),true);}if(node==wrapper){bad=true;node=wrapper.childNodes[offset];offset=0;if(!node){var line=lineView.rest?lst(lineView.rest):lineView.line;return badPos(Pos(lineNo(line),line.text.length),bad);}}var textNode=node.nodeType==3?node:null,topNode=node;if(!textNode&&node.childNodes.length==1&&node.firstChild.nodeType==3){textNode=node.firstChild;if(offset){offset=textNode.nodeValue.length;}}while(topNode.parentNode!=wrapper){topNode=topNode.parentNode;}var measure=lineView.measure,maps=measure.maps;function find(textNode,topNode,offset){for(var i=-1;i<(maps?maps.length:0);i++){var map=i<0?measure.map:maps[i];for(var j=0;j<map.length;j+=3){var curNode=map[j+2];if(curNode==textNode||curNode==topNode){var line=lineNo(i<0?lineView.line:lineView.rest[i]);var ch=map[j]+offset;if(offset<0||curNode!=textNode){ch=map[j+(offset?1:0)];}return Pos(line,ch);}}}}var found=find(textNode,topNode,offset);if(found){return badPos(found,bad);}// FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\nfor(var after=topNode.nextSibling,dist=textNode?textNode.nodeValue.length-offset:0;after;after=after.nextSibling){found=find(after,after.firstChild,0);if(found){return badPos(Pos(found.line,found.ch-dist),bad);}else{dist+=after.textContent.length;}}for(var before=topNode.previousSibling,dist$1=offset;before;before=before.previousSibling){found=find(before,before.firstChild,-1);if(found){return badPos(Pos(found.line,found.ch+dist$1),bad);}else{dist$1+=before.textContent.length;}}}// TEXTAREA INPUT STYLE\nfunction TextareaInput(cm){this.cm=cm;// See input.poll and input.reset\nthis.prevInput="";// Flag that indicates whether we expect input to appear real soon\n// now (after some event like \'keypress\' or \'input\') and are\n// polling intensively.\nthis.pollingFast=false;// Self-resetting timeout for the poller\nthis.polling=new Delayed();// Tracks when input.reset has punted to just putting a short\n// string into the textarea instead of the full selection.\nthis.inaccurateSelection=false;// Used to work around IE issue with selection being forgotten when focus moves away from textarea\nthis.hasSelection=false;this.composing=null;}TextareaInput.prototype=copyObj({init:function(display){var this$1=this;var input=this,cm=this.cm;// Wraps and hides input textarea\nvar div=this.wrapper=hiddenTextarea();// The semihidden textarea that is focused when the editor is\n// focused, and receives input.\nvar te=this.textarea=div.firstChild;display.wrapper.insertBefore(div,display.wrapper.firstChild);// Needed to hide big blue blinking cursor on Mobile Safari (doesn\'t seem to work in iOS 8 anymore)\nif(ios){te.style.width="0px";}on(te,"input",function(){if(ie&&ie_version>=9&&this$1.hasSelection){this$1.hasSelection=null;}input.poll();});on(te,"paste",function(e){if(signalDOMEvent(cm,e)||handlePaste(e,cm)){return;}cm.state.pasteIncoming=true;input.fastPoll();});function prepareCopyCut(e){if(signalDOMEvent(cm,e)){return;}if(cm.somethingSelected()){setLastCopied({lineWise:false,text:cm.getSelections()});if(input.inaccurateSelection){input.prevInput="";input.inaccurateSelection=false;te.value=lastCopied.text.join("\\n");selectInput(te);}}else if(!cm.options.lineWiseCopyCut){return;}else{var ranges=copyableRanges(cm);setLastCopied({lineWise:true,text:ranges.text});if(e.type=="cut"){cm.setSelections(ranges.ranges,null,sel_dontScroll);}else{input.prevInput="";te.value=ranges.text.join("\\n");selectInput(te);}}if(e.type=="cut"){cm.state.cutIncoming=true;}}on(te,"cut",prepareCopyCut);on(te,"copy",prepareCopyCut);on(display.scroller,"paste",function(e){if(eventInWidget(display,e)||signalDOMEvent(cm,e)){return;}cm.state.pasteIncoming=true;input.focus();});// Prevent normal selection in the editor (we handle our own)\non(display.lineSpace,"selectstart",function(e){if(!eventInWidget(display,e)){e_preventDefault(e);}});on(te,"compositionstart",function(){var start=cm.getCursor("from");if(input.composing){input.composing.range.clear();}input.composing={start:start,range:cm.markText(start,cm.getCursor("to"),{className:"CodeMirror-composing"})};});on(te,"compositionend",function(){if(input.composing){input.poll();input.composing.range.clear();input.composing=null;}});},prepareSelection:function(){// Redraw the selection and/or cursor\nvar cm=this.cm,display=cm.display,doc=cm.doc;var result=prepareSelection(cm);// Move the hidden textarea near the cursor to prevent scrolling artifacts\nif(cm.options.moveInputWithCursor){var headPos=cursorCoords(cm,doc.sel.primary().head,"div");var wrapOff=display.wrapper.getBoundingClientRect(),lineOff=display.lineDiv.getBoundingClientRect();result.teTop=Math.max(0,Math.min(display.wrapper.clientHeight-10,headPos.top+lineOff.top-wrapOff.top));result.teLeft=Math.max(0,Math.min(display.wrapper.clientWidth-10,headPos.left+lineOff.left-wrapOff.left));}return result;},showSelection:function(drawn){var cm=this.cm,display=cm.display;removeChildrenAndAdd(display.cursorDiv,drawn.cursors);removeChildrenAndAdd(display.selectionDiv,drawn.selection);if(drawn.teTop!=null){this.wrapper.style.top=drawn.teTop+"px";this.wrapper.style.left=drawn.teLeft+"px";}},// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nreset:function(typing){if(this.contextMenuPending){return;}var minimal,selected,cm=this.cm,doc=cm.doc;if(cm.somethingSelected()){this.prevInput="";var range=doc.sel.primary();minimal=hasCopyEvent&&(range.to().line-range.from().line>100||(selected=cm.getSelection()).length>1000);var content=minimal?"-":selected||cm.getSelection();this.textarea.value=content;if(cm.state.focused){selectInput(this.textarea);}if(ie&&ie_version>=9){this.hasSelection=content;}}else if(!typing){this.prevInput=this.textarea.value="";if(ie&&ie_version>=9){this.hasSelection=null;}}this.inaccurateSelection=minimal;},getField:function(){return this.textarea;},supportsTouch:function(){return false;},focus:function(){if(this.cm.options.readOnly!="nocursor"&&(!mobile||activeElt()!=this.textarea)){try{this.textarea.focus();}catch(e){}// IE8 will throw if the textarea is display: none or not in DOM\n}},blur:function(){this.textarea.blur();},resetPosition:function(){this.wrapper.style.top=this.wrapper.style.left=0;},receivedFocus:function(){this.slowPoll();},// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nslowPoll:function(){var this$1=this;if(this.pollingFast){return;}this.polling.set(this.cm.options.pollInterval,function(){this$1.poll();if(this$1.cm.state.focused){this$1.slowPoll();}});},// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nfastPoll:function(){var missed=false,input=this;input.pollingFast=true;function p(){var changed=input.poll();if(!changed&&!missed){missed=true;input.polling.set(60,p);}else{input.pollingFast=false;input.slowPoll();}}input.polling.set(20,p);},// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\npoll:function(){var this$1=this;var cm=this.cm,input=this.textarea,prevInput=this.prevInput;// Since this is called a *lot*, try to bail out as cheaply as\n// possible when it is clear that nothing happened. hasSelection\n// will be the case when there is a lot of text in the textarea,\n// in which case reading its value would be expensive.\nif(this.contextMenuPending||!cm.state.focused||hasSelection(input)&&!prevInput&&!this.composing||cm.isReadOnly()||cm.options.disableInput||cm.state.keySeq){return false;}var text=input.value;// If nothing changed, bail.\nif(text==prevInput&&!cm.somethingSelected()){return false;}// Work around nonsensical selection resetting in IE9/10, and\n// inexplicable appearance of private area unicode characters on\n// some key combos in Mac (#2689).\nif(ie&&ie_version>=9&&this.hasSelection===text||mac&&/[\\uf700-\\uf7ff]/.test(text)){cm.display.input.reset();return false;}if(cm.doc.sel==cm.display.selForContextMenu){var first=text.charCodeAt(0);if(first==0x200b&&!prevInput){prevInput="\\u200b";}if(first==0x21da){this.reset();return this.cm.execCommand("undo");}}// Find the part of the input that is actually new\nvar same=0,l=Math.min(prevInput.length,text.length);while(same<l&&prevInput.charCodeAt(same)==text.charCodeAt(same)){++same;}runInOp(cm,function(){applyTextInput(cm,text.slice(same),prevInput.length-same,null,this$1.composing?"*compose":null);// Don\'t leave long text in the textarea, since it makes further polling slow\nif(text.length>1000||text.indexOf("\\n")>-1){input.value=this$1.prevInput="";}else{this$1.prevInput=text;}if(this$1.composing){this$1.composing.range.clear();this$1.composing.range=cm.markText(this$1.composing.start,cm.getCursor("to"),{className:"CodeMirror-composing"});}});return true;},ensurePolled:function(){if(this.pollingFast&&this.poll()){this.pollingFast=false;}},onKeyPress:function(){if(ie&&ie_version>=9){this.hasSelection=null;}this.fastPoll();},onContextMenu:function(e){var input=this,cm=input.cm,display=cm.display,te=input.textarea;var pos=posFromMouse(cm,e),scrollPos=display.scroller.scrollTop;if(!pos||presto){return;}// Opera is difficult.\n// Reset the current text selection only if the click is done outside of the selection\n// and \'resetSelectionOnContextMenu\' option is true.\nvar reset=cm.options.resetSelectionOnContextMenu;if(reset&&cm.doc.sel.contains(pos)==-1){operation(cm,setSelection)(cm.doc,simpleSelection(pos),sel_dontScroll);}var oldCSS=te.style.cssText,oldWrapperCSS=input.wrapper.style.cssText;input.wrapper.style.cssText="position: absolute";var wrapperBox=input.wrapper.getBoundingClientRect();te.style.cssText="position: absolute; width: 30px; height: 30px;\\n      top: "+(e.clientY-wrapperBox.top-5)+"px; left: "+(e.clientX-wrapperBox.left-5)+"px;\\n      z-index: 1000; background: "+(ie?"rgba(255, 255, 255, .05)":"transparent")+";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var oldScrollY;if(webkit){oldScrollY=window.scrollY;}// Work around Chrome issue (#2712)\ndisplay.input.focus();if(webkit){window.scrollTo(null,oldScrollY);}display.input.reset();// Adds "Select all" to context menu in FF\nif(!cm.somethingSelected()){te.value=input.prevInput=" ";}input.contextMenuPending=true;display.selForContextMenu=cm.doc.sel;clearTimeout(display.detectingSelectAll);// Select-all will be greyed out if there\'s nothing to select, so\n// this adds a zero-width space so that we can later check whether\n// it got selected.\nfunction prepareSelectAllHack(){if(te.selectionStart!=null){var selected=cm.somethingSelected();var extval="\\u200b"+(selected?te.value:"");te.value="\\u21da";// Used to catch context-menu undo\nte.value=extval;input.prevInput=selected?"":"\\u200b";te.selectionStart=1;te.selectionEnd=extval.length;// Re-set this, in case some other handler touched the\n// selection in the meantime.\ndisplay.selForContextMenu=cm.doc.sel;}}function rehide(){input.contextMenuPending=false;input.wrapper.style.cssText=oldWrapperCSS;te.style.cssText=oldCSS;if(ie&&ie_version<9){display.scrollbars.setScrollTop(display.scroller.scrollTop=scrollPos);}// Try to detect the user choosing select-all\nif(te.selectionStart!=null){if(!ie||ie&&ie_version<9){prepareSelectAllHack();}var i=0,poll=function(){if(display.selForContextMenu==cm.doc.sel&&te.selectionStart==0&&te.selectionEnd>0&&input.prevInput=="\\u200b"){operation(cm,selectAll)(cm);}else if(i++<10){display.detectingSelectAll=setTimeout(poll,500);}else{display.input.reset();}};display.detectingSelectAll=setTimeout(poll,200);}}if(ie&&ie_version>=9){prepareSelectAllHack();}if(captureRightClick){e_stop(e);var mouseup=function(){off(window,"mouseup",mouseup);setTimeout(rehide,20);};on(window,"mouseup",mouseup);}else{setTimeout(rehide,50);}},readOnlyChanged:function(val){if(!val){this.reset();}},setUneditable:nothing,needsContentAttribute:false},TextareaInput.prototype);function fromTextArea(textarea,options){options=options?copyObj(options):{};options.value=textarea.value;if(!options.tabindex&&textarea.tabIndex){options.tabindex=textarea.tabIndex;}if(!options.placeholder&&textarea.placeholder){options.placeholder=textarea.placeholder;}// Set autofocus to true if this textarea is focused, or if it has\n// autofocus and no other element is focused.\nif(options.autofocus==null){var hasFocus=activeElt();options.autofocus=hasFocus==textarea||textarea.getAttribute("autofocus")!=null&&hasFocus==document.body;}function save(){textarea.value=cm.getValue();}var realSubmit;if(textarea.form){on(textarea.form,"submit",save);// Deplorable hack to make the submit method do the right thing.\nif(!options.leaveSubmitMethodAlone){var form=textarea.form;realSubmit=form.submit;try{var wrappedSubmit=form.submit=function(){save();form.submit=realSubmit;form.submit();form.submit=wrappedSubmit;};}catch(e){}}}options.finishInit=function(cm){cm.save=save;cm.getTextArea=function(){return textarea;};cm.toTextArea=function(){cm.toTextArea=isNaN;// Prevent this from being ran twice\nsave();textarea.parentNode.removeChild(cm.getWrapperElement());textarea.style.display="";if(textarea.form){off(textarea.form,"submit",save);if(typeof textarea.form.submit=="function"){textarea.form.submit=realSubmit;}}};};textarea.style.display="none";var cm=CodeMirror(function(node){return textarea.parentNode.insertBefore(node,textarea.nextSibling);},options);return cm;}function addLegacyProps(CodeMirror){CodeMirror.off=off;CodeMirror.on=on;CodeMirror.wheelEventPixels=wheelEventPixels;CodeMirror.Doc=Doc;CodeMirror.splitLines=splitLinesAuto;CodeMirror.countColumn=countColumn;CodeMirror.findColumn=findColumn;CodeMirror.isWordChar=isWordCharBasic;CodeMirror.Pass=Pass;CodeMirror.signal=signal;CodeMirror.Line=Line;CodeMirror.changeEnd=changeEnd;CodeMirror.scrollbarModel=scrollbarModel;CodeMirror.Pos=Pos;CodeMirror.cmpPos=cmp;CodeMirror.modes=modes;CodeMirror.mimeModes=mimeModes;CodeMirror.resolveMode=resolveMode;CodeMirror.getMode=getMode;CodeMirror.modeExtensions=modeExtensions;CodeMirror.extendMode=extendMode;CodeMirror.copyState=copyState;CodeMirror.startState=startState;CodeMirror.innerMode=innerMode;CodeMirror.commands=commands;CodeMirror.keyMap=keyMap;CodeMirror.keyName=keyName;CodeMirror.isModifierKey=isModifierKey;CodeMirror.lookupKey=lookupKey;CodeMirror.normalizeKeyMap=normalizeKeyMap;CodeMirror.StringStream=StringStream;CodeMirror.SharedTextMarker=SharedTextMarker;CodeMirror.TextMarker=TextMarker;CodeMirror.LineWidget=LineWidget;CodeMirror.e_preventDefault=e_preventDefault;CodeMirror.e_stopPropagation=e_stopPropagation;CodeMirror.e_stop=e_stop;CodeMirror.addClass=addClass;CodeMirror.contains=contains;CodeMirror.rmClass=rmClass;CodeMirror.keyNames=keyNames;}// EDITOR CONSTRUCTOR\ndefineOptions(CodeMirror);addEditorMethods(CodeMirror);// Set up methods on CodeMirror\'s prototype to redirect to the editor\'s document.\nvar dontDelegate="iter insert remove copy getEditor constructor".split(" ");for(var prop in Doc.prototype){if(Doc.prototype.hasOwnProperty(prop)&&indexOf(dontDelegate,prop)<0){CodeMirror.prototype[prop]=function(method){return function(){return method.apply(this.doc,arguments);};}(Doc.prototype[prop]);}}eventMixin(Doc);// INPUT HANDLING\nCodeMirror.inputStyles={"textarea":TextareaInput,"contenteditable":ContentEditableInput};// MODE DEFINITION AND QUERYING\n// Extra arguments are stored as the mode\'s dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror.defineMode=function(name/*, mode, */){if(!CodeMirror.defaults.mode&&name!="null"){CodeMirror.defaults.mode=name;}defineMode.apply(this,arguments);};CodeMirror.defineMIME=defineMIME;// Minimal default mode.\nCodeMirror.defineMode("null",function(){return{token:function(stream){return stream.skipToEnd();}};});CodeMirror.defineMIME("text/plain","null");// EXTENSIONS\nCodeMirror.defineExtension=function(name,func){CodeMirror.prototype[name]=func;};CodeMirror.defineDocExtension=function(name,func){Doc.prototype[name]=func;};CodeMirror.fromTextArea=fromTextArea;addLegacyProps(CodeMirror);CodeMirror.version="5.20.2";return CodeMirror;});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanM/YjQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHA6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG4vLyBUaGlzIGlzIENvZGVNaXJyb3IgKGh0dHA6Ly9jb2RlbWlycm9yLm5ldCksIGEgY29kZSBlZGl0b3Jcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxuLy9cbi8vIFlvdSBjYW4gZmluZCBzb21lIHRlY2huaWNhbCBiYWNrZ3JvdW5kIGZvciBzb21lIG9mIHRoZSBjb2RlIGJlbG93XG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXG4oZnVuY3Rpb24oZ2xvYmFsLGZhY3Rvcnkpe3R5cGVvZiBleHBvcnRzPT09J29iamVjdCcmJnR5cGVvZiBtb2R1bGUhPT0ndW5kZWZpbmVkJz9tb2R1bGUuZXhwb3J0cz1mYWN0b3J5KCk6dHlwZW9mIGRlZmluZT09PSdmdW5jdGlvbicmJmRlZmluZS5hbWQ/ZGVmaW5lKGZhY3RvcnkpOmdsb2JhbC5Db2RlTWlycm9yPWZhY3RvcnkoKTt9KSh0aGlzLGZ1bmN0aW9uKCl7J3VzZSBzdHJpY3QnOy8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxuLy8gZGV0ZWN0ZWQgYXJlIGVuYWJsZWQgYmFzZWQgb24gdXNlckFnZW50IGV0YyBzbmlmZmluZy5cbnZhciB1c2VyQWdlbnQ9bmF2aWdhdG9yLnVzZXJBZ2VudDt2YXIgcGxhdGZvcm09bmF2aWdhdG9yLnBsYXRmb3JtO3ZhciBnZWNrbz0vZ2Vja29cXC9cXGQvaS50ZXN0KHVzZXJBZ2VudCk7dmFyIGllX3VwdG8xMD0vTVNJRSBcXGQvLnRlc3QodXNlckFnZW50KTt2YXIgaWVfMTF1cD0vVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWModXNlckFnZW50KTt2YXIgaWU9aWVfdXB0bzEwfHxpZV8xMXVwO3ZhciBpZV92ZXJzaW9uPWllJiYoaWVfdXB0bzEwP2RvY3VtZW50LmRvY3VtZW50TW9kZXx8NjppZV8xMXVwWzFdKTt2YXIgd2Via2l0PS9XZWJLaXRcXC8vLnRlc3QodXNlckFnZW50KTt2YXIgcXR3ZWJraXQ9d2Via2l0JiYvUXRcXC9cXGQrXFwuXFxkKy8udGVzdCh1c2VyQWdlbnQpO3ZhciBjaHJvbWU9L0Nocm9tZVxcLy8udGVzdCh1c2VyQWdlbnQpO3ZhciBwcmVzdG89L09wZXJhXFwvLy50ZXN0KHVzZXJBZ2VudCk7dmFyIHNhZmFyaT0vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7dmFyIG1hY19nZU1vdW50YWluTGlvbj0vTWFjIE9TIFggMVxcZFxcRChbOC05XXxcXGRcXGQpXFxELy50ZXN0KHVzZXJBZ2VudCk7dmFyIHBoYW50b209L1BoYW50b21KUy8udGVzdCh1c2VyQWdlbnQpO3ZhciBpb3M9L0FwcGxlV2ViS2l0Ly50ZXN0KHVzZXJBZ2VudCkmJi9Nb2JpbGVcXC9cXHcrLy50ZXN0KHVzZXJBZ2VudCk7Ly8gVGhpcyBpcyB3b2VmdWxseSBpbmNvbXBsZXRlLiBTdWdnZXN0aW9ucyBmb3IgYWx0ZXJuYXRpdmUgbWV0aG9kcyB3ZWxjb21lLlxudmFyIG1vYmlsZT1pb3N8fC9BbmRyb2lkfHdlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpO3ZhciBtYWM9aW9zfHwvTWFjLy50ZXN0KHBsYXRmb3JtKTt2YXIgY2hyb21lT1M9L1xcYkNyT1NcXGIvLnRlc3QodXNlckFnZW50KTt2YXIgd2luZG93cz0vd2luL2kudGVzdChwbGF0Zm9ybSk7dmFyIHByZXN0b192ZXJzaW9uPXByZXN0byYmdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCpcXC5cXGQqKS8pO2lmKHByZXN0b192ZXJzaW9uKXtwcmVzdG9fdmVyc2lvbj1OdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pO31pZihwcmVzdG9fdmVyc2lvbiYmcHJlc3RvX3ZlcnNpb24+PTE1KXtwcmVzdG89ZmFsc2U7d2Via2l0PXRydWU7fS8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXG52YXIgZmxpcEN0cmxDbWQ9bWFjJiYocXR3ZWJraXR8fHByZXN0byYmKHByZXN0b192ZXJzaW9uPT1udWxsfHxwcmVzdG9fdmVyc2lvbjwxMi4xMSkpO3ZhciBjYXB0dXJlUmlnaHRDbGljaz1nZWNrb3x8aWUmJmllX3ZlcnNpb24+PTk7ZnVuY3Rpb24gY2xhc3NUZXN0KGNscyl7cmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIitjbHMrXCIoPzokfFxcXFxzKVxcXFxzKlwiKTt9dmFyIHJtQ2xhc3M9ZnVuY3Rpb24obm9kZSxjbHMpe3ZhciBjdXJyZW50PW5vZGUuY2xhc3NOYW1lO3ZhciBtYXRjaD1jbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpO2lmKG1hdGNoKXt2YXIgYWZ0ZXI9Y3VycmVudC5zbGljZShtYXRjaC5pbmRleCttYXRjaFswXS5sZW5ndGgpO25vZGUuY2xhc3NOYW1lPWN1cnJlbnQuc2xpY2UoMCxtYXRjaC5pbmRleCkrKGFmdGVyP21hdGNoWzFdK2FmdGVyOlwiXCIpO319O2Z1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpe2Zvcih2YXIgY291bnQ9ZS5jaGlsZE5vZGVzLmxlbmd0aDtjb3VudD4wOy0tY291bnQpe2UucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTt9cmV0dXJuIGU7fWZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCxlKXtyZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKTt9ZnVuY3Rpb24gZWx0KHRhZyxjb250ZW50LGNsYXNzTmFtZSxzdHlsZSl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO2lmKGNsYXNzTmFtZSl7ZS5jbGFzc05hbWU9Y2xhc3NOYW1lO31pZihzdHlsZSl7ZS5zdHlsZS5jc3NUZXh0PXN0eWxlO31pZih0eXBlb2YgY29udGVudD09XCJzdHJpbmdcIil7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7fWVsc2UgaWYoY29udGVudCl7Zm9yKHZhciBpPTA7aTxjb250ZW50Lmxlbmd0aDsrK2kpe2UuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7fX1yZXR1cm4gZTt9dmFyIHJhbmdlO2lmKGRvY3VtZW50LmNyZWF0ZVJhbmdlKXtyYW5nZT1mdW5jdGlvbihub2RlLHN0YXJ0LGVuZCxlbmROb2RlKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO3Iuc2V0RW5kKGVuZE5vZGV8fG5vZGUsZW5kKTtyLnNldFN0YXJ0KG5vZGUsc3RhcnQpO3JldHVybiByO307fWVsc2V7cmFuZ2U9ZnVuY3Rpb24obm9kZSxzdGFydCxlbmQpe3ZhciByPWRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7dHJ5e3IubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTt9Y2F0Y2goZSl7cmV0dXJuIHI7fXIuY29sbGFwc2UodHJ1ZSk7ci5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsZW5kKTtyLm1vdmVTdGFydChcImNoYXJhY3RlclwiLHN0YXJ0KTtyZXR1cm4gcjt9O31mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsY2hpbGQpe2lmKGNoaWxkLm5vZGVUeXBlPT0zKS8vIEFuZHJvaWQgYnJvd3NlciBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGNoaWxkIGlzIGEgdGV4dG5vZGVcbntjaGlsZD1jaGlsZC5wYXJlbnROb2RlO31pZihwYXJlbnQuY29udGFpbnMpe3JldHVybiBwYXJlbnQuY29udGFpbnMoY2hpbGQpO31kb3tpZihjaGlsZC5ub2RlVHlwZT09MTEpe2NoaWxkPWNoaWxkLmhvc3Q7fWlmKGNoaWxkPT1wYXJlbnQpe3JldHVybiB0cnVlO319d2hpbGUoY2hpbGQ9Y2hpbGQucGFyZW50Tm9kZSk7fXZhciBhY3RpdmVFbHQ9ZnVuY3Rpb24oKXt2YXIgYWN0aXZlRWxlbWVudD1kb2N1bWVudC5hY3RpdmVFbGVtZW50O3doaWxlKGFjdGl2ZUVsZW1lbnQmJmFjdGl2ZUVsZW1lbnQucm9vdCYmYWN0aXZlRWxlbWVudC5yb290LmFjdGl2ZUVsZW1lbnQpe2FjdGl2ZUVsZW1lbnQ9YWN0aXZlRWxlbWVudC5yb290LmFjdGl2ZUVsZW1lbnQ7fXJldHVybiBhY3RpdmVFbGVtZW50O307Ly8gT2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhyb3dzIHVuc3BlY2lmaWVkIGVycm9yIHdoZW4gdG91Y2hpbmdcbi8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gc29tZSBjYXNlcyAoZHVyaW5nIGxvYWRpbmcsIGluIGlmcmFtZSlcbmlmKGllJiZpZV92ZXJzaW9uPDExKXthY3RpdmVFbHQ9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7fWNhdGNoKGUpe3JldHVybiBkb2N1bWVudC5ib2R5O319O31mdW5jdGlvbiBhZGRDbGFzcyhub2RlLGNscyl7dmFyIGN1cnJlbnQ9bm9kZS5jbGFzc05hbWU7aWYoIWNsYXNzVGVzdChjbHMpLnRlc3QoY3VycmVudCkpe25vZGUuY2xhc3NOYW1lKz0oY3VycmVudD9cIiBcIjpcIlwiKStjbHM7fX1mdW5jdGlvbiBqb2luQ2xhc3NlcyhhLGIpe3ZhciBhcz1hLnNwbGl0KFwiIFwiKTtmb3IodmFyIGk9MDtpPGFzLmxlbmd0aDtpKyspe2lmKGFzW2ldJiYhY2xhc3NUZXN0KGFzW2ldKS50ZXN0KGIpKXtiKz1cIiBcIithc1tpXTt9fXJldHVybiBiO312YXIgc2VsZWN0SW5wdXQ9ZnVuY3Rpb24obm9kZSl7bm9kZS5zZWxlY3QoKTt9O2lmKGlvcykvLyBNb2JpbGUgU2FmYXJpIGFwcGFyZW50bHkgaGFzIGEgYnVnIHdoZXJlIHNlbGVjdCgpIGlzIGJyb2tlbi5cbntzZWxlY3RJbnB1dD1mdW5jdGlvbihub2RlKXtub2RlLnNlbGVjdGlvblN0YXJ0PTA7bm9kZS5zZWxlY3Rpb25FbmQ9bm9kZS52YWx1ZS5sZW5ndGg7fTt9ZWxzZSBpZihpZSkvLyBTdXBwcmVzcyBteXN0ZXJpb3VzIElFMTAgZXJyb3JzXG57c2VsZWN0SW5wdXQ9ZnVuY3Rpb24obm9kZSl7dHJ5e25vZGUuc2VsZWN0KCk7fWNhdGNoKF9lKXt9fTt9ZnVuY3Rpb24gYmluZChmKXt2YXIgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTt9O31mdW5jdGlvbiBjb3B5T2JqKG9iaix0YXJnZXQsb3ZlcndyaXRlKXtpZighdGFyZ2V0KXt0YXJnZXQ9e307fWZvcih2YXIgcHJvcCBpbiBvYmope2lmKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSYmKG92ZXJ3cml0ZSE9PWZhbHNlfHwhdGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3ApKSl7dGFyZ2V0W3Byb3BdPW9ialtwcm9wXTt9fXJldHVybiB0YXJnZXQ7fS8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZyxlbmQsdGFiU2l6ZSxzdGFydEluZGV4LHN0YXJ0VmFsdWUpe2lmKGVuZD09bnVsbCl7ZW5kPXN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtpZihlbmQ9PS0xKXtlbmQ9c3RyaW5nLmxlbmd0aDt9fWZvcih2YXIgaT1zdGFydEluZGV4fHwwLG49c3RhcnRWYWx1ZXx8MDs7KXt2YXIgbmV4dFRhYj1zdHJpbmcuaW5kZXhPZihcIlxcdFwiLGkpO2lmKG5leHRUYWI8MHx8bmV4dFRhYj49ZW5kKXtyZXR1cm4gbisoZW5kLWkpO31uKz1uZXh0VGFiLWk7bis9dGFiU2l6ZS1uJXRhYlNpemU7aT1uZXh0VGFiKzE7fX1mdW5jdGlvbiBEZWxheWVkKCl7dGhpcy5pZD1udWxsO31EZWxheWVkLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24obXMsZil7Y2xlYXJUaW1lb3V0KHRoaXMuaWQpO3RoaXMuaWQ9c2V0VGltZW91dChmLG1zKTt9O2Z1bmN0aW9uIGluZGV4T2YoYXJyYXksZWx0KXtmb3IodmFyIGk9MDtpPGFycmF5Lmxlbmd0aDsrK2kpe2lmKGFycmF5W2ldPT1lbHQpe3JldHVybiBpO319cmV0dXJuLTE7fS8vIE51bWJlciBvZiBwaXhlbHMgYWRkZWQgdG8gc2Nyb2xsZXIgYW5kIHNpemVyIHRvIGhpZGUgc2Nyb2xsYmFyXG52YXIgc2Nyb2xsZXJHYXA9MzA7Ly8gUmV0dXJuZWQgb3IgdGhyb3duIGJ5IHZhcmlvdXMgcHJvdG9jb2xzIHRvIHNpZ25hbCAnSSdtIG5vdFxuLy8gaGFuZGxpbmcgdGhpcycuXG52YXIgUGFzcz17dG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkNvZGVNaXJyb3IuUGFzc1wiO319Oy8vIFJldXNlZCBvcHRpb24gb2JqZWN0cyBmb3Igc2V0U2VsZWN0aW9uICYgZnJpZW5kc1xudmFyIHNlbF9kb250U2Nyb2xsPXtzY3JvbGw6ZmFsc2V9O3ZhciBzZWxfbW91c2U9e29yaWdpbjpcIiptb3VzZVwifTt2YXIgc2VsX21vdmU9e29yaWdpbjpcIittb3ZlXCJ9Oy8vIFRoZSBpbnZlcnNlIG9mIGNvdW50Q29sdW1uIC0tIGZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvXG4vLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsZ29hbCx0YWJTaXplKXtmb3IodmFyIHBvcz0wLGNvbD0wOzspe3ZhciBuZXh0VGFiPXN0cmluZy5pbmRleE9mKFwiXFx0XCIscG9zKTtpZihuZXh0VGFiPT0tMSl7bmV4dFRhYj1zdHJpbmcubGVuZ3RoO312YXIgc2tpcHBlZD1uZXh0VGFiLXBvcztpZihuZXh0VGFiPT1zdHJpbmcubGVuZ3RofHxjb2wrc2tpcHBlZD49Z29hbCl7cmV0dXJuIHBvcytNYXRoLm1pbihza2lwcGVkLGdvYWwtY29sKTt9Y29sKz1uZXh0VGFiLXBvcztjb2wrPXRhYlNpemUtY29sJXRhYlNpemU7cG9zPW5leHRUYWIrMTtpZihjb2w+PWdvYWwpe3JldHVybiBwb3M7fX19dmFyIHNwYWNlU3Rycz1bXCJcIl07ZnVuY3Rpb24gc3BhY2VTdHIobil7d2hpbGUoc3BhY2VTdHJzLmxlbmd0aDw9bil7c3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykrXCIgXCIpO31yZXR1cm4gc3BhY2VTdHJzW25dO31mdW5jdGlvbiBsc3QoYXJyKXtyZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV07fWZ1bmN0aW9uIG1hcChhcnJheSxmKXt2YXIgb3V0PVtdO2Zvcih2YXIgaT0wO2k8YXJyYXkubGVuZ3RoO2krKyl7b3V0W2ldPWYoYXJyYXlbaV0saSk7fXJldHVybiBvdXQ7fWZ1bmN0aW9uIGluc2VydFNvcnRlZChhcnJheSx2YWx1ZSxzY29yZSl7dmFyIHBvcz0wLHByaW9yaXR5PXNjb3JlKHZhbHVlKTt3aGlsZShwb3M8YXJyYXkubGVuZ3RoJiZzY29yZShhcnJheVtwb3NdKTw9cHJpb3JpdHkpe3BvcysrO31hcnJheS5zcGxpY2UocG9zLDAsdmFsdWUpO31mdW5jdGlvbiBub3RoaW5nKCl7fWZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLHByb3BzKXt2YXIgaW5zdDtpZihPYmplY3QuY3JlYXRlKXtpbnN0PU9iamVjdC5jcmVhdGUoYmFzZSk7fWVsc2V7bm90aGluZy5wcm90b3R5cGU9YmFzZTtpbnN0PW5ldyBub3RoaW5nKCk7fWlmKHByb3BzKXtjb3B5T2JqKHByb3BzLGluc3QpO31yZXR1cm4gaW5zdDt9dmFyIG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyPS9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztmdW5jdGlvbiBpc1dvcmRDaGFyQmFzaWMoY2gpe3JldHVybiAvXFx3Ly50ZXN0KGNoKXx8Y2g+XCJcXHg4MFwiJiYoY2gudG9VcHBlckNhc2UoKSE9Y2gudG9Mb3dlckNhc2UoKXx8bm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpO31mdW5jdGlvbiBpc1dvcmRDaGFyKGNoLGhlbHBlcil7aWYoIWhlbHBlcil7cmV0dXJuIGlzV29yZENoYXJCYXNpYyhjaCk7fWlmKGhlbHBlci5zb3VyY2UuaW5kZXhPZihcIlxcXFx3XCIpPi0xJiZpc1dvcmRDaGFyQmFzaWMoY2gpKXtyZXR1cm4gdHJ1ZTt9cmV0dXJuIGhlbHBlci50ZXN0KGNoKTt9ZnVuY3Rpb24gaXNFbXB0eShvYmope2Zvcih2YXIgbiBpbiBvYmope2lmKG9iai5oYXNPd25Qcm9wZXJ0eShuKSYmb2JqW25dKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9Ly8gRXh0ZW5kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy4gQSBzZXJpZXMgb2YgYSBub24tZXh0ZW5kaW5nIGNoYXIgK1xuLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxuLy8gYXMgZWRpdGluZyBhbmQgbWVhc3VyaW5nIGlzIGNvbmNlcm5lZC4gVGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCxcbi8vIHNpbmNlIHNvbWUgc2NyaXB0cy9mb250cy9icm93c2VycyBhbHNvIHRyZWF0IG90aGVyIGNvbmZpZ3VyYXRpb25zXG4vLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxudmFyIGV4dGVuZGluZ0NoYXJzPS9bXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjVlXFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGUtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA5MDAtXFx1MDkwMlxcdTA5M2NcXHUwOTQxLVxcdTA5NDhcXHUwOTRkXFx1MDk1MS1cXHUwOTU1XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDliY1xcdTA5YmVcXHUwOWMxLVxcdTA5YzRcXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MGEwMVxcdTBhMDJcXHUwYTNjXFx1MGE0MVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTcwXFx1MGE3MVxcdTBhNzVcXHUwYTgxXFx1MGE4MlxcdTBhYmNcXHUwYWMxLVxcdTBhYzVcXHUwYWM3XFx1MGFjOFxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBiMDFcXHUwYjNjXFx1MGIzZVxcdTBiM2ZcXHUwYjQxLVxcdTBiNDRcXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiODJcXHUwYmJlXFx1MGJjMFxcdTBiY2RcXHUwYmQ3XFx1MGMzZS1cXHUwYzQwXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjYmNcXHUwY2JmXFx1MGNjMlxcdTBjYzZcXHUwY2NjXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwZDNlXFx1MGQ0MS1cXHUwZDQ0XFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkY2FcXHUwZGNmXFx1MGRkMi1cXHUwZGQ0XFx1MGRkNlxcdTBkZGZcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGYxOFxcdTBmMTlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjcxLVxcdTBmN2VcXHUwZjgwLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOTAtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJkLVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzYVxcdTEwM2RcXHUxMDNlXFx1MTA1OFxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhkXFx1MTA5ZFxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNy1cXHUxN2JkXFx1MTdjNlxcdTE3YzktXFx1MTdkM1xcdTE3ZGRcXHUxODBiLVxcdTE4MGRcXHUxOGE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNiXFx1MWExN1xcdTFhMThcXHUxYTU2XFx1MWE1OC1cXHUxYTVlXFx1MWE2MFxcdTFhNjJcXHUxYTY1LVxcdTFhNmNcXHUxYTczLVxcdTFhN2NcXHUxYTdmXFx1MWIwMC1cXHUxYjAzXFx1MWIzNFxcdTFiMzYtXFx1MWIzYVxcdTFiM2NcXHUxYjQyXFx1MWI2Yi1cXHUxYjczXFx1MWI4MFxcdTFiODFcXHUxYmEyLVxcdTFiYTVcXHUxYmE4XFx1MWJhOVxcdTFjMmMtXFx1MWMzM1xcdTFjMzZcXHUxYzM3XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2UwXFx1MWNlMi1cXHUxY2U4XFx1MWNlZFxcdTFkYzAtXFx1MWRlNlxcdTFkZmQtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjBkMC1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjZmLVxcdWE2NzJcXHVhNjdjXFx1YTY3ZFxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyNVxcdWE4MjZcXHVhOGM0XFx1YThlMC1cXHVhOGYxXFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUxXFx1YTk4MC1cXHVhOTgyXFx1YTliM1xcdWE5YjYtXFx1YTliOVxcdWE5YmNcXHVhYTI5LVxcdWFhMmVcXHVhYTMxXFx1YWEzMlxcdWFhMzVcXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYmU1XFx1YWJlOFxcdWFiZWRcXHVkYzAwLVxcdWRmZmZcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmY5ZVxcdWZmOWZdLztmdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY2gpe3JldHVybiBjaC5jaGFyQ29kZUF0KDApPj03NjgmJmV4dGVuZGluZ0NoYXJzLnRlc3QoY2gpO30vLyBUaGUgZGlzcGxheSBoYW5kbGVzIHRoZSBET00gaW50ZWdyYXRpb24sIGJvdGggZm9yIGlucHV0IHJlYWRpbmdcbi8vIGFuZCBjb250ZW50IGRyYXdpbmcuIEl0IGhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIG5vZGVzIGFuZFxuLy8gZGlzcGxheS1yZWxhdGVkIHN0YXRlLlxuZnVuY3Rpb24gRGlzcGxheShwbGFjZSxkb2MsaW5wdXQpe3ZhciBkPXRoaXM7dGhpcy5pbnB1dD1pbnB1dDsvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cbmQuc2Nyb2xsYmFyRmlsbGVyPWVsdChcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcIik7ZC5zY3JvbGxiYXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIixcInRydWVcIik7Ly8gQ292ZXJzIGJvdHRvbSBvZiBndXR0ZXIgd2hlbiBjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciBpcyBvblxuLy8gYW5kIGggc2Nyb2xsYmFyIGlzIHByZXNlbnQuXG5kLmd1dHRlckZpbGxlcj1lbHQoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXCIpO2QuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsXCJ0cnVlXCIpOy8vIFdpbGwgY29udGFpbiB0aGUgYWN0dWFsIGNvZGUsIHBvc2l0aW9uZWQgdG8gY292ZXIgdGhlIHZpZXdwb3J0LlxuZC5saW5lRGl2PWVsdChcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWNvZGVcIik7Ly8gRWxlbWVudHMgYXJlIGFkZGVkIHRvIHRoZXNlIHRvIHJlcHJlc2VudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMuXG5kLnNlbGVjdGlvbkRpdj1lbHQoXCJkaXZcIixudWxsLG51bGwsXCJwb3NpdGlvbjogcmVsYXRpdmU7IHotaW5kZXg6IDFcIik7ZC5jdXJzb3JEaXY9ZWx0KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItY3Vyc29yc1wiKTsvLyBBIHZpc2liaWxpdHk6IGhpZGRlbiBlbGVtZW50IHVzZWQgdG8gZmluZCB0aGUgc2l6ZSBvZiB0aGluZ3MuXG5kLm1lYXN1cmU9ZWx0KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTsvLyBXaGVuIGxpbmVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGFyZSBtZWFzdXJlZCwgdGhleSBhcmUgZHJhd24gaW4gdGhpcy5cbmQubGluZU1lYXN1cmU9ZWx0KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTsvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxuZC5saW5lU3BhY2U9ZWx0KFwiZGl2XCIsW2QubWVhc3VyZSxkLmxpbmVNZWFzdXJlLGQuc2VsZWN0aW9uRGl2LGQuY3Vyc29yRGl2LGQubGluZURpdl0sbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZTsgb3V0bGluZTogbm9uZVwiKTsvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXG5kLm1vdmVyPWVsdChcImRpdlwiLFtlbHQoXCJkaXZcIixbZC5saW5lU3BhY2VdLFwiQ29kZU1pcnJvci1saW5lc1wiKV0sbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTsvLyBTZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQsIGFsbG93aW5nIHNjcm9sbGluZy5cbmQuc2l6ZXI9ZWx0KFwiZGl2XCIsW2QubW92ZXJdLFwiQ29kZU1pcnJvci1zaXplclwiKTtkLnNpemVyV2lkdGg9bnVsbDsvLyBCZWhhdmlvciBvZiBlbHRzIHdpdGggb3ZlcmZsb3c6IGF1dG8gYW5kIHBhZGRpbmcgaXNcbi8vIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhlXG4vLyBzY3JvbGxhYmxlIGFyZWEgaXMgYmlnIGVub3VnaC5cbmQuaGVpZ2h0Rm9yY2VyPWVsdChcImRpdlwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiBcIitzY3JvbGxlckdhcCtcInB4OyB3aWR0aDogMXB4O1wiKTsvLyBXaWxsIGNvbnRhaW4gdGhlIGd1dHRlcnMsIGlmIGFueS5cbmQuZ3V0dGVycz1lbHQoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1ndXR0ZXJzXCIpO2QubGluZUd1dHRlcj1udWxsOy8vIEFjdHVhbCBzY3JvbGxhYmxlIGVsZW1lbnQuXG5kLnNjcm9sbGVyPWVsdChcImRpdlwiLFtkLnNpemVyLGQuaGVpZ2h0Rm9yY2VyLGQuZ3V0dGVyc10sXCJDb2RlTWlycm9yLXNjcm9sbFwiKTtkLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsXCItMVwiKTsvLyBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLlxuZC53cmFwcGVyPWVsdChcImRpdlwiLFtkLnNjcm9sbGJhckZpbGxlcixkLmd1dHRlckZpbGxlcixkLnNjcm9sbGVyXSxcIkNvZGVNaXJyb3JcIik7Ly8gV29yayBhcm91bmQgSUU3IHotaW5kZXggYnVnIChub3QgcGVyZmVjdCwgaGVuY2UgSUU3IG5vdCByZWFsbHkgYmVpbmcgc3VwcG9ydGVkKVxuaWYoaWUmJmllX3ZlcnNpb248OCl7ZC5ndXR0ZXJzLnN0eWxlLnpJbmRleD0tMTtkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodD0wO31pZighd2Via2l0JiYhKGdlY2tvJiZtb2JpbGUpKXtkLnNjcm9sbGVyLmRyYWdnYWJsZT10cnVlO31pZihwbGFjZSl7aWYocGxhY2UuYXBwZW5kQ2hpbGQpe3BsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcik7fWVsc2V7cGxhY2UoZC53cmFwcGVyKTt9fS8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxuZC52aWV3RnJvbT1kLnZpZXdUbz1kb2MuZmlyc3Q7ZC5yZXBvcnRlZFZpZXdGcm9tPWQucmVwb3J0ZWRWaWV3VG89ZG9jLmZpcnN0Oy8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cbmQudmlldz1bXTtkLnJlbmRlcmVkVmlldz1udWxsOy8vIEhvbGRzIGluZm8gYWJvdXQgYSBzaW5nbGUgcmVuZGVyZWQgbGluZSB3aGVuIGl0IHdhcyByZW5kZXJlZFxuLy8gZm9yIG1lYXN1cmVtZW50LCB3aGlsZSBub3QgaW4gdmlldy5cbmQuZXh0ZXJuYWxNZWFzdXJlZD1udWxsOy8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XG5kLnZpZXdPZmZzZXQ9MDtkLmxhc3RXcmFwSGVpZ2h0PWQubGFzdFdyYXBXaWR0aD0wO2QudXBkYXRlTGluZU51bWJlcnM9bnVsbDtkLm5hdGl2ZUJhcldpZHRoPWQuYmFySGVpZ2h0PWQuYmFyV2lkdGg9MDtkLnNjcm9sbGJhcnNDbGlwcGVkPWZhbHNlOy8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxuLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBjcm9zc2VzIGEgYm91bmRhcnkgdGhhdCBtYWtlcyBpdHMgd2lkdGggY2hhbmdlKVxuZC5saW5lTnVtV2lkdGg9ZC5saW5lTnVtSW5uZXJXaWR0aD1kLmxpbmVOdW1DaGFycz1udWxsOy8vIFNldCB0byB0cnVlIHdoZW4gYSBub24taG9yaXpvbnRhbC1zY3JvbGxpbmcgbGluZSB3aWRnZXQgaXNcbi8vIGFkZGVkLiBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmUgd2lkZ2V0IGFsaWduaW5nIGlzIHNraXBwZWQgd2hlblxuLy8gdGhpcyBpcyBmYWxzZS5cbmQuYWxpZ25XaWRnZXRzPWZhbHNlO2QuY2FjaGVkQ2hhcldpZHRoPWQuY2FjaGVkVGV4dEhlaWdodD1kLmNhY2hlZFBhZGRpbmdIPW51bGw7Ly8gVHJhY2tzIHRoZSBtYXhpbXVtIGxpbmUgbGVuZ3RoIHNvIHRoYXQgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyXG4vLyBjYW4gYmUga2VwdCBzdGF0aWMgd2hlbiBzY3JvbGxpbmcuXG5kLm1heExpbmU9bnVsbDtkLm1heExpbmVMZW5ndGg9MDtkLm1heExpbmVDaGFuZ2VkPWZhbHNlOy8vIFVzZWQgZm9yIG1lYXN1cmluZyB3aGVlbCBzY3JvbGxpbmcgZ3JhbnVsYXJpdHlcbmQud2hlZWxEWD1kLndoZWVsRFk9ZC53aGVlbFN0YXJ0WD1kLndoZWVsU3RhcnRZPW51bGw7Ly8gVHJ1ZSB3aGVuIHNoaWZ0IGlzIGhlbGQgZG93bi5cbmQuc2hpZnQ9ZmFsc2U7Ly8gVXNlZCB0byB0cmFjayB3aGV0aGVyIGFueXRoaW5nIGhhcHBlbmVkIHNpbmNlIHRoZSBjb250ZXh0IG1lbnVcbi8vIHdhcyBvcGVuZWQuXG5kLnNlbEZvckNvbnRleHRNZW51PW51bGw7ZC5hY3RpdmVUb3VjaD1udWxsO2lucHV0LmluaXQoZCk7fS8vIEZpbmQgdGhlIGxpbmUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuZnVuY3Rpb24gZ2V0TGluZShkb2Msbil7bi09ZG9jLmZpcnN0O2lmKG48MHx8bj49ZG9jLnNpemUpe3Rocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIrKG4rZG9jLmZpcnN0KStcIiBpbiB0aGUgZG9jdW1lbnQuXCIpO312YXIgY2h1bms9ZG9jO3doaWxlKCFjaHVuay5saW5lcyl7Zm9yKHZhciBpPTA7OysraSl7dmFyIGNoaWxkPWNodW5rLmNoaWxkcmVuW2ldLHN6PWNoaWxkLmNodW5rU2l6ZSgpO2lmKG48c3ope2NodW5rPWNoaWxkO2JyZWFrO31uLT1zejt9fXJldHVybiBjaHVuay5saW5lc1tuXTt9Ly8gR2V0IHRoZSBwYXJ0IG9mIGEgZG9jdW1lbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLCBhcyBhbiBhcnJheSBvZlxuLy8gc3RyaW5ncy5cbmZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLHN0YXJ0LGVuZCl7dmFyIG91dD1bXSxuPXN0YXJ0LmxpbmU7ZG9jLml0ZXIoc3RhcnQubGluZSxlbmQubGluZSsxLGZ1bmN0aW9uKGxpbmUpe3ZhciB0ZXh0PWxpbmUudGV4dDtpZihuPT1lbmQubGluZSl7dGV4dD10ZXh0LnNsaWNlKDAsZW5kLmNoKTt9aWYobj09c3RhcnQubGluZSl7dGV4dD10ZXh0LnNsaWNlKHN0YXJ0LmNoKTt9b3V0LnB1c2godGV4dCk7KytuO30pO3JldHVybiBvdXQ7fS8vIEdldCB0aGUgbGluZXMgYmV0d2VlbiBmcm9tIGFuZCB0bywgYXMgYXJyYXkgb2Ygc3RyaW5ncy5cbmZ1bmN0aW9uIGdldExpbmVzKGRvYyxmcm9tLHRvKXt2YXIgb3V0PVtdO2RvYy5pdGVyKGZyb20sdG8sZnVuY3Rpb24obGluZSl7b3V0LnB1c2gobGluZS50ZXh0KTt9KTsvLyBpdGVyIGFib3J0cyB3aGVuIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5IHZhbHVlXG5yZXR1cm4gb3V0O30vLyBVcGRhdGUgdGhlIGhlaWdodCBvZiBhIGxpbmUsIHByb3BhZ2F0aW5nIHRoZSBoZWlnaHQgY2hhbmdlXG4vLyB1cHdhcmRzIHRvIHBhcmVudCBub2Rlcy5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmVIZWlnaHQobGluZSxoZWlnaHQpe3ZhciBkaWZmPWhlaWdodC1saW5lLmhlaWdodDtpZihkaWZmKXtmb3IodmFyIG49bGluZTtuO249bi5wYXJlbnQpe24uaGVpZ2h0Kz1kaWZmO319fS8vIEdpdmVuIGEgbGluZSBvYmplY3QsIGZpbmQgaXRzIGxpbmUgbnVtYmVyIGJ5IHdhbGtpbmcgdXAgdGhyb3VnaFxuLy8gaXRzIHBhcmVudCBsaW5rcy5cbmZ1bmN0aW9uIGxpbmVObyhsaW5lKXtpZihsaW5lLnBhcmVudD09bnVsbCl7cmV0dXJuIG51bGw7fXZhciBjdXI9bGluZS5wYXJlbnQsbm89aW5kZXhPZihjdXIubGluZXMsbGluZSk7Zm9yKHZhciBjaHVuaz1jdXIucGFyZW50O2NodW5rO2N1cj1jaHVuayxjaHVuaz1jaHVuay5wYXJlbnQpe2Zvcih2YXIgaT0wOzsrK2kpe2lmKGNodW5rLmNoaWxkcmVuW2ldPT1jdXIpe2JyZWFrO31ubys9Y2h1bmsuY2hpbGRyZW5baV0uY2h1bmtTaXplKCk7fX1yZXR1cm4gbm8rY3VyLmZpcnN0O30vLyBGaW5kIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbiwgdXNpbmcgdGhlIGhlaWdodFxuLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXG5mdW5jdGlvbiBsaW5lQXRIZWlnaHQoY2h1bmssaCl7dmFyIG49Y2h1bmsuZmlyc3Q7b3V0ZXI6ZG97Zm9yKHZhciBpJDE9MDtpJDE8Y2h1bmsuY2hpbGRyZW4ubGVuZ3RoOysraSQxKXt2YXIgY2hpbGQ9Y2h1bmsuY2hpbGRyZW5baSQxXSxjaD1jaGlsZC5oZWlnaHQ7aWYoaDxjaCl7Y2h1bms9Y2hpbGQ7Y29udGludWUgb3V0ZXI7fWgtPWNoO24rPWNoaWxkLmNodW5rU2l6ZSgpO31yZXR1cm4gbjt9d2hpbGUoIWNodW5rLmxpbmVzKTt2YXIgaT0wO2Zvcig7aTxjaHVuay5saW5lcy5sZW5ndGg7KytpKXt2YXIgbGluZT1jaHVuay5saW5lc1tpXSxsaD1saW5lLmhlaWdodDtpZihoPGxoKXticmVhazt9aC09bGg7fXJldHVybiBuK2k7fWZ1bmN0aW9uIGlzTGluZShkb2MsbCl7cmV0dXJuIGw+PWRvYy5maXJzdCYmbDxkb2MuZmlyc3QrZG9jLnNpemU7fWZ1bmN0aW9uIGxpbmVOdW1iZXJGb3Iob3B0aW9ucyxpKXtyZXR1cm4gU3RyaW5nKG9wdGlvbnMubGluZU51bWJlckZvcm1hdHRlcihpK29wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSk7fS8vIEEgUG9zIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRleHQuXG5mdW5jdGlvbiBQb3MobGluZSxjaCl7aWYoISh0aGlzIGluc3RhbmNlb2YgUG9zKSl7cmV0dXJuIG5ldyBQb3MobGluZSxjaCk7fXRoaXMubGluZT1saW5lO3RoaXMuY2g9Y2g7fS8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcbi8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cbmZ1bmN0aW9uIGNtcChhLGIpe3JldHVybiBhLmxpbmUtYi5saW5lfHxhLmNoLWIuY2g7fWZ1bmN0aW9uIGNvcHlQb3MoeCl7cmV0dXJuIFBvcyh4LmxpbmUseC5jaCk7fWZ1bmN0aW9uIG1heFBvcyhhLGIpe3JldHVybiBjbXAoYSxiKTwwP2I6YTt9ZnVuY3Rpb24gbWluUG9zKGEsYil7cmV0dXJuIGNtcChhLGIpPDA/YTpiO30vLyBNb3N0IG9mIHRoZSBleHRlcm5hbCBBUEkgY2xpcHMgZ2l2ZW4gcG9zaXRpb25zIHRvIG1ha2Ugc3VyZSB0aGV5XG4vLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gY2xpcExpbmUoZG9jLG4pe3JldHVybiBNYXRoLm1heChkb2MuZmlyc3QsTWF0aC5taW4obixkb2MuZmlyc3QrZG9jLnNpemUtMSkpO31mdW5jdGlvbiBjbGlwUG9zKGRvYyxwb3Mpe2lmKHBvcy5saW5lPGRvYy5maXJzdCl7cmV0dXJuIFBvcyhkb2MuZmlyc3QsMCk7fXZhciBsYXN0PWRvYy5maXJzdCtkb2Muc2l6ZS0xO2lmKHBvcy5saW5lPmxhc3Qpe3JldHVybiBQb3MobGFzdCxnZXRMaW5lKGRvYyxsYXN0KS50ZXh0Lmxlbmd0aCk7fXJldHVybiBjbGlwVG9MZW4ocG9zLGdldExpbmUoZG9jLHBvcy5saW5lKS50ZXh0Lmxlbmd0aCk7fWZ1bmN0aW9uIGNsaXBUb0xlbihwb3MsbGluZWxlbil7dmFyIGNoPXBvcy5jaDtpZihjaD09bnVsbHx8Y2g+bGluZWxlbil7cmV0dXJuIFBvcyhwb3MubGluZSxsaW5lbGVuKTt9ZWxzZSBpZihjaDwwKXtyZXR1cm4gUG9zKHBvcy5saW5lLDApO31lbHNle3JldHVybiBwb3M7fX1mdW5jdGlvbiBjbGlwUG9zQXJyYXkoZG9jLGFycmF5KXt2YXIgb3V0PVtdO2Zvcih2YXIgaT0wO2k8YXJyYXkubGVuZ3RoO2krKyl7b3V0W2ldPWNsaXBQb3MoZG9jLGFycmF5W2ldKTt9cmV0dXJuIG91dDt9Ly8gT3B0aW1pemUgc29tZSBjb2RlIHdoZW4gdGhlc2UgZmVhdHVyZXMgYXJlIG5vdCB1c2VkLlxudmFyIHNhd1JlYWRPbmx5U3BhbnM9ZmFsc2U7dmFyIHNhd0NvbGxhcHNlZFNwYW5zPWZhbHNlO2Z1bmN0aW9uIHNlZVJlYWRPbmx5U3BhbnMoKXtzYXdSZWFkT25seVNwYW5zPXRydWU7fWZ1bmN0aW9uIHNlZUNvbGxhcHNlZFNwYW5zKCl7c2F3Q29sbGFwc2VkU3BhbnM9dHJ1ZTt9Ly8gVEVYVE1BUktFUiBTUEFOU1xuZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsZnJvbSx0byl7dGhpcy5tYXJrZXI9bWFya2VyO3RoaXMuZnJvbT1mcm9tO3RoaXMudG89dG87fS8vIFNlYXJjaCBhbiBhcnJheSBvZiBzcGFucyBmb3IgYSBzcGFuIG1hdGNoaW5nIHRoZSBnaXZlbiBtYXJrZXIuXG5mdW5jdGlvbiBnZXRNYXJrZWRTcGFuRm9yKHNwYW5zLG1hcmtlcil7aWYoc3BhbnMpe2Zvcih2YXIgaT0wO2k8c3BhbnMubGVuZ3RoOysraSl7dmFyIHNwYW49c3BhbnNbaV07aWYoc3Bhbi5tYXJrZXI9PW1hcmtlcil7cmV0dXJuIHNwYW47fX19fS8vIFJlbW92ZSBhIHNwYW4gZnJvbSBhbiBhcnJheSwgcmV0dXJuaW5nIHVuZGVmaW5lZCBpZiBubyBzcGFucyBhcmVcbi8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXG5mdW5jdGlvbiByZW1vdmVNYXJrZWRTcGFuKHNwYW5zLHNwYW4pe3ZhciByO2Zvcih2YXIgaT0wO2k8c3BhbnMubGVuZ3RoOysraSl7aWYoc3BhbnNbaV0hPXNwYW4peyhyfHwocj1bXSkpLnB1c2goc3BhbnNbaV0pO319cmV0dXJuIHI7fS8vIEFkZCBhIHNwYW4gdG8gYSBsaW5lLlxuZnVuY3Rpb24gYWRkTWFya2VkU3BhbihsaW5lLHNwYW4pe2xpbmUubWFya2VkU3BhbnM9bGluZS5tYXJrZWRTcGFucz9saW5lLm1hcmtlZFNwYW5zLmNvbmNhdChbc3Bhbl0pOltzcGFuXTtzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpO30vLyBVc2VkIGZvciB0aGUgYWxnb3JpdGhtIHRoYXQgYWRqdXN0cyBtYXJrZXJzIGZvciBhIGNoYW5nZSBpbiB0aGVcbi8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cbi8vIGNoYXJhY3RlciBwb3NpdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHJlbWFpbmluZyBjaHVua3MgKG9yXG4vLyB1bmRlZmluZWQgaWYgbm90aGluZyByZW1haW5zKS5cbmZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCxzdGFydENoLGlzSW5zZXJ0KXt2YXIgbnc7aWYob2xkKXtmb3IodmFyIGk9MDtpPG9sZC5sZW5ndGg7KytpKXt2YXIgc3Bhbj1vbGRbaV0sbWFya2VyPXNwYW4ubWFya2VyO3ZhciBzdGFydHNCZWZvcmU9c3Bhbi5mcm9tPT1udWxsfHwobWFya2VyLmluY2x1c2l2ZUxlZnQ/c3Bhbi5mcm9tPD1zdGFydENoOnNwYW4uZnJvbTxzdGFydENoKTtpZihzdGFydHNCZWZvcmV8fHNwYW4uZnJvbT09c3RhcnRDaCYmbWFya2VyLnR5cGU9PVwiYm9va21hcmtcIiYmKCFpc0luc2VydHx8IXNwYW4ubWFya2VyLmluc2VydExlZnQpKXt2YXIgZW5kc0FmdGVyPXNwYW4udG89PW51bGx8fChtYXJrZXIuaW5jbHVzaXZlUmlnaHQ/c3Bhbi50bz49c3RhcnRDaDpzcGFuLnRvPnN0YXJ0Q2gpOyhud3x8KG53PVtdKSkucHVzaChuZXcgTWFya2VkU3BhbihtYXJrZXIsc3Bhbi5mcm9tLGVuZHNBZnRlcj9udWxsOnNwYW4udG8pKTt9fX1yZXR1cm4gbnc7fWZ1bmN0aW9uIG1hcmtlZFNwYW5zQWZ0ZXIob2xkLGVuZENoLGlzSW5zZXJ0KXt2YXIgbnc7aWYob2xkKXtmb3IodmFyIGk9MDtpPG9sZC5sZW5ndGg7KytpKXt2YXIgc3Bhbj1vbGRbaV0sbWFya2VyPXNwYW4ubWFya2VyO3ZhciBlbmRzQWZ0ZXI9c3Bhbi50bz09bnVsbHx8KG1hcmtlci5pbmNsdXNpdmVSaWdodD9zcGFuLnRvPj1lbmRDaDpzcGFuLnRvPmVuZENoKTtpZihlbmRzQWZ0ZXJ8fHNwYW4uZnJvbT09ZW5kQ2gmJm1hcmtlci50eXBlPT1cImJvb2ttYXJrXCImJighaXNJbnNlcnR8fHNwYW4ubWFya2VyLmluc2VydExlZnQpKXt2YXIgc3RhcnRzQmVmb3JlPXNwYW4uZnJvbT09bnVsbHx8KG1hcmtlci5pbmNsdXNpdmVMZWZ0P3NwYW4uZnJvbTw9ZW5kQ2g6c3Bhbi5mcm9tPGVuZENoKTsobnd8fChudz1bXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLHN0YXJ0c0JlZm9yZT9udWxsOnNwYW4uZnJvbS1lbmRDaCxzcGFuLnRvPT1udWxsP251bGw6c3Bhbi50by1lbmRDaCkpO319fXJldHVybiBudzt9Ly8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XG4vLyBjb3ZlciB0aGUgbGluZSBpbiB3aGljaCB0aGUgY2hhbmdlIHRvb2sgcGxhY2UuIFJlbW92ZXMgc3BhbnNcbi8vIGVudGlyZWx5IHdpdGhpbiB0aGUgY2hhbmdlLCByZWNvbm5lY3RzIHNwYW5zIGJlbG9uZ2luZyB0byB0aGVcbi8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXG4vLyBzcGFucyBwYXJ0aWFsbHkgd2l0aGluIHRoZSBjaGFuZ2UuIFJldHVybnMgYW4gYXJyYXkgb2Ygc3BhblxuLy8gYXJyYXlzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggbGluZSBpbiAoYWZ0ZXIpIHRoZSBjaGFuZ2UuXG5mdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYyxjaGFuZ2Upe2lmKGNoYW5nZS5mdWxsKXtyZXR1cm4gbnVsbDt9dmFyIG9sZEZpcnN0PWlzTGluZShkb2MsY2hhbmdlLmZyb20ubGluZSkmJmdldExpbmUoZG9jLGNoYW5nZS5mcm9tLmxpbmUpLm1hcmtlZFNwYW5zO3ZhciBvbGRMYXN0PWlzTGluZShkb2MsY2hhbmdlLnRvLmxpbmUpJiZnZXRMaW5lKGRvYyxjaGFuZ2UudG8ubGluZSkubWFya2VkU3BhbnM7aWYoIW9sZEZpcnN0JiYhb2xkTGFzdCl7cmV0dXJuIG51bGw7fXZhciBzdGFydENoPWNoYW5nZS5mcm9tLmNoLGVuZENoPWNoYW5nZS50by5jaCxpc0luc2VydD1jbXAoY2hhbmdlLmZyb20sY2hhbmdlLnRvKT09MDsvLyBHZXQgdGhlIHNwYW5zIHRoYXQgJ3N0aWNrIG91dCcgb24gYm90aCBzaWRlc1xudmFyIGZpcnN0PW1hcmtlZFNwYW5zQmVmb3JlKG9sZEZpcnN0LHN0YXJ0Q2gsaXNJbnNlcnQpO3ZhciBsYXN0PW1hcmtlZFNwYW5zQWZ0ZXIob2xkTGFzdCxlbmRDaCxpc0luc2VydCk7Ly8gTmV4dCwgbWVyZ2UgdGhvc2UgdHdvIGVuZHNcbnZhciBzYW1lTGluZT1jaGFuZ2UudGV4dC5sZW5ndGg9PTEsb2Zmc2V0PWxzdChjaGFuZ2UudGV4dCkubGVuZ3RoKyhzYW1lTGluZT9zdGFydENoOjApO2lmKGZpcnN0KXsvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcbmZvcih2YXIgaT0wO2k8Zmlyc3QubGVuZ3RoOysraSl7dmFyIHNwYW49Zmlyc3RbaV07aWYoc3Bhbi50bz09bnVsbCl7dmFyIGZvdW5kPWdldE1hcmtlZFNwYW5Gb3IobGFzdCxzcGFuLm1hcmtlcik7aWYoIWZvdW5kKXtzcGFuLnRvPXN0YXJ0Q2g7fWVsc2UgaWYoc2FtZUxpbmUpe3NwYW4udG89Zm91bmQudG89PW51bGw/bnVsbDpmb3VuZC50bytvZmZzZXQ7fX19fWlmKGxhc3Qpey8vIEZpeCB1cCAuZnJvbSBpbiBsYXN0IChvciBtb3ZlIHRoZW0gaW50byBmaXJzdCBpbiBjYXNlIG9mIHNhbWVMaW5lKVxuZm9yKHZhciBpJDE9MDtpJDE8bGFzdC5sZW5ndGg7KytpJDEpe3ZhciBzcGFuJDE9bGFzdFtpJDFdO2lmKHNwYW4kMS50byE9bnVsbCl7c3BhbiQxLnRvKz1vZmZzZXQ7fWlmKHNwYW4kMS5mcm9tPT1udWxsKXt2YXIgZm91bmQkMT1nZXRNYXJrZWRTcGFuRm9yKGZpcnN0LHNwYW4kMS5tYXJrZXIpO2lmKCFmb3VuZCQxKXtzcGFuJDEuZnJvbT1vZmZzZXQ7aWYoc2FtZUxpbmUpeyhmaXJzdHx8KGZpcnN0PVtdKSkucHVzaChzcGFuJDEpO319fWVsc2V7c3BhbiQxLmZyb20rPW9mZnNldDtpZihzYW1lTGluZSl7KGZpcnN0fHwoZmlyc3Q9W10pKS5wdXNoKHNwYW4kMSk7fX19fS8vIE1ha2Ugc3VyZSB3ZSBkaWRuJ3QgY3JlYXRlIGFueSB6ZXJvLWxlbmd0aCBzcGFuc1xuaWYoZmlyc3Qpe2ZpcnN0PWNsZWFyRW1wdHlTcGFucyhmaXJzdCk7fWlmKGxhc3QmJmxhc3QhPWZpcnN0KXtsYXN0PWNsZWFyRW1wdHlTcGFucyhsYXN0KTt9dmFyIG5ld01hcmtlcnM9W2ZpcnN0XTtpZighc2FtZUxpbmUpey8vIEZpbGwgZ2FwIHdpdGggd2hvbGUtbGluZS1zcGFuc1xudmFyIGdhcD1jaGFuZ2UudGV4dC5sZW5ndGgtMixnYXBNYXJrZXJzO2lmKGdhcD4wJiZmaXJzdCl7Zm9yKHZhciBpJDI9MDtpJDI8Zmlyc3QubGVuZ3RoOysraSQyKXtpZihmaXJzdFtpJDJdLnRvPT1udWxsKXsoZ2FwTWFya2Vyc3x8KGdhcE1hcmtlcnM9W10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKGZpcnN0W2kkMl0ubWFya2VyLG51bGwsbnVsbCkpO319fWZvcih2YXIgaSQzPTA7aSQzPGdhcDsrK2kkMyl7bmV3TWFya2Vycy5wdXNoKGdhcE1hcmtlcnMpO31uZXdNYXJrZXJzLnB1c2gobGFzdCk7fXJldHVybiBuZXdNYXJrZXJzO30vLyBSZW1vdmUgc3BhbnMgdGhhdCBhcmUgZW1wdHkgYW5kIGRvbid0IGhhdmUgYSBjbGVhcldoZW5FbXB0eVxuLy8gb3B0aW9uIG9mIGZhbHNlLlxuZnVuY3Rpb24gY2xlYXJFbXB0eVNwYW5zKHNwYW5zKXtmb3IodmFyIGk9MDtpPHNwYW5zLmxlbmd0aDsrK2kpe3ZhciBzcGFuPXNwYW5zW2ldO2lmKHNwYW4uZnJvbSE9bnVsbCYmc3Bhbi5mcm9tPT1zcGFuLnRvJiZzcGFuLm1hcmtlci5jbGVhcldoZW5FbXB0eSE9PWZhbHNlKXtzcGFucy5zcGxpY2UoaS0tLDEpO319aWYoIXNwYW5zLmxlbmd0aCl7cmV0dXJuIG51bGw7fXJldHVybiBzcGFuczt9Ly8gVXNlZCB0byAnY2xpcCcgb3V0IHJlYWRPbmx5IHJhbmdlcyB3aGVuIG1ha2luZyBhIGNoYW5nZS5cbmZ1bmN0aW9uIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYyxmcm9tLHRvKXt2YXIgbWFya2Vycz1udWxsO2RvYy5pdGVyKGZyb20ubGluZSx0by5saW5lKzEsZnVuY3Rpb24obGluZSl7aWYobGluZS5tYXJrZWRTcGFucyl7Zm9yKHZhciBpPTA7aTxsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsrK2kpe3ZhciBtYXJrPWxpbmUubWFya2VkU3BhbnNbaV0ubWFya2VyO2lmKG1hcmsucmVhZE9ubHkmJighbWFya2Vyc3x8aW5kZXhPZihtYXJrZXJzLG1hcmspPT0tMSkpeyhtYXJrZXJzfHwobWFya2Vycz1bXSkpLnB1c2gobWFyayk7fX19fSk7aWYoIW1hcmtlcnMpe3JldHVybiBudWxsO312YXIgcGFydHM9W3tmcm9tOmZyb20sdG86dG99XTtmb3IodmFyIGk9MDtpPG1hcmtlcnMubGVuZ3RoOysraSl7dmFyIG1rPW1hcmtlcnNbaV0sbT1tay5maW5kKDApO2Zvcih2YXIgaj0wO2o8cGFydHMubGVuZ3RoOysrail7dmFyIHA9cGFydHNbal07aWYoY21wKHAudG8sbS5mcm9tKTwwfHxjbXAocC5mcm9tLG0udG8pPjApe2NvbnRpbnVlO312YXIgbmV3UGFydHM9W2osMV0sZGZyb209Y21wKHAuZnJvbSxtLmZyb20pLGR0bz1jbXAocC50byxtLnRvKTtpZihkZnJvbTwwfHwhbWsuaW5jbHVzaXZlTGVmdCYmIWRmcm9tKXtuZXdQYXJ0cy5wdXNoKHtmcm9tOnAuZnJvbSx0bzptLmZyb219KTt9aWYoZHRvPjB8fCFtay5pbmNsdXNpdmVSaWdodCYmIWR0byl7bmV3UGFydHMucHVzaCh7ZnJvbTptLnRvLHRvOnAudG99KTt9cGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLG5ld1BhcnRzKTtqKz1uZXdQYXJ0cy5sZW5ndGgtMTt9fXJldHVybiBwYXJ0czt9Ly8gQ29ubmVjdCBvciBkaXNjb25uZWN0IHNwYW5zIGZyb20gYSBsaW5lLlxuZnVuY3Rpb24gZGV0YWNoTWFya2VkU3BhbnMobGluZSl7dmFyIHNwYW5zPWxpbmUubWFya2VkU3BhbnM7aWYoIXNwYW5zKXtyZXR1cm47fWZvcih2YXIgaT0wO2k8c3BhbnMubGVuZ3RoOysraSl7c3BhbnNbaV0ubWFya2VyLmRldGFjaExpbmUobGluZSk7fWxpbmUubWFya2VkU3BhbnM9bnVsbDt9ZnVuY3Rpb24gYXR0YWNoTWFya2VkU3BhbnMobGluZSxzcGFucyl7aWYoIXNwYW5zKXtyZXR1cm47fWZvcih2YXIgaT0wO2k8c3BhbnMubGVuZ3RoOysraSl7c3BhbnNbaV0ubWFya2VyLmF0dGFjaExpbmUobGluZSk7fWxpbmUubWFya2VkU3BhbnM9c3BhbnM7fS8vIEhlbHBlcnMgdXNlZCB3aGVuIGNvbXB1dGluZyB3aGljaCBvdmVybGFwcGluZyBjb2xsYXBzZWQgc3BhblxuLy8gY291bnRzIGFzIHRoZSBsYXJnZXIgb25lLlxuZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcil7cmV0dXJuIG1hcmtlci5pbmNsdXNpdmVMZWZ0Py0xOjA7fWZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKXtyZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0PzE6MDt9Ly8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcbi8vIHNwYW5zIGlzIGxhcmdlciAoYW5kIHRodXMgaW5jbHVkZXMgdGhlIG90aGVyKS4gRmFsbHMgYmFjayB0b1xuLy8gY29tcGFyaW5nIGlkcyB3aGVuIHRoZSBzcGFucyBjb3ZlciBleGFjdGx5IHRoZSBzYW1lIHJhbmdlLlxuZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSxiKXt2YXIgbGVuRGlmZj1hLmxpbmVzLmxlbmd0aC1iLmxpbmVzLmxlbmd0aDtpZihsZW5EaWZmIT0wKXtyZXR1cm4gbGVuRGlmZjt9dmFyIGFQb3M9YS5maW5kKCksYlBvcz1iLmZpbmQoKTt2YXIgZnJvbUNtcD1jbXAoYVBvcy5mcm9tLGJQb3MuZnJvbSl8fGV4dHJhTGVmdChhKS1leHRyYUxlZnQoYik7aWYoZnJvbUNtcCl7cmV0dXJuLWZyb21DbXA7fXZhciB0b0NtcD1jbXAoYVBvcy50byxiUG9zLnRvKXx8ZXh0cmFSaWdodChhKS1leHRyYVJpZ2h0KGIpO2lmKHRvQ21wKXtyZXR1cm4gdG9DbXA7fXJldHVybiBiLmlkLWEuaWQ7fS8vIEZpbmQgb3V0IHdoZXRoZXIgYSBsaW5lIGVuZHMgb3Igc3RhcnRzIGluIGEgY29sbGFwc2VkIHNwYW4uIElmXG4vLyBzbywgcmV0dXJuIHRoZSBtYXJrZXIgZm9yIHRoYXQgc3Bhbi5cbmZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSxzdGFydCl7dmFyIHNwcz1zYXdDb2xsYXBzZWRTcGFucyYmbGluZS5tYXJrZWRTcGFucyxmb3VuZDtpZihzcHMpe2Zvcih2YXIgc3A9dm9pZCAwLGk9MDtpPHNwcy5sZW5ndGg7KytpKXtzcD1zcHNbaV07aWYoc3AubWFya2VyLmNvbGxhcHNlZCYmKHN0YXJ0P3NwLmZyb206c3AudG8pPT1udWxsJiYoIWZvdW5kfHxjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCxzcC5tYXJrZXIpPDApKXtmb3VuZD1zcC5tYXJrZXI7fX19cmV0dXJuIGZvdW5kO31mdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKXtyZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLHRydWUpO31mdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSl7cmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSxmYWxzZSk7fS8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxuLy8gb3ZlcmxhcHMgKGNvdmVycyB0aGUgc3RhcnQgb3IgZW5kLCBidXQgbm90IGJvdGgpIG9mIGEgbmV3IHNwYW4uXG4vLyBTdWNoIG92ZXJsYXAgaXMgbm90IGFsbG93ZWQuXG5mdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYyxsaW5lTm8sZnJvbSx0byxtYXJrZXIpe3ZhciBsaW5lPWdldExpbmUoZG9jLGxpbmVObyk7dmFyIHNwcz1zYXdDb2xsYXBzZWRTcGFucyYmbGluZS5tYXJrZWRTcGFucztpZihzcHMpe2Zvcih2YXIgaT0wO2k8c3BzLmxlbmd0aDsrK2kpe3ZhciBzcD1zcHNbaV07aWYoIXNwLm1hcmtlci5jb2xsYXBzZWQpe2NvbnRpbnVlO312YXIgZm91bmQ9c3AubWFya2VyLmZpbmQoMCk7dmFyIGZyb21DbXA9Y21wKGZvdW5kLmZyb20sZnJvbSl8fGV4dHJhTGVmdChzcC5tYXJrZXIpLWV4dHJhTGVmdChtYXJrZXIpO3ZhciB0b0NtcD1jbXAoZm91bmQudG8sdG8pfHxleHRyYVJpZ2h0KHNwLm1hcmtlciktZXh0cmFSaWdodChtYXJrZXIpO2lmKGZyb21DbXA+PTAmJnRvQ21wPD0wfHxmcm9tQ21wPD0wJiZ0b0NtcD49MCl7Y29udGludWU7fWlmKGZyb21DbXA8PTAmJihzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQmJm1hcmtlci5pbmNsdXNpdmVMZWZ0P2NtcChmb3VuZC50byxmcm9tKT49MDpjbXAoZm91bmQudG8sZnJvbSk+MCl8fGZyb21DbXA+PTAmJihzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQmJm1hcmtlci5pbmNsdXNpdmVMZWZ0P2NtcChmb3VuZC5mcm9tLHRvKTw9MDpjbXAoZm91bmQuZnJvbSx0byk8MCkpe3JldHVybiB0cnVlO319fX0vLyBBIHZpc3VhbCBsaW5lIGlzIGEgbGluZSBhcyBkcmF3biBvbiB0aGUgc2NyZWVuLiBGb2xkaW5nLCBmb3Jcbi8vIGV4YW1wbGUsIGNhbiBjYXVzZSBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzIHRvIGFwcGVhciBvbiB0aGUgc2FtZVxuLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxuLy8gZ2l2ZW4gbGluZSBpcyBwYXJ0IG9mICh1c3VhbGx5IHRoYXQgaXMgdGhlIGxpbmUgaXRzZWxmKS5cbmZ1bmN0aW9uIHZpc3VhbExpbmUobGluZSl7dmFyIG1lcmdlZDt3aGlsZShtZXJnZWQ9Y29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkpe2xpbmU9bWVyZ2VkLmZpbmQoLTEsdHJ1ZSkubGluZTt9cmV0dXJuIGxpbmU7fS8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxuLy8gc3RhcnRlZCBieSB0aGUgYXJndW1lbnQsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gc3VjaCBsaW5lcy5cbmZ1bmN0aW9uIHZpc3VhbExpbmVDb250aW51ZWQobGluZSl7dmFyIG1lcmdlZCxsaW5lczt3aGlsZShtZXJnZWQ9Y29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKXtsaW5lPW1lcmdlZC5maW5kKDEsdHJ1ZSkubGluZTsobGluZXN8fChsaW5lcz1bXSkpLnB1c2gobGluZSk7fXJldHVybiBsaW5lczt9Ly8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXG4vLyBnaXZlbiBsaW5lIG51bWJlciBpcyBwYXJ0IG9mLlxuZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYyxsaW5lTil7dmFyIGxpbmU9Z2V0TGluZShkb2MsbGluZU4pLHZpcz12aXN1YWxMaW5lKGxpbmUpO2lmKGxpbmU9PXZpcyl7cmV0dXJuIGxpbmVOO31yZXR1cm4gbGluZU5vKHZpcyk7fS8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHZpc3VhbCBsaW5lIGFmdGVyXG4vLyB0aGUgZ2l2ZW4gbGluZS5cbmZ1bmN0aW9uIHZpc3VhbExpbmVFbmRObyhkb2MsbGluZU4pe2lmKGxpbmVOPmRvYy5sYXN0TGluZSgpKXtyZXR1cm4gbGluZU47fXZhciBsaW5lPWdldExpbmUoZG9jLGxpbmVOKSxtZXJnZWQ7aWYoIWxpbmVJc0hpZGRlbihkb2MsbGluZSkpe3JldHVybiBsaW5lTjt9d2hpbGUobWVyZ2VkPWNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSl7bGluZT1tZXJnZWQuZmluZCgxLHRydWUpLmxpbmU7fXJldHVybiBsaW5lTm8obGluZSkrMTt9Ly8gQ29tcHV0ZSB3aGV0aGVyIGEgbGluZSBpcyBoaWRkZW4uIExpbmVzIGNvdW50IGFzIGhpZGRlbiB3aGVuIHRoZXlcbi8vIGFyZSBwYXJ0IG9mIGEgdmlzdWFsIGxpbmUgdGhhdCBzdGFydHMgd2l0aCBhbm90aGVyIGxpbmUsIG9yIHdoZW5cbi8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXG5mdW5jdGlvbiBsaW5lSXNIaWRkZW4oZG9jLGxpbmUpe3ZhciBzcHM9c2F3Q29sbGFwc2VkU3BhbnMmJmxpbmUubWFya2VkU3BhbnM7aWYoc3BzKXtmb3IodmFyIHNwPXZvaWQgMCxpPTA7aTxzcHMubGVuZ3RoOysraSl7c3A9c3BzW2ldO2lmKCFzcC5tYXJrZXIuY29sbGFwc2VkKXtjb250aW51ZTt9aWYoc3AuZnJvbT09bnVsbCl7cmV0dXJuIHRydWU7fWlmKHNwLm1hcmtlci53aWRnZXROb2RlKXtjb250aW51ZTt9aWYoc3AuZnJvbT09MCYmc3AubWFya2VyLmluY2x1c2l2ZUxlZnQmJmxpbmVJc0hpZGRlbklubmVyKGRvYyxsaW5lLHNwKSl7cmV0dXJuIHRydWU7fX19fWZ1bmN0aW9uIGxpbmVJc0hpZGRlbklubmVyKGRvYyxsaW5lLHNwYW4pe2lmKHNwYW4udG89PW51bGwpe3ZhciBlbmQ9c3Bhbi5tYXJrZXIuZmluZCgxLHRydWUpO3JldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsZW5kLmxpbmUsZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucyxzcGFuLm1hcmtlcikpO31pZihzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCYmc3Bhbi50bz09bGluZS50ZXh0Lmxlbmd0aCl7cmV0dXJuIHRydWU7fWZvcih2YXIgc3A9dm9pZCAwLGk9MDtpPGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOysraSl7c3A9bGluZS5tYXJrZWRTcGFuc1tpXTtpZihzcC5tYXJrZXIuY29sbGFwc2VkJiYhc3AubWFya2VyLndpZGdldE5vZGUmJnNwLmZyb209PXNwYW4udG8mJihzcC50bz09bnVsbHx8c3AudG8hPXNwYW4uZnJvbSkmJihzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdHx8c3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQpJiZsaW5lSXNIaWRkZW5Jbm5lcihkb2MsbGluZSxzcCkpe3JldHVybiB0cnVlO319fS8vIEZpbmQgdGhlIGhlaWdodCBhYm92ZSB0aGUgZ2l2ZW4gbGluZS5cbmZ1bmN0aW9uIGhlaWdodEF0TGluZShsaW5lT2JqKXtsaW5lT2JqPXZpc3VhbExpbmUobGluZU9iaik7dmFyIGg9MCxjaHVuaz1saW5lT2JqLnBhcmVudDtmb3IodmFyIGk9MDtpPGNodW5rLmxpbmVzLmxlbmd0aDsrK2kpe3ZhciBsaW5lPWNodW5rLmxpbmVzW2ldO2lmKGxpbmU9PWxpbmVPYmope2JyZWFrO31lbHNle2grPWxpbmUuaGVpZ2h0O319Zm9yKHZhciBwPWNodW5rLnBhcmVudDtwO2NodW5rPXAscD1jaHVuay5wYXJlbnQpe2Zvcih2YXIgaSQxPTA7aSQxPHAuY2hpbGRyZW4ubGVuZ3RoOysraSQxKXt2YXIgY3VyPXAuY2hpbGRyZW5baSQxXTtpZihjdXI9PWNodW5rKXticmVhazt9ZWxzZXtoKz1jdXIuaGVpZ2h0O319fXJldHVybiBoO30vLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxuLy8gY29sbGFwc2VkIHJhbmdlcyAoc2VlIG1hcmtUZXh0KSB0aGF0IG1pZ2h0IGhpZGUgcGFydHMsIGFuZCBqb2luXG4vLyBvdGhlciBsaW5lcyBvbnRvIGl0LlxuZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKXtpZihsaW5lLmhlaWdodD09MCl7cmV0dXJuIDA7fXZhciBsZW49bGluZS50ZXh0Lmxlbmd0aCxtZXJnZWQsY3VyPWxpbmU7d2hpbGUobWVyZ2VkPWNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpe3ZhciBmb3VuZD1tZXJnZWQuZmluZCgwLHRydWUpO2N1cj1mb3VuZC5mcm9tLmxpbmU7bGVuKz1mb3VuZC5mcm9tLmNoLWZvdW5kLnRvLmNoO31jdXI9bGluZTt3aGlsZShtZXJnZWQ9Y29sbGFwc2VkU3BhbkF0RW5kKGN1cikpe3ZhciBmb3VuZCQxPW1lcmdlZC5maW5kKDAsdHJ1ZSk7bGVuLT1jdXIudGV4dC5sZW5ndGgtZm91bmQkMS5mcm9tLmNoO2N1cj1mb3VuZCQxLnRvLmxpbmU7bGVuKz1jdXIudGV4dC5sZW5ndGgtZm91bmQkMS50by5jaDt9cmV0dXJuIGxlbjt9Ly8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cbmZ1bmN0aW9uIGZpbmRNYXhMaW5lKGNtKXt2YXIgZD1jbS5kaXNwbGF5LGRvYz1jbS5kb2M7ZC5tYXhMaW5lPWdldExpbmUoZG9jLGRvYy5maXJzdCk7ZC5tYXhMaW5lTGVuZ3RoPWxpbmVMZW5ndGgoZC5tYXhMaW5lKTtkLm1heExpbmVDaGFuZ2VkPXRydWU7ZG9jLml0ZXIoZnVuY3Rpb24obGluZSl7dmFyIGxlbj1saW5lTGVuZ3RoKGxpbmUpO2lmKGxlbj5kLm1heExpbmVMZW5ndGgpe2QubWF4TGluZUxlbmd0aD1sZW47ZC5tYXhMaW5lPWxpbmU7fX0pO30vLyBCSURJIEhFTFBFUlNcbmZ1bmN0aW9uIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsZnJvbSx0byxmKXtpZighb3JkZXIpe3JldHVybiBmKGZyb20sdG8sXCJsdHJcIik7fXZhciBmb3VuZD1mYWxzZTtmb3IodmFyIGk9MDtpPG9yZGVyLmxlbmd0aDsrK2kpe3ZhciBwYXJ0PW9yZGVyW2ldO2lmKHBhcnQuZnJvbTx0byYmcGFydC50bz5mcm9tfHxmcm9tPT10byYmcGFydC50bz09ZnJvbSl7ZihNYXRoLm1heChwYXJ0LmZyb20sZnJvbSksTWF0aC5taW4ocGFydC50byx0bykscGFydC5sZXZlbD09MT9cInJ0bFwiOlwibHRyXCIpO2ZvdW5kPXRydWU7fX1pZighZm91bmQpe2YoZnJvbSx0byxcImx0clwiKTt9fWZ1bmN0aW9uIGJpZGlMZWZ0KHBhcnQpe3JldHVybiBwYXJ0LmxldmVsJTI/cGFydC50bzpwYXJ0LmZyb207fWZ1bmN0aW9uIGJpZGlSaWdodChwYXJ0KXtyZXR1cm4gcGFydC5sZXZlbCUyP3BhcnQuZnJvbTpwYXJ0LnRvO31mdW5jdGlvbiBsaW5lTGVmdChsaW5lKXt2YXIgb3JkZXI9Z2V0T3JkZXIobGluZSk7cmV0dXJuIG9yZGVyP2JpZGlMZWZ0KG9yZGVyWzBdKTowO31mdW5jdGlvbiBsaW5lUmlnaHQobGluZSl7dmFyIG9yZGVyPWdldE9yZGVyKGxpbmUpO2lmKCFvcmRlcil7cmV0dXJuIGxpbmUudGV4dC5sZW5ndGg7fXJldHVybiBiaWRpUmlnaHQobHN0KG9yZGVyKSk7fWZ1bmN0aW9uIGNvbXBhcmVCaWRpTGV2ZWwob3JkZXIsYSxiKXt2YXIgbGluZWRpcj1vcmRlclswXS5sZXZlbDtpZihhPT1saW5lZGlyKXtyZXR1cm4gdHJ1ZTt9aWYoYj09bGluZWRpcil7cmV0dXJuIGZhbHNlO31yZXR1cm4gYTxiO312YXIgYmlkaU90aGVyPW51bGw7ZnVuY3Rpb24gZ2V0QmlkaVBhcnRBdChvcmRlcixwb3Mpe3ZhciBmb3VuZDtiaWRpT3RoZXI9bnVsbDtmb3IodmFyIGk9MDtpPG9yZGVyLmxlbmd0aDsrK2kpe3ZhciBjdXI9b3JkZXJbaV07aWYoY3VyLmZyb208cG9zJiZjdXIudG8+cG9zKXtyZXR1cm4gaTt9aWYoY3VyLmZyb209PXBvc3x8Y3VyLnRvPT1wb3Mpe2lmKGZvdW5kPT1udWxsKXtmb3VuZD1pO31lbHNlIGlmKGNvbXBhcmVCaWRpTGV2ZWwob3JkZXIsY3VyLmxldmVsLG9yZGVyW2ZvdW5kXS5sZXZlbCkpe2lmKGN1ci5mcm9tIT1jdXIudG8pe2JpZGlPdGhlcj1mb3VuZDt9cmV0dXJuIGk7fWVsc2V7aWYoY3VyLmZyb20hPWN1ci50byl7YmlkaU90aGVyPWk7fXJldHVybiBmb3VuZDt9fX1yZXR1cm4gZm91bmQ7fWZ1bmN0aW9uIG1vdmVJbkxpbmUobGluZSxwb3MsZGlyLGJ5VW5pdCl7aWYoIWJ5VW5pdCl7cmV0dXJuIHBvcytkaXI7fWRve3Bvcys9ZGlyO313aGlsZShwb3M+MCYmaXNFeHRlbmRpbmdDaGFyKGxpbmUudGV4dC5jaGFyQXQocG9zKSkpO3JldHVybiBwb3M7fS8vIFRoaXMgaXMgbmVlZGVkIGluIG9yZGVyIHRvIG1vdmUgJ3Zpc3VhbGx5JyB0aHJvdWdoIGJpLWRpcmVjdGlvbmFsXG4vLyB0ZXh0IC0tIGkuZS4sIHByZXNzaW5nIGxlZnQgc2hvdWxkIG1ha2UgdGhlIGN1cnNvciBnbyBsZWZ0LCBldmVuXG4vLyB3aGVuIGluIFJUTCB0ZXh0LiBUaGUgdHJpY2t5IHBhcnQgaXMgdGhlICdqdW1wcycsIHdoZXJlIFJUTCBhbmRcbi8vIExUUiB0ZXh0IHRvdWNoIGVhY2ggb3RoZXIuIFRoaXMgb2Z0ZW4gcmVxdWlyZXMgdGhlIGN1cnNvciBvZmZzZXRcbi8vIHRvIG1vdmUgbW9yZSB0aGFuIG9uZSB1bml0LCBpbiBvcmRlciB0byB2aXN1YWxseSBtb3ZlIG9uZSB1bml0LlxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsc3RhcnQsZGlyLGJ5VW5pdCl7dmFyIGJpZGk9Z2V0T3JkZXIobGluZSk7aWYoIWJpZGkpe3JldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsc3RhcnQsZGlyLGJ5VW5pdCk7fXZhciBwb3M9Z2V0QmlkaVBhcnRBdChiaWRpLHN0YXJ0KSxwYXJ0PWJpZGlbcG9zXTt2YXIgdGFyZ2V0PW1vdmVJbkxpbmUobGluZSxzdGFydCxwYXJ0LmxldmVsJTI/LWRpcjpkaXIsYnlVbml0KTtmb3IoOzspe2lmKHRhcmdldD5wYXJ0LmZyb20mJnRhcmdldDxwYXJ0LnRvKXtyZXR1cm4gdGFyZ2V0O31pZih0YXJnZXQ9PXBhcnQuZnJvbXx8dGFyZ2V0PT1wYXJ0LnRvKXtpZihnZXRCaWRpUGFydEF0KGJpZGksdGFyZ2V0KT09cG9zKXtyZXR1cm4gdGFyZ2V0O31wYXJ0PWJpZGlbcG9zKz1kaXJdO3JldHVybiBkaXI+MD09cGFydC5sZXZlbCUyP3BhcnQudG86cGFydC5mcm9tO31lbHNle3BhcnQ9YmlkaVtwb3MrPWRpcl07aWYoIXBhcnQpe3JldHVybiBudWxsO31pZihkaXI+MD09cGFydC5sZXZlbCUyKXt0YXJnZXQ9bW92ZUluTGluZShsaW5lLHBhcnQudG8sLTEsYnlVbml0KTt9ZWxzZXt0YXJnZXQ9bW92ZUluTGluZShsaW5lLHBhcnQuZnJvbSwxLGJ5VW5pdCk7fX19fWZ1bmN0aW9uIG1vdmVMb2dpY2FsbHkobGluZSxzdGFydCxkaXIsYnlVbml0KXt2YXIgdGFyZ2V0PXN0YXJ0K2RpcjtpZihieVVuaXQpe3doaWxlKHRhcmdldD4wJiZpc0V4dGVuZGluZ0NoYXIobGluZS50ZXh0LmNoYXJBdCh0YXJnZXQpKSl7dGFyZ2V0Kz1kaXI7fX1yZXR1cm4gdGFyZ2V0PDB8fHRhcmdldD5saW5lLnRleHQubGVuZ3RoP251bGw6dGFyZ2V0O30vLyBCaWRpcmVjdGlvbmFsIG9yZGVyaW5nIGFsZ29yaXRobVxuLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxuLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXG4vLyBPbmUtY2hhciBjb2RlcyB1c2VkIGZvciBjaGFyYWN0ZXIgdHlwZXM6XG4vLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XG4vLyBSIChSKTogICBSaWdodC10by1MZWZ0XG4vLyByIChBTCk6ICBSaWdodC10by1MZWZ0IEFyYWJpY1xuLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXG4vLyArIChFUyk6ICBFdXJvcGVhbiBOdW1iZXIgU2VwYXJhdG9yXG4vLyAlIChFVCk6ICBFdXJvcGVhbiBOdW1iZXIgVGVybWluYXRvclxuLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxuLy8gLCAoQ1MpOiAgQ29tbW9uIE51bWJlciBTZXBhcmF0b3Jcbi8vIG0gKE5TTSk6IE5vbi1TcGFjaW5nIE1hcmtcbi8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcbi8vIHMgKEIpOiAgIFBhcmFncmFwaCBTZXBhcmF0b3Jcbi8vIHQgKFMpOiAgIFNlZ21lbnQgU2VwYXJhdG9yXG4vLyB3IChXUyk6ICBXaGl0ZXNwYWNlXG4vLyBOIChPTik6ICBPdGhlciBOZXV0cmFsc1xuLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcbi8vIChsZWZ0LXRvLXJpZ2h0KSwgb3IgYW4gYXJyYXkgb2Ygc2VjdGlvbnMgKHtmcm9tLCB0bywgbGV2ZWx9XG4vLyBvYmplY3RzKSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciB2aXN1YWxseS5cbnZhciBiaWRpT3JkZXJpbmc9ZnVuY3Rpb24oKXsvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGZmXG52YXIgbG93VHlwZXM9XCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlwiOy8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmZlxudmFyIGFyYWJpY1R5cGVzPVwicnJycnJycnJycnJyLHJOTm1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1ycnJycnJybm5ubm5ubm5ubiVubnJycm1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1ObW1tbVwiO2Z1bmN0aW9uIGNoYXJUeXBlKGNvZGUpe2lmKGNvZGU8PTB4Zjcpe3JldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSk7fWVsc2UgaWYoMHg1OTA8PWNvZGUmJmNvZGU8PTB4NWY0KXtyZXR1cm5cIlJcIjt9ZWxzZSBpZigweDYwMDw9Y29kZSYmY29kZTw9MHg2ZWQpe3JldHVybiBhcmFiaWNUeXBlcy5jaGFyQXQoY29kZS0weDYwMCk7fWVsc2UgaWYoMHg2ZWU8PWNvZGUmJmNvZGU8PTB4OGFjKXtyZXR1cm5cInJcIjt9ZWxzZSBpZigweDIwMDA8PWNvZGUmJmNvZGU8PTB4MjAwYil7cmV0dXJuXCJ3XCI7fWVsc2UgaWYoY29kZT09MHgyMDBjKXtyZXR1cm5cImJcIjt9ZWxzZXtyZXR1cm5cIkxcIjt9fXZhciBiaWRpUkU9L1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLzt2YXIgaXNOZXV0cmFsPS9bc3R3Tl0vLGlzU3Ryb25nPS9bTFJyXS8sY291bnRzQXNMZWZ0PS9bTGIxbl0vLGNvdW50c0FzTnVtPS9bMW5dLzsvLyBCcm93c2VycyBzZWVtIHRvIGFsd2F5cyB0cmVhdCB0aGUgYm91bmRhcmllcyBvZiBibG9jayBlbGVtZW50cyBhcyBiZWluZyBMLlxudmFyIG91dGVyVHlwZT1cIkxcIjtmdW5jdGlvbiBCaWRpU3BhbihsZXZlbCxmcm9tLHRvKXt0aGlzLmxldmVsPWxldmVsO3RoaXMuZnJvbT1mcm9tO3RoaXMudG89dG87fXJldHVybiBmdW5jdGlvbihzdHIpe2lmKCFiaWRpUkUudGVzdChzdHIpKXtyZXR1cm4gZmFsc2U7fXZhciBsZW49c3RyLmxlbmd0aCx0eXBlcz1bXTtmb3IodmFyIGk9MDtpPGxlbjsrK2kpe3R5cGVzLnB1c2goY2hhclR5cGUoc3RyLmNoYXJDb2RlQXQoaSkpKTt9Ly8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXG4vLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbi8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG5mb3IodmFyIGkkMT0wLHByZXY9b3V0ZXJUeXBlO2kkMTxsZW47KytpJDEpe3ZhciB0eXBlPXR5cGVzW2kkMV07aWYodHlwZT09XCJtXCIpe3R5cGVzW2kkMV09cHJldjt9ZWxzZXtwcmV2PXR5cGU7fX0vLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbi8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4vLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4vLyBudW1iZXIuXG4vLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbmZvcih2YXIgaSQyPTAsY3VyPW91dGVyVHlwZTtpJDI8bGVuOysraSQyKXt2YXIgdHlwZSQxPXR5cGVzW2kkMl07aWYodHlwZSQxPT1cIjFcIiYmY3VyPT1cInJcIil7dHlwZXNbaSQyXT1cIm5cIjt9ZWxzZSBpZihpc1N0cm9uZy50ZXN0KHR5cGUkMSkpe2N1cj10eXBlJDE7aWYodHlwZSQxPT1cInJcIil7dHlwZXNbaSQyXT1cIlJcIjt9fX0vLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnNcbi8vIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vbiBzZXBhcmF0b3IgYmV0d2VlblxuLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbmZvcih2YXIgaSQzPTEscHJldiQxPXR5cGVzWzBdO2kkMzxsZW4tMTsrK2kkMyl7dmFyIHR5cGUkMj10eXBlc1tpJDNdO2lmKHR5cGUkMj09XCIrXCImJnByZXYkMT09XCIxXCImJnR5cGVzW2kkMysxXT09XCIxXCIpe3R5cGVzW2kkM109XCIxXCI7fWVsc2UgaWYodHlwZSQyPT1cIixcIiYmcHJldiQxPT10eXBlc1tpJDMrMV0mJihwcmV2JDE9PVwiMVwifHxwcmV2JDE9PVwiblwiKSl7dHlwZXNbaSQzXT1wcmV2JDE7fXByZXYkMT10eXBlJDI7fS8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4vLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4vLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbi8vIE5ldXRyYWwuXG5mb3IodmFyIGkkND0wO2kkNDxsZW47KytpJDQpe3ZhciB0eXBlJDM9dHlwZXNbaSQ0XTtpZih0eXBlJDM9PVwiLFwiKXt0eXBlc1tpJDRdPVwiTlwiO31lbHNlIGlmKHR5cGUkMz09XCIlXCIpe3ZhciBlbmQ9dm9pZCAwO2ZvcihlbmQ9aSQ0KzE7ZW5kPGxlbiYmdHlwZXNbZW5kXT09XCIlXCI7KytlbmQpe312YXIgcmVwbGFjZT1pJDQmJnR5cGVzW2kkNC0xXT09XCIhXCJ8fGVuZDxsZW4mJnR5cGVzW2VuZF09PVwiMVwiP1wiMVwiOlwiTlwiO2Zvcih2YXIgaj1pJDQ7ajxlbmQ7KytqKXt0eXBlc1tqXT1yZXBsYWNlO31pJDQ9ZW5kLTE7fX0vLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbi8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cbmZvcih2YXIgaSQ1PTAsY3VyJDE9b3V0ZXJUeXBlO2kkNTxsZW47KytpJDUpe3ZhciB0eXBlJDQ9dHlwZXNbaSQ1XTtpZihjdXIkMT09XCJMXCImJnR5cGUkND09XCIxXCIpe3R5cGVzW2kkNV09XCJMXCI7fWVsc2UgaWYoaXNTdHJvbmcudGVzdCh0eXBlJDQpKXtjdXIkMT10eXBlJDQ7fX0vLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbi8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbi8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbmZvcih2YXIgaSQ2PTA7aSQ2PGxlbjsrK2kkNil7aWYoaXNOZXV0cmFsLnRlc3QodHlwZXNbaSQ2XSkpe3ZhciBlbmQkMT12b2lkIDA7Zm9yKGVuZCQxPWkkNisxO2VuZCQxPGxlbiYmaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kJDFdKTsrK2VuZCQxKXt9dmFyIGJlZm9yZT0oaSQ2P3R5cGVzW2kkNi0xXTpvdXRlclR5cGUpPT1cIkxcIjt2YXIgYWZ0ZXI9KGVuZCQxPGxlbj90eXBlc1tlbmQkMV06b3V0ZXJUeXBlKT09XCJMXCI7dmFyIHJlcGxhY2UkMT1iZWZvcmV8fGFmdGVyP1wiTFwiOlwiUlwiO2Zvcih2YXIgaiQxPWkkNjtqJDE8ZW5kJDE7KytqJDEpe3R5cGVzW2okMV09cmVwbGFjZSQxO31pJDY9ZW5kJDEtMTt9fS8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbi8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2Vcbi8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbi8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXG52YXIgb3JkZXI9W10sbTtmb3IodmFyIGkkNz0wO2kkNzxsZW47KXtpZihjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpJDddKSl7dmFyIHN0YXJ0PWkkNztmb3IoKytpJDc7aSQ3PGxlbiYmY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSk7KytpJDcpe31vcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLHN0YXJ0LGkkNykpO31lbHNle3ZhciBwb3M9aSQ3LGF0PW9yZGVyLmxlbmd0aDtmb3IoKytpJDc7aSQ3PGxlbiYmdHlwZXNbaSQ3XSE9XCJMXCI7KytpJDcpe31mb3IodmFyIGokMj1wb3M7aiQyPGkkNzspe2lmKGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSkpe2lmKHBvczxqJDIpe29yZGVyLnNwbGljZShhdCwwLG5ldyBCaWRpU3BhbigxLHBvcyxqJDIpKTt9dmFyIG5zdGFydD1qJDI7Zm9yKCsraiQyO2okMjxpJDcmJmNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSk7KytqJDIpe31vcmRlci5zcGxpY2UoYXQsMCxuZXcgQmlkaVNwYW4oMixuc3RhcnQsaiQyKSk7cG9zPWokMjt9ZWxzZXsrK2okMjt9fWlmKHBvczxpJDcpe29yZGVyLnNwbGljZShhdCwwLG5ldyBCaWRpU3BhbigxLHBvcyxpJDcpKTt9fX1pZihvcmRlclswXS5sZXZlbD09MSYmKG09c3RyLm1hdGNoKC9eXFxzKy8pKSl7b3JkZXJbMF0uZnJvbT1tWzBdLmxlbmd0aDtvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLDAsbVswXS5sZW5ndGgpKTt9aWYobHN0KG9yZGVyKS5sZXZlbD09MSYmKG09c3RyLm1hdGNoKC9cXHMrJC8pKSl7bHN0KG9yZGVyKS50by09bVswXS5sZW5ndGg7b3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCxsZW4tbVswXS5sZW5ndGgsbGVuKSk7fWlmKG9yZGVyWzBdLmxldmVsPT0yKXtvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigxLG9yZGVyWzBdLnRvLG9yZGVyWzBdLnRvKSk7fWlmKG9yZGVyWzBdLmxldmVsIT1sc3Qob3JkZXIpLmxldmVsKXtvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihvcmRlclswXS5sZXZlbCxsZW4sbGVuKSk7fXJldHVybiBvcmRlcjt9O30oKTsvLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXG4vLyBmYWxzZSBmb3IgbGluZXMgdGhhdCBhcmUgZnVsbHkgbGVmdC10by1yaWdodCwgYW5kIGFuIGFycmF5IG9mXG4vLyBCaWRpU3BhbiBvYmplY3RzIG90aGVyd2lzZS5cbmZ1bmN0aW9uIGdldE9yZGVyKGxpbmUpe3ZhciBvcmRlcj1saW5lLm9yZGVyO2lmKG9yZGVyPT1udWxsKXtvcmRlcj1saW5lLm9yZGVyPWJpZGlPcmRlcmluZyhsaW5lLnRleHQpO31yZXR1cm4gb3JkZXI7fS8vIEVWRU5UIEhBTkRMSU5HXG4vLyBMaWdodHdlaWdodCBldmVudCBmcmFtZXdvcmsuIG9uL29mZiBhbHNvIHdvcmsgb24gRE9NIG5vZGVzLFxuLy8gcmVnaXN0ZXJpbmcgbmF0aXZlIERPTSBoYW5kbGVycy5cbnZhciBvbj1mdW5jdGlvbihlbWl0dGVyLHR5cGUsZil7aWYoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKXtlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSxmLGZhbHNlKTt9ZWxzZSBpZihlbWl0dGVyLmF0dGFjaEV2ZW50KXtlbWl0dGVyLmF0dGFjaEV2ZW50KFwib25cIit0eXBlLGYpO31lbHNle3ZhciBtYXA9ZW1pdHRlci5faGFuZGxlcnN8fChlbWl0dGVyLl9oYW5kbGVycz17fSk7dmFyIGFycj1tYXBbdHlwZV18fChtYXBbdHlwZV09W10pO2Fyci5wdXNoKGYpO319O3ZhciBub0hhbmRsZXJzPVtdO2Z1bmN0aW9uIGdldEhhbmRsZXJzKGVtaXR0ZXIsdHlwZSxjb3B5KXt2YXIgYXJyPWVtaXR0ZXIuX2hhbmRsZXJzJiZlbWl0dGVyLl9oYW5kbGVyc1t0eXBlXTtpZihjb3B5KXtyZXR1cm4gYXJyJiZhcnIubGVuZ3RoPjA/YXJyLnNsaWNlKCk6bm9IYW5kbGVyczt9ZWxzZXtyZXR1cm4gYXJyfHxub0hhbmRsZXJzO319ZnVuY3Rpb24gb2ZmKGVtaXR0ZXIsdHlwZSxmKXtpZihlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIpe2VtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLGYsZmFsc2UpO31lbHNlIGlmKGVtaXR0ZXIuZGV0YWNoRXZlbnQpe2VtaXR0ZXIuZGV0YWNoRXZlbnQoXCJvblwiK3R5cGUsZik7fWVsc2V7dmFyIGhhbmRsZXJzPWdldEhhbmRsZXJzKGVtaXR0ZXIsdHlwZSxmYWxzZSk7Zm9yKHZhciBpPTA7aTxoYW5kbGVycy5sZW5ndGg7KytpKXtpZihoYW5kbGVyc1tpXT09Zil7aGFuZGxlcnMuc3BsaWNlKGksMSk7YnJlYWs7fX19fWZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLHR5cGUvKiwgdmFsdWVzLi4uKi8pe3ZhciBoYW5kbGVycz1nZXRIYW5kbGVycyhlbWl0dGVyLHR5cGUsdHJ1ZSk7aWYoIWhhbmRsZXJzLmxlbmd0aCl7cmV0dXJuO312YXIgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMik7Zm9yKHZhciBpPTA7aTxoYW5kbGVycy5sZW5ndGg7KytpKXtoYW5kbGVyc1tpXS5hcHBseShudWxsLGFyZ3MpO319Ly8gVGhlIERPTSBldmVudHMgdGhhdCBDb2RlTWlycm9yIGhhbmRsZXMgY2FuIGJlIG92ZXJyaWRkZW4gYnlcbi8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXG4vLyBhbmQgcHJldmVudERlZmF1bHQtaW5nIHRoZSBldmVudCBpbiB0aGF0IGhhbmRsZXIuXG5mdW5jdGlvbiBzaWduYWxET01FdmVudChjbSxlLG92ZXJyaWRlKXtpZih0eXBlb2YgZT09XCJzdHJpbmdcIil7ZT17dHlwZTplLHByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPXRydWU7fX07fXNpZ25hbChjbSxvdmVycmlkZXx8ZS50eXBlLGNtLGUpO3JldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSl8fGUuY29kZW1pcnJvcklnbm9yZTt9ZnVuY3Rpb24gc2lnbmFsQ3Vyc29yQWN0aXZpdHkoY20pe3ZhciBhcnI9Y20uX2hhbmRsZXJzJiZjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHk7aWYoIWFycil7cmV0dXJuO312YXIgc2V0PWNtLmN1ck9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnN8fChjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzPVtdKTtmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7KytpKXtpZihpbmRleE9mKHNldCxhcnJbaV0pPT0tMSl7c2V0LnB1c2goYXJyW2ldKTt9fX1mdW5jdGlvbiBoYXNIYW5kbGVyKGVtaXR0ZXIsdHlwZSl7cmV0dXJuIGdldEhhbmRsZXJzKGVtaXR0ZXIsdHlwZSkubGVuZ3RoPjA7fS8vIEFkZCBvbiBhbmQgb2ZmIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSwgdG8gbWFrZVxuLy8gcmVnaXN0ZXJpbmcgZXZlbnRzIG9uIHN1Y2ggb2JqZWN0cyBtb3JlIGNvbnZlbmllbnQuXG5mdW5jdGlvbiBldmVudE1peGluKGN0b3Ipe2N0b3IucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHR5cGUsZil7b24odGhpcyx0eXBlLGYpO307Y3Rvci5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKHR5cGUsZil7b2ZmKHRoaXMsdHlwZSxmKTt9O30vLyBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBzdGlsbCBzdXBwb3J0IGp1cmFzc2ljIElFIHZlcnNpb25zLCBzb21lXG4vLyBjb21wYXRpYmlsaXR5IHdyYXBwZXJzIGFyZSBuZWVkZWQuXG5mdW5jdGlvbiBlX3ByZXZlbnREZWZhdWx0KGUpe2lmKGUucHJldmVudERlZmF1bHQpe2UucHJldmVudERlZmF1bHQoKTt9ZWxzZXtlLnJldHVyblZhbHVlPWZhbHNlO319ZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSl7aWYoZS5zdG9wUHJvcGFnYXRpb24pe2Uuc3RvcFByb3BhZ2F0aW9uKCk7fWVsc2V7ZS5jYW5jZWxCdWJibGU9dHJ1ZTt9fWZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKXtyZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkIT1udWxsP2UuZGVmYXVsdFByZXZlbnRlZDplLnJldHVyblZhbHVlPT1mYWxzZTt9ZnVuY3Rpb24gZV9zdG9wKGUpe2VfcHJldmVudERlZmF1bHQoZSk7ZV9zdG9wUHJvcGFnYXRpb24oZSk7fWZ1bmN0aW9uIGVfdGFyZ2V0KGUpe3JldHVybiBlLnRhcmdldHx8ZS5zcmNFbGVtZW50O31mdW5jdGlvbiBlX2J1dHRvbihlKXt2YXIgYj1lLndoaWNoO2lmKGI9PW51bGwpe2lmKGUuYnV0dG9uJjEpe2I9MTt9ZWxzZSBpZihlLmJ1dHRvbiYyKXtiPTM7fWVsc2UgaWYoZS5idXR0b24mNCl7Yj0yO319aWYobWFjJiZlLmN0cmxLZXkmJmI9PTEpe2I9Mzt9cmV0dXJuIGI7fS8vIERldGVjdCBkcmFnLWFuZC1kcm9wXG52YXIgZHJhZ0FuZERyb3A9ZnVuY3Rpb24oKXsvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXG4vLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXG5pZihpZSYmaWVfdmVyc2lvbjw5KXtyZXR1cm4gZmFsc2U7fXZhciBkaXY9ZWx0KCdkaXYnKTtyZXR1cm5cImRyYWdnYWJsZVwiaW4gZGl2fHxcImRyYWdEcm9wXCJpbiBkaXY7fSgpO3ZhciB6d3NwU3VwcG9ydGVkO2Z1bmN0aW9uIHplcm9XaWR0aEVsZW1lbnQobWVhc3VyZSl7aWYoendzcFN1cHBvcnRlZD09bnVsbCl7dmFyIHRlc3Q9ZWx0KFwic3BhblwiLFwiXFx1MjAwYlwiKTtyZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLGVsdChcInNwYW5cIixbdGVzdCxkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIildKSk7aWYobWVhc3VyZS5maXJzdENoaWxkLm9mZnNldEhlaWdodCE9MCl7endzcFN1cHBvcnRlZD10ZXN0Lm9mZnNldFdpZHRoPD0xJiZ0ZXN0Lm9mZnNldEhlaWdodD4yJiYhKGllJiZpZV92ZXJzaW9uPDgpO319dmFyIG5vZGU9endzcFN1cHBvcnRlZD9lbHQoXCJzcGFuXCIsXCJcXHUyMDBiXCIpOmVsdChcInNwYW5cIixcIlxcdTAwYTBcIixudWxsLFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMXB4OyBtYXJnaW4tcmlnaHQ6IC0xcHhcIik7bm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsXCJcIik7cmV0dXJuIG5vZGU7fS8vIEZlYXR1cmUtZGV0ZWN0IElFJ3MgY3J1bW15IGNsaWVudCByZWN0IHJlcG9ydGluZyBmb3IgYmlkaSB0ZXh0XG52YXIgYmFkQmlkaVJlY3RzO2Z1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKXtpZihiYWRCaWRpUmVjdHMhPW51bGwpe3JldHVybiBiYWRCaWRpUmVjdHM7fXZhciB0eHQ9cmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSxkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkFcXHUwNjJlQVwiKSk7dmFyIHIwPXJhbmdlKHR4dCwwLDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciByMT1yYW5nZSh0eHQsMSwyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZW1vdmVDaGlsZHJlbihtZWFzdXJlKTtpZighcjB8fHIwLmxlZnQ9PXIwLnJpZ2h0KXtyZXR1cm4gZmFsc2U7fS8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXG5yZXR1cm4gYmFkQmlkaVJlY3RzPXIxLnJpZ2h0LXIwLnJpZ2h0PDM7fS8vIFNlZSBpZiBcIlwiLnNwbGl0IGlzIHRoZSBicm9rZW4gSUUgdmVyc2lvbiwgaWYgc28sIHByb3ZpZGUgYW5cbi8vIGFsdGVybmF0aXZlIHdheSB0byBzcGxpdCBsaW5lcy5cbnZhciBzcGxpdExpbmVzQXV0bz1cIlxcblxcbmJcIi5zcGxpdCgvXFxuLykubGVuZ3RoIT0zP2Z1bmN0aW9uKHN0cmluZyl7dmFyIHBvcz0wLHJlc3VsdD1bXSxsPXN0cmluZy5sZW5ndGg7d2hpbGUocG9zPD1sKXt2YXIgbmw9c3RyaW5nLmluZGV4T2YoXCJcXG5cIixwb3MpO2lmKG5sPT0tMSl7bmw9c3RyaW5nLmxlbmd0aDt9dmFyIGxpbmU9c3RyaW5nLnNsaWNlKHBvcyxzdHJpbmcuY2hhckF0KG5sLTEpPT1cIlxcclwiP25sLTE6bmwpO3ZhciBydD1saW5lLmluZGV4T2YoXCJcXHJcIik7aWYocnQhPS0xKXtyZXN1bHQucHVzaChsaW5lLnNsaWNlKDAscnQpKTtwb3MrPXJ0KzE7fWVsc2V7cmVzdWx0LnB1c2gobGluZSk7cG9zPW5sKzE7fX1yZXR1cm4gcmVzdWx0O306ZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gc3RyaW5nLnNwbGl0KC9cXHJcXG4/fFxcbi8pO307dmFyIGhhc1NlbGVjdGlvbj13aW5kb3cuZ2V0U2VsZWN0aW9uP2Z1bmN0aW9uKHRlKXt0cnl7cmV0dXJuIHRlLnNlbGVjdGlvblN0YXJ0IT10ZS5zZWxlY3Rpb25FbmQ7fWNhdGNoKGUpe3JldHVybiBmYWxzZTt9fTpmdW5jdGlvbih0ZSl7dmFyIHJhbmdlO3RyeXtyYW5nZT10ZS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO31jYXRjaChlKXt9aWYoIXJhbmdlfHxyYW5nZS5wYXJlbnRFbGVtZW50KCkhPXRlKXtyZXR1cm4gZmFsc2U7fXJldHVybiByYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLHJhbmdlKSE9MDt9O3ZhciBoYXNDb3B5RXZlbnQ9ZnVuY3Rpb24oKXt2YXIgZT1lbHQoXCJkaXZcIik7aWYoXCJvbmNvcHlcImluIGUpe3JldHVybiB0cnVlO31lLnNldEF0dHJpYnV0ZShcIm9uY29weVwiLFwicmV0dXJuO1wiKTtyZXR1cm4gdHlwZW9mIGUub25jb3B5PT1cImZ1bmN0aW9uXCI7fSgpO3ZhciBiYWRab29tZWRSZWN0cz1udWxsO2Z1bmN0aW9uIGhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpe2lmKGJhZFpvb21lZFJlY3RzIT1udWxsKXtyZXR1cm4gYmFkWm9vbWVkUmVjdHM7fXZhciBub2RlPXJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsZWx0KFwic3BhblwiLFwieFwiKSk7dmFyIG5vcm1hbD1ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciBmcm9tUmFuZ2U9cmFuZ2Uobm9kZSwwLDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybiBiYWRab29tZWRSZWN0cz1NYXRoLmFicyhub3JtYWwubGVmdC1mcm9tUmFuZ2UubGVmdCk+MTt9dmFyIG1vZGVzPXt9O3ZhciBtaW1lTW9kZXM9e307Ly8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4vLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XG4vLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbmZ1bmN0aW9uIGRlZmluZU1vZGUobmFtZSxtb2RlKXtpZihhcmd1bWVudHMubGVuZ3RoPjIpe21vZGUuZGVwZW5kZW5jaWVzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTt9bW9kZXNbbmFtZV09bW9kZTt9ZnVuY3Rpb24gZGVmaW5lTUlNRShtaW1lLHNwZWMpe21pbWVNb2Rlc1ttaW1lXT1zcGVjO30vLyBHaXZlbiBhIE1JTUUgdHlwZSwgYSB7bmFtZSwgLi4ub3B0aW9uc30gY29uZmlnIG9iamVjdCwgb3IgYSBuYW1lXG4vLyBzdHJpbmcsIHJldHVybiBhIG1vZGUgY29uZmlnIG9iamVjdC5cbmZ1bmN0aW9uIHJlc29sdmVNb2RlKHNwZWMpe2lmKHR5cGVvZiBzcGVjPT1cInN0cmluZ1wiJiZtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpe3NwZWM9bWltZU1vZGVzW3NwZWNdO31lbHNlIGlmKHNwZWMmJnR5cGVvZiBzcGVjLm5hbWU9PVwic3RyaW5nXCImJm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKXt2YXIgZm91bmQ9bWltZU1vZGVzW3NwZWMubmFtZV07aWYodHlwZW9mIGZvdW5kPT1cInN0cmluZ1wiKXtmb3VuZD17bmFtZTpmb3VuZH07fXNwZWM9Y3JlYXRlT2JqKGZvdW5kLHNwZWMpO3NwZWMubmFtZT1mb3VuZC5uYW1lO31lbHNlIGlmKHR5cGVvZiBzcGVjPT1cInN0cmluZ1wiJiYvXltcXHdcXC1dK1xcL1tcXHdcXC1dK1xcK3htbCQvLnRlc3Qoc3BlYykpe3JldHVybiByZXNvbHZlTW9kZShcImFwcGxpY2F0aW9uL3htbFwiKTt9ZWxzZSBpZih0eXBlb2Ygc3BlYz09XCJzdHJpbmdcIiYmL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCtqc29uJC8udGVzdChzcGVjKSl7cmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24vanNvblwiKTt9aWYodHlwZW9mIHNwZWM9PVwic3RyaW5nXCIpe3JldHVybntuYW1lOnNwZWN9O31lbHNle3JldHVybiBzcGVjfHx7bmFtZTpcIm51bGxcIn07fX0vLyBHaXZlbiBhIG1vZGUgc3BlYyAoYW55dGhpbmcgdGhhdCByZXNvbHZlTW9kZSBhY2NlcHRzKSwgZmluZCBhbmRcbi8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxuZnVuY3Rpb24gZ2V0TW9kZShvcHRpb25zLHNwZWMpe3NwZWM9cmVzb2x2ZU1vZGUoc3BlYyk7dmFyIG1mYWN0b3J5PW1vZGVzW3NwZWMubmFtZV07aWYoIW1mYWN0b3J5KXtyZXR1cm4gZ2V0TW9kZShvcHRpb25zLFwidGV4dC9wbGFpblwiKTt9dmFyIG1vZGVPYmo9bWZhY3Rvcnkob3B0aW9ucyxzcGVjKTtpZihtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKXt2YXIgZXh0cz1tb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdO2Zvcih2YXIgcHJvcCBpbiBleHRzKXtpZighZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSl7Y29udGludWU7fWlmKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpe21vZGVPYmpbXCJfXCIrcHJvcF09bW9kZU9ialtwcm9wXTt9bW9kZU9ialtwcm9wXT1leHRzW3Byb3BdO319bW9kZU9iai5uYW1lPXNwZWMubmFtZTtpZihzcGVjLmhlbHBlclR5cGUpe21vZGVPYmouaGVscGVyVHlwZT1zcGVjLmhlbHBlclR5cGU7fWlmKHNwZWMubW9kZVByb3BzKXtmb3IodmFyIHByb3AkMSBpbiBzcGVjLm1vZGVQcm9wcyl7bW9kZU9ialtwcm9wJDFdPXNwZWMubW9kZVByb3BzW3Byb3AkMV07fX1yZXR1cm4gbW9kZU9iajt9Ly8gVGhpcyBjYW4gYmUgdXNlZCB0byBhdHRhY2ggcHJvcGVydGllcyB0byBtb2RlIG9iamVjdHMgZnJvbVxuLy8gb3V0c2lkZSB0aGUgYWN0dWFsIG1vZGUgZGVmaW5pdGlvbi5cbnZhciBtb2RlRXh0ZW5zaW9ucz17fTtmdW5jdGlvbiBleHRlbmRNb2RlKG1vZGUscHJvcGVydGllcyl7dmFyIGV4dHM9bW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSk/bW9kZUV4dGVuc2lvbnNbbW9kZV06bW9kZUV4dGVuc2lvbnNbbW9kZV09e307Y29weU9iaihwcm9wZXJ0aWVzLGV4dHMpO31mdW5jdGlvbiBjb3B5U3RhdGUobW9kZSxzdGF0ZSl7aWYoc3RhdGU9PT10cnVlKXtyZXR1cm4gc3RhdGU7fWlmKG1vZGUuY29weVN0YXRlKXtyZXR1cm4gbW9kZS5jb3B5U3RhdGUoc3RhdGUpO312YXIgbnN0YXRlPXt9O2Zvcih2YXIgbiBpbiBzdGF0ZSl7dmFyIHZhbD1zdGF0ZVtuXTtpZih2YWwgaW5zdGFuY2VvZiBBcnJheSl7dmFsPXZhbC5jb25jYXQoW10pO31uc3RhdGVbbl09dmFsO31yZXR1cm4gbnN0YXRlO30vLyBHaXZlbiBhIG1vZGUgYW5kIGEgc3RhdGUgKGZvciB0aGF0IG1vZGUpLCBmaW5kIHRoZSBpbm5lciBtb2RlIGFuZFxuLy8gc3RhdGUgYXQgdGhlIHBvc2l0aW9uIHRoYXQgdGhlIHN0YXRlIHJlZmVycyB0by5cbmZ1bmN0aW9uIGlubmVyTW9kZShtb2RlLHN0YXRlKXt2YXIgaW5mbzt3aGlsZShtb2RlLmlubmVyTW9kZSl7aW5mbz1tb2RlLmlubmVyTW9kZShzdGF0ZSk7aWYoIWluZm98fGluZm8ubW9kZT09bW9kZSl7YnJlYWs7fXN0YXRlPWluZm8uc3RhdGU7bW9kZT1pbmZvLm1vZGU7fXJldHVybiBpbmZvfHx7bW9kZTptb2RlLHN0YXRlOnN0YXRlfTt9ZnVuY3Rpb24gc3RhcnRTdGF0ZShtb2RlLGExLGEyKXtyZXR1cm4gbW9kZS5zdGFydFN0YXRlP21vZGUuc3RhcnRTdGF0ZShhMSxhMik6dHJ1ZTt9Ly8gU1RSSU5HIFNUUkVBTVxuLy8gRmVkIHRvIHRoZSBtb2RlIHBhcnNlcnMsIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gbWFrZVxuLy8gcGFyc2VycyBtb3JlIHN1Y2NpbmN0LlxudmFyIFN0cmluZ1N0cmVhbT1mdW5jdGlvbihzdHJpbmcsdGFiU2l6ZSl7dGhpcy5wb3M9dGhpcy5zdGFydD0wO3RoaXMuc3RyaW5nPXN0cmluZzt0aGlzLnRhYlNpemU9dGFiU2l6ZXx8ODt0aGlzLmxhc3RDb2x1bW5Qb3M9dGhpcy5sYXN0Q29sdW1uVmFsdWU9MDt0aGlzLmxpbmVTdGFydD0wO307U3RyaW5nU3RyZWFtLnByb3RvdHlwZT17ZW9sOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zPj10aGlzLnN0cmluZy5sZW5ndGg7fSxzb2w6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3M9PXRoaXMubGluZVN0YXJ0O30scGVlazpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpfHx1bmRlZmluZWQ7fSxuZXh0OmZ1bmN0aW9uKCl7aWYodGhpcy5wb3M8dGhpcy5zdHJpbmcubGVuZ3RoKXtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO319LGVhdDpmdW5jdGlvbihtYXRjaCl7dmFyIGNoPXRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7dmFyIG9rO2lmKHR5cGVvZiBtYXRjaD09XCJzdHJpbmdcIil7b2s9Y2g9PW1hdGNoO31lbHNle29rPWNoJiYobWF0Y2gudGVzdD9tYXRjaC50ZXN0KGNoKTptYXRjaChjaCkpO31pZihvayl7Kyt0aGlzLnBvcztyZXR1cm4gY2g7fX0sZWF0V2hpbGU6ZnVuY3Rpb24obWF0Y2gpe3ZhciBzdGFydD10aGlzLnBvczt3aGlsZSh0aGlzLmVhdChtYXRjaCkpe31yZXR1cm4gdGhpcy5wb3M+c3RhcnQ7fSxlYXRTcGFjZTpmdW5jdGlvbigpe3ZhciB0aGlzJDE9dGhpczt2YXIgc3RhcnQ9dGhpcy5wb3M7d2hpbGUoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSl7Kyt0aGlzJDEucG9zO31yZXR1cm4gdGhpcy5wb3M+c3RhcnQ7fSxza2lwVG9FbmQ6ZnVuY3Rpb24oKXt0aGlzLnBvcz10aGlzLnN0cmluZy5sZW5ndGg7fSxza2lwVG86ZnVuY3Rpb24oY2gpe3ZhciBmb3VuZD10aGlzLnN0cmluZy5pbmRleE9mKGNoLHRoaXMucG9zKTtpZihmb3VuZD4tMSl7dGhpcy5wb3M9Zm91bmQ7cmV0dXJuIHRydWU7fX0sYmFja1VwOmZ1bmN0aW9uKG4pe3RoaXMucG9zLT1uO30sY29sdW1uOmZ1bmN0aW9uKCl7aWYodGhpcy5sYXN0Q29sdW1uUG9zPHRoaXMuc3RhcnQpe3RoaXMubGFzdENvbHVtblZhbHVlPWNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLHRoaXMuc3RhcnQsdGhpcy50YWJTaXplLHRoaXMubGFzdENvbHVtblBvcyx0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7dGhpcy5sYXN0Q29sdW1uUG9zPXRoaXMuc3RhcnQ7fXJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZS0odGhpcy5saW5lU3RhcnQ/Y291bnRDb2x1bW4odGhpcy5zdHJpbmcsdGhpcy5saW5lU3RhcnQsdGhpcy50YWJTaXplKTowKTt9LGluZGVudGF0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLG51bGwsdGhpcy50YWJTaXplKS0odGhpcy5saW5lU3RhcnQ/Y291bnRDb2x1bW4odGhpcy5zdHJpbmcsdGhpcy5saW5lU3RhcnQsdGhpcy50YWJTaXplKTowKTt9LG1hdGNoOmZ1bmN0aW9uKHBhdHRlcm4sY29uc3VtZSxjYXNlSW5zZW5zaXRpdmUpe2lmKHR5cGVvZiBwYXR0ZXJuPT1cInN0cmluZ1wiKXt2YXIgY2FzZWQ9ZnVuY3Rpb24oc3RyKXtyZXR1cm4gY2FzZUluc2Vuc2l0aXZlP3N0ci50b0xvd2VyQ2FzZSgpOnN0cjt9O3ZhciBzdWJzdHI9dGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLHBhdHRlcm4ubGVuZ3RoKTtpZihjYXNlZChzdWJzdHIpPT1jYXNlZChwYXR0ZXJuKSl7aWYoY29uc3VtZSE9PWZhbHNlKXt0aGlzLnBvcys9cGF0dGVybi5sZW5ndGg7fXJldHVybiB0cnVlO319ZWxzZXt2YXIgbWF0Y2g9dGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO2lmKG1hdGNoJiZtYXRjaC5pbmRleD4wKXtyZXR1cm4gbnVsbDt9aWYobWF0Y2gmJmNvbnN1bWUhPT1mYWxzZSl7dGhpcy5wb3MrPW1hdGNoWzBdLmxlbmd0aDt9cmV0dXJuIG1hdGNoO319LGN1cnJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCx0aGlzLnBvcyk7fSxoaWRlRmlyc3RDaGFyczpmdW5jdGlvbihuLGlubmVyKXt0aGlzLmxpbmVTdGFydCs9bjt0cnl7cmV0dXJuIGlubmVyKCk7fWZpbmFsbHl7dGhpcy5saW5lU3RhcnQtPW47fX19Oy8vIENvbXB1dGUgYSBzdHlsZSBhcnJheSAoYW4gYXJyYXkgc3RhcnRpbmcgd2l0aCBhIG1vZGUgZ2VuZXJhdGlvblxuLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxuLy8gc3R5bGUgc3RyaW5ncyksIHdoaWNoIGlzIHVzZWQgdG8gaGlnaGxpZ2h0IHRoZSB0b2tlbnMgb24gdGhlXG4vLyBsaW5lLlxuZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSxsaW5lLHN0YXRlLGZvcmNlVG9FbmQpey8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcbi8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cbnZhciBzdD1bY20uc3RhdGUubW9kZUdlbl0sbGluZUNsYXNzZXM9e307Ly8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcbnJ1bk1vZGUoY20sbGluZS50ZXh0LGNtLmRvYy5tb2RlLHN0YXRlLGZ1bmN0aW9uKGVuZCxzdHlsZSl7cmV0dXJuIHN0LnB1c2goZW5kLHN0eWxlKTt9LGxpbmVDbGFzc2VzLGZvcmNlVG9FbmQpOy8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxudmFyIGxvb3A9ZnVuY3Rpb24obyl7dmFyIG92ZXJsYXk9Y20uc3RhdGUub3ZlcmxheXNbb10saT0xLGF0PTA7cnVuTW9kZShjbSxsaW5lLnRleHQsb3ZlcmxheS5tb2RlLHRydWUsZnVuY3Rpb24oZW5kLHN0eWxlKXt2YXIgc3RhcnQ9aTsvLyBFbnN1cmUgdGhlcmUncyBhIHRva2VuIGVuZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoYXQgaSBwb2ludHMgYXQgaXRcbndoaWxlKGF0PGVuZCl7dmFyIGlfZW5kPXN0W2ldO2lmKGlfZW5kPmVuZCl7c3Quc3BsaWNlKGksMSxlbmQsc3RbaSsxXSxpX2VuZCk7fWkrPTI7YXQ9TWF0aC5taW4oZW5kLGlfZW5kKTt9aWYoIXN0eWxlKXtyZXR1cm47fWlmKG92ZXJsYXkub3BhcXVlKXtzdC5zcGxpY2Uoc3RhcnQsaS1zdGFydCxlbmQsXCJvdmVybGF5IFwiK3N0eWxlKTtpPXN0YXJ0KzI7fWVsc2V7Zm9yKDtzdGFydDxpO3N0YXJ0Kz0yKXt2YXIgY3VyPXN0W3N0YXJ0KzFdO3N0W3N0YXJ0KzFdPShjdXI/Y3VyK1wiIFwiOlwiXCIpK1wib3ZlcmxheSBcIitzdHlsZTt9fX0sbGluZUNsYXNzZXMpO307Zm9yKHZhciBvPTA7bzxjbS5zdGF0ZS5vdmVybGF5cy5sZW5ndGg7KytvKWxvb3Aobyk7cmV0dXJue3N0eWxlczpzdCxjbGFzc2VzOmxpbmVDbGFzc2VzLmJnQ2xhc3N8fGxpbmVDbGFzc2VzLnRleHRDbGFzcz9saW5lQ2xhc3NlczpudWxsfTt9ZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSxsaW5lLHVwZGF0ZUZyb250aWVyKXtpZighbGluZS5zdHlsZXN8fGxpbmUuc3R5bGVzWzBdIT1jbS5zdGF0ZS5tb2RlR2VuKXt2YXIgc3RhdGU9Z2V0U3RhdGVCZWZvcmUoY20sbGluZU5vKGxpbmUpKTt2YXIgcmVzdWx0PWhpZ2hsaWdodExpbmUoY20sbGluZSxsaW5lLnRleHQubGVuZ3RoPmNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoP2NvcHlTdGF0ZShjbS5kb2MubW9kZSxzdGF0ZSk6c3RhdGUpO2xpbmUuc3RhdGVBZnRlcj1zdGF0ZTtsaW5lLnN0eWxlcz1yZXN1bHQuc3R5bGVzO2lmKHJlc3VsdC5jbGFzc2VzKXtsaW5lLnN0eWxlQ2xhc3Nlcz1yZXN1bHQuY2xhc3Nlczt9ZWxzZSBpZihsaW5lLnN0eWxlQ2xhc3Nlcyl7bGluZS5zdHlsZUNsYXNzZXM9bnVsbDt9aWYodXBkYXRlRnJvbnRpZXI9PT1jbS5kb2MuZnJvbnRpZXIpe2NtLmRvYy5mcm9udGllcisrO319cmV0dXJuIGxpbmUuc3R5bGVzO31mdW5jdGlvbiBnZXRTdGF0ZUJlZm9yZShjbSxuLHByZWNpc2Upe3ZhciBkb2M9Y20uZG9jLGRpc3BsYXk9Y20uZGlzcGxheTtpZighZG9jLm1vZGUuc3RhcnRTdGF0ZSl7cmV0dXJuIHRydWU7fXZhciBwb3M9ZmluZFN0YXJ0TGluZShjbSxuLHByZWNpc2UpLHN0YXRlPXBvcz5kb2MuZmlyc3QmJmdldExpbmUoZG9jLHBvcy0xKS5zdGF0ZUFmdGVyO2lmKCFzdGF0ZSl7c3RhdGU9c3RhcnRTdGF0ZShkb2MubW9kZSk7fWVsc2V7c3RhdGU9Y29weVN0YXRlKGRvYy5tb2RlLHN0YXRlKTt9ZG9jLml0ZXIocG9zLG4sZnVuY3Rpb24obGluZSl7cHJvY2Vzc0xpbmUoY20sbGluZS50ZXh0LHN0YXRlKTt2YXIgc2F2ZT1wb3M9PW4tMXx8cG9zJTU9PTB8fHBvcz49ZGlzcGxheS52aWV3RnJvbSYmcG9zPGRpc3BsYXkudmlld1RvO2xpbmUuc3RhdGVBZnRlcj1zYXZlP2NvcHlTdGF0ZShkb2MubW9kZSxzdGF0ZSk6bnVsbDsrK3Bvczt9KTtpZihwcmVjaXNlKXtkb2MuZnJvbnRpZXI9cG9zO31yZXR1cm4gc3RhdGU7fS8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXG4vLyB1cGRhdGUgc3RhdGUsIGJ1dCBkb24ndCBzYXZlIGEgc3R5bGUgYXJyYXkuIFVzZWQgZm9yIGxpbmVzIHRoYXRcbi8vIGFyZW4ndCBjdXJyZW50bHkgdmlzaWJsZS5cbmZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLHRleHQsc3RhdGUsc3RhcnRBdCl7dmFyIG1vZGU9Y20uZG9jLm1vZGU7dmFyIHN0cmVhbT1uZXcgU3RyaW5nU3RyZWFtKHRleHQsY20ub3B0aW9ucy50YWJTaXplKTtzdHJlYW0uc3RhcnQ9c3RyZWFtLnBvcz1zdGFydEF0fHwwO2lmKHRleHQ9PVwiXCIpe2NhbGxCbGFua0xpbmUobW9kZSxzdGF0ZSk7fXdoaWxlKCFzdHJlYW0uZW9sKCkpe3JlYWRUb2tlbihtb2RlLHN0cmVhbSxzdGF0ZSk7c3RyZWFtLnN0YXJ0PXN0cmVhbS5wb3M7fX1mdW5jdGlvbiBjYWxsQmxhbmtMaW5lKG1vZGUsc3RhdGUpe2lmKG1vZGUuYmxhbmtMaW5lKXtyZXR1cm4gbW9kZS5ibGFua0xpbmUoc3RhdGUpO31pZighbW9kZS5pbm5lck1vZGUpe3JldHVybjt9dmFyIGlubmVyPWlubmVyTW9kZShtb2RlLHN0YXRlKTtpZihpbm5lci5tb2RlLmJsYW5rTGluZSl7cmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKTt9fWZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLHN0cmVhbSxzdGF0ZSxpbm5lcil7Zm9yKHZhciBpPTA7aTwxMDtpKyspe2lmKGlubmVyKXtpbm5lclswXT1pbm5lck1vZGUobW9kZSxzdGF0ZSkubW9kZTt9dmFyIHN0eWxlPW1vZGUudG9rZW4oc3RyZWFtLHN0YXRlKTtpZihzdHJlYW0ucG9zPnN0cmVhbS5zdGFydCl7cmV0dXJuIHN0eWxlO319dGhyb3cgbmV3IEVycm9yKFwiTW9kZSBcIittb2RlLm5hbWUrXCIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlwiKTt9Ly8gVXRpbGl0eSBmb3IgZ2V0VG9rZW5BdCBhbmQgZ2V0TGluZVRva2Vuc1xuZnVuY3Rpb24gdGFrZVRva2VuKGNtLHBvcyxwcmVjaXNlLGFzQXJyYXkpe3ZhciBnZXRPYmo9ZnVuY3Rpb24oY29weSl7cmV0dXJue3N0YXJ0OnN0cmVhbS5zdGFydCxlbmQ6c3RyZWFtLnBvcyxzdHJpbmc6c3RyZWFtLmN1cnJlbnQoKSx0eXBlOnN0eWxlfHxudWxsLHN0YXRlOmNvcHk/Y29weVN0YXRlKGRvYy5tb2RlLHN0YXRlKTpzdGF0ZX07fTt2YXIgZG9jPWNtLmRvYyxtb2RlPWRvYy5tb2RlLHN0eWxlO3Bvcz1jbGlwUG9zKGRvYyxwb3MpO3ZhciBsaW5lPWdldExpbmUoZG9jLHBvcy5saW5lKSxzdGF0ZT1nZXRTdGF0ZUJlZm9yZShjbSxwb3MubGluZSxwcmVjaXNlKTt2YXIgc3RyZWFtPW5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LGNtLm9wdGlvbnMudGFiU2l6ZSksdG9rZW5zO2lmKGFzQXJyYXkpe3Rva2Vucz1bXTt9d2hpbGUoKGFzQXJyYXl8fHN0cmVhbS5wb3M8cG9zLmNoKSYmIXN0cmVhbS5lb2woKSl7c3RyZWFtLnN0YXJ0PXN0cmVhbS5wb3M7c3R5bGU9cmVhZFRva2VuKG1vZGUsc3RyZWFtLHN0YXRlKTtpZihhc0FycmF5KXt0b2tlbnMucHVzaChnZXRPYmoodHJ1ZSkpO319cmV0dXJuIGFzQXJyYXk/dG9rZW5zOmdldE9iaigpO31mdW5jdGlvbiBleHRyYWN0TGluZUNsYXNzZXModHlwZSxvdXRwdXQpe2lmKHR5cGUpe2Zvcig7Oyl7dmFyIGxpbmVDbGFzcz10eXBlLm1hdGNoKC8oPzpefFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFMrKS8pO2lmKCFsaW5lQ2xhc3Mpe2JyZWFrO310eXBlPXR5cGUuc2xpY2UoMCxsaW5lQ2xhc3MuaW5kZXgpK3R5cGUuc2xpY2UobGluZUNsYXNzLmluZGV4K2xpbmVDbGFzc1swXS5sZW5ndGgpO3ZhciBwcm9wPWxpbmVDbGFzc1sxXT9cImJnQ2xhc3NcIjpcInRleHRDbGFzc1wiO2lmKG91dHB1dFtwcm9wXT09bnVsbCl7b3V0cHV0W3Byb3BdPWxpbmVDbGFzc1syXTt9ZWxzZSBpZighbmV3IFJlZ0V4cChcIig/Ol58XFxzKVwiK2xpbmVDbGFzc1syXStcIig/OiR8XFxzKVwiKS50ZXN0KG91dHB1dFtwcm9wXSkpe291dHB1dFtwcm9wXSs9XCIgXCIrbGluZUNsYXNzWzJdO319fXJldHVybiB0eXBlO30vLyBSdW4gdGhlIGdpdmVuIG1vZGUncyBwYXJzZXIgb3ZlciBhIGxpbmUsIGNhbGxpbmcgZiBmb3IgZWFjaCB0b2tlbi5cbmZ1bmN0aW9uIHJ1bk1vZGUoY20sdGV4dCxtb2RlLHN0YXRlLGYsbGluZUNsYXNzZXMsZm9yY2VUb0VuZCl7dmFyIGZsYXR0ZW5TcGFucz1tb2RlLmZsYXR0ZW5TcGFucztpZihmbGF0dGVuU3BhbnM9PW51bGwpe2ZsYXR0ZW5TcGFucz1jbS5vcHRpb25zLmZsYXR0ZW5TcGFuczt9dmFyIGN1clN0YXJ0PTAsY3VyU3R5bGU9bnVsbDt2YXIgc3RyZWFtPW5ldyBTdHJpbmdTdHJlYW0odGV4dCxjbS5vcHRpb25zLnRhYlNpemUpLHN0eWxlO3ZhciBpbm5lcj1jbS5vcHRpb25zLmFkZE1vZGVDbGFzcyYmW251bGxdO2lmKHRleHQ9PVwiXCIpe2V4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsc3RhdGUpLGxpbmVDbGFzc2VzKTt9d2hpbGUoIXN0cmVhbS5lb2woKSl7aWYoc3RyZWFtLnBvcz5jbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCl7ZmxhdHRlblNwYW5zPWZhbHNlO2lmKGZvcmNlVG9FbmQpe3Byb2Nlc3NMaW5lKGNtLHRleHQsc3RhdGUsc3RyZWFtLnBvcyk7fXN0cmVhbS5wb3M9dGV4dC5sZW5ndGg7c3R5bGU9bnVsbDt9ZWxzZXtzdHlsZT1leHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsc3RyZWFtLHN0YXRlLGlubmVyKSxsaW5lQ2xhc3Nlcyk7fWlmKGlubmVyKXt2YXIgbU5hbWU9aW5uZXJbMF0ubmFtZTtpZihtTmFtZSl7c3R5bGU9XCJtLVwiKyhzdHlsZT9tTmFtZStcIiBcIitzdHlsZTptTmFtZSk7fX1pZighZmxhdHRlblNwYW5zfHxjdXJTdHlsZSE9c3R5bGUpe3doaWxlKGN1clN0YXJ0PHN0cmVhbS5zdGFydCl7Y3VyU3RhcnQ9TWF0aC5taW4oc3RyZWFtLnN0YXJ0LGN1clN0YXJ0KzUwMDApO2YoY3VyU3RhcnQsY3VyU3R5bGUpO31jdXJTdHlsZT1zdHlsZTt9c3RyZWFtLnN0YXJ0PXN0cmVhbS5wb3M7fXdoaWxlKGN1clN0YXJ0PHN0cmVhbS5wb3Mpey8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDRcbi8vIGNoYXJhY3RlcnMsIGFuZCByZXR1cm5zIGluYWNjdXJhdGUgbWVhc3VyZW1lbnRzIGluIG5vZGVzXG4vLyBzdGFydGluZyBhcm91bmQgNTAwMCBjaGFycy5cbnZhciBwb3M9TWF0aC5taW4oc3RyZWFtLnBvcyxjdXJTdGFydCs1MDAwKTtmKHBvcyxjdXJTdHlsZSk7Y3VyU3RhcnQ9cG9zO319Ly8gRmluZHMgdGhlIGxpbmUgdG8gc3RhcnQgd2l0aCB3aGVuIHN0YXJ0aW5nIGEgcGFyc2UuIFRyaWVzIHRvXG4vLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXG4vLyB2YWxpZCBzdGF0ZS4gSWYgdGhhdCBmYWlscywgaXQgcmV0dXJucyB0aGUgbGluZSB3aXRoIHRoZVxuLy8gc21hbGxlc3QgaW5kZW50YXRpb24sIHdoaWNoIHRlbmRzIHRvIG5lZWQgdGhlIGxlYXN0IGNvbnRleHQgdG9cbi8vIHBhcnNlIGNvcnJlY3RseS5cbmZ1bmN0aW9uIGZpbmRTdGFydExpbmUoY20sbixwcmVjaXNlKXt2YXIgbWluaW5kZW50LG1pbmxpbmUsZG9jPWNtLmRvYzt2YXIgbGltPXByZWNpc2U/LTE6bi0oY20uZG9jLm1vZGUuaW5uZXJNb2RlPzEwMDA6MTAwKTtmb3IodmFyIHNlYXJjaD1uO3NlYXJjaD5saW07LS1zZWFyY2gpe2lmKHNlYXJjaDw9ZG9jLmZpcnN0KXtyZXR1cm4gZG9jLmZpcnN0O312YXIgbGluZT1nZXRMaW5lKGRvYyxzZWFyY2gtMSk7aWYobGluZS5zdGF0ZUFmdGVyJiYoIXByZWNpc2V8fHNlYXJjaDw9ZG9jLmZyb250aWVyKSl7cmV0dXJuIHNlYXJjaDt9dmFyIGluZGVudGVkPWNvdW50Q29sdW1uKGxpbmUudGV4dCxudWxsLGNtLm9wdGlvbnMudGFiU2l6ZSk7aWYobWlubGluZT09bnVsbHx8bWluaW5kZW50PmluZGVudGVkKXttaW5saW5lPXNlYXJjaC0xO21pbmluZGVudD1pbmRlbnRlZDt9fXJldHVybiBtaW5saW5lO30vLyBMSU5FIERBVEEgU1RSVUNUVVJFXG4vLyBMaW5lIG9iamVjdHMuIFRoZXNlIGhvbGQgc3RhdGUgcmVsYXRlZCB0byBhIGxpbmUsIGluY2x1ZGluZ1xuLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxuZnVuY3Rpb24gTGluZSh0ZXh0LG1hcmtlZFNwYW5zLGVzdGltYXRlSGVpZ2h0KXt0aGlzLnRleHQ9dGV4dDthdHRhY2hNYXJrZWRTcGFucyh0aGlzLG1hcmtlZFNwYW5zKTt0aGlzLmhlaWdodD1lc3RpbWF0ZUhlaWdodD9lc3RpbWF0ZUhlaWdodCh0aGlzKToxO31ldmVudE1peGluKExpbmUpO0xpbmUucHJvdG90eXBlLmxpbmVObz1mdW5jdGlvbigpe3JldHVybiBsaW5lTm8odGhpcyk7fTsvLyBDaGFuZ2UgdGhlIGNvbnRlbnQgKHRleHQsIG1hcmtlcnMpIG9mIGEgbGluZS4gQXV0b21hdGljYWxseVxuLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcbi8vIGxpbmUncyBoZWlnaHQuXG5mdW5jdGlvbiB1cGRhdGVMaW5lKGxpbmUsdGV4dCxtYXJrZWRTcGFucyxlc3RpbWF0ZUhlaWdodCl7bGluZS50ZXh0PXRleHQ7aWYobGluZS5zdGF0ZUFmdGVyKXtsaW5lLnN0YXRlQWZ0ZXI9bnVsbDt9aWYobGluZS5zdHlsZXMpe2xpbmUuc3R5bGVzPW51bGw7fWlmKGxpbmUub3JkZXIhPW51bGwpe2xpbmUub3JkZXI9bnVsbDt9ZGV0YWNoTWFya2VkU3BhbnMobGluZSk7YXR0YWNoTWFya2VkU3BhbnMobGluZSxtYXJrZWRTcGFucyk7dmFyIGVzdEhlaWdodD1lc3RpbWF0ZUhlaWdodD9lc3RpbWF0ZUhlaWdodChsaW5lKToxO2lmKGVzdEhlaWdodCE9bGluZS5oZWlnaHQpe3VwZGF0ZUxpbmVIZWlnaHQobGluZSxlc3RIZWlnaHQpO319Ly8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cbmZ1bmN0aW9uIGNsZWFuVXBMaW5lKGxpbmUpe2xpbmUucGFyZW50PW51bGw7ZGV0YWNoTWFya2VkU3BhbnMobGluZSk7fS8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xuLy8gY29udGFpbmluZyBvbmUgb3IgbW9yZSBzdHlsZXMpIHRvIGEgQ1NTIHN0eWxlLiBUaGlzIGlzIGNhY2hlZCxcbi8vIGFuZCBhbHNvIGxvb2tzIGZvciBsaW5lLXdpZGUgc3R5bGVzLlxudmFyIHN0eWxlVG9DbGFzc0NhY2hlPXt9O3ZhciBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlPXt9O2Z1bmN0aW9uIGludGVycHJldFRva2VuU3R5bGUoc3R5bGUsb3B0aW9ucyl7aWYoIXN0eWxlfHwvXlxccyokLy50ZXN0KHN0eWxlKSl7cmV0dXJuIG51bGw7fXZhciBjYWNoZT1vcHRpb25zLmFkZE1vZGVDbGFzcz9zdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlOnN0eWxlVG9DbGFzc0NhY2hlO3JldHVybiBjYWNoZVtzdHlsZV18fChjYWNoZVtzdHlsZV09c3R5bGUucmVwbGFjZSgvXFxTKy9nLFwiY20tJCZcIikpO30vLyBSZW5kZXIgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dCBvZiBhIGxpbmUuIEFsc28gYnVpbGRzXG4vLyB1cCBhICdsaW5lIG1hcCcsIHdoaWNoIHBvaW50cyBhdCB0aGUgRE9NIG5vZGVzIHRoYXQgcmVwcmVzZW50XG4vLyBzcGVjaWZpYyBzdHJldGNoZXMgb2YgdGV4dCwgYW5kIGlzIHVzZWQgYnkgdGhlIG1lYXN1cmluZyBjb2RlLlxuLy8gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgRE9NIG5vZGUsIHRoaXMgbWFwLCBhbmRcbi8vIGluZm9ybWF0aW9uIGFib3V0IGxpbmUtd2lkZSBzdHlsZXMgdGhhdCB3ZXJlIHNldCBieSB0aGUgbW9kZS5cbmZ1bmN0aW9uIGJ1aWxkTGluZUNvbnRlbnQoY20sbGluZVZpZXcpey8vIFRoZSBwYWRkaW5nLXJpZ2h0IGZvcmNlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgJ2JvcmRlcicsIHdoaWNoXG4vLyBpcyBuZWVkZWQgb24gV2Via2l0IHRvIGJlIGFibGUgdG8gZ2V0IGxpbmUtbGV2ZWwgYm91bmRpbmdcbi8vIHJlY3RhbmdsZXMgZm9yIGl0IChpbiBtZWFzdXJlQ2hhcikuXG52YXIgY29udGVudD1lbHQoXCJzcGFuXCIsbnVsbCxudWxsLHdlYmtpdD9cInBhZGRpbmctcmlnaHQ6IC4xcHhcIjpudWxsKTt2YXIgYnVpbGRlcj17cHJlOmVsdChcInByZVwiLFtjb250ZW50XSxcIkNvZGVNaXJyb3ItbGluZVwiKSxjb250ZW50OmNvbnRlbnQsY29sOjAscG9zOjAsY206Y20sdHJhaWxpbmdTcGFjZTpmYWxzZSxzcGxpdFNwYWNlczooaWV8fHdlYmtpdCkmJmNtLmdldE9wdGlvbihcImxpbmVXcmFwcGluZ1wiKX07bGluZVZpZXcubWVhc3VyZT17fTsvLyBJdGVyYXRlIG92ZXIgdGhlIGxvZ2ljYWwgbGluZXMgdGhhdCBtYWtlIHVwIHRoaXMgdmlzdWFsIGxpbmUuXG5mb3IodmFyIGk9MDtpPD0obGluZVZpZXcucmVzdD9saW5lVmlldy5yZXN0Lmxlbmd0aDowKTtpKyspe3ZhciBsaW5lPWk/bGluZVZpZXcucmVzdFtpLTFdOmxpbmVWaWV3LmxpbmUsb3JkZXI9dm9pZCAwO2J1aWxkZXIucG9zPTA7YnVpbGRlci5hZGRUb2tlbj1idWlsZFRva2VuOy8vIE9wdGlvbmFsbHkgd2lyZSBpbiBzb21lIGhhY2tzIGludG8gdGhlIHRva2VuLXJlbmRlcmluZ1xuLy8gYWxnb3JpdGhtLCB0byBkZWFsIHdpdGggYnJvd3NlciBxdWlya3MuXG5pZihoYXNCYWRCaWRpUmVjdHMoY20uZGlzcGxheS5tZWFzdXJlKSYmKG9yZGVyPWdldE9yZGVyKGxpbmUpKSl7YnVpbGRlci5hZGRUb2tlbj1idWlsZFRva2VuQmFkQmlkaShidWlsZGVyLmFkZFRva2VuLG9yZGVyKTt9YnVpbGRlci5tYXA9W107dmFyIGFsbG93RnJvbnRpZXJVcGRhdGU9bGluZVZpZXchPWNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCYmbGluZU5vKGxpbmUpO2luc2VydExpbmVDb250ZW50KGxpbmUsYnVpbGRlcixnZXRMaW5lU3R5bGVzKGNtLGxpbmUsYWxsb3dGcm9udGllclVwZGF0ZSkpO2lmKGxpbmUuc3R5bGVDbGFzc2VzKXtpZihsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzKXtidWlsZGVyLmJnQ2xhc3M9am9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcyxidWlsZGVyLmJnQ2xhc3N8fFwiXCIpO31pZihsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3Mpe2J1aWxkZXIudGV4dENsYXNzPWpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcyxidWlsZGVyLnRleHRDbGFzc3x8XCJcIik7fX0vLyBFbnN1cmUgYXQgbGVhc3QgYSBzaW5nbGUgbm9kZSBpcyBwcmVzZW50LCBmb3IgbWVhc3VyaW5nLlxuaWYoYnVpbGRlci5tYXAubGVuZ3RoPT0wKXtidWlsZGVyLm1hcC5wdXNoKDAsMCxidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7fS8vIFN0b3JlIHRoZSBtYXAgYW5kIGEgY2FjaGUgb2JqZWN0IGZvciB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmVcbmlmKGk9PTApe2xpbmVWaWV3Lm1lYXN1cmUubWFwPWJ1aWxkZXIubWFwO2xpbmVWaWV3Lm1lYXN1cmUuY2FjaGU9e307fWVsc2V7OyhsaW5lVmlldy5tZWFzdXJlLm1hcHN8fChsaW5lVmlldy5tZWFzdXJlLm1hcHM9W10pKS5wdXNoKGJ1aWxkZXIubWFwKTsobGluZVZpZXcubWVhc3VyZS5jYWNoZXN8fChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcz1bXSkpLnB1c2goe30pO319Ly8gU2VlIGlzc3VlICMyOTAxXG5pZih3ZWJraXQpe3ZhciBsYXN0PWJ1aWxkZXIuY29udGVudC5sYXN0Q2hpbGQ7aWYoL1xcYmNtLXRhYlxcYi8udGVzdChsYXN0LmNsYXNzTmFtZSl8fGxhc3QucXVlcnlTZWxlY3RvciYmbGFzdC5xdWVyeVNlbGVjdG9yKFwiLmNtLXRhYlwiKSl7YnVpbGRlci5jb250ZW50LmNsYXNzTmFtZT1cImNtLXRhYi13cmFwLWhhY2tcIjt9fXNpZ25hbChjbSxcInJlbmRlckxpbmVcIixjbSxsaW5lVmlldy5saW5lLGJ1aWxkZXIucHJlKTtpZihidWlsZGVyLnByZS5jbGFzc05hbWUpe2J1aWxkZXIudGV4dENsYXNzPWpvaW5DbGFzc2VzKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSxidWlsZGVyLnRleHRDbGFzc3x8XCJcIik7fXJldHVybiBidWlsZGVyO31mdW5jdGlvbiBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlcihjaCl7dmFyIHRva2VuPWVsdChcInNwYW5cIixcIlxcdTIwMjJcIixcImNtLWludmFsaWRjaGFyXCIpO3Rva2VuLnRpdGxlPVwiXFxcXHVcIitjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTt0b2tlbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsdG9rZW4udGl0bGUpO3JldHVybiB0b2tlbjt9Ly8gQnVpbGQgdXAgdGhlIERPTSByZXByZXNlbnRhdGlvbiBmb3IgYSBzaW5nbGUgdG9rZW4sIGFuZCBhZGQgaXQgdG9cbi8vIHRoZSBsaW5lIG1hcC4gVGFrZXMgY2FyZSB0byByZW5kZXIgc3BlY2lhbCBjaGFyYWN0ZXJzIHNlcGFyYXRlbHkuXG5mdW5jdGlvbiBidWlsZFRva2VuKGJ1aWxkZXIsdGV4dCxzdHlsZSxzdGFydFN0eWxlLGVuZFN0eWxlLHRpdGxlLGNzcyl7aWYoIXRleHQpe3JldHVybjt9dmFyIGRpc3BsYXlUZXh0PWJ1aWxkZXIuc3BsaXRTcGFjZXM/c3BsaXRTcGFjZXModGV4dCxidWlsZGVyLnRyYWlsaW5nU3BhY2UpOnRleHQ7dmFyIHNwZWNpYWw9YnVpbGRlci5jbS5zdGF0ZS5zcGVjaWFsQ2hhcnMsbXVzdFdyYXA9ZmFsc2U7dmFyIGNvbnRlbnQ7aWYoIXNwZWNpYWwudGVzdCh0ZXh0KSl7YnVpbGRlci5jb2wrPXRleHQubGVuZ3RoO2NvbnRlbnQ9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpO2J1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsYnVpbGRlci5wb3MrdGV4dC5sZW5ndGgsY29udGVudCk7aWYoaWUmJmllX3ZlcnNpb248OSl7bXVzdFdyYXA9dHJ1ZTt9YnVpbGRlci5wb3MrPXRleHQubGVuZ3RoO31lbHNle2NvbnRlbnQ9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO3ZhciBwb3M9MDt3aGlsZSh0cnVlKXtzcGVjaWFsLmxhc3RJbmRleD1wb3M7dmFyIG09c3BlY2lhbC5leGVjKHRleHQpO3ZhciBza2lwcGVkPW0/bS5pbmRleC1wb3M6dGV4dC5sZW5ndGgtcG9zO2lmKHNraXBwZWQpe3ZhciB0eHQ9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQuc2xpY2UocG9zLHBvcytza2lwcGVkKSk7aWYoaWUmJmllX3ZlcnNpb248OSl7Y29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsW3R4dF0pKTt9ZWxzZXtjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7fWJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsYnVpbGRlci5wb3Mrc2tpcHBlZCx0eHQpO2J1aWxkZXIuY29sKz1za2lwcGVkO2J1aWxkZXIucG9zKz1za2lwcGVkO31pZighbSl7YnJlYWs7fXBvcys9c2tpcHBlZCsxO3ZhciB0eHQkMT12b2lkIDA7aWYobVswXT09XCJcXHRcIil7dmFyIHRhYlNpemU9YnVpbGRlci5jbS5vcHRpb25zLnRhYlNpemUsdGFiV2lkdGg9dGFiU2l6ZS1idWlsZGVyLmNvbCV0YWJTaXplO3R4dCQxPWNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLHNwYWNlU3RyKHRhYldpZHRoKSxcImNtLXRhYlwiKSk7dHh0JDEuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwicHJlc2VudGF0aW9uXCIpO3R4dCQxLnNldEF0dHJpYnV0ZShcImNtLXRleHRcIixcIlxcdFwiKTtidWlsZGVyLmNvbCs9dGFiV2lkdGg7fWVsc2UgaWYobVswXT09XCJcXHJcInx8bVswXT09XCJcXG5cIil7dHh0JDE9Y29udGVudC5hcHBlbmRDaGlsZChlbHQoXCJzcGFuXCIsbVswXT09XCJcXHJcIj9cIlxcdTI0MGRcIjpcIlxcdTI0MjRcIixcImNtLWludmFsaWRjaGFyXCIpKTt0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsbVswXSk7YnVpbGRlci5jb2wrPTE7fWVsc2V7dHh0JDE9YnVpbGRlci5jbS5vcHRpb25zLnNwZWNpYWxDaGFyUGxhY2Vob2xkZXIobVswXSk7dHh0JDEuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLG1bMF0pO2lmKGllJiZpZV92ZXJzaW9uPDkpe2NvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLFt0eHQkMV0pKTt9ZWxzZXtjb250ZW50LmFwcGVuZENoaWxkKHR4dCQxKTt9YnVpbGRlci5jb2wrPTE7fWJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsYnVpbGRlci5wb3MrMSx0eHQkMSk7YnVpbGRlci5wb3MrKzt9fWJ1aWxkZXIudHJhaWxpbmdTcGFjZT1kaXNwbGF5VGV4dC5jaGFyQ29kZUF0KHRleHQubGVuZ3RoLTEpPT0zMjtpZihzdHlsZXx8c3RhcnRTdHlsZXx8ZW5kU3R5bGV8fG11c3RXcmFwfHxjc3Mpe3ZhciBmdWxsU3R5bGU9c3R5bGV8fFwiXCI7aWYoc3RhcnRTdHlsZSl7ZnVsbFN0eWxlKz1zdGFydFN0eWxlO31pZihlbmRTdHlsZSl7ZnVsbFN0eWxlKz1lbmRTdHlsZTt9dmFyIHRva2VuPWVsdChcInNwYW5cIixbY29udGVudF0sZnVsbFN0eWxlLGNzcyk7aWYodGl0bGUpe3Rva2VuLnRpdGxlPXRpdGxlO31yZXR1cm4gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHRva2VuKTt9YnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO31mdW5jdGlvbiBzcGxpdFNwYWNlcyh0ZXh0LHRyYWlsaW5nQmVmb3JlKXtpZih0ZXh0Lmxlbmd0aD4xJiYhLyAgLy50ZXN0KHRleHQpKXtyZXR1cm4gdGV4dDt9dmFyIHNwYWNlQmVmb3JlPXRyYWlsaW5nQmVmb3JlLHJlc3VsdD1cIlwiO2Zvcih2YXIgaT0wO2k8dGV4dC5sZW5ndGg7aSsrKXt2YXIgY2g9dGV4dC5jaGFyQXQoaSk7aWYoY2g9PVwiIFwiJiZzcGFjZUJlZm9yZSYmKGk9PXRleHQubGVuZ3RoLTF8fHRleHQuY2hhckNvZGVBdChpKzEpPT0zMikpe2NoPVwiXFx1MDBhMFwiO31yZXN1bHQrPWNoO3NwYWNlQmVmb3JlPWNoPT1cIiBcIjt9cmV0dXJuIHJlc3VsdDt9Ly8gV29yayBhcm91bmQgbm9uc2Vuc2UgZGltZW5zaW9ucyBiZWluZyByZXBvcnRlZCBmb3Igc3RyZXRjaGVzIG9mXG4vLyByaWdodC10by1sZWZ0IHRleHQuXG5mdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lcixvcmRlcil7cmV0dXJuIGZ1bmN0aW9uKGJ1aWxkZXIsdGV4dCxzdHlsZSxzdGFydFN0eWxlLGVuZFN0eWxlLHRpdGxlLGNzcyl7c3R5bGU9c3R5bGU/c3R5bGUrXCIgY20tZm9yY2UtYm9yZGVyXCI6XCJjbS1mb3JjZS1ib3JkZXJcIjt2YXIgc3RhcnQ9YnVpbGRlci5wb3MsZW5kPXN0YXJ0K3RleHQubGVuZ3RoO2Zvcig7Oyl7Ly8gRmluZCB0aGUgcGFydCB0aGF0IG92ZXJsYXBzIHdpdGggdGhlIHN0YXJ0IG9mIHRoaXMgdGV4dFxudmFyIHBhcnQ9dm9pZCAwO2Zvcih2YXIgaT0wO2k8b3JkZXIubGVuZ3RoO2krKyl7cGFydD1vcmRlcltpXTtpZihwYXJ0LnRvPnN0YXJ0JiZwYXJ0LmZyb208PXN0YXJ0KXticmVhazt9fWlmKHBhcnQudG8+PWVuZCl7cmV0dXJuIGlubmVyKGJ1aWxkZXIsdGV4dCxzdHlsZSxzdGFydFN0eWxlLGVuZFN0eWxlLHRpdGxlLGNzcyk7fWlubmVyKGJ1aWxkZXIsdGV4dC5zbGljZSgwLHBhcnQudG8tc3RhcnQpLHN0eWxlLHN0YXJ0U3R5bGUsbnVsbCx0aXRsZSxjc3MpO3N0YXJ0U3R5bGU9bnVsbDt0ZXh0PXRleHQuc2xpY2UocGFydC50by1zdGFydCk7c3RhcnQ9cGFydC50bzt9fTt9ZnVuY3Rpb24gYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsc2l6ZSxtYXJrZXIsaWdub3JlV2lkZ2V0KXt2YXIgd2lkZ2V0PSFpZ25vcmVXaWRnZXQmJm1hcmtlci53aWRnZXROb2RlO2lmKHdpZGdldCl7YnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcyxidWlsZGVyLnBvcytzaXplLHdpZGdldCk7fWlmKCFpZ25vcmVXaWRnZXQmJmJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUpe2lmKCF3aWRnZXQpe3dpZGdldD1idWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO313aWRnZXQuc2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIsbWFya2VyLmlkKTt9aWYod2lkZ2V0KXtidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZSh3aWRnZXQpO2J1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO31idWlsZGVyLnBvcys9c2l6ZTtidWlsZGVyLnRyYWlsaW5nU3BhY2U9ZmFsc2U7fS8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcbi8vIGFuZCBtYXJrZWQgdGV4dCBpbnRvIGFjY291bnQuXG5mdW5jdGlvbiBpbnNlcnRMaW5lQ29udGVudChsaW5lLGJ1aWxkZXIsc3R5bGVzKXt2YXIgc3BhbnM9bGluZS5tYXJrZWRTcGFucyxhbGxUZXh0PWxpbmUudGV4dCxhdD0wO2lmKCFzcGFucyl7Zm9yKHZhciBpJDE9MTtpJDE8c3R5bGVzLmxlbmd0aDtpJDErPTIpe2J1aWxkZXIuYWRkVG9rZW4oYnVpbGRlcixhbGxUZXh0LnNsaWNlKGF0LGF0PXN0eWxlc1tpJDFdKSxpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpJDErMV0sYnVpbGRlci5jbS5vcHRpb25zKSk7fXJldHVybjt9dmFyIGxlbj1hbGxUZXh0Lmxlbmd0aCxwb3M9MCxpPTEsdGV4dD1cIlwiLHN0eWxlLGNzczt2YXIgbmV4dENoYW5nZT0wLHNwYW5TdHlsZSxzcGFuRW5kU3R5bGUsc3BhblN0YXJ0U3R5bGUsdGl0bGUsY29sbGFwc2VkO2Zvcig7Oyl7aWYobmV4dENoYW5nZT09cG9zKXsvLyBVcGRhdGUgY3VycmVudCBtYXJrZXIgc2V0XG5zcGFuU3R5bGU9c3BhbkVuZFN0eWxlPXNwYW5TdGFydFN0eWxlPXRpdGxlPWNzcz1cIlwiO2NvbGxhcHNlZD1udWxsO25leHRDaGFuZ2U9SW5maW5pdHk7dmFyIGZvdW5kQm9va21hcmtzPVtdLGVuZFN0eWxlcz12b2lkIDA7Zm9yKHZhciBqPTA7ajxzcGFucy5sZW5ndGg7KytqKXt2YXIgc3A9c3BhbnNbal0sbT1zcC5tYXJrZXI7aWYobS50eXBlPT1cImJvb2ttYXJrXCImJnNwLmZyb209PXBvcyYmbS53aWRnZXROb2RlKXtmb3VuZEJvb2ttYXJrcy5wdXNoKG0pO31lbHNlIGlmKHNwLmZyb208PXBvcyYmKHNwLnRvPT1udWxsfHxzcC50bz5wb3N8fG0uY29sbGFwc2VkJiZzcC50bz09cG9zJiZzcC5mcm9tPT1wb3MpKXtpZihzcC50byE9bnVsbCYmc3AudG8hPXBvcyYmbmV4dENoYW5nZT5zcC50byl7bmV4dENoYW5nZT1zcC50bztzcGFuRW5kU3R5bGU9XCJcIjt9aWYobS5jbGFzc05hbWUpe3NwYW5TdHlsZSs9XCIgXCIrbS5jbGFzc05hbWU7fWlmKG0uY3NzKXtjc3M9KGNzcz9jc3MrXCI7XCI6XCJcIikrbS5jc3M7fWlmKG0uc3RhcnRTdHlsZSYmc3AuZnJvbT09cG9zKXtzcGFuU3RhcnRTdHlsZSs9XCIgXCIrbS5zdGFydFN0eWxlO31pZihtLmVuZFN0eWxlJiZzcC50bz09bmV4dENoYW5nZSl7KGVuZFN0eWxlc3x8KGVuZFN0eWxlcz1bXSkpLnB1c2gobS5lbmRTdHlsZSxzcC50byk7fWlmKG0udGl0bGUmJiF0aXRsZSl7dGl0bGU9bS50aXRsZTt9aWYobS5jb2xsYXBzZWQmJighY29sbGFwc2VkfHxjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhjb2xsYXBzZWQubWFya2VyLG0pPDApKXtjb2xsYXBzZWQ9c3A7fX1lbHNlIGlmKHNwLmZyb20+cG9zJiZuZXh0Q2hhbmdlPnNwLmZyb20pe25leHRDaGFuZ2U9c3AuZnJvbTt9fWlmKGVuZFN0eWxlcyl7Zm9yKHZhciBqJDE9MDtqJDE8ZW5kU3R5bGVzLmxlbmd0aDtqJDErPTIpe2lmKGVuZFN0eWxlc1tqJDErMV09PW5leHRDaGFuZ2Upe3NwYW5FbmRTdHlsZSs9XCIgXCIrZW5kU3R5bGVzW2okMV07fX19aWYoIWNvbGxhcHNlZHx8Y29sbGFwc2VkLmZyb209PXBvcyl7Zm9yKHZhciBqJDI9MDtqJDI8Zm91bmRCb29rbWFya3MubGVuZ3RoOysraiQyKXtidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwwLGZvdW5kQm9va21hcmtzW2okMl0pO319aWYoY29sbGFwc2VkJiYoY29sbGFwc2VkLmZyb218fDApPT1wb3Mpe2J1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLChjb2xsYXBzZWQudG89PW51bGw/bGVuKzE6Y29sbGFwc2VkLnRvKS1wb3MsY29sbGFwc2VkLm1hcmtlcixjb2xsYXBzZWQuZnJvbT09bnVsbCk7aWYoY29sbGFwc2VkLnRvPT1udWxsKXtyZXR1cm47fWlmKGNvbGxhcHNlZC50bz09cG9zKXtjb2xsYXBzZWQ9ZmFsc2U7fX19aWYocG9zPj1sZW4pe2JyZWFrO312YXIgdXB0bz1NYXRoLm1pbihsZW4sbmV4dENoYW5nZSk7d2hpbGUodHJ1ZSl7aWYodGV4dCl7dmFyIGVuZD1wb3MrdGV4dC5sZW5ndGg7aWYoIWNvbGxhcHNlZCl7dmFyIHRva2VuVGV4dD1lbmQ+dXB0bz90ZXh0LnNsaWNlKDAsdXB0by1wb3MpOnRleHQ7YnVpbGRlci5hZGRUb2tlbihidWlsZGVyLHRva2VuVGV4dCxzdHlsZT9zdHlsZStzcGFuU3R5bGU6c3BhblN0eWxlLHNwYW5TdGFydFN0eWxlLHBvcyt0b2tlblRleHQubGVuZ3RoPT1uZXh0Q2hhbmdlP3NwYW5FbmRTdHlsZTpcIlwiLHRpdGxlLGNzcyk7fWlmKGVuZD49dXB0byl7dGV4dD10ZXh0LnNsaWNlKHVwdG8tcG9zKTtwb3M9dXB0bzticmVhazt9cG9zPWVuZDtzcGFuU3RhcnRTdHlsZT1cIlwiO310ZXh0PWFsbFRleHQuc2xpY2UoYXQsYXQ9c3R5bGVzW2krK10pO3N0eWxlPWludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sYnVpbGRlci5jbS5vcHRpb25zKTt9fX0vLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxuLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcbi8vIGxvZ2ljYWwgbGluZXMsIGlmIHRob3NlIGFyZSBjb25uZWN0ZWQgYnkgY29sbGFwc2VkIHJhbmdlcy5cbmZ1bmN0aW9uIExpbmVWaWV3KGRvYyxsaW5lLGxpbmVOKXsvLyBUaGUgc3RhcnRpbmcgbGluZVxudGhpcy5saW5lPWxpbmU7Ly8gQ29udGludWluZyBsaW5lcywgaWYgYW55XG50aGlzLnJlc3Q9dmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKTsvLyBOdW1iZXIgb2YgbG9naWNhbCBsaW5lcyBpbiB0aGlzIHZpc3VhbCBsaW5lXG50aGlzLnNpemU9dGhpcy5yZXN0P2xpbmVObyhsc3QodGhpcy5yZXN0KSktbGluZU4rMToxO3RoaXMubm9kZT10aGlzLnRleHQ9bnVsbDt0aGlzLmhpZGRlbj1saW5lSXNIaWRkZW4oZG9jLGxpbmUpO30vLyBDcmVhdGUgYSByYW5nZSBvZiBMaW5lVmlldyBvYmplY3RzIGZvciB0aGUgZ2l2ZW4gbGluZXMuXG5mdW5jdGlvbiBidWlsZFZpZXdBcnJheShjbSxmcm9tLHRvKXt2YXIgYXJyYXk9W10sbmV4dFBvcztmb3IodmFyIHBvcz1mcm9tO3Bvczx0bztwb3M9bmV4dFBvcyl7dmFyIHZpZXc9bmV3IExpbmVWaWV3KGNtLmRvYyxnZXRMaW5lKGNtLmRvYyxwb3MpLHBvcyk7bmV4dFBvcz1wb3Mrdmlldy5zaXplO2FycmF5LnB1c2godmlldyk7fXJldHVybiBhcnJheTt9dmFyIG9wZXJhdGlvbkdyb3VwPW51bGw7ZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCl7aWYob3BlcmF0aW9uR3JvdXApe29wZXJhdGlvbkdyb3VwLm9wcy5wdXNoKG9wKTt9ZWxzZXtvcC5vd25zR3JvdXA9b3BlcmF0aW9uR3JvdXA9e29wczpbb3BdLGRlbGF5ZWRDYWxsYmFja3M6W119O319ZnVuY3Rpb24gZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCl7Ly8gQ2FsbHMgZGVsYXllZCBjYWxsYmFja3MgYW5kIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIHVudGlsIG5vXG4vLyBuZXcgb25lcyBhcHBlYXJcbnZhciBjYWxsYmFja3M9Z3JvdXAuZGVsYXllZENhbGxiYWNrcyxpPTA7ZG97Zm9yKDtpPGNhbGxiYWNrcy5sZW5ndGg7aSsrKXtjYWxsYmFja3NbaV0uY2FsbChudWxsKTt9Zm9yKHZhciBqPTA7ajxncm91cC5vcHMubGVuZ3RoO2orKyl7dmFyIG9wPWdyb3VwLm9wc1tqXTtpZihvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzKXt3aGlsZShvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZDxvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aCl7b3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCsrXS5jYWxsKG51bGwsb3AuY20pO319fX13aGlsZShpPGNhbGxiYWNrcy5sZW5ndGgpO31mdW5jdGlvbiBmaW5pc2hPcGVyYXRpb24ob3AsZW5kQ2Ipe3ZhciBncm91cD1vcC5vd25zR3JvdXA7aWYoIWdyb3VwKXtyZXR1cm47fXRyeXtmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKTt9ZmluYWxseXtvcGVyYXRpb25Hcm91cD1udWxsO2VuZENiKGdyb3VwKTt9fXZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzPW51bGw7Ly8gT2Z0ZW4sIHdlIHdhbnQgdG8gc2lnbmFsIGV2ZW50cyBhdCBhIHBvaW50IHdoZXJlIHdlIGFyZSBpbiB0aGVcbi8vIG1pZGRsZSBvZiBzb21lIHdvcmssIGJ1dCBkb24ndCB3YW50IHRoZSBoYW5kbGVyIHRvIHN0YXJ0IGNhbGxpbmdcbi8vIG90aGVyIG1ldGhvZHMgb24gdGhlIGVkaXRvciwgd2hpY2ggbWlnaHQgYmUgaW4gYW4gaW5jb25zaXN0ZW50XG4vLyBzdGF0ZSBvciBzaW1wbHkgbm90IGV4cGVjdCBhbnkgb3RoZXIgZXZlbnRzIHRvIGhhcHBlbi5cbi8vIHNpZ25hbExhdGVyIGxvb2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBoYW5kbGVycywgYW5kIHNjaGVkdWxlc1xuLy8gdGhlbSB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBsYXN0IG9wZXJhdGlvbiBlbmRzLCBvciwgaWYgbm9cbi8vIG9wZXJhdGlvbiBpcyBhY3RpdmUsIHdoZW4gYSB0aW1lb3V0IGZpcmVzLlxuZnVuY3Rpb24gc2lnbmFsTGF0ZXIoZW1pdHRlcix0eXBlLyosIHZhbHVlcy4uLiovKXt2YXIgYXJyPWdldEhhbmRsZXJzKGVtaXR0ZXIsdHlwZSxmYWxzZSk7aWYoIWFyci5sZW5ndGgpe3JldHVybjt9dmFyIGFyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpLGxpc3Q7aWYob3BlcmF0aW9uR3JvdXApe2xpc3Q9b3BlcmF0aW9uR3JvdXAuZGVsYXllZENhbGxiYWNrczt9ZWxzZSBpZihvcnBoYW5EZWxheWVkQ2FsbGJhY2tzKXtsaXN0PW9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7fWVsc2V7bGlzdD1vcnBoYW5EZWxheWVkQ2FsbGJhY2tzPVtdO3NldFRpbWVvdXQoZmlyZU9ycGhhbkRlbGF5ZWQsMCk7fXZhciBsb29wPWZ1bmN0aW9uKGkpe2xpc3QucHVzaChmdW5jdGlvbigpe3JldHVybiBhcnJbaV0uYXBwbHkobnVsbCxhcmdzKTt9KTt9O2Zvcih2YXIgaT0wO2k8YXJyLmxlbmd0aDsrK2kpbG9vcChpKTt9ZnVuY3Rpb24gZmlyZU9ycGhhbkRlbGF5ZWQoKXt2YXIgZGVsYXllZD1vcnBoYW5EZWxheWVkQ2FsbGJhY2tzO29ycGhhbkRlbGF5ZWRDYWxsYmFja3M9bnVsbDtmb3IodmFyIGk9MDtpPGRlbGF5ZWQubGVuZ3RoOysraSl7ZGVsYXllZFtpXSgpO319Ly8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXG4vLyBsaW5lVmlldy5jaGFuZ2VzLiBUaGlzIHVwZGF0ZXMgdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGxpbmUnc1xuLy8gRE9NIHN0cnVjdHVyZS5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLGxpbmVWaWV3LGxpbmVOLGRpbXMpe2Zvcih2YXIgaj0wO2o8bGluZVZpZXcuY2hhbmdlcy5sZW5ndGg7aisrKXt2YXIgdHlwZT1saW5lVmlldy5jaGFuZ2VzW2pdO2lmKHR5cGU9PVwidGV4dFwiKXt1cGRhdGVMaW5lVGV4dChjbSxsaW5lVmlldyk7fWVsc2UgaWYodHlwZT09XCJndXR0ZXJcIil7dXBkYXRlTGluZUd1dHRlcihjbSxsaW5lVmlldyxsaW5lTixkaW1zKTt9ZWxzZSBpZih0eXBlPT1cImNsYXNzXCIpe3VwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KTt9ZWxzZSBpZih0eXBlPT1cIndpZGdldFwiKXt1cGRhdGVMaW5lV2lkZ2V0cyhjbSxsaW5lVmlldyxkaW1zKTt9fWxpbmVWaWV3LmNoYW5nZXM9bnVsbDt9Ly8gTGluZXMgd2l0aCBndXR0ZXIgZWxlbWVudHMsIHdpZGdldHMgb3IgYSBiYWNrZ3JvdW5kIGNsYXNzIG5lZWQgdG9cbi8vIGJlIHdyYXBwZWQsIGFuZCBoYXZlIHRoZSBleHRyYSBlbGVtZW50cyBhZGRlZCB0byB0aGUgd3JhcHBlciBkaXZcbmZ1bmN0aW9uIGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KXtpZihsaW5lVmlldy5ub2RlPT1saW5lVmlldy50ZXh0KXtsaW5lVmlldy5ub2RlPWVsdChcImRpdlwiLG51bGwsbnVsbCxcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtpZihsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpe2xpbmVWaWV3LnRleHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobGluZVZpZXcubm9kZSxsaW5lVmlldy50ZXh0KTt9bGluZVZpZXcubm9kZS5hcHBlbmRDaGlsZChsaW5lVmlldy50ZXh0KTtpZihpZSYmaWVfdmVyc2lvbjw4KXtsaW5lVmlldy5ub2RlLnN0eWxlLnpJbmRleD0yO319cmV0dXJuIGxpbmVWaWV3Lm5vZGU7fWZ1bmN0aW9uIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KXt2YXIgY2xzPWxpbmVWaWV3LmJnQ2xhc3M/bGluZVZpZXcuYmdDbGFzcytcIiBcIisobGluZVZpZXcubGluZS5iZ0NsYXNzfHxcIlwiKTpsaW5lVmlldy5saW5lLmJnQ2xhc3M7aWYoY2xzKXtjbHMrPVwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcIjt9aWYobGluZVZpZXcuYmFja2dyb3VuZCl7aWYoY2xzKXtsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZT1jbHM7fWVsc2V7bGluZVZpZXcuYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3LmJhY2tncm91bmQpO2xpbmVWaWV3LmJhY2tncm91bmQ9bnVsbDt9fWVsc2UgaWYoY2xzKXt2YXIgd3JhcD1lbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7bGluZVZpZXcuYmFja2dyb3VuZD13cmFwLmluc2VydEJlZm9yZShlbHQoXCJkaXZcIixudWxsLGNscyksd3JhcC5maXJzdENoaWxkKTt9fS8vIFdyYXBwZXIgYXJvdW5kIGJ1aWxkTGluZUNvbnRlbnQgd2hpY2ggd2lsbCByZXVzZSB0aGUgc3RydWN0dXJlXG4vLyBpbiBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgd2hlbiBwb3NzaWJsZS5cbmZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLGxpbmVWaWV3KXt2YXIgZXh0PWNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtpZihleHQmJmV4dC5saW5lPT1saW5lVmlldy5saW5lKXtjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ9bnVsbDtsaW5lVmlldy5tZWFzdXJlPWV4dC5tZWFzdXJlO3JldHVybiBleHQuYnVpbHQ7fXJldHVybiBidWlsZExpbmVDb250ZW50KGNtLGxpbmVWaWV3KTt9Ly8gUmVkcmF3IHRoZSBsaW5lJ3MgdGV4dC4gSW50ZXJhY3RzIHdpdGggdGhlIGJhY2tncm91bmQgYW5kIHRleHRcbi8vIGNsYXNzZXMgYmVjYXVzZSB0aGUgbW9kZSBtYXkgb3V0cHV0IHRva2VucyB0aGF0IGluZmx1ZW5jZSB0aGVzZVxuLy8gY2xhc3Nlcy5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmVUZXh0KGNtLGxpbmVWaWV3KXt2YXIgY2xzPWxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO3ZhciBidWlsdD1nZXRMaW5lQ29udGVudChjbSxsaW5lVmlldyk7aWYobGluZVZpZXcudGV4dD09bGluZVZpZXcubm9kZSl7bGluZVZpZXcubm9kZT1idWlsdC5wcmU7fWxpbmVWaWV3LnRleHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYnVpbHQucHJlLGxpbmVWaWV3LnRleHQpO2xpbmVWaWV3LnRleHQ9YnVpbHQucHJlO2lmKGJ1aWx0LmJnQ2xhc3MhPWxpbmVWaWV3LmJnQ2xhc3N8fGJ1aWx0LnRleHRDbGFzcyE9bGluZVZpZXcudGV4dENsYXNzKXtsaW5lVmlldy5iZ0NsYXNzPWJ1aWx0LmJnQ2xhc3M7bGluZVZpZXcudGV4dENsYXNzPWJ1aWx0LnRleHRDbGFzczt1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldyk7fWVsc2UgaWYoY2xzKXtsaW5lVmlldy50ZXh0LmNsYXNzTmFtZT1jbHM7fX1mdW5jdGlvbiB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldyl7dXBkYXRlTGluZUJhY2tncm91bmQobGluZVZpZXcpO2lmKGxpbmVWaWV3LmxpbmUud3JhcENsYXNzKXtlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lPWxpbmVWaWV3LmxpbmUud3JhcENsYXNzO31lbHNlIGlmKGxpbmVWaWV3Lm5vZGUhPWxpbmVWaWV3LnRleHQpe2xpbmVWaWV3Lm5vZGUuY2xhc3NOYW1lPVwiXCI7fXZhciB0ZXh0Q2xhc3M9bGluZVZpZXcudGV4dENsYXNzP2xpbmVWaWV3LnRleHRDbGFzcytcIiBcIisobGluZVZpZXcubGluZS50ZXh0Q2xhc3N8fFwiXCIpOmxpbmVWaWV3LmxpbmUudGV4dENsYXNzO2xpbmVWaWV3LnRleHQuY2xhc3NOYW1lPXRleHRDbGFzc3x8XCJcIjt9ZnVuY3Rpb24gdXBkYXRlTGluZUd1dHRlcihjbSxsaW5lVmlldyxsaW5lTixkaW1zKXtpZihsaW5lVmlldy5ndXR0ZXIpe2xpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyKTtsaW5lVmlldy5ndXR0ZXI9bnVsbDt9aWYobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCl7bGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKTtsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kPW51bGw7fWlmKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3Mpe3ZhciB3cmFwPWVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kPWVsdChcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIFwiK2xpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MsXCJsZWZ0OiBcIisoY20ub3B0aW9ucy5maXhlZEd1dHRlcj9kaW1zLmZpeGVkUG9zOi1kaW1zLmd1dHRlclRvdGFsV2lkdGgpK1wicHg7IHdpZHRoOiBcIitkaW1zLmd1dHRlclRvdGFsV2lkdGgrXCJweFwiKTt3cmFwLmluc2VydEJlZm9yZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kLGxpbmVWaWV3LnRleHQpO312YXIgbWFya2Vycz1saW5lVmlldy5saW5lLmd1dHRlck1hcmtlcnM7aWYoY20ub3B0aW9ucy5saW5lTnVtYmVyc3x8bWFya2Vycyl7dmFyIHdyYXAkMT1lbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7dmFyIGd1dHRlcldyYXA9bGluZVZpZXcuZ3V0dGVyPWVsdChcImRpdlwiLG51bGwsXCJDb2RlTWlycm9yLWd1dHRlci13cmFwcGVyXCIsXCJsZWZ0OiBcIisoY20ub3B0aW9ucy5maXhlZEd1dHRlcj9kaW1zLmZpeGVkUG9zOi1kaW1zLmd1dHRlclRvdGFsV2lkdGgpK1wicHhcIik7Y20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGd1dHRlcldyYXApO3dyYXAkMS5pbnNlcnRCZWZvcmUoZ3V0dGVyV3JhcCxsaW5lVmlldy50ZXh0KTtpZihsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKXtndXR0ZXJXcmFwLmNsYXNzTmFtZSs9XCIgXCIrbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzczt9aWYoY20ub3B0aW9ucy5saW5lTnVtYmVycyYmKCFtYXJrZXJzfHwhbWFya2Vyc1tcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0pKXtsaW5lVmlldy5saW5lTnVtYmVyPWd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsbGluZU51bWJlckZvcihjbS5vcHRpb25zLGxpbmVOKSxcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIixcImxlZnQ6IFwiK2RpbXMuZ3V0dGVyTGVmdFtcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIl0rXCJweDsgd2lkdGg6IFwiK2NtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGgrXCJweFwiKSk7fWlmKG1hcmtlcnMpe2Zvcih2YXIgaz0wO2s8Y20ub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsrK2spe3ZhciBpZD1jbS5vcHRpb25zLmd1dHRlcnNba10sZm91bmQ9bWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkmJm1hcmtlcnNbaWRdO2lmKGZvdW5kKXtndXR0ZXJXcmFwLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLFtmb3VuZF0sXCJDb2RlTWlycm9yLWd1dHRlci1lbHRcIixcImxlZnQ6IFwiK2RpbXMuZ3V0dGVyTGVmdFtpZF0rXCJweDsgd2lkdGg6IFwiK2RpbXMuZ3V0dGVyV2lkdGhbaWRdK1wicHhcIikpO319fX19ZnVuY3Rpb24gdXBkYXRlTGluZVdpZGdldHMoY20sbGluZVZpZXcsZGltcyl7aWYobGluZVZpZXcuYWxpZ25hYmxlKXtsaW5lVmlldy5hbGlnbmFibGU9bnVsbDt9Zm9yKHZhciBub2RlPWxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCxuZXh0PXZvaWQgMDtub2RlO25vZGU9bmV4dCl7bmV4dD1ub2RlLm5leHRTaWJsaW5nO2lmKG5vZGUuY2xhc3NOYW1lPT1cIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiKXtsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKG5vZGUpO319aW5zZXJ0TGluZVdpZGdldHMoY20sbGluZVZpZXcsZGltcyk7fS8vIEJ1aWxkIGEgbGluZSdzIERPTSByZXByZXNlbnRhdGlvbiBmcm9tIHNjcmF0Y2hcbmZ1bmN0aW9uIGJ1aWxkTGluZUVsZW1lbnQoY20sbGluZVZpZXcsbGluZU4sZGltcyl7dmFyIGJ1aWx0PWdldExpbmVDb250ZW50KGNtLGxpbmVWaWV3KTtsaW5lVmlldy50ZXh0PWxpbmVWaWV3Lm5vZGU9YnVpbHQucHJlO2lmKGJ1aWx0LmJnQ2xhc3Mpe2xpbmVWaWV3LmJnQ2xhc3M9YnVpbHQuYmdDbGFzczt9aWYoYnVpbHQudGV4dENsYXNzKXtsaW5lVmlldy50ZXh0Q2xhc3M9YnVpbHQudGV4dENsYXNzO311cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldyk7dXBkYXRlTGluZUd1dHRlcihjbSxsaW5lVmlldyxsaW5lTixkaW1zKTtpbnNlcnRMaW5lV2lkZ2V0cyhjbSxsaW5lVmlldyxkaW1zKTtyZXR1cm4gbGluZVZpZXcubm9kZTt9Ly8gQSBsaW5lVmlldyBtYXkgY29udGFpbiBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzICh3aGVuIG1lcmdlZCBieVxuLy8gY29sbGFwc2VkIHNwYW5zKS4gVGhlIHdpZGdldHMgZm9yIGFsbCBvZiB0aGVtIG5lZWQgdG8gYmUgZHJhd24uXG5mdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSxsaW5lVmlldyxkaW1zKXtpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSxsaW5lVmlldy5saW5lLGxpbmVWaWV3LGRpbXMsdHJ1ZSk7aWYobGluZVZpZXcucmVzdCl7Zm9yKHZhciBpPTA7aTxsaW5lVmlldy5yZXN0Lmxlbmd0aDtpKyspe2luc2VydExpbmVXaWRnZXRzRm9yKGNtLGxpbmVWaWV3LnJlc3RbaV0sbGluZVZpZXcsZGltcyxmYWxzZSk7fX19ZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sbGluZSxsaW5lVmlldyxkaW1zLGFsbG93QWJvdmUpe2lmKCFsaW5lLndpZGdldHMpe3JldHVybjt9dmFyIHdyYXA9ZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO2Zvcih2YXIgaT0wLHdzPWxpbmUud2lkZ2V0cztpPHdzLmxlbmd0aDsrK2kpe3ZhciB3aWRnZXQ9d3NbaV0sbm9kZT1lbHQoXCJkaXZcIixbd2lkZ2V0Lm5vZGVdLFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIpO2lmKCF3aWRnZXQuaGFuZGxlTW91c2VFdmVudHMpe25vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLFwidHJ1ZVwiKTt9cG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCxub2RlLGxpbmVWaWV3LGRpbXMpO2NtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtpZihhbGxvd0Fib3ZlJiZ3aWRnZXQuYWJvdmUpe3dyYXAuaW5zZXJ0QmVmb3JlKG5vZGUsbGluZVZpZXcuZ3V0dGVyfHxsaW5lVmlldy50ZXh0KTt9ZWxzZXt3cmFwLmFwcGVuZENoaWxkKG5vZGUpO31zaWduYWxMYXRlcih3aWRnZXQsXCJyZWRyYXdcIik7fX1mdW5jdGlvbiBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LG5vZGUsbGluZVZpZXcsZGltcyl7aWYod2lkZ2V0Lm5vSFNjcm9sbCl7OyhsaW5lVmlldy5hbGlnbmFibGV8fChsaW5lVmlldy5hbGlnbmFibGU9W10pKS5wdXNoKG5vZGUpO3ZhciB3aWR0aD1kaW1zLndyYXBwZXJXaWR0aDtub2RlLnN0eWxlLmxlZnQ9ZGltcy5maXhlZFBvcytcInB4XCI7aWYoIXdpZGdldC5jb3Zlckd1dHRlcil7d2lkdGgtPWRpbXMuZ3V0dGVyVG90YWxXaWR0aDtub2RlLnN0eWxlLnBhZGRpbmdMZWZ0PWRpbXMuZ3V0dGVyVG90YWxXaWR0aCtcInB4XCI7fW5vZGUuc3R5bGUud2lkdGg9d2lkdGgrXCJweFwiO31pZih3aWRnZXQuY292ZXJHdXR0ZXIpe25vZGUuc3R5bGUuekluZGV4PTU7bm9kZS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCI7aWYoIXdpZGdldC5ub0hTY3JvbGwpe25vZGUuc3R5bGUubWFyZ2luTGVmdD0tZGltcy5ndXR0ZXJUb3RhbFdpZHRoK1wicHhcIjt9fX1mdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KXtpZih3aWRnZXQuaGVpZ2h0IT1udWxsKXtyZXR1cm4gd2lkZ2V0LmhlaWdodDt9dmFyIGNtPXdpZGdldC5kb2MuY207aWYoIWNtKXtyZXR1cm4gMDt9aWYoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksd2lkZ2V0Lm5vZGUpKXt2YXIgcGFyZW50U3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7XCI7aWYod2lkZ2V0LmNvdmVyR3V0dGVyKXtwYXJlbnRTdHlsZSs9XCJtYXJnaW4tbGVmdDogLVwiK2NtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCtcInB4O1wiO31pZih3aWRnZXQubm9IU2Nyb2xsKXtwYXJlbnRTdHlsZSs9XCJ3aWR0aDogXCIrY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoK1wicHg7XCI7fXJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSxlbHQoXCJkaXZcIixbd2lkZ2V0Lm5vZGVdLG51bGwscGFyZW50U3R5bGUpKTt9cmV0dXJuIHdpZGdldC5oZWlnaHQ9d2lkZ2V0Lm5vZGUucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQ7fS8vIFJldHVybiB0cnVlIHdoZW4gdGhlIGdpdmVuIG1vdXNlIGV2ZW50IGhhcHBlbmVkIGluIGEgd2lkZ2V0XG5mdW5jdGlvbiBldmVudEluV2lkZ2V0KGRpc3BsYXksZSl7Zm9yKHZhciBuPWVfdGFyZ2V0KGUpO24hPWRpc3BsYXkud3JhcHBlcjtuPW4ucGFyZW50Tm9kZSl7aWYoIW58fG4ubm9kZVR5cGU9PTEmJm4uZ2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiKT09XCJ0cnVlXCJ8fG4ucGFyZW50Tm9kZT09ZGlzcGxheS5zaXplciYmbiE9ZGlzcGxheS5tb3Zlcil7cmV0dXJuIHRydWU7fX19Ly8gUE9TSVRJT04gTUVBU1VSRU1FTlRcbmZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSl7cmV0dXJuIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldFRvcDt9ZnVuY3Rpb24gcGFkZGluZ1ZlcnQoZGlzcGxheSl7cmV0dXJuIGRpc3BsYXkubW92ZXIub2Zmc2V0SGVpZ2h0LWRpc3BsYXkubGluZVNwYWNlLm9mZnNldEhlaWdodDt9ZnVuY3Rpb24gcGFkZGluZ0goZGlzcGxheSl7aWYoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCl7cmV0dXJuIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0g7fXZhciBlPXJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSxlbHQoXCJwcmVcIixcInhcIikpO3ZhciBzdHlsZT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZT93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKTplLmN1cnJlbnRTdHlsZTt2YXIgZGF0YT17bGVmdDpwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCkscmlnaHQ6cGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0KX07aWYoIWlzTmFOKGRhdGEubGVmdCkmJiFpc05hTihkYXRhLnJpZ2h0KSl7ZGlzcGxheS5jYWNoZWRQYWRkaW5nSD1kYXRhO31yZXR1cm4gZGF0YTt9ZnVuY3Rpb24gc2Nyb2xsR2FwKGNtKXtyZXR1cm4gc2Nyb2xsZXJHYXAtY20uZGlzcGxheS5uYXRpdmVCYXJXaWR0aDt9ZnVuY3Rpb24gZGlzcGxheVdpZHRoKGNtKXtyZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aC1zY3JvbGxHYXAoY20pLWNtLmRpc3BsYXkuYmFyV2lkdGg7fWZ1bmN0aW9uIGRpc3BsYXlIZWlnaHQoY20pe3JldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodC1zY3JvbGxHYXAoY20pLWNtLmRpc3BsYXkuYmFySGVpZ2h0O30vLyBFbnN1cmUgdGhlIGxpbmVWaWV3LndyYXBwaW5nLmhlaWdodHMgYXJyYXkgaXMgcG9wdWxhdGVkLiBUaGlzIGlzXG4vLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXG4vLyBsaW5lLiBXaGVuIGxpbmVXcmFwcGluZyBpcyBvbiwgdGhlcmUgbWlnaHQgYmUgbW9yZSB0aGFuIG9uZVxuLy8gaGVpZ2h0LlxuZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sbGluZVZpZXcscmVjdCl7dmFyIHdyYXBwaW5nPWNtLm9wdGlvbnMubGluZVdyYXBwaW5nO3ZhciBjdXJXaWR0aD13cmFwcGluZyYmZGlzcGxheVdpZHRoKGNtKTtpZighbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzfHx3cmFwcGluZyYmbGluZVZpZXcubWVhc3VyZS53aWR0aCE9Y3VyV2lkdGgpe3ZhciBoZWlnaHRzPWxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cz1bXTtpZih3cmFwcGluZyl7bGluZVZpZXcubWVhc3VyZS53aWR0aD1jdXJXaWR0aDt2YXIgcmVjdHM9bGluZVZpZXcudGV4dC5maXJzdENoaWxkLmdldENsaWVudFJlY3RzKCk7Zm9yKHZhciBpPTA7aTxyZWN0cy5sZW5ndGgtMTtpKyspe3ZhciBjdXI9cmVjdHNbaV0sbmV4dD1yZWN0c1tpKzFdO2lmKE1hdGguYWJzKGN1ci5ib3R0b20tbmV4dC5ib3R0b20pPjIpe2hlaWdodHMucHVzaCgoY3VyLmJvdHRvbStuZXh0LnRvcCkvMi1yZWN0LnRvcCk7fX19aGVpZ2h0cy5wdXNoKHJlY3QuYm90dG9tLXJlY3QudG9wKTt9fS8vIEZpbmQgYSBsaW5lIG1hcCAobWFwcGluZyBjaGFyYWN0ZXIgb2Zmc2V0cyB0byB0ZXh0IG5vZGVzKSBhbmQgYVxuLy8gbWVhc3VyZW1lbnQgY2FjaGUgZm9yIHRoZSBnaXZlbiBsaW5lIG51bWJlci4gKEEgbGluZSB2aWV3IG1pZ2h0XG4vLyBjb250YWluIG11bHRpcGxlIGxpbmVzIHdoZW4gY29sbGFwc2VkIHJhbmdlcyBhcmUgcHJlc2VudC4pXG5mdW5jdGlvbiBtYXBGcm9tTGluZVZpZXcobGluZVZpZXcsbGluZSxsaW5lTil7aWYobGluZVZpZXcubGluZT09bGluZSl7cmV0dXJue21hcDpsaW5lVmlldy5tZWFzdXJlLm1hcCxjYWNoZTpsaW5lVmlldy5tZWFzdXJlLmNhY2hlfTt9Zm9yKHZhciBpPTA7aTxsaW5lVmlldy5yZXN0Lmxlbmd0aDtpKyspe2lmKGxpbmVWaWV3LnJlc3RbaV09PWxpbmUpe3JldHVybnttYXA6bGluZVZpZXcubWVhc3VyZS5tYXBzW2ldLGNhY2hlOmxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldfTt9fWZvcih2YXIgaSQxPTA7aSQxPGxpbmVWaWV3LnJlc3QubGVuZ3RoO2kkMSsrKXtpZihsaW5lTm8obGluZVZpZXcucmVzdFtpJDFdKT5saW5lTil7cmV0dXJue21hcDpsaW5lVmlldy5tZWFzdXJlLm1hcHNbaSQxXSxjYWNoZTpsaW5lVmlldy5tZWFzdXJlLmNhY2hlc1tpJDFdLGJlZm9yZTp0cnVlfTt9fX0vLyBSZW5kZXIgYSBsaW5lIGludG8gdGhlIGhpZGRlbiBub2RlIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZC4gVXNlZFxuLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cbmZ1bmN0aW9uIHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sbGluZSl7bGluZT12aXN1YWxMaW5lKGxpbmUpO3ZhciBsaW5lTj1saW5lTm8obGluZSk7dmFyIHZpZXc9Y20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkPW5ldyBMaW5lVmlldyhjbS5kb2MsbGluZSxsaW5lTik7dmlldy5saW5lTj1saW5lTjt2YXIgYnVpbHQ9dmlldy5idWlsdD1idWlsZExpbmVDb250ZW50KGNtLHZpZXcpO3ZpZXcudGV4dD1idWlsdC5wcmU7cmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5saW5lTWVhc3VyZSxidWlsdC5wcmUpO3JldHVybiB2aWV3O30vLyBHZXQgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggKGluIGxpbmUtbG9jYWwgY29vcmRpbmF0ZXMpXG4vLyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXG5mdW5jdGlvbiBtZWFzdXJlQ2hhcihjbSxsaW5lLGNoLGJpYXMpe3JldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSxsaW5lKSxjaCxiaWFzKTt9Ly8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cbmZ1bmN0aW9uIGZpbmRWaWV3Rm9yTGluZShjbSxsaW5lTil7aWYobGluZU4+PWNtLmRpc3BsYXkudmlld0Zyb20mJmxpbmVOPGNtLmRpc3BsYXkudmlld1RvKXtyZXR1cm4gY20uZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sbGluZU4pXTt9dmFyIGV4dD1jbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7aWYoZXh0JiZsaW5lTj49ZXh0LmxpbmVOJiZsaW5lTjxleHQubGluZU4rZXh0LnNpemUpe3JldHVybiBleHQ7fX0vLyBNZWFzdXJlbWVudCBjYW4gYmUgc3BsaXQgaW4gdHdvIHN0ZXBzLCB0aGUgc2V0LXVwIHdvcmsgdGhhdFxuLy8gYXBwbGllcyB0byB0aGUgd2hvbGUgbGluZSwgYW5kIHRoZSBtZWFzdXJlbWVudCBvZiB0aGUgYWN0dWFsXG4vLyBjaGFyYWN0ZXIuIEZ1bmN0aW9ucyBsaWtlIGNvb3Jkc0NoYXIsIHRoYXQgbmVlZCB0byBkbyBhIGxvdCBvZlxuLy8gbWVhc3VyZW1lbnRzIGluIGEgcm93LCBjYW4gdGh1cyBlbnN1cmUgdGhhdCB0aGUgc2V0LXVwIHdvcmsgaXNcbi8vIG9ubHkgZG9uZSBvbmNlLlxuZnVuY3Rpb24gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLGxpbmUpe3ZhciBsaW5lTj1saW5lTm8obGluZSk7dmFyIHZpZXc9ZmluZFZpZXdGb3JMaW5lKGNtLGxpbmVOKTtpZih2aWV3JiYhdmlldy50ZXh0KXt2aWV3PW51bGw7fWVsc2UgaWYodmlldyYmdmlldy5jaGFuZ2VzKXt1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSx2aWV3LGxpbmVOLGdldERpbWVuc2lvbnMoY20pKTtjbS5jdXJPcC5mb3JjZVVwZGF0ZT10cnVlO31pZighdmlldyl7dmlldz11cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLGxpbmUpO312YXIgaW5mbz1tYXBGcm9tTGluZVZpZXcodmlldyxsaW5lLGxpbmVOKTtyZXR1cm57bGluZTpsaW5lLHZpZXc6dmlldyxyZWN0Om51bGwsbWFwOmluZm8ubWFwLGNhY2hlOmluZm8uY2FjaGUsYmVmb3JlOmluZm8uYmVmb3JlLGhhc0hlaWdodHM6ZmFsc2V9O30vLyBHaXZlbiBhIHByZXBhcmVkIG1lYXN1cmVtZW50IG9iamVjdCwgbWVhc3VyZXMgdGhlIHBvc2l0aW9uIG9mIGFuXG4vLyBhY3R1YWwgY2hhcmFjdGVyIChvciBmZXRjaGVzIGl0IGZyb20gdGhlIGNhY2hlKS5cbmZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20scHJlcGFyZWQsY2gsYmlhcyx2YXJIZWlnaHQpe2lmKHByZXBhcmVkLmJlZm9yZSl7Y2g9LTE7fXZhciBrZXk9Y2grKGJpYXN8fFwiXCIpLGZvdW5kO2lmKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpe2ZvdW5kPXByZXBhcmVkLmNhY2hlW2tleV07fWVsc2V7aWYoIXByZXBhcmVkLnJlY3Qpe3ByZXBhcmVkLnJlY3Q9cHJlcGFyZWQudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO31pZighcHJlcGFyZWQuaGFzSGVpZ2h0cyl7ZW5zdXJlTGluZUhlaWdodHMoY20scHJlcGFyZWQudmlldyxwcmVwYXJlZC5yZWN0KTtwcmVwYXJlZC5oYXNIZWlnaHRzPXRydWU7fWZvdW5kPW1lYXN1cmVDaGFySW5uZXIoY20scHJlcGFyZWQsY2gsYmlhcyk7aWYoIWZvdW5kLmJvZ3VzKXtwcmVwYXJlZC5jYWNoZVtrZXldPWZvdW5kO319cmV0dXJue2xlZnQ6Zm91bmQubGVmdCxyaWdodDpmb3VuZC5yaWdodCx0b3A6dmFySGVpZ2h0P2ZvdW5kLnJ0b3A6Zm91bmQudG9wLGJvdHRvbTp2YXJIZWlnaHQ/Zm91bmQucmJvdHRvbTpmb3VuZC5ib3R0b219O312YXIgbnVsbFJlY3Q9e2xlZnQ6MCxyaWdodDowLHRvcDowLGJvdHRvbTowfTtmdW5jdGlvbiBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKG1hcCxjaCxiaWFzKXt2YXIgbm9kZSxzdGFydCxlbmQsY29sbGFwc2UsbVN0YXJ0LG1FbmQ7Ly8gRmlyc3QsIHNlYXJjaCB0aGUgbGluZSBtYXAgZm9yIHRoZSB0ZXh0IG5vZGUgY29ycmVzcG9uZGluZyB0byxcbi8vIG9yIGNsb3Nlc3QgdG8sIHRoZSB0YXJnZXQgY2hhcmFjdGVyLlxuZm9yKHZhciBpPTA7aTxtYXAubGVuZ3RoO2krPTMpe21TdGFydD1tYXBbaV07bUVuZD1tYXBbaSsxXTtpZihjaDxtU3RhcnQpe3N0YXJ0PTA7ZW5kPTE7Y29sbGFwc2U9XCJsZWZ0XCI7fWVsc2UgaWYoY2g8bUVuZCl7c3RhcnQ9Y2gtbVN0YXJ0O2VuZD1zdGFydCsxO31lbHNlIGlmKGk9PW1hcC5sZW5ndGgtM3x8Y2g9PW1FbmQmJm1hcFtpKzNdPmNoKXtlbmQ9bUVuZC1tU3RhcnQ7c3RhcnQ9ZW5kLTE7aWYoY2g+PW1FbmQpe2NvbGxhcHNlPVwicmlnaHRcIjt9fWlmKHN0YXJ0IT1udWxsKXtub2RlPW1hcFtpKzJdO2lmKG1TdGFydD09bUVuZCYmYmlhcz09KG5vZGUuaW5zZXJ0TGVmdD9cImxlZnRcIjpcInJpZ2h0XCIpKXtjb2xsYXBzZT1iaWFzO31pZihiaWFzPT1cImxlZnRcIiYmc3RhcnQ9PTApe3doaWxlKGkmJm1hcFtpLTJdPT1tYXBbaS0zXSYmbWFwW2ktMV0uaW5zZXJ0TGVmdCl7bm9kZT1tYXBbKGktPTMpKzJdO2NvbGxhcHNlPVwibGVmdFwiO319aWYoYmlhcz09XCJyaWdodFwiJiZzdGFydD09bUVuZC1tU3RhcnQpe3doaWxlKGk8bWFwLmxlbmd0aC0zJiZtYXBbaSszXT09bWFwW2krNF0mJiFtYXBbaSs1XS5pbnNlcnRMZWZ0KXtub2RlPW1hcFsoaSs9MykrMl07Y29sbGFwc2U9XCJyaWdodFwiO319YnJlYWs7fX1yZXR1cm57bm9kZTpub2RlLHN0YXJ0OnN0YXJ0LGVuZDplbmQsY29sbGFwc2U6Y29sbGFwc2UsY292ZXJTdGFydDptU3RhcnQsY292ZXJFbmQ6bUVuZH07fWZ1bmN0aW9uIGdldFVzZWZ1bFJlY3QocmVjdHMsYmlhcyl7dmFyIHJlY3Q9bnVsbFJlY3Q7aWYoYmlhcz09XCJsZWZ0XCIpe2Zvcih2YXIgaT0wO2k8cmVjdHMubGVuZ3RoO2krKyl7aWYoKHJlY3Q9cmVjdHNbaV0pLmxlZnQhPXJlY3QucmlnaHQpe2JyZWFrO319fWVsc2V7Zm9yKHZhciBpJDE9cmVjdHMubGVuZ3RoLTE7aSQxPj0wO2kkMS0tKXtpZigocmVjdD1yZWN0c1tpJDFdKS5sZWZ0IT1yZWN0LnJpZ2h0KXticmVhazt9fX1yZXR1cm4gcmVjdDt9ZnVuY3Rpb24gbWVhc3VyZUNoYXJJbm5lcihjbSxwcmVwYXJlZCxjaCxiaWFzKXt2YXIgcGxhY2U9bm9kZUFuZE9mZnNldEluTGluZU1hcChwcmVwYXJlZC5tYXAsY2gsYmlhcyk7dmFyIG5vZGU9cGxhY2Uubm9kZSxzdGFydD1wbGFjZS5zdGFydCxlbmQ9cGxhY2UuZW5kLGNvbGxhcHNlPXBsYWNlLmNvbGxhcHNlO3ZhciByZWN0O2lmKG5vZGUubm9kZVR5cGU9PTMpey8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXG5mb3IodmFyIGkkMT0wO2kkMTw0O2kkMSsrKXsvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXG53aGlsZShzdGFydCYmaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCtzdGFydCkpKXstLXN0YXJ0O313aGlsZShwbGFjZS5jb3ZlclN0YXJ0K2VuZDxwbGFjZS5jb3ZlckVuZCYmaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCtlbmQpKSl7KytlbmQ7fWlmKGllJiZpZV92ZXJzaW9uPDkmJnN0YXJ0PT0wJiZlbmQ9PXBsYWNlLmNvdmVyRW5kLXBsYWNlLmNvdmVyU3RhcnQpe3JlY3Q9bm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO31lbHNle3JlY3Q9Z2V0VXNlZnVsUmVjdChyYW5nZShub2RlLHN0YXJ0LGVuZCkuZ2V0Q2xpZW50UmVjdHMoKSxiaWFzKTt9aWYocmVjdC5sZWZ0fHxyZWN0LnJpZ2h0fHxzdGFydD09MCl7YnJlYWs7fWVuZD1zdGFydDtzdGFydD1zdGFydC0xO2NvbGxhcHNlPVwicmlnaHRcIjt9aWYoaWUmJmllX3ZlcnNpb248MTEpe3JlY3Q9bWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhjbS5kaXNwbGF5Lm1lYXN1cmUscmVjdCk7fX1lbHNley8vIElmIGl0IGlzIGEgd2lkZ2V0LCBzaW1wbHkgZ2V0IHRoZSBib3ggZm9yIHRoZSB3aG9sZSB3aWRnZXQuXG5pZihzdGFydD4wKXtjb2xsYXBzZT1iaWFzPVwicmlnaHRcIjt9dmFyIHJlY3RzO2lmKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nJiYocmVjdHM9bm9kZS5nZXRDbGllbnRSZWN0cygpKS5sZW5ndGg+MSl7cmVjdD1yZWN0c1tiaWFzPT1cInJpZ2h0XCI/cmVjdHMubGVuZ3RoLTE6MF07fWVsc2V7cmVjdD1ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO319aWYoaWUmJmllX3ZlcnNpb248OSYmIXN0YXJ0JiYoIXJlY3R8fCFyZWN0LmxlZnQmJiFyZWN0LnJpZ2h0KSl7dmFyIHJTcGFuPW5vZGUucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdO2lmKHJTcGFuKXtyZWN0PXtsZWZ0OnJTcGFuLmxlZnQscmlnaHQ6clNwYW4ubGVmdCtjaGFyV2lkdGgoY20uZGlzcGxheSksdG9wOnJTcGFuLnRvcCxib3R0b206clNwYW4uYm90dG9tfTt9ZWxzZXtyZWN0PW51bGxSZWN0O319dmFyIHJ0b3A9cmVjdC50b3AtcHJlcGFyZWQucmVjdC50b3AscmJvdD1yZWN0LmJvdHRvbS1wcmVwYXJlZC5yZWN0LnRvcDt2YXIgbWlkPShydG9wK3Jib3QpLzI7dmFyIGhlaWdodHM9cHJlcGFyZWQudmlldy5tZWFzdXJlLmhlaWdodHM7dmFyIGk9MDtmb3IoO2k8aGVpZ2h0cy5sZW5ndGgtMTtpKyspe2lmKG1pZDxoZWlnaHRzW2ldKXticmVhazt9fXZhciB0b3A9aT9oZWlnaHRzW2ktMV06MCxib3Q9aGVpZ2h0c1tpXTt2YXIgcmVzdWx0PXtsZWZ0Oihjb2xsYXBzZT09XCJyaWdodFwiP3JlY3QucmlnaHQ6cmVjdC5sZWZ0KS1wcmVwYXJlZC5yZWN0LmxlZnQscmlnaHQ6KGNvbGxhcHNlPT1cImxlZnRcIj9yZWN0LmxlZnQ6cmVjdC5yaWdodCktcHJlcGFyZWQucmVjdC5sZWZ0LHRvcDp0b3AsYm90dG9tOmJvdH07aWYoIXJlY3QubGVmdCYmIXJlY3QucmlnaHQpe3Jlc3VsdC5ib2d1cz10cnVlO31pZighY20ub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lKXtyZXN1bHQucnRvcD1ydG9wO3Jlc3VsdC5yYm90dG9tPXJib3Q7fXJldHVybiByZXN1bHQ7fS8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXG4vLyByZXR1cm5lZCBpbmNvcnJlY3RseSB3aGVuIHpvb21lZCBvbiBJRTEwIGFuZCBiZWxvdy5cbmZ1bmN0aW9uIG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcobWVhc3VyZSxyZWN0KXtpZighd2luZG93LnNjcmVlbnx8c2NyZWVuLmxvZ2ljYWxYRFBJPT1udWxsfHxzY3JlZW4ubG9naWNhbFhEUEk9PXNjcmVlbi5kZXZpY2VYRFBJfHwhaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkpe3JldHVybiByZWN0O312YXIgc2NhbGVYPXNjcmVlbi5sb2dpY2FsWERQSS9zY3JlZW4uZGV2aWNlWERQSTt2YXIgc2NhbGVZPXNjcmVlbi5sb2dpY2FsWURQSS9zY3JlZW4uZGV2aWNlWURQSTtyZXR1cm57bGVmdDpyZWN0LmxlZnQqc2NhbGVYLHJpZ2h0OnJlY3QucmlnaHQqc2NhbGVYLHRvcDpyZWN0LnRvcCpzY2FsZVksYm90dG9tOnJlY3QuYm90dG9tKnNjYWxlWX07fWZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpe2lmKGxpbmVWaWV3Lm1lYXN1cmUpe2xpbmVWaWV3Lm1lYXN1cmUuY2FjaGU9e307bGluZVZpZXcubWVhc3VyZS5oZWlnaHRzPW51bGw7aWYobGluZVZpZXcucmVzdCl7Zm9yKHZhciBpPTA7aTxsaW5lVmlldy5yZXN0Lmxlbmd0aDtpKyspe2xpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldPXt9O319fX1mdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKXtjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZT1udWxsO3JlbW92ZUNoaWxkcmVuKGNtLmRpc3BsYXkubGluZU1lYXN1cmUpO2Zvcih2YXIgaT0wO2k8Y20uZGlzcGxheS52aWV3Lmxlbmd0aDtpKyspe2NsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IoY20uZGlzcGxheS52aWV3W2ldKTt9fWZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKXtjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKTtjbS5kaXNwbGF5LmNhY2hlZENoYXJXaWR0aD1jbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ9Y20uZGlzcGxheS5jYWNoZWRQYWRkaW5nSD1udWxsO2lmKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyl7Y20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZD10cnVlO31jbS5kaXNwbGF5LmxpbmVOdW1DaGFycz1udWxsO31mdW5jdGlvbiBwYWdlU2Nyb2xsWCgpe3JldHVybiB3aW5kb3cucGFnZVhPZmZzZXR8fChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR8fGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnQ7fWZ1bmN0aW9uIHBhZ2VTY3JvbGxZKCl7cmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldHx8KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudHx8ZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wO30vLyBDb252ZXJ0cyBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCBmcm9tIGxpbmUtbG9jYWxcbi8vIGNvb3JkaW5hdGVzIGludG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS4gQ29udGV4dCBtYXkgYmUgb25lIG9mXG4vLyBcImxpbmVcIiwgXCJkaXZcIiAoZGlzcGxheS5saW5lRGl2KSwgXCJsb2NhbFwiLi9udWxsIChlZGl0b3IpLCBcIndpbmRvd1wiLFxuLy8gb3IgXCJwYWdlXCIuXG5mdW5jdGlvbiBpbnRvQ29vcmRTeXN0ZW0oY20sbGluZU9iaixyZWN0LGNvbnRleHQpe2lmKGxpbmVPYmoud2lkZ2V0cyl7Zm9yKHZhciBpPTA7aTxsaW5lT2JqLndpZGdldHMubGVuZ3RoOysraSl7aWYobGluZU9iai53aWRnZXRzW2ldLmFib3ZlKXt2YXIgc2l6ZT13aWRnZXRIZWlnaHQobGluZU9iai53aWRnZXRzW2ldKTtyZWN0LnRvcCs9c2l6ZTtyZWN0LmJvdHRvbSs9c2l6ZTt9fX1pZihjb250ZXh0PT1cImxpbmVcIil7cmV0dXJuIHJlY3Q7fWlmKCFjb250ZXh0KXtjb250ZXh0PVwibG9jYWxcIjt9dmFyIHlPZmY9aGVpZ2h0QXRMaW5lKGxpbmVPYmopO2lmKGNvbnRleHQ9PVwibG9jYWxcIil7eU9mZis9cGFkZGluZ1RvcChjbS5kaXNwbGF5KTt9ZWxzZXt5T2ZmLT1jbS5kaXNwbGF5LnZpZXdPZmZzZXQ7fWlmKGNvbnRleHQ9PVwicGFnZVwifHxjb250ZXh0PT1cIndpbmRvd1wiKXt2YXIgbE9mZj1jbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt5T2ZmKz1sT2ZmLnRvcCsoY29udGV4dD09XCJ3aW5kb3dcIj8wOnBhZ2VTY3JvbGxZKCkpO3ZhciB4T2ZmPWxPZmYubGVmdCsoY29udGV4dD09XCJ3aW5kb3dcIj8wOnBhZ2VTY3JvbGxYKCkpO3JlY3QubGVmdCs9eE9mZjtyZWN0LnJpZ2h0Kz14T2ZmO31yZWN0LnRvcCs9eU9mZjtyZWN0LmJvdHRvbSs9eU9mZjtyZXR1cm4gcmVjdDt9Ly8gQ292ZXJ0cyBhIGJveCBmcm9tIFwiZGl2XCIgY29vcmRzIHRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uXG4vLyBDb250ZXh0IG1heSBiZSBcIndpbmRvd1wiLCBcInBhZ2VcIiwgXCJkaXZcIiwgb3IgXCJsb2NhbFwiLi9udWxsLlxuZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLGNvb3Jkcyxjb250ZXh0KXtpZihjb250ZXh0PT1cImRpdlwiKXtyZXR1cm4gY29vcmRzO312YXIgbGVmdD1jb29yZHMubGVmdCx0b3A9Y29vcmRzLnRvcDsvLyBGaXJzdCBtb3ZlIGludG8gXCJwYWdlXCIgY29vcmRpbmF0ZSBzeXN0ZW1cbmlmKGNvbnRleHQ9PVwicGFnZVwiKXtsZWZ0LT1wYWdlU2Nyb2xsWCgpO3RvcC09cGFnZVNjcm9sbFkoKTt9ZWxzZSBpZihjb250ZXh0PT1cImxvY2FsXCJ8fCFjb250ZXh0KXt2YXIgbG9jYWxCb3g9Y20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtsZWZ0Kz1sb2NhbEJveC5sZWZ0O3RvcCs9bG9jYWxCb3gudG9wO312YXIgbGluZVNwYWNlQm94PWNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybntsZWZ0OmxlZnQtbGluZVNwYWNlQm94LmxlZnQsdG9wOnRvcC1saW5lU3BhY2VCb3gudG9wfTt9ZnVuY3Rpb24gY2hhckNvb3JkcyhjbSxwb3MsY29udGV4dCxsaW5lT2JqLGJpYXMpe2lmKCFsaW5lT2JqKXtsaW5lT2JqPWdldExpbmUoY20uZG9jLHBvcy5saW5lKTt9cmV0dXJuIGludG9Db29yZFN5c3RlbShjbSxsaW5lT2JqLG1lYXN1cmVDaGFyKGNtLGxpbmVPYmoscG9zLmNoLGJpYXMpLGNvbnRleHQpO30vLyBSZXR1cm5zIGEgYm94IGZvciBhIGdpdmVuIGN1cnNvciBwb3NpdGlvbiwgd2hpY2ggbWF5IGhhdmUgYW5cbi8vICdvdGhlcicgcHJvcGVydHkgY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZGFyeSBjdXJzb3Jcbi8vIG9uIGEgYmlkaSBib3VuZGFyeS5cbmZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSxwb3MsY29udGV4dCxsaW5lT2JqLHByZXBhcmVkTWVhc3VyZSx2YXJIZWlnaHQpe2xpbmVPYmo9bGluZU9ianx8Z2V0TGluZShjbS5kb2MscG9zLmxpbmUpO2lmKCFwcmVwYXJlZE1lYXN1cmUpe3ByZXBhcmVkTWVhc3VyZT1wcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sbGluZU9iaik7fWZ1bmN0aW9uIGdldChjaCxyaWdodCl7dmFyIG09bWVhc3VyZUNoYXJQcmVwYXJlZChjbSxwcmVwYXJlZE1lYXN1cmUsY2gscmlnaHQ/XCJyaWdodFwiOlwibGVmdFwiLHZhckhlaWdodCk7aWYocmlnaHQpe20ubGVmdD1tLnJpZ2h0O31lbHNle20ucmlnaHQ9bS5sZWZ0O31yZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLGxpbmVPYmosbSxjb250ZXh0KTt9ZnVuY3Rpb24gZ2V0QmlkaShjaCxwYXJ0UG9zKXt2YXIgcGFydD1vcmRlcltwYXJ0UG9zXSxyaWdodD1wYXJ0LmxldmVsJTI7aWYoY2g9PWJpZGlMZWZ0KHBhcnQpJiZwYXJ0UG9zJiZwYXJ0LmxldmVsPG9yZGVyW3BhcnRQb3MtMV0ubGV2ZWwpe3BhcnQ9b3JkZXJbLS1wYXJ0UG9zXTtjaD1iaWRpUmlnaHQocGFydCktKHBhcnQubGV2ZWwlMj8wOjEpO3JpZ2h0PXRydWU7fWVsc2UgaWYoY2g9PWJpZGlSaWdodChwYXJ0KSYmcGFydFBvczxvcmRlci5sZW5ndGgtMSYmcGFydC5sZXZlbDxvcmRlcltwYXJ0UG9zKzFdLmxldmVsKXtwYXJ0PW9yZGVyWysrcGFydFBvc107Y2g9YmlkaUxlZnQocGFydCktcGFydC5sZXZlbCUyO3JpZ2h0PWZhbHNlO31pZihyaWdodCYmY2g9PXBhcnQudG8mJmNoPnBhcnQuZnJvbSl7cmV0dXJuIGdldChjaC0xKTt9cmV0dXJuIGdldChjaCxyaWdodCk7fXZhciBvcmRlcj1nZXRPcmRlcihsaW5lT2JqKSxjaD1wb3MuY2g7aWYoIW9yZGVyKXtyZXR1cm4gZ2V0KGNoKTt9dmFyIHBhcnRQb3M9Z2V0QmlkaVBhcnRBdChvcmRlcixjaCk7dmFyIHZhbD1nZXRCaWRpKGNoLHBhcnRQb3MpO2lmKGJpZGlPdGhlciE9bnVsbCl7dmFsLm90aGVyPWdldEJpZGkoY2gsYmlkaU90aGVyKTt9cmV0dXJuIHZhbDt9Ly8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3Jcbi8vIGludGVybWVkaWF0ZSBzY3JvbGwgdXBkYXRlcy5cbmZ1bmN0aW9uIGVzdGltYXRlQ29vcmRzKGNtLHBvcyl7dmFyIGxlZnQ9MDtwb3M9Y2xpcFBvcyhjbS5kb2MscG9zKTtpZighY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpe2xlZnQ9Y2hhcldpZHRoKGNtLmRpc3BsYXkpKnBvcy5jaDt9dmFyIGxpbmVPYmo9Z2V0TGluZShjbS5kb2MscG9zLmxpbmUpO3ZhciB0b3A9aGVpZ2h0QXRMaW5lKGxpbmVPYmopK3BhZGRpbmdUb3AoY20uZGlzcGxheSk7cmV0dXJue2xlZnQ6bGVmdCxyaWdodDpsZWZ0LHRvcDp0b3AsYm90dG9tOnRvcCtsaW5lT2JqLmhlaWdodH07fS8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cbi8vIHhSZWwgaXMgdGhlIHJlbGF0aXZlIHggcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvb3JkaW5hdGVzIGNvbXBhcmVkXG4vLyB0byB0aGUgZm91bmQgcG9zaXRpb24gKHNvIHhSZWwgPiAwIG1lYW5zIHRoZSBjb29yZGluYXRlcyBhcmUgdG9cbi8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxuLy8gaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgbGllIG91dHNpZGUgdGhlIGxpbmUnc1xuLy8gdmVydGljYWwgcmFuZ2UuXG5mdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLGNoLG91dHNpZGUseFJlbCl7dmFyIHBvcz1Qb3MobGluZSxjaCk7cG9zLnhSZWw9eFJlbDtpZihvdXRzaWRlKXtwb3Mub3V0c2lkZT10cnVlO31yZXR1cm4gcG9zO30vLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4vLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXCJkaXZcIiBjb29yZGluYXRlIHN5c3RlbSkuXG5mdW5jdGlvbiBjb29yZHNDaGFyKGNtLHgseSl7dmFyIGRvYz1jbS5kb2M7eSs9Y20uZGlzcGxheS52aWV3T2Zmc2V0O2lmKHk8MCl7cmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCwwLHRydWUsLTEpO312YXIgbGluZU49bGluZUF0SGVpZ2h0KGRvYyx5KSxsYXN0PWRvYy5maXJzdCtkb2Muc2l6ZS0xO2lmKGxpbmVOPmxhc3Qpe3JldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QrZG9jLnNpemUtMSxnZXRMaW5lKGRvYyxsYXN0KS50ZXh0Lmxlbmd0aCx0cnVlLDEpO31pZih4PDApe3g9MDt9dmFyIGxpbmVPYmo9Z2V0TGluZShkb2MsbGluZU4pO2Zvcig7Oyl7dmFyIGZvdW5kPWNvb3Jkc0NoYXJJbm5lcihjbSxsaW5lT2JqLGxpbmVOLHgseSk7dmFyIG1lcmdlZD1jb2xsYXBzZWRTcGFuQXRFbmQobGluZU9iaik7dmFyIG1lcmdlZFBvcz1tZXJnZWQmJm1lcmdlZC5maW5kKDAsdHJ1ZSk7aWYobWVyZ2VkJiYoZm91bmQuY2g+bWVyZ2VkUG9zLmZyb20uY2h8fGZvdW5kLmNoPT1tZXJnZWRQb3MuZnJvbS5jaCYmZm91bmQueFJlbD4wKSl7bGluZU49bGluZU5vKGxpbmVPYmo9bWVyZ2VkUG9zLnRvLmxpbmUpO31lbHNle3JldHVybiBmb3VuZDt9fX1mdW5jdGlvbiBjb29yZHNDaGFySW5uZXIoY20sbGluZU9iaixsaW5lTm8seCx5KXt2YXIgaW5uZXJPZmY9eS1oZWlnaHRBdExpbmUobGluZU9iaik7dmFyIHdyb25nTGluZT1mYWxzZSxhZGp1c3Q9MipjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGg7dmFyIHByZXBhcmVkTWVhc3VyZT1wcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sbGluZU9iaik7ZnVuY3Rpb24gZ2V0WChjaCl7dmFyIHNwPWN1cnNvckNvb3JkcyhjbSxQb3MobGluZU5vLGNoKSxcImxpbmVcIixsaW5lT2JqLHByZXBhcmVkTWVhc3VyZSk7d3JvbmdMaW5lPXRydWU7aWYoaW5uZXJPZmY+c3AuYm90dG9tKXtyZXR1cm4gc3AubGVmdC1hZGp1c3Q7fWVsc2UgaWYoaW5uZXJPZmY8c3AudG9wKXtyZXR1cm4gc3AubGVmdCthZGp1c3Q7fWVsc2V7d3JvbmdMaW5lPWZhbHNlO31yZXR1cm4gc3AubGVmdDt9dmFyIGJpZGk9Z2V0T3JkZXIobGluZU9iaiksZGlzdD1saW5lT2JqLnRleHQubGVuZ3RoO3ZhciBmcm9tPWxpbmVMZWZ0KGxpbmVPYmopLHRvPWxpbmVSaWdodChsaW5lT2JqKTt2YXIgZnJvbVg9Z2V0WChmcm9tKSxmcm9tT3V0c2lkZT13cm9uZ0xpbmUsdG9YPWdldFgodG8pLHRvT3V0c2lkZT13cm9uZ0xpbmU7aWYoeD50b1gpe3JldHVybiBQb3NXaXRoSW5mbyhsaW5lTm8sdG8sdG9PdXRzaWRlLDEpO30vLyBEbyBhIGJpbmFyeSBzZWFyY2ggYmV0d2VlbiB0aGVzZSBib3VuZHMuXG5mb3IoOzspe2lmKGJpZGk/dG89PWZyb218fHRvPT1tb3ZlVmlzdWFsbHkobGluZU9iaixmcm9tLDEpOnRvLWZyb208PTEpe3ZhciBjaD14PGZyb21YfHx4LWZyb21YPD10b1gteD9mcm9tOnRvO3ZhciBvdXRzaWRlPWNoPT1mcm9tP2Zyb21PdXRzaWRlOnRvT3V0c2lkZTt2YXIgeERpZmY9eC0oY2g9PWZyb20/ZnJvbVg6dG9YKTsvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY29vcmRpbmF0ZXNcbi8vIGFyZSBhZnRlciBhIGxpbmUtd3JhcHBlZCBsaW5lLiBXZSBzaG91bGQgcmVwbGFjZSBpdCB3aXRoIGFcbi8vIG1vcmUgZ2VuZXJhbCBoYW5kbGluZyBvZiBjdXJzb3IgcG9zaXRpb25zIGFyb3VuZCBsaW5lXG4vLyBicmVha3MuIChJc3N1ZSAjNDA3OClcbmlmKHRvT3V0c2lkZSYmIWJpZGkmJiEvXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoY2gpKSYmeERpZmY+MCYmY2g8bGluZU9iai50ZXh0Lmxlbmd0aCYmcHJlcGFyZWRNZWFzdXJlLnZpZXcubWVhc3VyZS5oZWlnaHRzLmxlbmd0aD4xKXt2YXIgY2hhclNpemU9bWVhc3VyZUNoYXJQcmVwYXJlZChjbSxwcmVwYXJlZE1lYXN1cmUsY2gsXCJyaWdodFwiKTtpZihpbm5lck9mZjw9Y2hhclNpemUuYm90dG9tJiZpbm5lck9mZj49Y2hhclNpemUudG9wJiZNYXRoLmFicyh4LWNoYXJTaXplLnJpZ2h0KTx4RGlmZil7b3V0c2lkZT1mYWxzZTtjaCsrO3hEaWZmPXgtY2hhclNpemUucmlnaHQ7fX13aGlsZShpc0V4dGVuZGluZ0NoYXIobGluZU9iai50ZXh0LmNoYXJBdChjaCkpKXsrK2NoO312YXIgcG9zPVBvc1dpdGhJbmZvKGxpbmVObyxjaCxvdXRzaWRlLHhEaWZmPC0xPy0xOnhEaWZmPjE/MTowKTtyZXR1cm4gcG9zO312YXIgc3RlcD1NYXRoLmNlaWwoZGlzdC8yKSxtaWRkbGU9ZnJvbStzdGVwO2lmKGJpZGkpe21pZGRsZT1mcm9tO2Zvcih2YXIgaT0wO2k8c3RlcDsrK2kpe21pZGRsZT1tb3ZlVmlzdWFsbHkobGluZU9iaixtaWRkbGUsMSk7fX12YXIgbWlkZGxlWD1nZXRYKG1pZGRsZSk7aWYobWlkZGxlWD54KXt0bz1taWRkbGU7dG9YPW1pZGRsZVg7aWYodG9PdXRzaWRlPXdyb25nTGluZSl7dG9YKz0xMDAwO31kaXN0PXN0ZXA7fWVsc2V7ZnJvbT1taWRkbGU7ZnJvbVg9bWlkZGxlWDtmcm9tT3V0c2lkZT13cm9uZ0xpbmU7ZGlzdC09c3RlcDt9fX12YXIgbWVhc3VyZVRleHQ7Ly8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cbmZ1bmN0aW9uIHRleHRIZWlnaHQoZGlzcGxheSl7aWYoZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0IT1udWxsKXtyZXR1cm4gZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O31pZihtZWFzdXJlVGV4dD09bnVsbCl7bWVhc3VyZVRleHQ9ZWx0KFwicHJlXCIpOy8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxuLy8gZnJhY3Rpb25hbCBoZWlnaHRzLlxuZm9yKHZhciBpPTA7aTw0OTsrK2kpe21lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7bWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFwiYnJcIikpO31tZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpO31yZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsbWVhc3VyZVRleHQpO3ZhciBoZWlnaHQ9bWVhc3VyZVRleHQub2Zmc2V0SGVpZ2h0LzUwO2lmKGhlaWdodD4zKXtkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ9aGVpZ2h0O31yZW1vdmVDaGlsZHJlbihkaXNwbGF5Lm1lYXN1cmUpO3JldHVybiBoZWlnaHR8fDE7fS8vIENvbXB1dGUgdGhlIGRlZmF1bHQgY2hhcmFjdGVyIHdpZHRoLlxuZnVuY3Rpb24gY2hhcldpZHRoKGRpc3BsYXkpe2lmKGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoIT1udWxsKXtyZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGg7fXZhciBhbmNob3I9ZWx0KFwic3BhblwiLFwieHh4eHh4eHh4eFwiKTt2YXIgcHJlPWVsdChcInByZVwiLFthbmNob3JdKTtyZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUscHJlKTt2YXIgcmVjdD1hbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksd2lkdGg9KHJlY3QucmlnaHQtcmVjdC5sZWZ0KS8xMDtpZih3aWR0aD4yKXtkaXNwbGF5LmNhY2hlZENoYXJXaWR0aD13aWR0aDt9cmV0dXJuIHdpZHRofHwxMDt9Ly8gRG8gYSBidWxrLXJlYWQgb2YgdGhlIERPTSBwb3NpdGlvbnMgYW5kIHNpemVzIG5lZWRlZCB0byBkcmF3IHRoZVxuLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoY20pe3ZhciBkPWNtLmRpc3BsYXksbGVmdD17fSx3aWR0aD17fTt2YXIgZ3V0dGVyTGVmdD1kLmd1dHRlcnMuY2xpZW50TGVmdDtmb3IodmFyIG49ZC5ndXR0ZXJzLmZpcnN0Q2hpbGQsaT0wO247bj1uLm5leHRTaWJsaW5nLCsraSl7bGVmdFtjbS5vcHRpb25zLmd1dHRlcnNbaV1dPW4ub2Zmc2V0TGVmdCtuLmNsaWVudExlZnQrZ3V0dGVyTGVmdDt3aWR0aFtjbS5vcHRpb25zLmd1dHRlcnNbaV1dPW4uY2xpZW50V2lkdGg7fXJldHVybntmaXhlZFBvczpjb21wZW5zYXRlRm9ySFNjcm9sbChkKSxndXR0ZXJUb3RhbFdpZHRoOmQuZ3V0dGVycy5vZmZzZXRXaWR0aCxndXR0ZXJMZWZ0OmxlZnQsZ3V0dGVyV2lkdGg6d2lkdGgsd3JhcHBlcldpZHRoOmQud3JhcHBlci5jbGllbnRXaWR0aH07fS8vIENvbXB1dGVzIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCxcbi8vIGJ1dCB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdG8gZ2V0IGEgc3ViLXBpeGVsLWFjY3VyYXRlXG4vLyByZXN1bHQuXG5mdW5jdGlvbiBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KXtyZXR1cm4gZGlzcGxheS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LWRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDt9Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcbi8vIGZpcnN0IGFwcHJveGltYXRpb24gdW50aWwgdGhlIGxpbmUgYmVjb21lcyB2aXNpYmxlIChhbmQgaXMgdGh1c1xuLy8gcHJvcGVybHkgbWVhc3VyYWJsZSkuXG5mdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSl7dmFyIHRoPXRleHRIZWlnaHQoY20uZGlzcGxheSksd3JhcHBpbmc9Y20ub3B0aW9ucy5saW5lV3JhcHBpbmc7dmFyIHBlckxpbmU9d3JhcHBpbmcmJk1hdGgubWF4KDUsY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aC9jaGFyV2lkdGgoY20uZGlzcGxheSktMyk7cmV0dXJuIGZ1bmN0aW9uKGxpbmUpe2lmKGxpbmVJc0hpZGRlbihjbS5kb2MsbGluZSkpe3JldHVybiAwO312YXIgd2lkZ2V0c0hlaWdodD0wO2lmKGxpbmUud2lkZ2V0cyl7Zm9yKHZhciBpPTA7aTxsaW5lLndpZGdldHMubGVuZ3RoO2krKyl7aWYobGluZS53aWRnZXRzW2ldLmhlaWdodCl7d2lkZ2V0c0hlaWdodCs9bGluZS53aWRnZXRzW2ldLmhlaWdodDt9fX1pZih3cmFwcGluZyl7cmV0dXJuIHdpZGdldHNIZWlnaHQrKE1hdGguY2VpbChsaW5lLnRleHQubGVuZ3RoL3BlckxpbmUpfHwxKSp0aDt9ZWxzZXtyZXR1cm4gd2lkZ2V0c0hlaWdodCt0aDt9fTt9ZnVuY3Rpb24gZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSl7dmFyIGRvYz1jbS5kb2MsZXN0PWVzdGltYXRlSGVpZ2h0KGNtKTtkb2MuaXRlcihmdW5jdGlvbihsaW5lKXt2YXIgZXN0SGVpZ2h0PWVzdChsaW5lKTtpZihlc3RIZWlnaHQhPWxpbmUuaGVpZ2h0KXt1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsZXN0SGVpZ2h0KTt9fSk7fS8vIEdpdmVuIGEgbW91c2UgZXZlbnQsIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24uIElmIGxpYmVyYWxcbi8vIGlzIGZhbHNlLCBpdCBjaGVja3Mgd2hldGhlciBhIGd1dHRlciBvciBzY3JvbGxiYXIgd2FzIGNsaWNrZWQsXG4vLyBhbmQgcmV0dXJucyBudWxsIGlmIGl0IHdhcy4gZm9yUmVjdCBpcyB1c2VkIGJ5IHJlY3Rhbmd1bGFyXG4vLyBzZWxlY3Rpb25zLCBhbmQgdHJpZXMgdG8gZXN0aW1hdGUgYSBjaGFyYWN0ZXIgcG9zaXRpb24gZXZlbiBmb3Jcbi8vIGNvb3JkaW5hdGVzIGJleW9uZCB0aGUgcmlnaHQgb2YgdGhlIHRleHQuXG5mdW5jdGlvbiBwb3NGcm9tTW91c2UoY20sZSxsaWJlcmFsLGZvclJlY3Qpe3ZhciBkaXNwbGF5PWNtLmRpc3BsYXk7aWYoIWxpYmVyYWwmJmVfdGFyZ2V0KGUpLmdldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIpPT1cInRydWVcIil7cmV0dXJuIG51bGw7fXZhciB4LHksc3BhY2U9ZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7Ly8gRmFpbHMgdW5wcmVkaWN0YWJseSBvbiBJRVs2N10gd2hlbiBtb3VzZSBpcyBkcmFnZ2VkIGFyb3VuZCBxdWlja2x5LlxudHJ5e3g9ZS5jbGllbnRYLXNwYWNlLmxlZnQ7eT1lLmNsaWVudFktc3BhY2UudG9wO31jYXRjaChlKXtyZXR1cm4gbnVsbDt9dmFyIGNvb3Jkcz1jb29yZHNDaGFyKGNtLHgseSksbGluZTtpZihmb3JSZWN0JiZjb29yZHMueFJlbD09MSYmKGxpbmU9Z2V0TGluZShjbS5kb2MsY29vcmRzLmxpbmUpLnRleHQpLmxlbmd0aD09Y29vcmRzLmNoKXt2YXIgY29sRGlmZj1jb3VudENvbHVtbihsaW5lLGxpbmUubGVuZ3RoLGNtLm9wdGlvbnMudGFiU2l6ZSktbGluZS5sZW5ndGg7Y29vcmRzPVBvcyhjb29yZHMubGluZSxNYXRoLm1heCgwLE1hdGgucm91bmQoKHgtcGFkZGluZ0goY20uZGlzcGxheSkubGVmdCkvY2hhcldpZHRoKGNtLmRpc3BsYXkpKS1jb2xEaWZmKSk7fXJldHVybiBjb29yZHM7fS8vIEZpbmQgdGhlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGluZS4gUmV0dXJuIG51bGxcbi8vIHdoZW4gdGhlIGxpbmUgaXNuJ3QgdmlzaWJsZS5cbmZ1bmN0aW9uIGZpbmRWaWV3SW5kZXgoY20sbil7aWYobj49Y20uZGlzcGxheS52aWV3VG8pe3JldHVybiBudWxsO31uLT1jbS5kaXNwbGF5LnZpZXdGcm9tO2lmKG48MCl7cmV0dXJuIG51bGw7fXZhciB2aWV3PWNtLmRpc3BsYXkudmlldztmb3IodmFyIGk9MDtpPHZpZXcubGVuZ3RoO2krKyl7bi09dmlld1tpXS5zaXplO2lmKG48MCl7cmV0dXJuIGk7fX19ZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKGNtKXtjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oY20uZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpO31mdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLHByaW1hcnkpe3ZhciBkb2M9Y20uZG9jLHJlc3VsdD17fTt2YXIgY3VyRnJhZ21lbnQ9cmVzdWx0LmN1cnNvcnM9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO3ZhciBzZWxGcmFnbWVudD1yZXN1bHQuc2VsZWN0aW9uPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtmb3IodmFyIGk9MDtpPGRvYy5zZWwucmFuZ2VzLmxlbmd0aDtpKyspe2lmKHByaW1hcnk9PT1mYWxzZSYmaT09ZG9jLnNlbC5wcmltSW5kZXgpe2NvbnRpbnVlO312YXIgcmFuZ2U9ZG9jLnNlbC5yYW5nZXNbaV07aWYocmFuZ2UuZnJvbSgpLmxpbmU+PWNtLmRpc3BsYXkudmlld1RvfHxyYW5nZS50bygpLmxpbmU8Y20uZGlzcGxheS52aWV3RnJvbSl7Y29udGludWU7fXZhciBjb2xsYXBzZWQ9cmFuZ2UuZW1wdHkoKTtpZihjb2xsYXBzZWR8fGNtLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3Rpbmcpe2RyYXdTZWxlY3Rpb25DdXJzb3IoY20scmFuZ2UuaGVhZCxjdXJGcmFnbWVudCk7fWlmKCFjb2xsYXBzZWQpe2RyYXdTZWxlY3Rpb25SYW5nZShjbSxyYW5nZSxzZWxGcmFnbWVudCk7fX1yZXR1cm4gcmVzdWx0O30vLyBEcmF3cyBhIGN1cnNvciBmb3IgdGhlIGdpdmVuIHJhbmdlXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLGhlYWQsb3V0cHV0KXt2YXIgcG9zPWN1cnNvckNvb3JkcyhjbSxoZWFkLFwiZGl2XCIsbnVsbCxudWxsLCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpO3ZhciBjdXJzb3I9b3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLFwiXFx1MDBhMFwiLFwiQ29kZU1pcnJvci1jdXJzb3JcIikpO2N1cnNvci5zdHlsZS5sZWZ0PXBvcy5sZWZ0K1wicHhcIjtjdXJzb3Iuc3R5bGUudG9wPXBvcy50b3ArXCJweFwiO2N1cnNvci5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCxwb3MuYm90dG9tLXBvcy50b3ApKmNtLm9wdGlvbnMuY3Vyc29ySGVpZ2h0K1wicHhcIjtpZihwb3Mub3RoZXIpey8vIFNlY29uZGFyeSBjdXJzb3IsIHNob3duIHdoZW4gb24gYSAnanVtcCcgaW4gYmktZGlyZWN0aW9uYWwgdGV4dFxudmFyIG90aGVyQ3Vyc29yPW91dHB1dC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIixcIlxcdTAwYTBcIixcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXCIpKTtvdGhlckN1cnNvci5zdHlsZS5kaXNwbGF5PVwiXCI7b3RoZXJDdXJzb3Iuc3R5bGUubGVmdD1wb3Mub3RoZXIubGVmdCtcInB4XCI7b3RoZXJDdXJzb3Iuc3R5bGUudG9wPXBvcy5vdGhlci50b3ArXCJweFwiO290aGVyQ3Vyc29yLnN0eWxlLmhlaWdodD0ocG9zLm90aGVyLmJvdHRvbS1wb3Mub3RoZXIudG9wKSouODUrXCJweFwiO319Ly8gRHJhd3MgdGhlIGdpdmVuIHJhbmdlIGFzIGEgaGlnaGxpZ2h0ZWQgc2VsZWN0aW9uXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uUmFuZ2UoY20scmFuZ2Usb3V0cHV0KXt2YXIgZGlzcGxheT1jbS5kaXNwbGF5LGRvYz1jbS5kb2M7dmFyIGZyYWdtZW50PWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt2YXIgcGFkZGluZz1wYWRkaW5nSChjbS5kaXNwbGF5KSxsZWZ0U2lkZT1wYWRkaW5nLmxlZnQ7dmFyIHJpZ2h0U2lkZT1NYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsZGlzcGxheVdpZHRoKGNtKS1kaXNwbGF5LnNpemVyLm9mZnNldExlZnQpLXBhZGRpbmcucmlnaHQ7ZnVuY3Rpb24gYWRkKGxlZnQsdG9wLHdpZHRoLGJvdHRvbSl7aWYodG9wPDApe3RvcD0wO310b3A9TWF0aC5yb3VuZCh0b3ApO2JvdHRvbT1NYXRoLnJvdW5kKGJvdHRvbSk7ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3Itc2VsZWN0ZWRcIixcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXCIrbGVmdCtcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIit0b3ArXCJweDsgd2lkdGg6IFwiKyh3aWR0aD09bnVsbD9yaWdodFNpZGUtbGVmdDp3aWR0aCkrXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIrKGJvdHRvbS10b3ApK1wicHhcIikpO31mdW5jdGlvbiBkcmF3Rm9yTGluZShsaW5lLGZyb21BcmcsdG9Bcmcpe3ZhciBsaW5lT2JqPWdldExpbmUoZG9jLGxpbmUpO3ZhciBsaW5lTGVuPWxpbmVPYmoudGV4dC5sZW5ndGg7dmFyIHN0YXJ0LGVuZDtmdW5jdGlvbiBjb29yZHMoY2gsYmlhcyl7cmV0dXJuIGNoYXJDb29yZHMoY20sUG9zKGxpbmUsY2gpLFwiZGl2XCIsbGluZU9iaixiaWFzKTt9aXRlcmF0ZUJpZGlTZWN0aW9ucyhnZXRPcmRlcihsaW5lT2JqKSxmcm9tQXJnfHwwLHRvQXJnPT1udWxsP2xpbmVMZW46dG9BcmcsZnVuY3Rpb24oZnJvbSx0byxkaXIpe3ZhciBsZWZ0UG9zPWNvb3Jkcyhmcm9tLFwibGVmdFwiKSxyaWdodFBvcyxsZWZ0LHJpZ2h0O2lmKGZyb209PXRvKXtyaWdodFBvcz1sZWZ0UG9zO2xlZnQ9cmlnaHQ9bGVmdFBvcy5sZWZ0O31lbHNle3JpZ2h0UG9zPWNvb3Jkcyh0by0xLFwicmlnaHRcIik7aWYoZGlyPT1cInJ0bFwiKXt2YXIgdG1wPWxlZnRQb3M7bGVmdFBvcz1yaWdodFBvcztyaWdodFBvcz10bXA7fWxlZnQ9bGVmdFBvcy5sZWZ0O3JpZ2h0PXJpZ2h0UG9zLnJpZ2h0O31pZihmcm9tQXJnPT1udWxsJiZmcm9tPT0wKXtsZWZ0PWxlZnRTaWRlO31pZihyaWdodFBvcy50b3AtbGVmdFBvcy50b3A+Myl7Ly8gRGlmZmVyZW50IGxpbmVzLCBkcmF3IHRvcCBwYXJ0XG5hZGQobGVmdCxsZWZ0UG9zLnRvcCxudWxsLGxlZnRQb3MuYm90dG9tKTtsZWZ0PWxlZnRTaWRlO2lmKGxlZnRQb3MuYm90dG9tPHJpZ2h0UG9zLnRvcCl7YWRkKGxlZnQsbGVmdFBvcy5ib3R0b20sbnVsbCxyaWdodFBvcy50b3ApO319aWYodG9Bcmc9PW51bGwmJnRvPT1saW5lTGVuKXtyaWdodD1yaWdodFNpZGU7fWlmKCFzdGFydHx8bGVmdFBvcy50b3A8c3RhcnQudG9wfHxsZWZ0UG9zLnRvcD09c3RhcnQudG9wJiZsZWZ0UG9zLmxlZnQ8c3RhcnQubGVmdCl7c3RhcnQ9bGVmdFBvczt9aWYoIWVuZHx8cmlnaHRQb3MuYm90dG9tPmVuZC5ib3R0b218fHJpZ2h0UG9zLmJvdHRvbT09ZW5kLmJvdHRvbSYmcmlnaHRQb3MucmlnaHQ+ZW5kLnJpZ2h0KXtlbmQ9cmlnaHRQb3M7fWlmKGxlZnQ8bGVmdFNpZGUrMSl7bGVmdD1sZWZ0U2lkZTt9YWRkKGxlZnQscmlnaHRQb3MudG9wLHJpZ2h0LWxlZnQscmlnaHRQb3MuYm90dG9tKTt9KTtyZXR1cm57c3RhcnQ6c3RhcnQsZW5kOmVuZH07fXZhciBzRnJvbT1yYW5nZS5mcm9tKCksc1RvPXJhbmdlLnRvKCk7aWYoc0Zyb20ubGluZT09c1RvLmxpbmUpe2RyYXdGb3JMaW5lKHNGcm9tLmxpbmUsc0Zyb20uY2gsc1RvLmNoKTt9ZWxzZXt2YXIgZnJvbUxpbmU9Z2V0TGluZShkb2Msc0Zyb20ubGluZSksdG9MaW5lPWdldExpbmUoZG9jLHNUby5saW5lKTt2YXIgc2luZ2xlVkxpbmU9dmlzdWFsTGluZShmcm9tTGluZSk9PXZpc3VhbExpbmUodG9MaW5lKTt2YXIgbGVmdEVuZD1kcmF3Rm9yTGluZShzRnJvbS5saW5lLHNGcm9tLmNoLHNpbmdsZVZMaW5lP2Zyb21MaW5lLnRleHQubGVuZ3RoKzE6bnVsbCkuZW5kO3ZhciByaWdodFN0YXJ0PWRyYXdGb3JMaW5lKHNUby5saW5lLHNpbmdsZVZMaW5lPzA6bnVsbCxzVG8uY2gpLnN0YXJ0O2lmKHNpbmdsZVZMaW5lKXtpZihsZWZ0RW5kLnRvcDxyaWdodFN0YXJ0LnRvcC0yKXthZGQobGVmdEVuZC5yaWdodCxsZWZ0RW5kLnRvcCxudWxsLGxlZnRFbmQuYm90dG9tKTthZGQobGVmdFNpZGUscmlnaHRTdGFydC50b3AscmlnaHRTdGFydC5sZWZ0LHJpZ2h0U3RhcnQuYm90dG9tKTt9ZWxzZXthZGQobGVmdEVuZC5yaWdodCxsZWZ0RW5kLnRvcCxyaWdodFN0YXJ0LmxlZnQtbGVmdEVuZC5yaWdodCxsZWZ0RW5kLmJvdHRvbSk7fX1pZihsZWZ0RW5kLmJvdHRvbTxyaWdodFN0YXJ0LnRvcCl7YWRkKGxlZnRTaWRlLGxlZnRFbmQuYm90dG9tLG51bGwscmlnaHRTdGFydC50b3ApO319b3V0cHV0LmFwcGVuZENoaWxkKGZyYWdtZW50KTt9Ly8gQ3Vyc29yLWJsaW5raW5nXG5mdW5jdGlvbiByZXN0YXJ0QmxpbmsoY20pe2lmKCFjbS5zdGF0ZS5mb2N1c2VkKXtyZXR1cm47fXZhciBkaXNwbGF5PWNtLmRpc3BsYXk7Y2xlYXJJbnRlcnZhbChkaXNwbGF5LmJsaW5rZXIpO3ZhciBvbj10cnVlO2Rpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJcIjtpZihjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZT4wKXtkaXNwbGF5LmJsaW5rZXI9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtyZXR1cm4gZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT0ob249IW9uKT9cIlwiOlwiaGlkZGVuXCI7fSxjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSk7fWVsc2UgaWYoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGU8MCl7ZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwiO319ZnVuY3Rpb24gZW5zdXJlRm9jdXMoY20pe2lmKCFjbS5zdGF0ZS5mb2N1c2VkKXtjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7b25Gb2N1cyhjbSk7fX1mdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSl7Y20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQ9dHJ1ZTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpe2NtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50PWZhbHNlO29uQmx1cihjbSk7fX0sMTAwKTt9ZnVuY3Rpb24gb25Gb2N1cyhjbSxlKXtpZihjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCl7Y20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQ9ZmFsc2U7fWlmKGNtLm9wdGlvbnMucmVhZE9ubHk9PVwibm9jdXJzb3JcIil7cmV0dXJuO31pZighY20uc3RhdGUuZm9jdXNlZCl7c2lnbmFsKGNtLFwiZm9jdXNcIixjbSxlKTtjbS5zdGF0ZS5mb2N1c2VkPXRydWU7YWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpOy8vIFRoaXMgdGVzdCBwcmV2ZW50cyB0aGlzIGZyb20gZmlyaW5nIHdoZW4gYSBjb250ZXh0XG4vLyBtZW51IGlzIGNsb3NlZCAoc2luY2UgdGhlIGlucHV0IHJlc2V0IHdvdWxkIGtpbGwgdGhlXG4vLyBzZWxlY3QtYWxsIGRldGVjdGlvbiBoYWNrKVxuaWYoIWNtLmN1ck9wJiZjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51IT1jbS5kb2Muc2VsKXtjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7aWYod2Via2l0KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7fSwyMCk7fS8vIElzc3VlICMxNzMwXG59Y20uZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKCk7fXJlc3RhcnRCbGluayhjbSk7fWZ1bmN0aW9uIG9uQmx1cihjbSxlKXtpZihjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCl7cmV0dXJuO31pZihjbS5zdGF0ZS5mb2N1c2VkKXtzaWduYWwoY20sXCJibHVyXCIsY20sZSk7Y20uc3RhdGUuZm9jdXNlZD1mYWxzZTtybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlcixcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKTt9Y2xlYXJJbnRlcnZhbChjbS5kaXNwbGF5LmJsaW5rZXIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtpZighY20uc3RhdGUuZm9jdXNlZCl7Y20uZGlzcGxheS5zaGlmdD1mYWxzZTt9fSwxNTApO30vLyBSZS1hbGlnbiBsaW5lIG51bWJlcnMgYW5kIGd1dHRlciBtYXJrcyB0byBjb21wZW5zYXRlIGZvclxuLy8gaG9yaXpvbnRhbCBzY3JvbGxpbmcuXG5mdW5jdGlvbiBhbGlnbkhvcml6b250YWxseShjbSl7dmFyIGRpc3BsYXk9Y20uZGlzcGxheSx2aWV3PWRpc3BsYXkudmlldztpZighZGlzcGxheS5hbGlnbldpZGdldHMmJighZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGR8fCFjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSl7cmV0dXJuO312YXIgY29tcD1jb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KS1kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQrY20uZG9jLnNjcm9sbExlZnQ7dmFyIGd1dHRlclc9ZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLGxlZnQ9Y29tcCtcInB4XCI7Zm9yKHZhciBpPTA7aTx2aWV3Lmxlbmd0aDtpKyspe2lmKCF2aWV3W2ldLmhpZGRlbil7aWYoY20ub3B0aW9ucy5maXhlZEd1dHRlcil7aWYodmlld1tpXS5ndXR0ZXIpe3ZpZXdbaV0uZ3V0dGVyLnN0eWxlLmxlZnQ9bGVmdDt9aWYodmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kKXt2aWV3W2ldLmd1dHRlckJhY2tncm91bmQuc3R5bGUubGVmdD1sZWZ0O319dmFyIGFsaWduPXZpZXdbaV0uYWxpZ25hYmxlO2lmKGFsaWduKXtmb3IodmFyIGo9MDtqPGFsaWduLmxlbmd0aDtqKyspe2FsaWduW2pdLnN0eWxlLmxlZnQ9bGVmdDt9fX19aWYoY20ub3B0aW9ucy5maXhlZEd1dHRlcil7ZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQ9Y29tcCtndXR0ZXJXK1wicHhcIjt9fS8vIFVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBpcyBzdGlsbCB0aGUgcmlnaHRcbi8vIHNpemUgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IHNpemUuIFJldHVybnMgdHJ1ZSB3aGVuIGFuIHVwZGF0ZVxuLy8gaXMgbmVlZGVkLlxuZnVuY3Rpb24gbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pe2lmKCFjbS5vcHRpb25zLmxpbmVOdW1iZXJzKXtyZXR1cm4gZmFsc2U7fXZhciBkb2M9Y20uZG9jLGxhc3Q9bGluZU51bWJlckZvcihjbS5vcHRpb25zLGRvYy5maXJzdCtkb2Muc2l6ZS0xKSxkaXNwbGF5PWNtLmRpc3BsYXk7aWYobGFzdC5sZW5ndGghPWRpc3BsYXkubGluZU51bUNoYXJzKXt2YXIgdGVzdD1kaXNwbGF5Lm1lYXN1cmUuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsW2VsdChcImRpdlwiLGxhc3QpXSxcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIikpO3ZhciBpbm5lclc9dGVzdC5maXJzdENoaWxkLm9mZnNldFdpZHRoLHBhZGRpbmc9dGVzdC5vZmZzZXRXaWR0aC1pbm5lclc7ZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoPVwiXCI7ZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aD1NYXRoLm1heChpbm5lclcsZGlzcGxheS5saW5lR3V0dGVyLm9mZnNldFdpZHRoLXBhZGRpbmcpKzE7ZGlzcGxheS5saW5lTnVtV2lkdGg9ZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCtwYWRkaW5nO2Rpc3BsYXkubGluZU51bUNoYXJzPWRpc3BsYXkubGluZU51bUlubmVyV2lkdGg/bGFzdC5sZW5ndGg6LTE7ZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoPWRpc3BsYXkubGluZU51bVdpZHRoK1wicHhcIjt1cGRhdGVHdXR0ZXJTcGFjZShjbSk7cmV0dXJuIHRydWU7fXJldHVybiBmYWxzZTt9Ly8gUmVhZCB0aGUgYWN0dWFsIGhlaWdodHMgb2YgdGhlIHJlbmRlcmVkIGxpbmVzLCBhbmQgdXBkYXRlIHRoZWlyXG4vLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cbmZ1bmN0aW9uIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKXt2YXIgZGlzcGxheT1jbS5kaXNwbGF5O3ZhciBwcmV2Qm90dG9tPWRpc3BsYXkubGluZURpdi5vZmZzZXRUb3A7Zm9yKHZhciBpPTA7aTxkaXNwbGF5LnZpZXcubGVuZ3RoO2krKyl7dmFyIGN1cj1kaXNwbGF5LnZpZXdbaV0saGVpZ2h0PXZvaWQgMDtpZihjdXIuaGlkZGVuKXtjb250aW51ZTt9aWYoaWUmJmllX3ZlcnNpb248OCl7dmFyIGJvdD1jdXIubm9kZS5vZmZzZXRUb3ArY3VyLm5vZGUub2Zmc2V0SGVpZ2h0O2hlaWdodD1ib3QtcHJldkJvdHRvbTtwcmV2Qm90dG9tPWJvdDt9ZWxzZXt2YXIgYm94PWN1ci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2hlaWdodD1ib3guYm90dG9tLWJveC50b3A7fXZhciBkaWZmPWN1ci5saW5lLmhlaWdodC1oZWlnaHQ7aWYoaGVpZ2h0PDIpe2hlaWdodD10ZXh0SGVpZ2h0KGRpc3BsYXkpO31pZihkaWZmPi4wMDF8fGRpZmY8LS4wMDEpe3VwZGF0ZUxpbmVIZWlnaHQoY3VyLmxpbmUsaGVpZ2h0KTt1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO2lmKGN1ci5yZXN0KXtmb3IodmFyIGo9MDtqPGN1ci5yZXN0Lmxlbmd0aDtqKyspe3VwZGF0ZVdpZGdldEhlaWdodChjdXIucmVzdFtqXSk7fX19fX0vLyBSZWFkIGFuZCBzdG9yZSB0aGUgaGVpZ2h0IG9mIGxpbmUgd2lkZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlXG4vLyBnaXZlbiBsaW5lLlxuZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpe2lmKGxpbmUud2lkZ2V0cyl7Zm9yKHZhciBpPTA7aTxsaW5lLndpZGdldHMubGVuZ3RoOysraSl7bGluZS53aWRnZXRzW2ldLmhlaWdodD1saW5lLndpZGdldHNbaV0ubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodDt9fX0vLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXG4vLyB0aGUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uKS4gdmlld3BvcnQgbWF5IGNvbnRhaW4gdG9wLFxuLy8gaGVpZ2h0LCBhbmQgZW5zdXJlIChzZWUgb3Auc2Nyb2xsVG9Qb3MpIHByb3BlcnRpZXMuXG5mdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSxkb2Msdmlld3BvcnQpe3ZhciB0b3A9dmlld3BvcnQmJnZpZXdwb3J0LnRvcCE9bnVsbD9NYXRoLm1heCgwLHZpZXdwb3J0LnRvcCk6ZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7dG9wPU1hdGguZmxvb3IodG9wLXBhZGRpbmdUb3AoZGlzcGxheSkpO3ZhciBib3R0b209dmlld3BvcnQmJnZpZXdwb3J0LmJvdHRvbSE9bnVsbD92aWV3cG9ydC5ib3R0b206dG9wK2Rpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7dmFyIGZyb209bGluZUF0SGVpZ2h0KGRvYyx0b3ApLHRvPWxpbmVBdEhlaWdodChkb2MsYm90dG9tKTsvLyBFbnN1cmUgaXMgYSB7ZnJvbToge2xpbmUsIGNofSwgdG86IHtsaW5lLCBjaH19IG9iamVjdCwgYW5kXG4vLyBmb3JjZXMgdGhvc2UgbGluZXMgaW50byB0aGUgdmlld3BvcnQgKGlmIHBvc3NpYmxlKS5cbmlmKHZpZXdwb3J0JiZ2aWV3cG9ydC5lbnN1cmUpe3ZhciBlbnN1cmVGcm9tPXZpZXdwb3J0LmVuc3VyZS5mcm9tLmxpbmUsZW5zdXJlVG89dmlld3BvcnQuZW5zdXJlLnRvLmxpbmU7aWYoZW5zdXJlRnJvbTxmcm9tKXtmcm9tPWVuc3VyZUZyb207dG89bGluZUF0SGVpZ2h0KGRvYyxoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsZW5zdXJlRnJvbSkpK2Rpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpO31lbHNlIGlmKE1hdGgubWluKGVuc3VyZVRvLGRvYy5sYXN0TGluZSgpKT49dG8pe2Zyb209bGluZUF0SGVpZ2h0KGRvYyxoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsZW5zdXJlVG8pKS1kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTt0bz1lbnN1cmVUbzt9fXJldHVybntmcm9tOmZyb20sdG86TWF0aC5tYXgodG8sZnJvbSsxKX07fS8vIFN5bmMgdGhlIHNjcm9sbGFibGUgYXJlYSBhbmQgc2Nyb2xsYmFycywgZW5zdXJlIHRoZSB2aWV3cG9ydFxuLy8gY292ZXJzIHRoZSB2aXNpYmxlIGFyZWEuXG5mdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sdmFsKXtpZihNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wLXZhbCk8Mil7cmV0dXJuO31jbS5kb2Muc2Nyb2xsVG9wPXZhbDtpZighZ2Vja28pe3VwZGF0ZURpc3BsYXlTaW1wbGUoY20se3RvcDp2YWx9KTt9aWYoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AhPXZhbCl7Y20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A9dmFsO31jbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKHZhbCk7aWYoZ2Vja28pe3VwZGF0ZURpc3BsYXlTaW1wbGUoY20pO31zdGFydFdvcmtlcihjbSwxMDApO30vLyBTeW5jIHNjcm9sbGVyIGFuZCBzY3JvbGxiYXIsIGVuc3VyZSB0aGUgZ3V0dGVyIGVsZW1lbnRzIGFyZVxuLy8gYWxpZ25lZC5cbmZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sdmFsLGlzU2Nyb2xsZXIpe2lmKGlzU2Nyb2xsZXI/dmFsPT1jbS5kb2Muc2Nyb2xsTGVmdDpNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdC12YWwpPDIpe3JldHVybjt9dmFsPU1hdGgubWluKHZhbCxjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoLWNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpO2NtLmRvYy5zY3JvbGxMZWZ0PXZhbDthbGlnbkhvcml6b250YWxseShjbSk7aWYoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0IT12YWwpe2NtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdD12YWw7fWNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbCk7fS8vIFNpbmNlIHRoZSBkZWx0YSB2YWx1ZXMgcmVwb3J0ZWQgb24gbW91c2Ugd2hlZWwgZXZlbnRzIGFyZVxuLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcbi8vIGdlbmVyYWxseSBob3JyaWJseSB1bnByZWRpY3RhYmxlLCB0aGlzIGNvZGUgc3RhcnRzIGJ5IG1lYXN1cmluZ1xuLy8gdGhlIHNjcm9sbCBlZmZlY3QgdGhhdCB0aGUgZmlyc3QgZmV3IG1vdXNlIHdoZWVsIGV2ZW50cyBoYXZlLFxuLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcbi8vIG9mZnNldHMgYWZ0ZXJ3YXJkcy5cbi8vXG4vLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcbi8vIGlzIHRoYXQgaXQgZ2l2ZXMgdXMgYSBjaGFuY2UgdG8gdXBkYXRlIHRoZSBkaXNwbGF5IGJlZm9yZSB0aGVcbi8vIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgcmVkdWNpbmcgZmxpY2tlcmluZy5cbnZhciB3aGVlbFNhbXBsZXM9MDt2YXIgd2hlZWxQaXhlbHNQZXJVbml0PW51bGw7Ly8gRmlsbCBpbiBhIGJyb3dzZXItZGV0ZWN0ZWQgc3RhcnRpbmcgdmFsdWUgb24gYnJvd3NlcnMgd2hlcmUgd2Vcbi8vIGtub3cgb25lLiBUaGVzZSBkb24ndCBoYXZlIHRvIGJlIGFjY3VyYXRlIC0tIHRoZSByZXN1bHQgb2YgdGhlbVxuLy8gYmVpbmcgd3Jvbmcgd291bGQganVzdCBiZSBhIHNsaWdodCBmbGlja2VyIG9uIHRoZSBmaXJzdCB3aGVlbFxuLy8gc2Nyb2xsIChpZiBpdCBpcyBsYXJnZSBlbm91Z2gpLlxuaWYoaWUpe3doZWVsUGl4ZWxzUGVyVW5pdD0tLjUzO31lbHNlIGlmKGdlY2tvKXt3aGVlbFBpeGVsc1BlclVuaXQ9MTU7fWVsc2UgaWYoY2hyb21lKXt3aGVlbFBpeGVsc1BlclVuaXQ9LS43O31lbHNlIGlmKHNhZmFyaSl7d2hlZWxQaXhlbHNQZXJVbml0PS0xLzM7fWZ1bmN0aW9uIHdoZWVsRXZlbnREZWx0YShlKXt2YXIgZHg9ZS53aGVlbERlbHRhWCxkeT1lLndoZWVsRGVsdGFZO2lmKGR4PT1udWxsJiZlLmRldGFpbCYmZS5heGlzPT1lLkhPUklaT05UQUxfQVhJUyl7ZHg9ZS5kZXRhaWw7fWlmKGR5PT1udWxsJiZlLmRldGFpbCYmZS5heGlzPT1lLlZFUlRJQ0FMX0FYSVMpe2R5PWUuZGV0YWlsO31lbHNlIGlmKGR5PT1udWxsKXtkeT1lLndoZWVsRGVsdGE7fXJldHVybnt4OmR4LHk6ZHl9O31mdW5jdGlvbiB3aGVlbEV2ZW50UGl4ZWxzKGUpe3ZhciBkZWx0YT13aGVlbEV2ZW50RGVsdGEoZSk7ZGVsdGEueCo9d2hlZWxQaXhlbHNQZXJVbml0O2RlbHRhLnkqPXdoZWVsUGl4ZWxzUGVyVW5pdDtyZXR1cm4gZGVsdGE7fWZ1bmN0aW9uIG9uU2Nyb2xsV2hlZWwoY20sZSl7dmFyIGRlbHRhPXdoZWVsRXZlbnREZWx0YShlKSxkeD1kZWx0YS54LGR5PWRlbHRhLnk7dmFyIGRpc3BsYXk9Y20uZGlzcGxheSxzY3JvbGw9ZGlzcGxheS5zY3JvbGxlcjsvLyBRdWl0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzY3JvbGwgaGVyZVxudmFyIGNhblNjcm9sbFg9c2Nyb2xsLnNjcm9sbFdpZHRoPnNjcm9sbC5jbGllbnRXaWR0aDt2YXIgY2FuU2Nyb2xsWT1zY3JvbGwuc2Nyb2xsSGVpZ2h0PnNjcm9sbC5jbGllbnRIZWlnaHQ7aWYoIShkeCYmY2FuU2Nyb2xsWHx8ZHkmJmNhblNjcm9sbFkpKXtyZXR1cm47fS8vIFdlYmtpdCBicm93c2VycyBvbiBPUyBYIGFib3J0IG1vbWVudHVtIHNjcm9sbHMgd2hlbiB0aGUgdGFyZ2V0XG4vLyBvZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50LlxuLy8gVGhpcyBoYWNrIChzZWUgcmVsYXRlZCBjb2RlIGluIHBhdGNoRGlzcGxheSkgbWFrZXMgc3VyZSB0aGVcbi8vIGVsZW1lbnQgaXMga2VwdCBhcm91bmQuXG5pZihkeSYmbWFjJiZ3ZWJraXQpe291dGVyOmZvcih2YXIgY3VyPWUudGFyZ2V0LHZpZXc9ZGlzcGxheS52aWV3O2N1ciE9c2Nyb2xsO2N1cj1jdXIucGFyZW50Tm9kZSl7Zm9yKHZhciBpPTA7aTx2aWV3Lmxlbmd0aDtpKyspe2lmKHZpZXdbaV0ubm9kZT09Y3VyKXtjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldD1jdXI7YnJlYWsgb3V0ZXI7fX19fS8vIE9uIHNvbWUgYnJvd3NlcnMsIGhvcml6b250YWwgc2Nyb2xsaW5nIHdpbGwgY2F1c2UgcmVkcmF3cyB0b1xuLy8gaGFwcGVuIGJlZm9yZSB0aGUgZ3V0dGVyIGhhcyBiZWVuIHJlYWxpZ25lZCwgY2F1c2luZyBpdCB0b1xuLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXG4vLyBlc3RpbWF0ZWQgcGl4ZWxzL2RlbHRhIHZhbHVlLCB3ZSBqdXN0IGhhbmRsZSBob3Jpem9udGFsXG4vLyBzY3JvbGxpbmcgZW50aXJlbHkgaGVyZS4gSXQnbGwgYmUgc2xpZ2h0bHkgb2ZmIGZyb20gbmF0aXZlLCBidXRcbi8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXG5pZihkeCYmIWdlY2tvJiYhcHJlc3RvJiZ3aGVlbFBpeGVsc1BlclVuaXQhPW51bGwpe2lmKGR5JiZjYW5TY3JvbGxZKXtzZXRTY3JvbGxUb3AoY20sTWF0aC5tYXgoMCxNYXRoLm1pbihzY3JvbGwuc2Nyb2xsVG9wK2R5KndoZWVsUGl4ZWxzUGVyVW5pdCxzY3JvbGwuc2Nyb2xsSGVpZ2h0LXNjcm9sbC5jbGllbnRIZWlnaHQpKSk7fXNldFNjcm9sbExlZnQoY20sTWF0aC5tYXgoMCxNYXRoLm1pbihzY3JvbGwuc2Nyb2xsTGVmdCtkeCp3aGVlbFBpeGVsc1BlclVuaXQsc2Nyb2xsLnNjcm9sbFdpZHRoLXNjcm9sbC5jbGllbnRXaWR0aCkpKTsvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgaWYgdmVydGljYWwgc2Nyb2xsaW5nIGlzXG4vLyBhY3R1YWxseSBwb3NzaWJsZS4gT3RoZXJ3aXNlLCBpdCBjYXVzZXMgdmVydGljYWwgc2Nyb2xsXG4vLyBqaXR0ZXIgb24gT1NYIHRyYWNrcGFkcyB3aGVuIGRlbHRhWCBpcyBzbWFsbCBhbmQgZGVsdGFZXG4vLyBpcyBsYXJnZSAoaXNzdWUgIzM1NzkpXG5pZighZHl8fGR5JiZjYW5TY3JvbGxZKXtlX3ByZXZlbnREZWZhdWx0KGUpO31kaXNwbGF5LndoZWVsU3RhcnRYPW51bGw7Ly8gQWJvcnQgbWVhc3VyZW1lbnQsIGlmIGluIHByb2dyZXNzXG5yZXR1cm47fS8vICdQcm9qZWN0JyB0aGUgdmlzaWJsZSB2aWV3cG9ydCB0byBjb3ZlciB0aGUgYXJlYSB0aGF0IGlzIGJlaW5nXG4vLyBzY3JvbGxlZCBpbnRvIHZpZXcgKGlmIHdlIGtub3cgZW5vdWdoIHRvIGVzdGltYXRlIGl0KS5cbmlmKGR5JiZ3aGVlbFBpeGVsc1BlclVuaXQhPW51bGwpe3ZhciBwaXhlbHM9ZHkqd2hlZWxQaXhlbHNQZXJVbml0O3ZhciB0b3A9Y20uZG9jLnNjcm9sbFRvcCxib3Q9dG9wK2Rpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7aWYocGl4ZWxzPDApe3RvcD1NYXRoLm1heCgwLHRvcCtwaXhlbHMtNTApO31lbHNle2JvdD1NYXRoLm1pbihjbS5kb2MuaGVpZ2h0LGJvdCtwaXhlbHMrNTApO311cGRhdGVEaXNwbGF5U2ltcGxlKGNtLHt0b3A6dG9wLGJvdHRvbTpib3R9KTt9aWYod2hlZWxTYW1wbGVzPDIwKXtpZihkaXNwbGF5LndoZWVsU3RhcnRYPT1udWxsKXtkaXNwbGF5LndoZWVsU3RhcnRYPXNjcm9sbC5zY3JvbGxMZWZ0O2Rpc3BsYXkud2hlZWxTdGFydFk9c2Nyb2xsLnNjcm9sbFRvcDtkaXNwbGF5LndoZWVsRFg9ZHg7ZGlzcGxheS53aGVlbERZPWR5O3NldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihkaXNwbGF5LndoZWVsU3RhcnRYPT1udWxsKXtyZXR1cm47fXZhciBtb3ZlZFg9c2Nyb2xsLnNjcm9sbExlZnQtZGlzcGxheS53aGVlbFN0YXJ0WDt2YXIgbW92ZWRZPXNjcm9sbC5zY3JvbGxUb3AtZGlzcGxheS53aGVlbFN0YXJ0WTt2YXIgc2FtcGxlPW1vdmVkWSYmZGlzcGxheS53aGVlbERZJiZtb3ZlZFkvZGlzcGxheS53aGVlbERZfHxtb3ZlZFgmJmRpc3BsYXkud2hlZWxEWCYmbW92ZWRYL2Rpc3BsYXkud2hlZWxEWDtkaXNwbGF5LndoZWVsU3RhcnRYPWRpc3BsYXkud2hlZWxTdGFydFk9bnVsbDtpZighc2FtcGxlKXtyZXR1cm47fXdoZWVsUGl4ZWxzUGVyVW5pdD0od2hlZWxQaXhlbHNQZXJVbml0KndoZWVsU2FtcGxlcytzYW1wbGUpLyh3aGVlbFNhbXBsZXMrMSk7Kyt3aGVlbFNhbXBsZXM7fSwyMDApO31lbHNle2Rpc3BsYXkud2hlZWxEWCs9ZHg7ZGlzcGxheS53aGVlbERZKz1keTt9fX0vLyBTQ1JPTExCQVJTXG4vLyBQcmVwYXJlIERPTSByZWFkcyBuZWVkZWQgdG8gdXBkYXRlIHRoZSBzY3JvbGxiYXJzLiBEb25lIGluIG9uZVxuLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxuZnVuY3Rpb24gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pe3ZhciBkPWNtLmRpc3BsYXksZ3V0dGVyVz1kLmd1dHRlcnMub2Zmc2V0V2lkdGg7dmFyIGRvY0g9TWF0aC5yb3VuZChjbS5kb2MuaGVpZ2h0K3BhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpKTtyZXR1cm57Y2xpZW50SGVpZ2h0OmQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LHZpZXdIZWlnaHQ6ZC53cmFwcGVyLmNsaWVudEhlaWdodCxzY3JvbGxXaWR0aDpkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLGNsaWVudFdpZHRoOmQuc2Nyb2xsZXIuY2xpZW50V2lkdGgsdmlld1dpZHRoOmQud3JhcHBlci5jbGllbnRXaWR0aCxiYXJMZWZ0OmNtLm9wdGlvbnMuZml4ZWRHdXR0ZXI/Z3V0dGVyVzowLGRvY0hlaWdodDpkb2NILHNjcm9sbEhlaWdodDpkb2NIK3Njcm9sbEdhcChjbSkrZC5iYXJIZWlnaHQsbmF0aXZlQmFyV2lkdGg6ZC5uYXRpdmVCYXJXaWR0aCxndXR0ZXJXaWR0aDpndXR0ZXJXfTt9ZnVuY3Rpb24gTmF0aXZlU2Nyb2xsYmFycyhwbGFjZSxzY3JvbGwsY20pe3RoaXMuY209Y207dmFyIHZlcnQ9dGhpcy52ZXJ0PWVsdChcImRpdlwiLFtlbHQoXCJkaXZcIixudWxsLG51bGwsXCJtaW4td2lkdGg6IDFweFwiKV0sXCJDb2RlTWlycm9yLXZzY3JvbGxiYXJcIik7dmFyIGhvcml6PXRoaXMuaG9yaXo9ZWx0KFwiZGl2XCIsW2VsdChcImRpdlwiLG51bGwsbnVsbCxcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XCIpXSxcIkNvZGVNaXJyb3ItaHNjcm9sbGJhclwiKTtwbGFjZSh2ZXJ0KTtwbGFjZShob3Jpeik7b24odmVydCxcInNjcm9sbFwiLGZ1bmN0aW9uKCl7aWYodmVydC5jbGllbnRIZWlnaHQpe3Njcm9sbCh2ZXJ0LnNjcm9sbFRvcCxcInZlcnRpY2FsXCIpO319KTtvbihob3JpeixcInNjcm9sbFwiLGZ1bmN0aW9uKCl7aWYoaG9yaXouY2xpZW50V2lkdGgpe3Njcm9sbChob3Jpei5zY3JvbGxMZWZ0LFwiaG9yaXpvbnRhbFwiKTt9fSk7dGhpcy5jaGVja2VkWmVyb1dpZHRoPWZhbHNlOy8vIE5lZWQgdG8gc2V0IGEgbWluaW11bSB3aWR0aCB0byBzZWUgdGhlIHNjcm9sbGJhciBvbiBJRTcgKGJ1dCBtdXN0IG5vdCBzZXQgaXQgb24gSUU4KS5cbmlmKGllJiZpZV92ZXJzaW9uPDgpe3RoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0PXRoaXMudmVydC5zdHlsZS5taW5XaWR0aD1cIjE4cHhcIjt9fU5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlPWNvcHlPYmooe3VwZGF0ZTpmdW5jdGlvbihtZWFzdXJlKXt2YXIgbmVlZHNIPW1lYXN1cmUuc2Nyb2xsV2lkdGg+bWVhc3VyZS5jbGllbnRXaWR0aCsxO3ZhciBuZWVkc1Y9bWVhc3VyZS5zY3JvbGxIZWlnaHQ+bWVhc3VyZS5jbGllbnRIZWlnaHQrMTt2YXIgc1dpZHRoPW1lYXN1cmUubmF0aXZlQmFyV2lkdGg7aWYobmVlZHNWKXt0aGlzLnZlcnQuc3R5bGUuZGlzcGxheT1cImJsb2NrXCI7dGhpcy52ZXJ0LnN0eWxlLmJvdHRvbT1uZWVkc0g/c1dpZHRoK1wicHhcIjpcIjBcIjt2YXIgdG90YWxIZWlnaHQ9bWVhc3VyZS52aWV3SGVpZ2h0LShuZWVkc0g/c1dpZHRoOjApOy8vIEEgYnVnIGluIElFOCBjYW4gY2F1c2UgdGhpcyB2YWx1ZSB0byBiZSBuZWdhdGl2ZSwgc28gZ3VhcmQgaXQuXG50aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoMCxtZWFzdXJlLnNjcm9sbEhlaWdodC1tZWFzdXJlLmNsaWVudEhlaWdodCt0b3RhbEhlaWdodCkrXCJweFwiO31lbHNle3RoaXMudmVydC5zdHlsZS5kaXNwbGF5PVwiXCI7dGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0PVwiMFwiO31pZihuZWVkc0gpe3RoaXMuaG9yaXouc3R5bGUuZGlzcGxheT1cImJsb2NrXCI7dGhpcy5ob3Jpei5zdHlsZS5yaWdodD1uZWVkc1Y/c1dpZHRoK1wicHhcIjpcIjBcIjt0aGlzLmhvcml6LnN0eWxlLmxlZnQ9bWVhc3VyZS5iYXJMZWZ0K1wicHhcIjt2YXIgdG90YWxXaWR0aD1tZWFzdXJlLnZpZXdXaWR0aC1tZWFzdXJlLmJhckxlZnQtKG5lZWRzVj9zV2lkdGg6MCk7dGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoPW1lYXN1cmUuc2Nyb2xsV2lkdGgtbWVhc3VyZS5jbGllbnRXaWR0aCt0b3RhbFdpZHRoK1wicHhcIjt9ZWxzZXt0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXk9XCJcIjt0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9XCIwXCI7fWlmKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGgmJm1lYXN1cmUuY2xpZW50SGVpZ2h0PjApe2lmKHNXaWR0aD09MCl7dGhpcy56ZXJvV2lkdGhIYWNrKCk7fXRoaXMuY2hlY2tlZFplcm9XaWR0aD10cnVlO31yZXR1cm57cmlnaHQ6bmVlZHNWP3NXaWR0aDowLGJvdHRvbTpuZWVkc0g/c1dpZHRoOjB9O30sc2V0U2Nyb2xsTGVmdDpmdW5jdGlvbihwb3Mpe2lmKHRoaXMuaG9yaXouc2Nyb2xsTGVmdCE9cG9zKXt0aGlzLmhvcml6LnNjcm9sbExlZnQ9cG9zO31pZih0aGlzLmRpc2FibGVIb3Jpeil7dGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy5ob3Jpeix0aGlzLmRpc2FibGVIb3Jpeik7fX0sc2V0U2Nyb2xsVG9wOmZ1bmN0aW9uKHBvcyl7aWYodGhpcy52ZXJ0LnNjcm9sbFRvcCE9cG9zKXt0aGlzLnZlcnQuc2Nyb2xsVG9wPXBvczt9aWYodGhpcy5kaXNhYmxlVmVydCl7dGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy52ZXJ0LHRoaXMuZGlzYWJsZVZlcnQpO319LHplcm9XaWR0aEhhY2s6ZnVuY3Rpb24oKXt2YXIgdz1tYWMmJiFtYWNfZ2VNb3VudGFpbkxpb24/XCIxMnB4XCI6XCIxOHB4XCI7dGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQ9dGhpcy52ZXJ0LnN0eWxlLndpZHRoPXc7dGhpcy5ob3Jpei5zdHlsZS5wb2ludGVyRXZlbnRzPXRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiO3RoaXMuZGlzYWJsZUhvcml6PW5ldyBEZWxheWVkKCk7dGhpcy5kaXNhYmxlVmVydD1uZXcgRGVsYXllZCgpO30sZW5hYmxlWmVyb1dpZHRoQmFyOmZ1bmN0aW9uKGJhcixkZWxheSl7YmFyLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJhdXRvXCI7ZnVuY3Rpb24gbWF5YmVEaXNhYmxlKCl7Ly8gVG8gZmluZCBvdXQgd2hldGhlciB0aGUgc2Nyb2xsYmFyIGlzIHN0aWxsIHZpc2libGUsIHdlXG4vLyBjaGVjayB3aGV0aGVyIHRoZSBlbGVtZW50IHVuZGVyIHRoZSBwaXhlbCBpbiB0aGUgYm90dG9tXG4vLyBsZWZ0IGNvcm5lciBvZiB0aGUgc2Nyb2xsYmFyIGJveCBpcyB0aGUgc2Nyb2xsYmFyIGJveFxuLy8gaXRzZWxmICh3aGVuIHRoZSBiYXIgaXMgc3RpbGwgdmlzaWJsZSkgb3IgaXRzIGZpbGxlciBjaGlsZFxuLy8gKHdoZW4gdGhlIGJhciBpcyBoaWRkZW4pLiBJZiBpdCBpcyBzdGlsbCB2aXNpYmxlLCB3ZSBrZWVwXG4vLyBpdCBlbmFibGVkLCBpZiBpdCdzIGhpZGRlbiwgd2UgZGlzYWJsZSBwb2ludGVyIGV2ZW50cy5cbnZhciBib3g9YmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciBlbHQ9ZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChib3gubGVmdCsxLGJveC5ib3R0b20tMSk7aWYoZWx0IT1iYXIpe2Jhci5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiO31lbHNle2RlbGF5LnNldCgxMDAwLG1heWJlRGlzYWJsZSk7fX1kZWxheS5zZXQoMTAwMCxtYXliZURpc2FibGUpO30sY2xlYXI6ZnVuY3Rpb24oKXt2YXIgcGFyZW50PXRoaXMuaG9yaXoucGFyZW50Tm9kZTtwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3Jpeik7cGFyZW50LnJlbW92ZUNoaWxkKHRoaXMudmVydCk7fX0sTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUpO2Z1bmN0aW9uIE51bGxTY3JvbGxiYXJzKCl7fU51bGxTY3JvbGxiYXJzLnByb3RvdHlwZT1jb3B5T2JqKHt1cGRhdGU6ZnVuY3Rpb24oKXtyZXR1cm57Ym90dG9tOjAscmlnaHQ6MH07fSxzZXRTY3JvbGxMZWZ0OmZ1bmN0aW9uKCl7fSxzZXRTY3JvbGxUb3A6ZnVuY3Rpb24oKXt9LGNsZWFyOmZ1bmN0aW9uKCl7fX0sTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlKTtmdW5jdGlvbiB1cGRhdGVTY3JvbGxiYXJzKGNtLG1lYXN1cmUpe2lmKCFtZWFzdXJlKXttZWFzdXJlPW1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTt9dmFyIHN0YXJ0V2lkdGg9Y20uZGlzcGxheS5iYXJXaWR0aCxzdGFydEhlaWdodD1jbS5kaXNwbGF5LmJhckhlaWdodDt1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sbWVhc3VyZSk7Zm9yKHZhciBpPTA7aTw0JiZzdGFydFdpZHRoIT1jbS5kaXNwbGF5LmJhcldpZHRofHxzdGFydEhlaWdodCE9Y20uZGlzcGxheS5iYXJIZWlnaHQ7aSsrKXtpZihzdGFydFdpZHRoIT1jbS5kaXNwbGF5LmJhcldpZHRoJiZjbS5vcHRpb25zLmxpbmVXcmFwcGluZyl7dXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO311cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKTtzdGFydFdpZHRoPWNtLmRpc3BsYXkuYmFyV2lkdGg7c3RhcnRIZWlnaHQ9Y20uZGlzcGxheS5iYXJIZWlnaHQ7fX0vLyBSZS1zeW5jaHJvbml6ZSB0aGUgZmFrZSBzY3JvbGxiYXJzIHdpdGggdGhlIGFjdHVhbCBzaXplIG9mIHRoZVxuLy8gY29udGVudC5cbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSxtZWFzdXJlKXt2YXIgZD1jbS5kaXNwbGF5O3ZhciBzaXplcz1kLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpO2Quc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0PShkLmJhcldpZHRoPXNpemVzLnJpZ2h0KStcInB4XCI7ZC5zaXplci5zdHlsZS5wYWRkaW5nQm90dG9tPShkLmJhckhlaWdodD1zaXplcy5ib3R0b20pK1wicHhcIjtkLmhlaWdodEZvcmNlci5zdHlsZS5ib3JkZXJCb3R0b209c2l6ZXMuYm90dG9tK1wicHggc29saWQgdHJhbnNwYXJlbnRcIjtpZihzaXplcy5yaWdodCYmc2l6ZXMuYm90dG9tKXtkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIjtkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQ9c2l6ZXMuYm90dG9tK1wicHhcIjtkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aD1zaXplcy5yaWdodCtcInB4XCI7fWVsc2V7ZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheT1cIlwiO31pZihzaXplcy5ib3R0b20mJmNtLm9wdGlvbnMuY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXImJmNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpe2QuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiO2QuZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodD1zaXplcy5ib3R0b20rXCJweFwiO2QuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoPW1lYXN1cmUuZ3V0dGVyV2lkdGgrXCJweFwiO31lbHNle2QuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXk9XCJcIjt9fXZhciBzY3JvbGxiYXJNb2RlbD17XCJuYXRpdmVcIjpOYXRpdmVTY3JvbGxiYXJzLFwibnVsbFwiOk51bGxTY3JvbGxiYXJzfTtmdW5jdGlvbiBpbml0U2Nyb2xsYmFycyhjbSl7aWYoY20uZGlzcGxheS5zY3JvbGxiYXJzKXtjbS5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKTtpZihjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3Mpe3JtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7fX1jbS5kaXNwbGF5LnNjcm9sbGJhcnM9bmV3IHNjcm9sbGJhck1vZGVsW2NtLm9wdGlvbnMuc2Nyb2xsYmFyU3R5bGVdKGZ1bmN0aW9uKG5vZGUpe2NtLmRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUobm9kZSxjbS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcik7Ly8gUHJldmVudCBjbGlja3MgaW4gdGhlIHNjcm9sbGJhcnMgZnJvbSBraWxsaW5nIGZvY3VzXG5vbihub2RlLFwibW91c2Vkb3duXCIsZnVuY3Rpb24oKXtpZihjbS5zdGF0ZS5mb2N1c2VkKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LDApO319KTtub2RlLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsXCJ0cnVlXCIpO30sZnVuY3Rpb24ocG9zLGF4aXMpe2lmKGF4aXM9PVwiaG9yaXpvbnRhbFwiKXtzZXRTY3JvbGxMZWZ0KGNtLHBvcyk7fWVsc2V7c2V0U2Nyb2xsVG9wKGNtLHBvcyk7fX0sY20pO2lmKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyl7YWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7fX0vLyBTQ1JPTExJTkcgVEhJTkdTIElOVE8gVklFV1xuLy8gSWYgYW4gZWRpdG9yIHNpdHMgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHdpbmRvdywgcGFydGlhbGx5XG4vLyBzY3JvbGxlZCBvdXQgb2YgdmlldywgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBpcyB2aXNpYmxlLlxuZnVuY3Rpb24gbWF5YmVTY3JvbGxXaW5kb3coY20sY29vcmRzKXtpZihzaWduYWxET01FdmVudChjbSxcInNjcm9sbEN1cnNvckludG9WaWV3XCIpKXtyZXR1cm47fXZhciBkaXNwbGF5PWNtLmRpc3BsYXksYm94PWRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZG9TY3JvbGw9bnVsbDtpZihjb29yZHMudG9wK2JveC50b3A8MCl7ZG9TY3JvbGw9dHJ1ZTt9ZWxzZSBpZihjb29yZHMuYm90dG9tK2JveC50b3A+KHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpe2RvU2Nyb2xsPWZhbHNlO31pZihkb1Njcm9sbCE9bnVsbCYmIXBoYW50b20pe3ZhciBzY3JvbGxOb2RlPWVsdChcImRpdlwiLFwiXFx1MjAwYlwiLG51bGwsXCJwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCIrKGNvb3Jkcy50b3AtZGlzcGxheS52aWV3T2Zmc2V0LXBhZGRpbmdUb3AoY20uZGlzcGxheSkpK1wicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIrKGNvb3Jkcy5ib3R0b20tY29vcmRzLnRvcCtzY3JvbGxHYXAoY20pK2Rpc3BsYXkuYmFySGVpZ2h0KStcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIitjb29yZHMubGVmdCtcInB4OyB3aWR0aDogMnB4O1wiKTtjbS5kaXNwbGF5LmxpbmVTcGFjZS5hcHBlbmRDaGlsZChzY3JvbGxOb2RlKTtzY3JvbGxOb2RlLnNjcm9sbEludG9WaWV3KGRvU2Nyb2xsKTtjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChzY3JvbGxOb2RlKTt9fS8vIFNjcm9sbCBhIGdpdmVuIHBvc2l0aW9uIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLCB2ZXJpZnlpbmcgdGhhdFxuLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxuLy8gbWVhc3VyZWQsIHRoZSBwb3NpdGlvbiBvZiBzb21ldGhpbmcgbWF5ICdkcmlmdCcgZHVyaW5nIGRyYXdpbmcpLlxuZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20scG9zLGVuZCxtYXJnaW4pe2lmKG1hcmdpbj09bnVsbCl7bWFyZ2luPTA7fXZhciBjb29yZHM7Zm9yKHZhciBsaW1pdD0wO2xpbWl0PDU7bGltaXQrKyl7dmFyIGNoYW5nZWQ9ZmFsc2U7Y29vcmRzPWN1cnNvckNvb3JkcyhjbSxwb3MpO3ZhciBlbmRDb29yZHM9IWVuZHx8ZW5kPT1wb3M/Y29vcmRzOmN1cnNvckNvb3JkcyhjbSxlbmQpO3ZhciBzY3JvbGxQb3M9Y2FsY3VsYXRlU2Nyb2xsUG9zKGNtLE1hdGgubWluKGNvb3Jkcy5sZWZ0LGVuZENvb3Jkcy5sZWZ0KSxNYXRoLm1pbihjb29yZHMudG9wLGVuZENvb3Jkcy50b3ApLW1hcmdpbixNYXRoLm1heChjb29yZHMubGVmdCxlbmRDb29yZHMubGVmdCksTWF0aC5tYXgoY29vcmRzLmJvdHRvbSxlbmRDb29yZHMuYm90dG9tKSttYXJnaW4pO3ZhciBzdGFydFRvcD1jbS5kb2Muc2Nyb2xsVG9wLHN0YXJ0TGVmdD1jbS5kb2Muc2Nyb2xsTGVmdDtpZihzY3JvbGxQb3Muc2Nyb2xsVG9wIT1udWxsKXtzZXRTY3JvbGxUb3AoY20sc2Nyb2xsUG9zLnNjcm9sbFRvcCk7aWYoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcC1zdGFydFRvcCk+MSl7Y2hhbmdlZD10cnVlO319aWYoc2Nyb2xsUG9zLnNjcm9sbExlZnQhPW51bGwpe3NldFNjcm9sbExlZnQoY20sc2Nyb2xsUG9zLnNjcm9sbExlZnQpO2lmKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxMZWZ0LXN0YXJ0TGVmdCk+MSl7Y2hhbmdlZD10cnVlO319aWYoIWNoYW5nZWQpe2JyZWFrO319cmV0dXJuIGNvb3Jkczt9Ly8gU2Nyb2xsIGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLlxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY20seDEseTEseDIseTIpe3ZhciBzY3JvbGxQb3M9Y2FsY3VsYXRlU2Nyb2xsUG9zKGNtLHgxLHkxLHgyLHkyKTtpZihzY3JvbGxQb3Muc2Nyb2xsVG9wIT1udWxsKXtzZXRTY3JvbGxUb3AoY20sc2Nyb2xsUG9zLnNjcm9sbFRvcCk7fWlmKHNjcm9sbFBvcy5zY3JvbGxMZWZ0IT1udWxsKXtzZXRTY3JvbGxMZWZ0KGNtLHNjcm9sbFBvcy5zY3JvbGxMZWZ0KTt9fS8vIENhbGN1bGF0ZSBhIG5ldyBzY3JvbGwgcG9zaXRpb24gbmVlZGVkIHRvIHNjcm9sbCB0aGUgZ2l2ZW5cbi8vIHJlY3RhbmdsZSBpbnRvIHZpZXcuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggc2Nyb2xsVG9wIGFuZFxuLy8gc2Nyb2xsTGVmdCBwcm9wZXJ0aWVzLiBXaGVuIHRoZXNlIGFyZSB1bmRlZmluZWQsIHRoZVxuLy8gdmVydGljYWwvaG9yaXpvbnRhbCBwb3NpdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkanVzdGVkLlxuZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLHgxLHkxLHgyLHkyKXt2YXIgZGlzcGxheT1jbS5kaXNwbGF5LHNuYXBNYXJnaW49dGV4dEhlaWdodChjbS5kaXNwbGF5KTtpZih5MTwwKXt5MT0wO312YXIgc2NyZWVudG9wPWNtLmN1ck9wJiZjbS5jdXJPcC5zY3JvbGxUb3AhPW51bGw/Y20uY3VyT3Auc2Nyb2xsVG9wOmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO3ZhciBzY3JlZW49ZGlzcGxheUhlaWdodChjbSkscmVzdWx0PXt9O2lmKHkyLXkxPnNjcmVlbil7eTI9eTErc2NyZWVuO312YXIgZG9jQm90dG9tPWNtLmRvYy5oZWlnaHQrcGFkZGluZ1ZlcnQoZGlzcGxheSk7dmFyIGF0VG9wPXkxPHNuYXBNYXJnaW4sYXRCb3R0b209eTI+ZG9jQm90dG9tLXNuYXBNYXJnaW47aWYoeTE8c2NyZWVudG9wKXtyZXN1bHQuc2Nyb2xsVG9wPWF0VG9wPzA6eTE7fWVsc2UgaWYoeTI+c2NyZWVudG9wK3NjcmVlbil7dmFyIG5ld1RvcD1NYXRoLm1pbih5MSwoYXRCb3R0b20/ZG9jQm90dG9tOnkyKS1zY3JlZW4pO2lmKG5ld1RvcCE9c2NyZWVudG9wKXtyZXN1bHQuc2Nyb2xsVG9wPW5ld1RvcDt9fXZhciBzY3JlZW5sZWZ0PWNtLmN1ck9wJiZjbS5jdXJPcC5zY3JvbGxMZWZ0IT1udWxsP2NtLmN1ck9wLnNjcm9sbExlZnQ6ZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0O3ZhciBzY3JlZW53PWRpc3BsYXlXaWR0aChjbSktKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXI/ZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoOjApO3ZhciB0b29XaWRlPXgyLXgxPnNjcmVlbnc7aWYodG9vV2lkZSl7eDI9eDErc2NyZWVudzt9aWYoeDE8MTApe3Jlc3VsdC5zY3JvbGxMZWZ0PTA7fWVsc2UgaWYoeDE8c2NyZWVubGVmdCl7cmVzdWx0LnNjcm9sbExlZnQ9TWF0aC5tYXgoMCx4MS0odG9vV2lkZT8wOjEwKSk7fWVsc2UgaWYoeDI+c2NyZWVudytzY3JlZW5sZWZ0LTMpe3Jlc3VsdC5zY3JvbGxMZWZ0PXgyKyh0b29XaWRlPzA6MTApLXNjcmVlbnc7fXJldHVybiByZXN1bHQ7fS8vIFN0b3JlIGEgcmVsYXRpdmUgYWRqdXN0bWVudCB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50XG4vLyBvcGVyYXRpb24gKHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpbmlzaGVzKS5cbmZ1bmN0aW9uIGFkZFRvU2Nyb2xsUG9zKGNtLGxlZnQsdG9wKXtpZihsZWZ0IT1udWxsfHx0b3AhPW51bGwpe3Jlc29sdmVTY3JvbGxUb1BvcyhjbSk7fWlmKGxlZnQhPW51bGwpe2NtLmN1ck9wLnNjcm9sbExlZnQ9KGNtLmN1ck9wLnNjcm9sbExlZnQ9PW51bGw/Y20uZG9jLnNjcm9sbExlZnQ6Y20uY3VyT3Auc2Nyb2xsTGVmdCkrbGVmdDt9aWYodG9wIT1udWxsKXtjbS5jdXJPcC5zY3JvbGxUb3A9KGNtLmN1ck9wLnNjcm9sbFRvcD09bnVsbD9jbS5kb2Muc2Nyb2xsVG9wOmNtLmN1ck9wLnNjcm9sbFRvcCkrdG9wO319Ly8gTWFrZSBzdXJlIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uIHRoZSBjdXJyZW50IGN1cnNvciBpc1xuLy8gc2hvd24uXG5mdW5jdGlvbiBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKXtyZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO3ZhciBjdXI9Y20uZ2V0Q3Vyc29yKCksZnJvbT1jdXIsdG89Y3VyO2lmKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyl7ZnJvbT1jdXIuY2g/UG9zKGN1ci5saW5lLGN1ci5jaC0xKTpjdXI7dG89UG9zKGN1ci5saW5lLGN1ci5jaCsxKTt9Y20uY3VyT3Auc2Nyb2xsVG9Qb3M9e2Zyb206ZnJvbSx0bzp0byxtYXJnaW46Y20ub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4saXNDdXJzb3I6dHJ1ZX07fS8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxuLy8gc2Nyb2xsIGFjdGlvbiBpcyBhcHBsaWVkIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24sIHRoaXNcbi8vICdzaW11bGF0ZXMnIHNjcm9sbGluZyB0aGF0IHBvc2l0aW9uIGludG8gdmlldyBpbiBhIGNoZWFwIHdheSwgc29cbi8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxuZnVuY3Rpb24gcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKXt2YXIgcmFuZ2U9Y20uY3VyT3Auc2Nyb2xsVG9Qb3M7aWYocmFuZ2Upe2NtLmN1ck9wLnNjcm9sbFRvUG9zPW51bGw7dmFyIGZyb209ZXN0aW1hdGVDb29yZHMoY20scmFuZ2UuZnJvbSksdG89ZXN0aW1hdGVDb29yZHMoY20scmFuZ2UudG8pO3ZhciBzUG9zPWNhbGN1bGF0ZVNjcm9sbFBvcyhjbSxNYXRoLm1pbihmcm9tLmxlZnQsdG8ubGVmdCksTWF0aC5taW4oZnJvbS50b3AsdG8udG9wKS1yYW5nZS5tYXJnaW4sTWF0aC5tYXgoZnJvbS5yaWdodCx0by5yaWdodCksTWF0aC5tYXgoZnJvbS5ib3R0b20sdG8uYm90dG9tKStyYW5nZS5tYXJnaW4pO2NtLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCxzUG9zLnNjcm9sbFRvcCk7fX0vLyBPcGVyYXRpb25zIGFyZSB1c2VkIHRvIHdyYXAgYSBzZXJpZXMgb2YgY2hhbmdlcyB0byB0aGUgZWRpdG9yXG4vLyBzdGF0ZSBpbiBzdWNoIGEgd2F5IHRoYXQgZWFjaCBjaGFuZ2Ugd29uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlXG4vLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxuLy8gZXJyb3ItcHJvbmUpLiBJbnN0ZWFkLCBkaXNwbGF5IHVwZGF0ZXMgYXJlIGJhdGNoZWQgYW5kIHRoZW4gYWxsXG4vLyBjb21iaW5lZCBhbmQgZXhlY3V0ZWQgYXQgb25jZS5cbnZhciBuZXh0T3BJZD0wOy8vIFN0YXJ0IGEgbmV3IG9wZXJhdGlvbi5cbmZ1bmN0aW9uIHN0YXJ0T3BlcmF0aW9uKGNtKXtjbS5jdXJPcD17Y206Y20sdmlld0NoYW5nZWQ6ZmFsc2UsLy8gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGxpbmVzIG1pZ2h0IG5lZWQgdG8gYmUgcmVkcmF3blxuc3RhcnRIZWlnaHQ6Y20uZG9jLmhlaWdodCwvLyBVc2VkIHRvIGRldGVjdCBuZWVkIHRvIHVwZGF0ZSBzY3JvbGxiYXJcbmZvcmNlVXBkYXRlOmZhbHNlLC8vIFVzZWQgdG8gZm9yY2UgYSByZWRyYXdcbnVwZGF0ZUlucHV0Om51bGwsLy8gV2hldGhlciB0byByZXNldCB0aGUgaW5wdXQgdGV4dGFyZWFcbnR5cGluZzpmYWxzZSwvLyBXaGV0aGVyIHRoaXMgcmVzZXQgc2hvdWxkIGJlIGNhcmVmdWwgdG8gbGVhdmUgZXhpc3RpbmcgdGV4dCAoZm9yIGNvbXBvc2l0aW5nKVxuY2hhbmdlT2JqczpudWxsLC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xuY3Vyc29yQWN0aXZpdHlIYW5kbGVyczpudWxsLC8vIFNldCBvZiBoYW5kbGVycyB0byBmaXJlIGN1cnNvckFjdGl2aXR5IG9uXG5jdXJzb3JBY3Rpdml0eUNhbGxlZDowLC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcbnNlbGVjdGlvbkNoYW5nZWQ6ZmFsc2UsLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHJlZHJhd25cbnVwZGF0ZU1heExpbmU6ZmFsc2UsLy8gU2V0IHdoZW4gdGhlIHdpZGVzdCBsaW5lIG5lZWRzIHRvIGJlIGRldGVybWluZWQgYW5ld1xuc2Nyb2xsTGVmdDpudWxsLHNjcm9sbFRvcDpudWxsLC8vIEludGVybWVkaWF0ZSBzY3JvbGwgcG9zaXRpb24sIG5vdCBwdXNoZWQgdG8gRE9NIHlldFxuc2Nyb2xsVG9Qb3M6bnVsbCwvLyBVc2VkIHRvIHNjcm9sbCB0byBhIHNwZWNpZmljIHBvc2l0aW9uXG5mb2N1czpmYWxzZSxpZDorK25leHRPcElkLy8gVW5pcXVlIElEXG59O3B1c2hPcGVyYXRpb24oY20uY3VyT3ApO30vLyBGaW5pc2ggYW4gb3BlcmF0aW9uLCB1cGRhdGluZyB0aGUgZGlzcGxheSBhbmQgc2lnbmFsbGluZyBkZWxheWVkIGV2ZW50c1xuZnVuY3Rpb24gZW5kT3BlcmF0aW9uKGNtKXt2YXIgb3A9Y20uY3VyT3A7ZmluaXNoT3BlcmF0aW9uKG9wLGZ1bmN0aW9uKGdyb3VwKXtmb3IodmFyIGk9MDtpPGdyb3VwLm9wcy5sZW5ndGg7aSsrKXtncm91cC5vcHNbaV0uY20uY3VyT3A9bnVsbDt9ZW5kT3BlcmF0aW9ucyhncm91cCk7fSk7fS8vIFRoZSBET00gdXBkYXRlcyBkb25lIHdoZW4gYW4gb3BlcmF0aW9uIGZpbmlzaGVzIGFyZSBiYXRjaGVkIHNvXG4vLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxuZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCl7dmFyIG9wcz1ncm91cC5vcHM7Zm9yKHZhciBpPTA7aTxvcHMubGVuZ3RoO2krKykvLyBSZWFkIERPTVxue2VuZE9wZXJhdGlvbl9SMShvcHNbaV0pO31mb3IodmFyIGkkMT0wO2kkMTxvcHMubGVuZ3RoO2kkMSsrKS8vIFdyaXRlIERPTSAobWF5YmUpXG57ZW5kT3BlcmF0aW9uX1cxKG9wc1tpJDFdKTt9Zm9yKHZhciBpJDI9MDtpJDI8b3BzLmxlbmd0aDtpJDIrKykvLyBSZWFkIERPTVxue2VuZE9wZXJhdGlvbl9SMihvcHNbaSQyXSk7fWZvcih2YXIgaSQzPTA7aSQzPG9wcy5sZW5ndGg7aSQzKyspLy8gV3JpdGUgRE9NIChtYXliZSlcbntlbmRPcGVyYXRpb25fVzIob3BzW2kkM10pO31mb3IodmFyIGkkND0wO2kkNDxvcHMubGVuZ3RoO2kkNCsrKS8vIFJlYWQgRE9NXG57ZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaSQ0XSk7fX1mdW5jdGlvbiBlbmRPcGVyYXRpb25fUjEob3Ape3ZhciBjbT1vcC5jbSxkaXNwbGF5PWNtLmRpc3BsYXk7bWF5YmVDbGlwU2Nyb2xsYmFycyhjbSk7aWYob3AudXBkYXRlTWF4TGluZSl7ZmluZE1heExpbmUoY20pO31vcC5tdXN0VXBkYXRlPW9wLnZpZXdDaGFuZ2VkfHxvcC5mb3JjZVVwZGF0ZXx8b3Auc2Nyb2xsVG9wIT1udWxsfHxvcC5zY3JvbGxUb1BvcyYmKG9wLnNjcm9sbFRvUG9zLmZyb20ubGluZTxkaXNwbGF5LnZpZXdGcm9tfHxvcC5zY3JvbGxUb1Bvcy50by5saW5lPj1kaXNwbGF5LnZpZXdUbyl8fGRpc3BsYXkubWF4TGluZUNoYW5nZWQmJmNtLm9wdGlvbnMubGluZVdyYXBwaW5nO29wLnVwZGF0ZT1vcC5tdXN0VXBkYXRlJiZuZXcgRGlzcGxheVVwZGF0ZShjbSxvcC5tdXN0VXBkYXRlJiZ7dG9wOm9wLnNjcm9sbFRvcCxlbnN1cmU6b3Auc2Nyb2xsVG9Qb3N9LG9wLmZvcmNlVXBkYXRlKTt9ZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cxKG9wKXtvcC51cGRhdGVkRGlzcGxheT1vcC5tdXN0VXBkYXRlJiZ1cGRhdGVEaXNwbGF5SWZOZWVkZWQob3AuY20sb3AudXBkYXRlKTt9ZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IyKG9wKXt2YXIgY209b3AuY20sZGlzcGxheT1jbS5kaXNwbGF5O2lmKG9wLnVwZGF0ZWREaXNwbGF5KXt1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7fW9wLmJhck1lYXN1cmU9bWVhc3VyZUZvclNjcm9sbGJhcnMoY20pOy8vIElmIHRoZSBtYXggbGluZSBjaGFuZ2VkIHNpbmNlIGl0IHdhcyBsYXN0IG1lYXN1cmVkLCBtZWFzdXJlIGl0LFxuLy8gYW5kIGVuc3VyZSB0aGUgZG9jdW1lbnQncyB3aWR0aCBtYXRjaGVzIGl0LlxuLy8gdXBkYXRlRGlzcGxheV9XMiB3aWxsIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGRvIHRoZSBhY3R1YWwgcmVzaXppbmdcbmlmKGRpc3BsYXkubWF4TGluZUNoYW5nZWQmJiFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyl7b3AuYWRqdXN0V2lkdGhUbz1tZWFzdXJlQ2hhcihjbSxkaXNwbGF5Lm1heExpbmUsZGlzcGxheS5tYXhMaW5lLnRleHQubGVuZ3RoKS5sZWZ0KzM7Y20uZGlzcGxheS5zaXplcldpZHRoPW9wLmFkanVzdFdpZHRoVG87b3AuYmFyTWVhc3VyZS5zY3JvbGxXaWR0aD1NYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCtvcC5hZGp1c3RXaWR0aFRvK3Njcm9sbEdhcChjbSkrY20uZGlzcGxheS5iYXJXaWR0aCk7b3AubWF4U2Nyb2xsTGVmdD1NYXRoLm1heCgwLGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCtvcC5hZGp1c3RXaWR0aFRvLWRpc3BsYXlXaWR0aChjbSkpO31pZihvcC51cGRhdGVkRGlzcGxheXx8b3Auc2VsZWN0aW9uQ2hhbmdlZCl7b3AucHJlcGFyZWRTZWxlY3Rpb249ZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKG9wLmZvY3VzKTt9fWZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMihvcCl7dmFyIGNtPW9wLmNtO2lmKG9wLmFkanVzdFdpZHRoVG8hPW51bGwpe2NtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGg9b3AuYWRqdXN0V2lkdGhUbytcInB4XCI7aWYob3AubWF4U2Nyb2xsTGVmdDxjbS5kb2Muc2Nyb2xsTGVmdCl7c2V0U2Nyb2xsTGVmdChjbSxNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsb3AubWF4U2Nyb2xsTGVmdCksdHJ1ZSk7fWNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQ9ZmFsc2U7fXZhciB0YWtlRm9jdXM9b3AuZm9jdXMmJm9wLmZvY3VzPT1hY3RpdmVFbHQoKSYmKCFkb2N1bWVudC5oYXNGb2N1c3x8ZG9jdW1lbnQuaGFzRm9jdXMoKSk7aWYob3AucHJlcGFyZWRTZWxlY3Rpb24pe2NtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihvcC5wcmVwYXJlZFNlbGVjdGlvbix0YWtlRm9jdXMpO31pZihvcC51cGRhdGVkRGlzcGxheXx8b3Auc3RhcnRIZWlnaHQhPWNtLmRvYy5oZWlnaHQpe3VwZGF0ZVNjcm9sbGJhcnMoY20sb3AuYmFyTWVhc3VyZSk7fWlmKG9wLnVwZGF0ZWREaXNwbGF5KXtzZXREb2N1bWVudEhlaWdodChjbSxvcC5iYXJNZWFzdXJlKTt9aWYob3Auc2VsZWN0aW9uQ2hhbmdlZCl7cmVzdGFydEJsaW5rKGNtKTt9aWYoY20uc3RhdGUuZm9jdXNlZCYmb3AudXBkYXRlSW5wdXQpe2NtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKTt9aWYodGFrZUZvY3VzKXtlbnN1cmVGb2N1cyhvcC5jbSk7fX1mdW5jdGlvbiBlbmRPcGVyYXRpb25fZmluaXNoKG9wKXt2YXIgY209b3AuY20sZGlzcGxheT1jbS5kaXNwbGF5LGRvYz1jbS5kb2M7aWYob3AudXBkYXRlZERpc3BsYXkpe3Bvc3RVcGRhdGVEaXNwbGF5KGNtLG9wLnVwZGF0ZSk7fS8vIEFib3J0IG1vdXNlIHdoZWVsIGRlbHRhIG1lYXN1cmVtZW50LCB3aGVuIHNjcm9sbGluZyBleHBsaWNpdGx5XG5pZihkaXNwbGF5LndoZWVsU3RhcnRYIT1udWxsJiYob3Auc2Nyb2xsVG9wIT1udWxsfHxvcC5zY3JvbGxMZWZ0IT1udWxsfHxvcC5zY3JvbGxUb1Bvcykpe2Rpc3BsYXkud2hlZWxTdGFydFg9ZGlzcGxheS53aGVlbFN0YXJ0WT1udWxsO30vLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxuaWYob3Auc2Nyb2xsVG9wIT1udWxsJiYoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AhPW9wLnNjcm9sbFRvcHx8b3AuZm9yY2VTY3JvbGwpKXtkb2Muc2Nyb2xsVG9wPU1hdGgubWF4KDAsTWF0aC5taW4oZGlzcGxheS5zY3JvbGxlci5zY3JvbGxIZWlnaHQtZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsb3Auc2Nyb2xsVG9wKSk7ZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkb2Muc2Nyb2xsVG9wKTtkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcD1kb2Muc2Nyb2xsVG9wO31pZihvcC5zY3JvbGxMZWZ0IT1udWxsJiYoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0IT1vcC5zY3JvbGxMZWZ0fHxvcC5mb3JjZVNjcm9sbCkpe2RvYy5zY3JvbGxMZWZ0PU1hdGgubWF4KDAsTWF0aC5taW4oZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aC1kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLG9wLnNjcm9sbExlZnQpKTtkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChkb2Muc2Nyb2xsTGVmdCk7ZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0PWRvYy5zY3JvbGxMZWZ0O2FsaWduSG9yaXpvbnRhbGx5KGNtKTt9Ly8gSWYgd2UgbmVlZCB0byBzY3JvbGwgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbnRvIHZpZXcsIGRvIHNvLlxuaWYob3Auc2Nyb2xsVG9Qb3Mpe3ZhciBjb29yZHM9c2Nyb2xsUG9zSW50b1ZpZXcoY20sY2xpcFBvcyhkb2Msb3Auc2Nyb2xsVG9Qb3MuZnJvbSksY2xpcFBvcyhkb2Msb3Auc2Nyb2xsVG9Qb3MudG8pLG9wLnNjcm9sbFRvUG9zLm1hcmdpbik7aWYob3Auc2Nyb2xsVG9Qb3MuaXNDdXJzb3ImJmNtLnN0YXRlLmZvY3VzZWQpe21heWJlU2Nyb2xsV2luZG93KGNtLGNvb3Jkcyk7fX0vLyBGaXJlIGV2ZW50cyBmb3IgbWFya2VycyB0aGF0IGFyZSBoaWRkZW4vdW5pZGRlbiBieSBlZGl0aW5nIG9yXG4vLyB1bmRvaW5nXG52YXIgaGlkZGVuPW9wLm1heWJlSGlkZGVuTWFya2Vycyx1bmhpZGRlbj1vcC5tYXliZVVuaGlkZGVuTWFya2VycztpZihoaWRkZW4pe2Zvcih2YXIgaT0wO2k8aGlkZGVuLmxlbmd0aDsrK2kpe2lmKCFoaWRkZW5baV0ubGluZXMubGVuZ3RoKXtzaWduYWwoaGlkZGVuW2ldLFwiaGlkZVwiKTt9fX1pZih1bmhpZGRlbil7Zm9yKHZhciBpJDE9MDtpJDE8dW5oaWRkZW4ubGVuZ3RoOysraSQxKXtpZih1bmhpZGRlbltpJDFdLmxpbmVzLmxlbmd0aCl7c2lnbmFsKHVuaGlkZGVuW2kkMV0sXCJ1bmhpZGVcIik7fX19aWYoZGlzcGxheS53cmFwcGVyLm9mZnNldEhlaWdodCl7ZG9jLnNjcm9sbFRvcD1jbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDt9Ly8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xuaWYob3AuY2hhbmdlT2Jqcyl7c2lnbmFsKGNtLFwiY2hhbmdlc1wiLGNtLG9wLmNoYW5nZU9ianMpO31pZihvcC51cGRhdGUpe29wLnVwZGF0ZS5maW5pc2goKTt9fS8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uXG5mdW5jdGlvbiBydW5Jbk9wKGNtLGYpe2lmKGNtLmN1ck9wKXtyZXR1cm4gZigpO31zdGFydE9wZXJhdGlvbihjbSk7dHJ5e3JldHVybiBmKCk7fWZpbmFsbHl7ZW5kT3BlcmF0aW9uKGNtKTt9fS8vIFdyYXBzIGEgZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uLiBSZXR1cm5zIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuZnVuY3Rpb24gb3BlcmF0aW9uKGNtLGYpe3JldHVybiBmdW5jdGlvbigpe2lmKGNtLmN1ck9wKXtyZXR1cm4gZi5hcHBseShjbSxhcmd1bWVudHMpO31zdGFydE9wZXJhdGlvbihjbSk7dHJ5e3JldHVybiBmLmFwcGx5KGNtLGFyZ3VtZW50cyk7fWZpbmFsbHl7ZW5kT3BlcmF0aW9uKGNtKTt9fTt9Ly8gVXNlZCB0byBhZGQgbWV0aG9kcyB0byBlZGl0b3IgYW5kIGRvYyBpbnN0YW5jZXMsIHdyYXBwaW5nIHRoZW0gaW5cbi8vIG9wZXJhdGlvbnMuXG5mdW5jdGlvbiBtZXRob2RPcChmKXtyZXR1cm4gZnVuY3Rpb24oKXtpZih0aGlzLmN1ck9wKXtyZXR1cm4gZi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fXN0YXJ0T3BlcmF0aW9uKHRoaXMpO3RyeXtyZXR1cm4gZi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fWZpbmFsbHl7ZW5kT3BlcmF0aW9uKHRoaXMpO319O31mdW5jdGlvbiBkb2NNZXRob2RPcChmKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgY209dGhpcy5jbTtpZighY218fGNtLmN1ck9wKXtyZXR1cm4gZi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7fXN0YXJ0T3BlcmF0aW9uKGNtKTt0cnl7cmV0dXJuIGYuYXBwbHkodGhpcyxhcmd1bWVudHMpO31maW5hbGx5e2VuZE9wZXJhdGlvbihjbSk7fX07fS8vIFVwZGF0ZXMgdGhlIGRpc3BsYXkudmlldyBkYXRhIHN0cnVjdHVyZSBmb3IgYSBnaXZlbiBjaGFuZ2UgdG8gdGhlXG4vLyBkb2N1bWVudC4gRnJvbSBhbmQgdG8gYXJlIGluIHByZS1jaGFuZ2UgY29vcmRpbmF0ZXMuIExlbmRpZmYgaXNcbi8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXG4vLyB1c2VkIGZvciBjaGFuZ2VzIHRoYXQgc3BhbiBtdWx0aXBsZSBsaW5lcywgb3IgY2hhbmdlIHRoZSB3YXlcbi8vIGxpbmVzIGFyZSBkaXZpZGVkIGludG8gdmlzdWFsIGxpbmVzLiByZWdMaW5lQ2hhbmdlIChiZWxvdylcbi8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxuZnVuY3Rpb24gcmVnQ2hhbmdlKGNtLGZyb20sdG8sbGVuZGlmZil7aWYoZnJvbT09bnVsbCl7ZnJvbT1jbS5kb2MuZmlyc3Q7fWlmKHRvPT1udWxsKXt0bz1jbS5kb2MuZmlyc3QrY20uZG9jLnNpemU7fWlmKCFsZW5kaWZmKXtsZW5kaWZmPTA7fXZhciBkaXNwbGF5PWNtLmRpc3BsYXk7aWYobGVuZGlmZiYmdG88ZGlzcGxheS52aWV3VG8mJihkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzPT1udWxsfHxkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzPmZyb20pKXtkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzPWZyb207fWNtLmN1ck9wLnZpZXdDaGFuZ2VkPXRydWU7aWYoZnJvbT49ZGlzcGxheS52aWV3VG8pey8vIENoYW5nZSBhZnRlclxuaWYoc2F3Q29sbGFwc2VkU3BhbnMmJnZpc3VhbExpbmVObyhjbS5kb2MsZnJvbSk8ZGlzcGxheS52aWV3VG8pe3Jlc2V0VmlldyhjbSk7fX1lbHNlIGlmKHRvPD1kaXNwbGF5LnZpZXdGcm9tKXsvLyBDaGFuZ2UgYmVmb3JlXG5pZihzYXdDb2xsYXBzZWRTcGFucyYmdmlzdWFsTGluZUVuZE5vKGNtLmRvYyx0bytsZW5kaWZmKT5kaXNwbGF5LnZpZXdGcm9tKXtyZXNldFZpZXcoY20pO31lbHNle2Rpc3BsYXkudmlld0Zyb20rPWxlbmRpZmY7ZGlzcGxheS52aWV3VG8rPWxlbmRpZmY7fX1lbHNlIGlmKGZyb208PWRpc3BsYXkudmlld0Zyb20mJnRvPj1kaXNwbGF5LnZpZXdUbyl7Ly8gRnVsbCBvdmVybGFwXG5yZXNldFZpZXcoY20pO31lbHNlIGlmKGZyb208PWRpc3BsYXkudmlld0Zyb20pey8vIFRvcCBvdmVybGFwXG52YXIgY3V0PXZpZXdDdXR0aW5nUG9pbnQoY20sdG8sdG8rbGVuZGlmZiwxKTtpZihjdXQpe2Rpc3BsYXkudmlldz1kaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KTtkaXNwbGF5LnZpZXdGcm9tPWN1dC5saW5lTjtkaXNwbGF5LnZpZXdUbys9bGVuZGlmZjt9ZWxzZXtyZXNldFZpZXcoY20pO319ZWxzZSBpZih0bz49ZGlzcGxheS52aWV3VG8pey8vIEJvdHRvbSBvdmVybGFwXG52YXIgY3V0JDE9dmlld0N1dHRpbmdQb2ludChjbSxmcm9tLGZyb20sLTEpO2lmKGN1dCQxKXtkaXNwbGF5LnZpZXc9ZGlzcGxheS52aWV3LnNsaWNlKDAsY3V0JDEuaW5kZXgpO2Rpc3BsYXkudmlld1RvPWN1dCQxLmxpbmVOO31lbHNle3Jlc2V0VmlldyhjbSk7fX1lbHNley8vIEdhcCBpbiB0aGUgbWlkZGxlXG52YXIgY3V0VG9wPXZpZXdDdXR0aW5nUG9pbnQoY20sZnJvbSxmcm9tLC0xKTt2YXIgY3V0Qm90PXZpZXdDdXR0aW5nUG9pbnQoY20sdG8sdG8rbGVuZGlmZiwxKTtpZihjdXRUb3AmJmN1dEJvdCl7ZGlzcGxheS52aWV3PWRpc3BsYXkudmlldy5zbGljZSgwLGN1dFRvcC5pbmRleCkuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLGN1dFRvcC5saW5lTixjdXRCb3QubGluZU4pKS5jb25jYXQoZGlzcGxheS52aWV3LnNsaWNlKGN1dEJvdC5pbmRleCkpO2Rpc3BsYXkudmlld1RvKz1sZW5kaWZmO31lbHNle3Jlc2V0VmlldyhjbSk7fX12YXIgZXh0PWRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtpZihleHQpe2lmKHRvPGV4dC5saW5lTil7ZXh0LmxpbmVOKz1sZW5kaWZmO31lbHNlIGlmKGZyb208ZXh0LmxpbmVOK2V4dC5zaXplKXtkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ9bnVsbDt9fX0vLyBSZWdpc3RlciBhIGNoYW5nZSB0byBhIHNpbmdsZSBsaW5lLiBUeXBlIG11c3QgYmUgb25lIG9mIFwidGV4dFwiLFxuLy8gXCJndXR0ZXJcIiwgXCJjbGFzc1wiLCBcIndpZGdldFwiXG5mdW5jdGlvbiByZWdMaW5lQ2hhbmdlKGNtLGxpbmUsdHlwZSl7Y20uY3VyT3Audmlld0NoYW5nZWQ9dHJ1ZTt2YXIgZGlzcGxheT1jbS5kaXNwbGF5LGV4dD1jbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7aWYoZXh0JiZsaW5lPj1leHQubGluZU4mJmxpbmU8ZXh0LmxpbmVOK2V4dC5zaXplKXtkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ9bnVsbDt9aWYobGluZTxkaXNwbGF5LnZpZXdGcm9tfHxsaW5lPj1kaXNwbGF5LnZpZXdUbyl7cmV0dXJuO312YXIgbGluZVZpZXc9ZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sbGluZSldO2lmKGxpbmVWaWV3Lm5vZGU9PW51bGwpe3JldHVybjt9dmFyIGFycj1saW5lVmlldy5jaGFuZ2VzfHwobGluZVZpZXcuY2hhbmdlcz1bXSk7aWYoaW5kZXhPZihhcnIsdHlwZSk9PS0xKXthcnIucHVzaCh0eXBlKTt9fS8vIENsZWFyIHRoZSB2aWV3LlxuZnVuY3Rpb24gcmVzZXRWaWV3KGNtKXtjbS5kaXNwbGF5LnZpZXdGcm9tPWNtLmRpc3BsYXkudmlld1RvPWNtLmRvYy5maXJzdDtjbS5kaXNwbGF5LnZpZXc9W107Y20uZGlzcGxheS52aWV3T2Zmc2V0PTA7fWZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sb2xkTixuZXdOLGRpcil7dmFyIGluZGV4PWZpbmRWaWV3SW5kZXgoY20sb2xkTiksZGlmZix2aWV3PWNtLmRpc3BsYXkudmlldztpZighc2F3Q29sbGFwc2VkU3BhbnN8fG5ld049PWNtLmRvYy5maXJzdCtjbS5kb2Muc2l6ZSl7cmV0dXJue2luZGV4OmluZGV4LGxpbmVOOm5ld059O312YXIgbj1jbS5kaXNwbGF5LnZpZXdGcm9tO2Zvcih2YXIgaT0wO2k8aW5kZXg7aSsrKXtuKz12aWV3W2ldLnNpemU7fWlmKG4hPW9sZE4pe2lmKGRpcj4wKXtpZihpbmRleD09dmlldy5sZW5ndGgtMSl7cmV0dXJuIG51bGw7fWRpZmY9bit2aWV3W2luZGV4XS5zaXplLW9sZE47aW5kZXgrKzt9ZWxzZXtkaWZmPW4tb2xkTjt9b2xkTis9ZGlmZjtuZXdOKz1kaWZmO313aGlsZSh2aXN1YWxMaW5lTm8oY20uZG9jLG5ld04pIT1uZXdOKXtpZihpbmRleD09KGRpcjwwPzA6dmlldy5sZW5ndGgtMSkpe3JldHVybiBudWxsO31uZXdOKz1kaXIqdmlld1tpbmRleC0oZGlyPDA/MTowKV0uc2l6ZTtpbmRleCs9ZGlyO31yZXR1cm57aW5kZXg6aW5kZXgsbGluZU46bmV3Tn07fS8vIEZvcmNlIHRoZSB2aWV3IHRvIGNvdmVyIGEgZ2l2ZW4gcmFuZ2UsIGFkZGluZyBlbXB0eSB2aWV3IGVsZW1lbnRcbi8vIG9yIGNsaXBwaW5nIG9mZiBleGlzdGluZyBvbmVzIGFzIG5lZWRlZC5cbmZ1bmN0aW9uIGFkanVzdFZpZXcoY20sZnJvbSx0byl7dmFyIGRpc3BsYXk9Y20uZGlzcGxheSx2aWV3PWRpc3BsYXkudmlldztpZih2aWV3Lmxlbmd0aD09MHx8ZnJvbT49ZGlzcGxheS52aWV3VG98fHRvPD1kaXNwbGF5LnZpZXdGcm9tKXtkaXNwbGF5LnZpZXc9YnVpbGRWaWV3QXJyYXkoY20sZnJvbSx0byk7ZGlzcGxheS52aWV3RnJvbT1mcm9tO31lbHNle2lmKGRpc3BsYXkudmlld0Zyb20+ZnJvbSl7ZGlzcGxheS52aWV3PWJ1aWxkVmlld0FycmF5KGNtLGZyb20sZGlzcGxheS52aWV3RnJvbSkuY29uY2F0KGRpc3BsYXkudmlldyk7fWVsc2UgaWYoZGlzcGxheS52aWV3RnJvbTxmcm9tKXtkaXNwbGF5LnZpZXc9ZGlzcGxheS52aWV3LnNsaWNlKGZpbmRWaWV3SW5kZXgoY20sZnJvbSkpO31kaXNwbGF5LnZpZXdGcm9tPWZyb207aWYoZGlzcGxheS52aWV3VG88dG8pe2Rpc3BsYXkudmlldz1kaXNwbGF5LnZpZXcuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLGRpc3BsYXkudmlld1RvLHRvKSk7fWVsc2UgaWYoZGlzcGxheS52aWV3VG8+dG8pe2Rpc3BsYXkudmlldz1kaXNwbGF5LnZpZXcuc2xpY2UoMCxmaW5kVmlld0luZGV4KGNtLHRvKSk7fX1kaXNwbGF5LnZpZXdUbz10bzt9Ly8gQ291bnQgdGhlIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgdmlldyB3aG9zZSBET00gcmVwcmVzZW50YXRpb24gaXNcbi8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXG5mdW5jdGlvbiBjb3VudERpcnR5VmlldyhjbSl7dmFyIHZpZXc9Y20uZGlzcGxheS52aWV3LGRpcnR5PTA7Zm9yKHZhciBpPTA7aTx2aWV3Lmxlbmd0aDtpKyspe3ZhciBsaW5lVmlldz12aWV3W2ldO2lmKCFsaW5lVmlldy5oaWRkZW4mJighbGluZVZpZXcubm9kZXx8bGluZVZpZXcuY2hhbmdlcykpeysrZGlydHk7fX1yZXR1cm4gZGlydHk7fS8vIEhJR0hMSUdIVCBXT1JLRVJcbmZ1bmN0aW9uIHN0YXJ0V29ya2VyKGNtLHRpbWUpe2lmKGNtLmRvYy5tb2RlLnN0YXJ0U3RhdGUmJmNtLmRvYy5mcm9udGllcjxjbS5kaXNwbGF5LnZpZXdUbyl7Y20uc3RhdGUuaGlnaGxpZ2h0LnNldCh0aW1lLGJpbmQoaGlnaGxpZ2h0V29ya2VyLGNtKSk7fX1mdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pe3ZhciBkb2M9Y20uZG9jO2lmKGRvYy5mcm9udGllcjxkb2MuZmlyc3Qpe2RvYy5mcm9udGllcj1kb2MuZmlyc3Q7fWlmKGRvYy5mcm9udGllcj49Y20uZGlzcGxheS52aWV3VG8pe3JldHVybjt9dmFyIGVuZD0rbmV3IERhdGUoKStjbS5vcHRpb25zLndvcmtUaW1lO3ZhciBzdGF0ZT1jb3B5U3RhdGUoZG9jLm1vZGUsZ2V0U3RhdGVCZWZvcmUoY20sZG9jLmZyb250aWVyKSk7dmFyIGNoYW5nZWRMaW5lcz1bXTtkb2MuaXRlcihkb2MuZnJvbnRpZXIsTWF0aC5taW4oZG9jLmZpcnN0K2RvYy5zaXplLGNtLmRpc3BsYXkudmlld1RvKzUwMCksZnVuY3Rpb24obGluZSl7aWYoZG9jLmZyb250aWVyPj1jbS5kaXNwbGF5LnZpZXdGcm9tKXsvLyBWaXNpYmxlXG52YXIgb2xkU3R5bGVzPWxpbmUuc3R5bGVzLHRvb0xvbmc9bGluZS50ZXh0Lmxlbmd0aD5jbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aDt2YXIgaGlnaGxpZ2h0ZWQ9aGlnaGxpZ2h0TGluZShjbSxsaW5lLHRvb0xvbmc/Y29weVN0YXRlKGRvYy5tb2RlLHN0YXRlKTpzdGF0ZSx0cnVlKTtsaW5lLnN0eWxlcz1oaWdobGlnaHRlZC5zdHlsZXM7dmFyIG9sZENscz1saW5lLnN0eWxlQ2xhc3NlcyxuZXdDbHM9aGlnaGxpZ2h0ZWQuY2xhc3NlcztpZihuZXdDbHMpe2xpbmUuc3R5bGVDbGFzc2VzPW5ld0Nsczt9ZWxzZSBpZihvbGRDbHMpe2xpbmUuc3R5bGVDbGFzc2VzPW51bGw7fXZhciBpc2NoYW5nZT0hb2xkU3R5bGVzfHxvbGRTdHlsZXMubGVuZ3RoIT1saW5lLnN0eWxlcy5sZW5ndGh8fG9sZENscyE9bmV3Q2xzJiYoIW9sZENsc3x8IW5ld0Nsc3x8b2xkQ2xzLmJnQ2xhc3MhPW5ld0Nscy5iZ0NsYXNzfHxvbGRDbHMudGV4dENsYXNzIT1uZXdDbHMudGV4dENsYXNzKTtmb3IodmFyIGk9MDshaXNjaGFuZ2UmJmk8b2xkU3R5bGVzLmxlbmd0aDsrK2kpe2lzY2hhbmdlPW9sZFN0eWxlc1tpXSE9bGluZS5zdHlsZXNbaV07fWlmKGlzY2hhbmdlKXtjaGFuZ2VkTGluZXMucHVzaChkb2MuZnJvbnRpZXIpO31saW5lLnN0YXRlQWZ0ZXI9dG9vTG9uZz9zdGF0ZTpjb3B5U3RhdGUoZG9jLm1vZGUsc3RhdGUpO31lbHNle2lmKGxpbmUudGV4dC5sZW5ndGg8PWNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKXtwcm9jZXNzTGluZShjbSxsaW5lLnRleHQsc3RhdGUpO31saW5lLnN0YXRlQWZ0ZXI9ZG9jLmZyb250aWVyJTU9PTA/Y29weVN0YXRlKGRvYy5tb2RlLHN0YXRlKTpudWxsO30rK2RvYy5mcm9udGllcjtpZigrbmV3IERhdGUoKT5lbmQpe3N0YXJ0V29ya2VyKGNtLGNtLm9wdGlvbnMud29ya0RlbGF5KTtyZXR1cm4gdHJ1ZTt9fSk7aWYoY2hhbmdlZExpbmVzLmxlbmd0aCl7cnVuSW5PcChjbSxmdW5jdGlvbigpe2Zvcih2YXIgaT0wO2k8Y2hhbmdlZExpbmVzLmxlbmd0aDtpKyspe3JlZ0xpbmVDaGFuZ2UoY20sY2hhbmdlZExpbmVzW2ldLFwidGV4dFwiKTt9fSk7fX0vLyBESVNQTEFZIERSQVdJTkdcbmZ1bmN0aW9uIERpc3BsYXlVcGRhdGUoY20sdmlld3BvcnQsZm9yY2Upe3ZhciBkaXNwbGF5PWNtLmRpc3BsYXk7dGhpcy52aWV3cG9ydD12aWV3cG9ydDsvLyBTdG9yZSBzb21lIHZhbHVlcyB0aGF0IHdlJ2xsIG5lZWQgbGF0ZXIgKGJ1dCBkb24ndCB3YW50IHRvIGZvcmNlIGEgcmVsYXlvdXQgZm9yKVxudGhpcy52aXNpYmxlPXZpc2libGVMaW5lcyhkaXNwbGF5LGNtLmRvYyx2aWV3cG9ydCk7dGhpcy5lZGl0b3JJc0hpZGRlbj0hZGlzcGxheS53cmFwcGVyLm9mZnNldFdpZHRoO3RoaXMud3JhcHBlckhlaWdodD1kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O3RoaXMud3JhcHBlcldpZHRoPWRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDt0aGlzLm9sZERpc3BsYXlXaWR0aD1kaXNwbGF5V2lkdGgoY20pO3RoaXMuZm9yY2U9Zm9yY2U7dGhpcy5kaW1zPWdldERpbWVuc2lvbnMoY20pO3RoaXMuZXZlbnRzPVtdO31EaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5zaWduYWw9ZnVuY3Rpb24oZW1pdHRlcix0eXBlKXtpZihoYXNIYW5kbGVyKGVtaXR0ZXIsdHlwZSkpe3RoaXMuZXZlbnRzLnB1c2goYXJndW1lbnRzKTt9fTtEaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXt2YXIgdGhpcyQxPXRoaXM7Zm9yKHZhciBpPTA7aTx0aGlzLmV2ZW50cy5sZW5ndGg7aSsrKXtzaWduYWwuYXBwbHkobnVsbCx0aGlzJDEuZXZlbnRzW2ldKTt9fTtmdW5jdGlvbiBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKXt2YXIgZGlzcGxheT1jbS5kaXNwbGF5O2lmKCFkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkJiZkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoKXtkaXNwbGF5Lm5hdGl2ZUJhcldpZHRoPWRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGgtZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aDtkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQ9c2Nyb2xsR2FwKGNtKStcInB4XCI7ZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5Cb3R0b209LWRpc3BsYXkubmF0aXZlQmFyV2lkdGgrXCJweFwiO2Rpc3BsYXkuc2l6ZXIuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aD1zY3JvbGxHYXAoY20pK1wicHhcIjtkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkPXRydWU7fX0vLyBEb2VzIHRoZSBhY3R1YWwgdXBkYXRpbmcgb2YgdGhlIGxpbmUgZGlzcGxheS4gQmFpbHMgb3V0XG4vLyAocmV0dXJuaW5nIGZhbHNlKSB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gYmUgZG9uZSBhbmQgZm9yY2VkIGlzXG4vLyBmYWxzZS5cbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSx1cGRhdGUpe3ZhciBkaXNwbGF5PWNtLmRpc3BsYXksZG9jPWNtLmRvYztpZih1cGRhdGUuZWRpdG9ySXNIaWRkZW4pe3Jlc2V0VmlldyhjbSk7cmV0dXJuIGZhbHNlO30vLyBCYWlsIG91dCBpZiB0aGUgdmlzaWJsZSBhcmVhIGlzIGFscmVhZHkgcmVuZGVyZWQgYW5kIG5vdGhpbmcgY2hhbmdlZC5cbmlmKCF1cGRhdGUuZm9yY2UmJnVwZGF0ZS52aXNpYmxlLmZyb20+PWRpc3BsYXkudmlld0Zyb20mJnVwZGF0ZS52aXNpYmxlLnRvPD1kaXNwbGF5LnZpZXdUbyYmKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnM9PW51bGx8fGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnM+PWRpc3BsYXkudmlld1RvKSYmZGlzcGxheS5yZW5kZXJlZFZpZXc9PWRpc3BsYXkudmlldyYmY291bnREaXJ0eVZpZXcoY20pPT0wKXtyZXR1cm4gZmFsc2U7fWlmKG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSl7cmVzZXRWaWV3KGNtKTt1cGRhdGUuZGltcz1nZXREaW1lbnNpb25zKGNtKTt9Ly8gQ29tcHV0ZSBhIHN1aXRhYmxlIG5ldyB2aWV3cG9ydCAoZnJvbSAmIHRvKVxudmFyIGVuZD1kb2MuZmlyc3QrZG9jLnNpemU7dmFyIGZyb209TWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbS1jbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLGRvYy5maXJzdCk7dmFyIHRvPU1hdGgubWluKGVuZCx1cGRhdGUudmlzaWJsZS50bytjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKTtpZihkaXNwbGF5LnZpZXdGcm9tPGZyb20mJmZyb20tZGlzcGxheS52aWV3RnJvbTwyMCl7ZnJvbT1NYXRoLm1heChkb2MuZmlyc3QsZGlzcGxheS52aWV3RnJvbSk7fWlmKGRpc3BsYXkudmlld1RvPnRvJiZkaXNwbGF5LnZpZXdUby10bzwyMCl7dG89TWF0aC5taW4oZW5kLGRpc3BsYXkudmlld1RvKTt9aWYoc2F3Q29sbGFwc2VkU3BhbnMpe2Zyb209dmlzdWFsTGluZU5vKGNtLmRvYyxmcm9tKTt0bz12aXN1YWxMaW5lRW5kTm8oY20uZG9jLHRvKTt9dmFyIGRpZmZlcmVudD1mcm9tIT1kaXNwbGF5LnZpZXdGcm9tfHx0byE9ZGlzcGxheS52aWV3VG98fGRpc3BsYXkubGFzdFdyYXBIZWlnaHQhPXVwZGF0ZS53cmFwcGVySGVpZ2h0fHxkaXNwbGF5Lmxhc3RXcmFwV2lkdGghPXVwZGF0ZS53cmFwcGVyV2lkdGg7YWRqdXN0VmlldyhjbSxmcm9tLHRvKTtkaXNwbGF5LnZpZXdPZmZzZXQ9aGVpZ2h0QXRMaW5lKGdldExpbmUoY20uZG9jLGRpc3BsYXkudmlld0Zyb20pKTsvLyBQb3NpdGlvbiB0aGUgbW92ZXIgZGl2IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG5jbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcD1kaXNwbGF5LnZpZXdPZmZzZXQrXCJweFwiO3ZhciB0b1VwZGF0ZT1jb3VudERpcnR5VmlldyhjbSk7aWYoIWRpZmZlcmVudCYmdG9VcGRhdGU9PTAmJiF1cGRhdGUuZm9yY2UmJmRpc3BsYXkucmVuZGVyZWRWaWV3PT1kaXNwbGF5LnZpZXcmJihkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzPT1udWxsfHxkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzPj1kaXNwbGF5LnZpZXdUbykpe3JldHVybiBmYWxzZTt9Ly8gRm9yIGJpZyBjaGFuZ2VzLCB3ZSBoaWRlIHRoZSBlbmNsb3NpbmcgZWxlbWVudCBkdXJpbmcgdGhlXG4vLyB1cGRhdGUsIHNpbmNlIHRoYXQgc3BlZWRzIHVwIHRoZSBvcGVyYXRpb25zIG9uIG1vc3QgYnJvd3NlcnMuXG52YXIgZm9jdXNlZD1hY3RpdmVFbHQoKTtpZih0b1VwZGF0ZT40KXtkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjt9cGF0Y2hEaXNwbGF5KGNtLGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMsdXBkYXRlLmRpbXMpO2lmKHRvVXBkYXRlPjQpe2Rpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5PVwiXCI7fWRpc3BsYXkucmVuZGVyZWRWaWV3PWRpc3BsYXkudmlldzsvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxuLy8gaGlkZGVuIG9yIHVwZGF0ZWQsIGlmIHNvIHJlLWZvY3VzIGl0LlxuaWYoZm9jdXNlZCYmYWN0aXZlRWx0KCkhPWZvY3VzZWQmJmZvY3VzZWQub2Zmc2V0SGVpZ2h0KXtmb2N1c2VkLmZvY3VzKCk7fS8vIFByZXZlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCB0aGUgc2Nyb2xsXG4vLyB3aWR0aCBhbmQgaGVpZ2h0LlxucmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5jdXJzb3JEaXYpO3JlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KTtkaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0PWRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0PTA7aWYoZGlmZmVyZW50KXtkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0PXVwZGF0ZS53cmFwcGVySGVpZ2h0O2Rpc3BsYXkubGFzdFdyYXBXaWR0aD11cGRhdGUud3JhcHBlcldpZHRoO3N0YXJ0V29ya2VyKGNtLDQwMCk7fWRpc3BsYXkudXBkYXRlTGluZU51bWJlcnM9bnVsbDtyZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gcG9zdFVwZGF0ZURpc3BsYXkoY20sdXBkYXRlKXt2YXIgdmlld3BvcnQ9dXBkYXRlLnZpZXdwb3J0O2Zvcih2YXIgZmlyc3Q9dHJ1ZTs7Zmlyc3Q9ZmFsc2Upe2lmKCFmaXJzdHx8IWNtLm9wdGlvbnMubGluZVdyYXBwaW5nfHx1cGRhdGUub2xkRGlzcGxheVdpZHRoPT1kaXNwbGF5V2lkdGgoY20pKXsvLyBDbGlwIGZvcmNlZCB2aWV3cG9ydCB0byBhY3R1YWwgc2Nyb2xsYWJsZSBhcmVhLlxuaWYodmlld3BvcnQmJnZpZXdwb3J0LnRvcCE9bnVsbCl7dmlld3BvcnQ9e3RvcDpNYXRoLm1pbihjbS5kb2MuaGVpZ2h0K3BhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpLWRpc3BsYXlIZWlnaHQoY20pLHZpZXdwb3J0LnRvcCl9O30vLyBVcGRhdGVkIGxpbmUgaGVpZ2h0cyBtaWdodCByZXN1bHQgaW4gdGhlIGRyYXduIGFyZWEgbm90XG4vLyBhY3R1YWxseSBjb3ZlcmluZyB0aGUgdmlld3BvcnQuIEtlZXAgbG9vcGluZyB1bnRpbCBpdCBkb2VzLlxudXBkYXRlLnZpc2libGU9dmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksY20uZG9jLHZpZXdwb3J0KTtpZih1cGRhdGUudmlzaWJsZS5mcm9tPj1jbS5kaXNwbGF5LnZpZXdGcm9tJiZ1cGRhdGUudmlzaWJsZS50bzw9Y20uZGlzcGxheS52aWV3VG8pe2JyZWFrO319aWYoIXVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSx1cGRhdGUpKXticmVhazt9dXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO3ZhciBiYXJNZWFzdXJlPW1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTt1cGRhdGVTZWxlY3Rpb24oY20pO3VwZGF0ZVNjcm9sbGJhcnMoY20sYmFyTWVhc3VyZSk7c2V0RG9jdW1lbnRIZWlnaHQoY20sYmFyTWVhc3VyZSk7fXVwZGF0ZS5zaWduYWwoY20sXCJ1cGRhdGVcIixjbSk7aWYoY20uZGlzcGxheS52aWV3RnJvbSE9Y20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tfHxjbS5kaXNwbGF5LnZpZXdUbyE9Y20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbyl7dXBkYXRlLnNpZ25hbChjbSxcInZpZXdwb3J0Q2hhbmdlXCIsY20sY20uZGlzcGxheS52aWV3RnJvbSxjbS5kaXNwbGF5LnZpZXdUbyk7Y20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tPWNtLmRpc3BsYXkudmlld0Zyb207Y20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbz1jbS5kaXNwbGF5LnZpZXdUbzt9fWZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sdmlld3BvcnQpe3ZhciB1cGRhdGU9bmV3IERpc3BsYXlVcGRhdGUoY20sdmlld3BvcnQpO2lmKHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSx1cGRhdGUpKXt1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7cG9zdFVwZGF0ZURpc3BsYXkoY20sdXBkYXRlKTt2YXIgYmFyTWVhc3VyZT1tZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7dXBkYXRlU2VsZWN0aW9uKGNtKTt1cGRhdGVTY3JvbGxiYXJzKGNtLGJhck1lYXN1cmUpO3NldERvY3VtZW50SGVpZ2h0KGNtLGJhck1lYXN1cmUpO3VwZGF0ZS5maW5pc2goKTt9fS8vIFN5bmMgdGhlIGFjdHVhbCBkaXNwbGF5IERPTSBzdHJ1Y3R1cmUgd2l0aCBkaXNwbGF5LnZpZXcsIHJlbW92aW5nXG4vLyBub2RlcyBmb3IgbGluZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHZpZXcsIGFuZCBjcmVhdGluZyB0aGUgb25lc1xuLy8gdGhhdCBhcmUgbm90IHRoZXJlIHlldCwgYW5kIHVwZGF0aW5nIHRoZSBvbmVzIHRoYXQgYXJlIG91dCBvZlxuLy8gZGF0ZS5cbmZ1bmN0aW9uIHBhdGNoRGlzcGxheShjbSx1cGRhdGVOdW1iZXJzRnJvbSxkaW1zKXt2YXIgZGlzcGxheT1jbS5kaXNwbGF5LGxpbmVOdW1iZXJzPWNtLm9wdGlvbnMubGluZU51bWJlcnM7dmFyIGNvbnRhaW5lcj1kaXNwbGF5LmxpbmVEaXYsY3VyPWNvbnRhaW5lci5maXJzdENoaWxkO2Z1bmN0aW9uIHJtKG5vZGUpe3ZhciBuZXh0PW5vZGUubmV4dFNpYmxpbmc7Ly8gV29ya3MgYXJvdW5kIGEgdGhyb3ctc2Nyb2xsIGJ1ZyBpbiBPUyBYIFdlYmtpdFxuaWYod2Via2l0JiZtYWMmJmNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0PT1ub2RlKXtub2RlLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7fWVsc2V7bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO31yZXR1cm4gbmV4dDt9dmFyIHZpZXc9ZGlzcGxheS52aWV3LGxpbmVOPWRpc3BsYXkudmlld0Zyb207Ly8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcbi8vIGluIGRpc3BsYXkubGluZURpdikgd2l0aCB0aGUgdmlldyBhcyB3ZSBnby5cbmZvcih2YXIgaT0wO2k8dmlldy5sZW5ndGg7aSsrKXt2YXIgbGluZVZpZXc9dmlld1tpXTtpZihsaW5lVmlldy5oaWRkZW4pe31lbHNlIGlmKCFsaW5lVmlldy5ub2RlfHxsaW5lVmlldy5ub2RlLnBhcmVudE5vZGUhPWNvbnRhaW5lcil7Ly8gTm90IGRyYXduIHlldFxudmFyIG5vZGU9YnVpbGRMaW5lRWxlbWVudChjbSxsaW5lVmlldyxsaW5lTixkaW1zKTtjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsY3VyKTt9ZWxzZXsvLyBBbHJlYWR5IGRyYXduXG53aGlsZShjdXIhPWxpbmVWaWV3Lm5vZGUpe2N1cj1ybShjdXIpO312YXIgdXBkYXRlTnVtYmVyPWxpbmVOdW1iZXJzJiZ1cGRhdGVOdW1iZXJzRnJvbSE9bnVsbCYmdXBkYXRlTnVtYmVyc0Zyb208PWxpbmVOJiZsaW5lVmlldy5saW5lTnVtYmVyO2lmKGxpbmVWaWV3LmNoYW5nZXMpe2lmKGluZGV4T2YobGluZVZpZXcuY2hhbmdlcyxcImd1dHRlclwiKT4tMSl7dXBkYXRlTnVtYmVyPWZhbHNlO311cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSxsaW5lVmlldyxsaW5lTixkaW1zKTt9aWYodXBkYXRlTnVtYmVyKXtyZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKTtsaW5lVmlldy5saW5lTnVtYmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucyxsaW5lTikpKTt9Y3VyPWxpbmVWaWV3Lm5vZGUubmV4dFNpYmxpbmc7fWxpbmVOKz1saW5lVmlldy5zaXplO313aGlsZShjdXIpe2N1cj1ybShjdXIpO319ZnVuY3Rpb24gdXBkYXRlR3V0dGVyU3BhY2UoY20pe3ZhciB3aWR0aD1jbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7Y20uZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5MZWZ0PXdpZHRoK1wicHhcIjt9ZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sbWVhc3VyZSl7Y20uZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQ9bWVhc3VyZS5kb2NIZWlnaHQrXCJweFwiO2NtLmRpc3BsYXkuaGVpZ2h0Rm9yY2VyLnN0eWxlLnRvcD1tZWFzdXJlLmRvY0hlaWdodCtcInB4XCI7Y20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodD1tZWFzdXJlLmRvY0hlaWdodCtjbS5kaXNwbGF5LmJhckhlaWdodCtzY3JvbGxHYXAoY20pK1wicHhcIjt9Ly8gUmVidWlsZCB0aGUgZ3V0dGVyIGVsZW1lbnRzLCBlbnN1cmUgdGhlIG1hcmdpbiB0byB0aGUgbGVmdCBvZiB0aGVcbi8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cbmZ1bmN0aW9uIHVwZGF0ZUd1dHRlcnMoY20pe3ZhciBndXR0ZXJzPWNtLmRpc3BsYXkuZ3V0dGVycyxzcGVjcz1jbS5vcHRpb25zLmd1dHRlcnM7cmVtb3ZlQ2hpbGRyZW4oZ3V0dGVycyk7dmFyIGk9MDtmb3IoO2k8c3BlY3MubGVuZ3RoOysraSl7dmFyIGd1dHRlckNsYXNzPXNwZWNzW2ldO3ZhciBnRWx0PWd1dHRlcnMuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsbnVsbCxcIkNvZGVNaXJyb3ItZ3V0dGVyIFwiK2d1dHRlckNsYXNzKSk7aWYoZ3V0dGVyQ2xhc3M9PVwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiKXtjbS5kaXNwbGF5LmxpbmVHdXR0ZXI9Z0VsdDtnRWx0LnN0eWxlLndpZHRoPShjbS5kaXNwbGF5LmxpbmVOdW1XaWR0aHx8MSkrXCJweFwiO319Z3V0dGVycy5zdHlsZS5kaXNwbGF5PWk/XCJcIjpcIm5vbmVcIjt1cGRhdGVHdXR0ZXJTcGFjZShjbSk7fS8vIE1ha2Ugc3VyZSB0aGUgZ3V0dGVycyBvcHRpb25zIGNvbnRhaW5zIHRoZSBlbGVtZW50XG4vLyBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIiB3aGVuIHRoZSBsaW5lTnVtYmVycyBvcHRpb24gaXMgdHJ1ZS5cbmZ1bmN0aW9uIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhvcHRpb25zKXt2YXIgZm91bmQ9aW5kZXhPZihvcHRpb25zLmd1dHRlcnMsXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpO2lmKGZvdW5kPT0tMSYmb3B0aW9ucy5saW5lTnVtYmVycyl7b3B0aW9ucy5ndXR0ZXJzPW9wdGlvbnMuZ3V0dGVycy5jb25jYXQoW1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSk7fWVsc2UgaWYoZm91bmQ+LTEmJiFvcHRpb25zLmxpbmVOdW1iZXJzKXtvcHRpb25zLmd1dHRlcnM9b3B0aW9ucy5ndXR0ZXJzLnNsaWNlKDApO29wdGlvbnMuZ3V0dGVycy5zcGxpY2UoZm91bmQsMSk7fX0vLyBTZWxlY3Rpb24gb2JqZWN0cyBhcmUgaW1tdXRhYmxlLiBBIG5ldyBvbmUgaXMgY3JlYXRlZCBldmVyeSB0aW1lXG4vLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIEEgc2VsZWN0aW9uIGlzIG9uZSBvciBtb3JlIG5vbi1vdmVybGFwcGluZ1xuLy8gKGFuZCBub24tdG91Y2hpbmcpIHJhbmdlcywgc29ydGVkLCBhbmQgYW4gaW50ZWdlciB0aGF0IGluZGljYXRlc1xuLy8gd2hpY2ggb25lIGlzIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiAodGhlIG9uZSB0aGF0J3Mgc2Nyb2xsZWQgaW50b1xuLy8gdmlldywgdGhhdCBnZXRDdXJzb3IgcmV0dXJucywgZXRjKS5cbmZ1bmN0aW9uIFNlbGVjdGlvbihyYW5nZXMscHJpbUluZGV4KXt0aGlzLnJhbmdlcz1yYW5nZXM7dGhpcy5wcmltSW5kZXg9cHJpbUluZGV4O31TZWxlY3Rpb24ucHJvdG90eXBlPXtwcmltYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XTt9LGVxdWFsczpmdW5jdGlvbihvdGhlcil7dmFyIHRoaXMkMT10aGlzO2lmKG90aGVyPT10aGlzKXtyZXR1cm4gdHJ1ZTt9aWYob3RoZXIucHJpbUluZGV4IT10aGlzLnByaW1JbmRleHx8b3RoZXIucmFuZ2VzLmxlbmd0aCE9dGhpcy5yYW5nZXMubGVuZ3RoKXtyZXR1cm4gZmFsc2U7fWZvcih2YXIgaT0wO2k8dGhpcy5yYW5nZXMubGVuZ3RoO2krKyl7dmFyIGhlcmU9dGhpcyQxLnJhbmdlc1tpXSx0aGVyZT1vdGhlci5yYW5nZXNbaV07aWYoY21wKGhlcmUuYW5jaG9yLHRoZXJlLmFuY2hvcikhPTB8fGNtcChoZXJlLmhlYWQsdGhlcmUuaGVhZCkhPTApe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO30sZGVlcENvcHk6ZnVuY3Rpb24oKXt2YXIgdGhpcyQxPXRoaXM7dmFyIG91dD1bXTtmb3IodmFyIGk9MDtpPHRoaXMucmFuZ2VzLmxlbmd0aDtpKyspe291dFtpXT1uZXcgUmFuZ2UoY29weVBvcyh0aGlzJDEucmFuZ2VzW2ldLmFuY2hvciksY29weVBvcyh0aGlzJDEucmFuZ2VzW2ldLmhlYWQpKTt9cmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LHRoaXMucHJpbUluZGV4KTt9LHNvbWV0aGluZ1NlbGVjdGVkOmZ1bmN0aW9uKCl7dmFyIHRoaXMkMT10aGlzO2Zvcih2YXIgaT0wO2k8dGhpcy5yYW5nZXMubGVuZ3RoO2krKyl7aWYoIXRoaXMkMS5yYW5nZXNbaV0uZW1wdHkoKSl7cmV0dXJuIHRydWU7fX1yZXR1cm4gZmFsc2U7fSxjb250YWluczpmdW5jdGlvbihwb3MsZW5kKXt2YXIgdGhpcyQxPXRoaXM7aWYoIWVuZCl7ZW5kPXBvczt9Zm9yKHZhciBpPTA7aTx0aGlzLnJhbmdlcy5sZW5ndGg7aSsrKXt2YXIgcmFuZ2U9dGhpcyQxLnJhbmdlc1tpXTtpZihjbXAoZW5kLHJhbmdlLmZyb20oKSk+PTAmJmNtcChwb3MscmFuZ2UudG8oKSk8PTApe3JldHVybiBpO319cmV0dXJuLTE7fX07ZnVuY3Rpb24gUmFuZ2UoYW5jaG9yLGhlYWQpe3RoaXMuYW5jaG9yPWFuY2hvcjt0aGlzLmhlYWQ9aGVhZDt9UmFuZ2UucHJvdG90eXBlPXtmcm9tOmZ1bmN0aW9uKCl7cmV0dXJuIG1pblBvcyh0aGlzLmFuY2hvcix0aGlzLmhlYWQpO30sdG86ZnVuY3Rpb24oKXtyZXR1cm4gbWF4UG9zKHRoaXMuYW5jaG9yLHRoaXMuaGVhZCk7fSxlbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQubGluZT09dGhpcy5hbmNob3IubGluZSYmdGhpcy5oZWFkLmNoPT10aGlzLmFuY2hvci5jaDt9fTsvLyBUYWtlIGFuIHVuc29ydGVkLCBwb3RlbnRpYWxseSBvdmVybGFwcGluZyBzZXQgb2YgcmFuZ2VzLCBhbmRcbi8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xuLy8gaXQpLlxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcyxwcmltSW5kZXgpe3ZhciBwcmltPXJhbmdlc1twcmltSW5kZXhdO3Jhbmdlcy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGNtcChhLmZyb20oKSxiLmZyb20oKSk7fSk7cHJpbUluZGV4PWluZGV4T2YocmFuZ2VzLHByaW0pO2Zvcih2YXIgaT0xO2k8cmFuZ2VzLmxlbmd0aDtpKyspe3ZhciBjdXI9cmFuZ2VzW2ldLHByZXY9cmFuZ2VzW2ktMV07aWYoY21wKHByZXYudG8oKSxjdXIuZnJvbSgpKT49MCl7dmFyIGZyb209bWluUG9zKHByZXYuZnJvbSgpLGN1ci5mcm9tKCkpLHRvPW1heFBvcyhwcmV2LnRvKCksY3VyLnRvKCkpO3ZhciBpbnY9cHJldi5lbXB0eSgpP2N1ci5mcm9tKCk9PWN1ci5oZWFkOnByZXYuZnJvbSgpPT1wcmV2LmhlYWQ7aWYoaTw9cHJpbUluZGV4KXstLXByaW1JbmRleDt9cmFuZ2VzLnNwbGljZSgtLWksMixuZXcgUmFuZ2UoaW52P3RvOmZyb20saW52P2Zyb206dG8pKTt9fXJldHVybiBuZXcgU2VsZWN0aW9uKHJhbmdlcyxwcmltSW5kZXgpO31mdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLGhlYWQpe3JldHVybiBuZXcgU2VsZWN0aW9uKFtuZXcgUmFuZ2UoYW5jaG9yLGhlYWR8fGFuY2hvcildLDApO30vLyBDb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIGEgY2hhbmdlIChpdHMgJ3RvJyBwcm9wZXJ0eVxuLy8gcmVmZXJzIHRvIHRoZSBwcmUtY2hhbmdlIGVuZCkuXG5mdW5jdGlvbiBjaGFuZ2VFbmQoY2hhbmdlKXtpZighY2hhbmdlLnRleHQpe3JldHVybiBjaGFuZ2UudG87fXJldHVybiBQb3MoY2hhbmdlLmZyb20ubGluZStjaGFuZ2UudGV4dC5sZW5ndGgtMSxsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCsoY2hhbmdlLnRleHQubGVuZ3RoPT0xP2NoYW5nZS5mcm9tLmNoOjApKTt9Ly8gQWRqdXN0IGEgcG9zaXRpb24gdG8gcmVmZXIgdG8gdGhlIHBvc3QtY2hhbmdlIHBvc2l0aW9uIG9mIHRoZVxuLy8gc2FtZSB0ZXh0LCBvciB0aGUgZW5kIG9mIHRoZSBjaGFuZ2UgaWYgdGhlIGNoYW5nZSBjb3ZlcnMgaXQuXG5mdW5jdGlvbiBhZGp1c3RGb3JDaGFuZ2UocG9zLGNoYW5nZSl7aWYoY21wKHBvcyxjaGFuZ2UuZnJvbSk8MCl7cmV0dXJuIHBvczt9aWYoY21wKHBvcyxjaGFuZ2UudG8pPD0wKXtyZXR1cm4gY2hhbmdlRW5kKGNoYW5nZSk7fXZhciBsaW5lPXBvcy5saW5lK2NoYW5nZS50ZXh0Lmxlbmd0aC0oY2hhbmdlLnRvLmxpbmUtY2hhbmdlLmZyb20ubGluZSktMSxjaD1wb3MuY2g7aWYocG9zLmxpbmU9PWNoYW5nZS50by5saW5lKXtjaCs9Y2hhbmdlRW5kKGNoYW5nZSkuY2gtY2hhbmdlLnRvLmNoO31yZXR1cm4gUG9zKGxpbmUsY2gpO31mdW5jdGlvbiBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLGNoYW5nZSl7dmFyIG91dD1bXTtmb3IodmFyIGk9MDtpPGRvYy5zZWwucmFuZ2VzLmxlbmd0aDtpKyspe3ZhciByYW5nZT1kb2Muc2VsLnJhbmdlc1tpXTtvdXQucHVzaChuZXcgUmFuZ2UoYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmFuY2hvcixjaGFuZ2UpLGFkanVzdEZvckNoYW5nZShyYW5nZS5oZWFkLGNoYW5nZSkpKTt9cmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsZG9jLnNlbC5wcmltSW5kZXgpO31mdW5jdGlvbiBvZmZzZXRQb3MocG9zLG9sZCxudyl7aWYocG9zLmxpbmU9PW9sZC5saW5lKXtyZXR1cm4gUG9zKG53LmxpbmUscG9zLmNoLW9sZC5jaCtudy5jaCk7fWVsc2V7cmV0dXJuIFBvcyhudy5saW5lKyhwb3MubGluZS1vbGQubGluZSkscG9zLmNoKTt9fS8vIFVzZWQgYnkgcmVwbGFjZVNlbGVjdGlvbnMgdG8gYWxsb3cgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG8gdGhlXG4vLyBzdGFydCBvciBhcm91bmQgdGhlIHJlcGxhY2VkIHRlc3QuIEhpbnQgbWF5IGJlIFwic3RhcnRcIiBvciBcImFyb3VuZFwiLlxuZnVuY3Rpb24gY29tcHV0ZVJlcGxhY2VkU2VsKGRvYyxjaGFuZ2VzLGhpbnQpe3ZhciBvdXQ9W107dmFyIG9sZFByZXY9UG9zKGRvYy5maXJzdCwwKSxuZXdQcmV2PW9sZFByZXY7Zm9yKHZhciBpPTA7aTxjaGFuZ2VzLmxlbmd0aDtpKyspe3ZhciBjaGFuZ2U9Y2hhbmdlc1tpXTt2YXIgZnJvbT1vZmZzZXRQb3MoY2hhbmdlLmZyb20sb2xkUHJldixuZXdQcmV2KTt2YXIgdG89b2Zmc2V0UG9zKGNoYW5nZUVuZChjaGFuZ2UpLG9sZFByZXYsbmV3UHJldik7b2xkUHJldj1jaGFuZ2UudG87bmV3UHJldj10bztpZihoaW50PT1cImFyb3VuZFwiKXt2YXIgcmFuZ2U9ZG9jLnNlbC5yYW5nZXNbaV0saW52PWNtcChyYW5nZS5oZWFkLHJhbmdlLmFuY2hvcik8MDtvdXRbaV09bmV3IFJhbmdlKGludj90bzpmcm9tLGludj9mcm9tOnRvKTt9ZWxzZXtvdXRbaV09bmV3IFJhbmdlKGZyb20sZnJvbSk7fX1yZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsZG9jLnNlbC5wcmltSW5kZXgpO30vLyBVc2VkIHRvIGdldCB0aGUgZWRpdG9yIGludG8gYSBjb25zaXN0ZW50IHN0YXRlIGFnYWluIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG5mdW5jdGlvbiBsb2FkTW9kZShjbSl7Y20uZG9jLm1vZGU9Z2V0TW9kZShjbS5vcHRpb25zLGNtLmRvYy5tb2RlT3B0aW9uKTtyZXNldE1vZGVTdGF0ZShjbSk7fWZ1bmN0aW9uIHJlc2V0TW9kZVN0YXRlKGNtKXtjbS5kb2MuaXRlcihmdW5jdGlvbihsaW5lKXtpZihsaW5lLnN0YXRlQWZ0ZXIpe2xpbmUuc3RhdGVBZnRlcj1udWxsO31pZihsaW5lLnN0eWxlcyl7bGluZS5zdHlsZXM9bnVsbDt9fSk7Y20uZG9jLmZyb250aWVyPWNtLmRvYy5maXJzdDtzdGFydFdvcmtlcihjbSwxMDApO2NtLnN0YXRlLm1vZGVHZW4rKztpZihjbS5jdXJPcCl7cmVnQ2hhbmdlKGNtKTt9fS8vIERPQ1VNRU5UIERBVEEgU1RSVUNUVVJFXG4vLyBCeSBkZWZhdWx0LCB1cGRhdGVzIHRoYXQgc3RhcnQgYW5kIGVuZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZVxuLy8gYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBpbiBvcmRlciB0byBtYWtlIHRoZSBhc3NvY2lhdGlvbiBvZiBsaW5lXG4vLyB3aWRnZXRzIGFuZCBtYXJrZXIgZWxlbWVudHMgd2l0aCB0aGUgdGV4dCBiZWhhdmUgbW9yZSBpbnR1aXRpdmUuXG5mdW5jdGlvbiBpc1dob2xlTGluZVVwZGF0ZShkb2MsY2hhbmdlKXtyZXR1cm4gY2hhbmdlLmZyb20uY2g9PTAmJmNoYW5nZS50by5jaD09MCYmbHN0KGNoYW5nZS50ZXh0KT09XCJcIiYmKCFkb2MuY218fGRvYy5jbS5vcHRpb25zLndob2xlTGluZVVwZGF0ZUJlZm9yZSk7fS8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxuZnVuY3Rpb24gdXBkYXRlRG9jKGRvYyxjaGFuZ2UsbWFya2VkU3BhbnMsZXN0aW1hdGVIZWlnaHQpe2Z1bmN0aW9uIHNwYW5zRm9yKG4pe3JldHVybiBtYXJrZWRTcGFucz9tYXJrZWRTcGFuc1tuXTpudWxsO31mdW5jdGlvbiB1cGRhdGUobGluZSx0ZXh0LHNwYW5zKXt1cGRhdGVMaW5lKGxpbmUsdGV4dCxzcGFucyxlc3RpbWF0ZUhlaWdodCk7c2lnbmFsTGF0ZXIobGluZSxcImNoYW5nZVwiLGxpbmUsY2hhbmdlKTt9ZnVuY3Rpb24gbGluZXNGb3Ioc3RhcnQsZW5kKXt2YXIgcmVzdWx0PVtdO2Zvcih2YXIgaT1zdGFydDtpPGVuZDsrK2kpe3Jlc3VsdC5wdXNoKG5ldyBMaW5lKHRleHRbaV0sc3BhbnNGb3IoaSksZXN0aW1hdGVIZWlnaHQpKTt9cmV0dXJuIHJlc3VsdDt9dmFyIGZyb209Y2hhbmdlLmZyb20sdG89Y2hhbmdlLnRvLHRleHQ9Y2hhbmdlLnRleHQ7dmFyIGZpcnN0TGluZT1nZXRMaW5lKGRvYyxmcm9tLmxpbmUpLGxhc3RMaW5lPWdldExpbmUoZG9jLHRvLmxpbmUpO3ZhciBsYXN0VGV4dD1sc3QodGV4dCksbGFzdFNwYW5zPXNwYW5zRm9yKHRleHQubGVuZ3RoLTEpLG5saW5lcz10by5saW5lLWZyb20ubGluZTsvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXG5pZihjaGFuZ2UuZnVsbCl7ZG9jLmluc2VydCgwLGxpbmVzRm9yKDAsdGV4dC5sZW5ndGgpKTtkb2MucmVtb3ZlKHRleHQubGVuZ3RoLGRvYy5zaXplLXRleHQubGVuZ3RoKTt9ZWxzZSBpZihpc1dob2xlTGluZVVwZGF0ZShkb2MsY2hhbmdlKSl7Ly8gVGhpcyBpcyBhIHdob2xlLWxpbmUgcmVwbGFjZS4gVHJlYXRlZCBzcGVjaWFsbHkgdG8gbWFrZVxuLy8gc3VyZSBsaW5lIG9iamVjdHMgbW92ZSB0aGUgd2F5IHRoZXkgYXJlIHN1cHBvc2VkIHRvLlxudmFyIGFkZGVkPWxpbmVzRm9yKDAsdGV4dC5sZW5ndGgtMSk7dXBkYXRlKGxhc3RMaW5lLGxhc3RMaW5lLnRleHQsbGFzdFNwYW5zKTtpZihubGluZXMpe2RvYy5yZW1vdmUoZnJvbS5saW5lLG5saW5lcyk7fWlmKGFkZGVkLmxlbmd0aCl7ZG9jLmluc2VydChmcm9tLmxpbmUsYWRkZWQpO319ZWxzZSBpZihmaXJzdExpbmU9PWxhc3RMaW5lKXtpZih0ZXh0Lmxlbmd0aD09MSl7dXBkYXRlKGZpcnN0TGluZSxmaXJzdExpbmUudGV4dC5zbGljZSgwLGZyb20uY2gpK2xhc3RUZXh0K2ZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSxsYXN0U3BhbnMpO31lbHNle3ZhciBhZGRlZCQxPWxpbmVzRm9yKDEsdGV4dC5sZW5ndGgtMSk7YWRkZWQkMS5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0K2ZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSxsYXN0U3BhbnMsZXN0aW1hdGVIZWlnaHQpKTt1cGRhdGUoZmlyc3RMaW5lLGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsZnJvbS5jaCkrdGV4dFswXSxzcGFuc0ZvcigwKSk7ZG9jLmluc2VydChmcm9tLmxpbmUrMSxhZGRlZCQxKTt9fWVsc2UgaWYodGV4dC5sZW5ndGg9PTEpe3VwZGF0ZShmaXJzdExpbmUsZmlyc3RMaW5lLnRleHQuc2xpY2UoMCxmcm9tLmNoKSt0ZXh0WzBdK2xhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLHNwYW5zRm9yKDApKTtkb2MucmVtb3ZlKGZyb20ubGluZSsxLG5saW5lcyk7fWVsc2V7dXBkYXRlKGZpcnN0TGluZSxmaXJzdExpbmUudGV4dC5zbGljZSgwLGZyb20uY2gpK3RleHRbMF0sc3BhbnNGb3IoMCkpO3VwZGF0ZShsYXN0TGluZSxsYXN0VGV4dCtsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSxsYXN0U3BhbnMpO3ZhciBhZGRlZCQyPWxpbmVzRm9yKDEsdGV4dC5sZW5ndGgtMSk7aWYobmxpbmVzPjEpe2RvYy5yZW1vdmUoZnJvbS5saW5lKzEsbmxpbmVzLTEpO31kb2MuaW5zZXJ0KGZyb20ubGluZSsxLGFkZGVkJDIpO31zaWduYWxMYXRlcihkb2MsXCJjaGFuZ2VcIixkb2MsY2hhbmdlKTt9Ly8gQ2FsbCBmIGZvciBhbGwgbGlua2VkIGRvY3VtZW50cy5cbmZ1bmN0aW9uIGxpbmtlZERvY3MoZG9jLGYsc2hhcmVkSGlzdE9ubHkpe2Z1bmN0aW9uIHByb3BhZ2F0ZShkb2Msc2tpcCxzaGFyZWRIaXN0KXtpZihkb2MubGlua2VkKXtmb3IodmFyIGk9MDtpPGRvYy5saW5rZWQubGVuZ3RoOysraSl7dmFyIHJlbD1kb2MubGlua2VkW2ldO2lmKHJlbC5kb2M9PXNraXApe2NvbnRpbnVlO312YXIgc2hhcmVkPXNoYXJlZEhpc3QmJnJlbC5zaGFyZWRIaXN0O2lmKHNoYXJlZEhpc3RPbmx5JiYhc2hhcmVkKXtjb250aW51ZTt9ZihyZWwuZG9jLHNoYXJlZCk7cHJvcGFnYXRlKHJlbC5kb2MsZG9jLHNoYXJlZCk7fX19cHJvcGFnYXRlKGRvYyxudWxsLHRydWUpO30vLyBBdHRhY2ggYSBkb2N1bWVudCB0byBhbiBlZGl0b3IuXG5mdW5jdGlvbiBhdHRhY2hEb2MoY20sZG9jKXtpZihkb2MuY20pe3Rocm93IG5ldyBFcnJvcihcIlRoaXMgZG9jdW1lbnQgaXMgYWxyZWFkeSBpbiB1c2UuXCIpO31jbS5kb2M9ZG9jO2RvYy5jbT1jbTtlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtsb2FkTW9kZShjbSk7aWYoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKXtmaW5kTWF4TGluZShjbSk7fWNtLm9wdGlvbnMubW9kZT1kb2MubW9kZU9wdGlvbjtyZWdDaGFuZ2UoY20pO31mdW5jdGlvbiBIaXN0b3J5KHN0YXJ0R2VuKXsvLyBBcnJheXMgb2YgY2hhbmdlIGV2ZW50cyBhbmQgc2VsZWN0aW9ucy4gRG9pbmcgc29tZXRoaW5nIGFkZHMgYW5cbi8vIGV2ZW50IHRvIGRvbmUgYW5kIGNsZWFycyB1bmRvLiBVbmRvaW5nIG1vdmVzIGV2ZW50cyBmcm9tIGRvbmVcbi8vIHRvIHVuZG9uZSwgcmVkb2luZyBtb3ZlcyB0aGVtIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG50aGlzLmRvbmU9W107dGhpcy51bmRvbmU9W107dGhpcy51bmRvRGVwdGg9SW5maW5pdHk7Ly8gVXNlZCB0byB0cmFjayB3aGVuIGNoYW5nZXMgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIHVuZG9cbi8vIGV2ZW50XG50aGlzLmxhc3RNb2RUaW1lPXRoaXMubGFzdFNlbFRpbWU9MDt0aGlzLmxhc3RPcD10aGlzLmxhc3RTZWxPcD1udWxsO3RoaXMubGFzdE9yaWdpbj10aGlzLmxhc3RTZWxPcmlnaW49bnVsbDsvLyBVc2VkIGJ5IHRoZSBpc0NsZWFuKCkgbWV0aG9kXG50aGlzLmdlbmVyYXRpb249dGhpcy5tYXhHZW5lcmF0aW9uPXN0YXJ0R2VufHwxO30vLyBDcmVhdGUgYSBoaXN0b3J5IGNoYW5nZSBldmVudCBmcm9tIGFuIHVwZGF0ZURvYy1zdHlsZSBjaGFuZ2Vcbi8vIG9iamVjdC5cbmZ1bmN0aW9uIGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYyxjaGFuZ2Upe3ZhciBoaXN0Q2hhbmdlPXtmcm9tOmNvcHlQb3MoY2hhbmdlLmZyb20pLHRvOmNoYW5nZUVuZChjaGFuZ2UpLHRleHQ6Z2V0QmV0d2Vlbihkb2MsY2hhbmdlLmZyb20sY2hhbmdlLnRvKX07YXR0YWNoTG9jYWxTcGFucyhkb2MsaGlzdENoYW5nZSxjaGFuZ2UuZnJvbS5saW5lLGNoYW5nZS50by5saW5lKzEpO2xpbmtlZERvY3MoZG9jLGZ1bmN0aW9uKGRvYyl7cmV0dXJuIGF0dGFjaExvY2FsU3BhbnMoZG9jLGhpc3RDaGFuZ2UsY2hhbmdlLmZyb20ubGluZSxjaGFuZ2UudG8ubGluZSsxKTt9LHRydWUpO3JldHVybiBoaXN0Q2hhbmdlO30vLyBQb3AgYWxsIHNlbGVjdGlvbiBldmVudHMgb2ZmIHRoZSBlbmQgb2YgYSBoaXN0b3J5IGFycmF5LiBTdG9wIGF0XG4vLyBhIGNoYW5nZSBldmVudC5cbmZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KXt3aGlsZShhcnJheS5sZW5ndGgpe3ZhciBsYXN0PWxzdChhcnJheSk7aWYobGFzdC5yYW5nZXMpe2FycmF5LnBvcCgpO31lbHNle2JyZWFrO319fS8vIEZpbmQgdGhlIHRvcCBjaGFuZ2UgZXZlbnQgaW4gdGhlIGhpc3RvcnkuIFBvcCBvZmYgc2VsZWN0aW9uXG4vLyBldmVudHMgdGhhdCBhcmUgaW4gdGhlIHdheS5cbmZ1bmN0aW9uIGxhc3RDaGFuZ2VFdmVudChoaXN0LGZvcmNlKXtpZihmb3JjZSl7Y2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC5kb25lKTtyZXR1cm4gbHN0KGhpc3QuZG9uZSk7fWVsc2UgaWYoaGlzdC5kb25lLmxlbmd0aCYmIWxzdChoaXN0LmRvbmUpLnJhbmdlcyl7cmV0dXJuIGxzdChoaXN0LmRvbmUpO31lbHNlIGlmKGhpc3QuZG9uZS5sZW5ndGg+MSYmIWhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoLTJdLnJhbmdlcyl7aGlzdC5kb25lLnBvcCgpO3JldHVybiBsc3QoaGlzdC5kb25lKTt9fS8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cbi8vIGEgc2luZ2xlIG9wZXJhdGlvbiwgb3IgYXJlIGNsb3NlIHRvZ2V0aGVyIHdpdGggYW4gb3JpZ2luIHRoYXRcbi8vIGFsbG93cyBtZXJnaW5nIChzdGFydGluZyB3aXRoIFwiK1wiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxuZnVuY3Rpb24gYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYyxjaGFuZ2Usc2VsQWZ0ZXIsb3BJZCl7dmFyIGhpc3Q9ZG9jLmhpc3Rvcnk7aGlzdC51bmRvbmUubGVuZ3RoPTA7dmFyIHRpbWU9K25ldyBEYXRlKCksY3VyO3ZhciBsYXN0O2lmKChoaXN0Lmxhc3RPcD09b3BJZHx8aGlzdC5sYXN0T3JpZ2luPT1jaGFuZ2Uub3JpZ2luJiZjaGFuZ2Uub3JpZ2luJiYoY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCk9PVwiK1wiJiZkb2MuY20mJmhpc3QubGFzdE1vZFRpbWU+dGltZS1kb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheXx8Y2hhbmdlLm9yaWdpbi5jaGFyQXQoMCk9PVwiKlwiKSkmJihjdXI9bGFzdENoYW5nZUV2ZW50KGhpc3QsaGlzdC5sYXN0T3A9PW9wSWQpKSl7Ly8gTWVyZ2UgdGhpcyBjaGFuZ2UgaW50byB0aGUgbGFzdCBldmVudFxubGFzdD1sc3QoY3VyLmNoYW5nZXMpO2lmKGNtcChjaGFuZ2UuZnJvbSxjaGFuZ2UudG8pPT0wJiZjbXAoY2hhbmdlLmZyb20sbGFzdC50byk9PTApey8vIE9wdGltaXplZCBjYXNlIGZvciBzaW1wbGUgaW5zZXJ0aW9uIC0tIGRvbid0IHdhbnQgdG8gYWRkXG4vLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXG5sYXN0LnRvPWNoYW5nZUVuZChjaGFuZ2UpO31lbHNley8vIEFkZCBuZXcgc3ViLWV2ZW50XG5jdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYyxjaGFuZ2UpKTt9fWVsc2V7Ly8gQ2FuIG5vdCBiZSBtZXJnZWQsIHN0YXJ0IGEgbmV3IGV2ZW50LlxudmFyIGJlZm9yZT1sc3QoaGlzdC5kb25lKTtpZighYmVmb3JlfHwhYmVmb3JlLnJhbmdlcyl7cHVzaFNlbGVjdGlvblRvSGlzdG9yeShkb2Muc2VsLGhpc3QuZG9uZSk7fWN1cj17Y2hhbmdlczpbaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLGNoYW5nZSldLGdlbmVyYXRpb246aGlzdC5nZW5lcmF0aW9ufTtoaXN0LmRvbmUucHVzaChjdXIpO3doaWxlKGhpc3QuZG9uZS5sZW5ndGg+aGlzdC51bmRvRGVwdGgpe2hpc3QuZG9uZS5zaGlmdCgpO2lmKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKXtoaXN0LmRvbmUuc2hpZnQoKTt9fX1oaXN0LmRvbmUucHVzaChzZWxBZnRlcik7aGlzdC5nZW5lcmF0aW9uPSsraGlzdC5tYXhHZW5lcmF0aW9uO2hpc3QubGFzdE1vZFRpbWU9aGlzdC5sYXN0U2VsVGltZT10aW1lO2hpc3QubGFzdE9wPWhpc3QubGFzdFNlbE9wPW9wSWQ7aGlzdC5sYXN0T3JpZ2luPWhpc3QubGFzdFNlbE9yaWdpbj1jaGFuZ2Uub3JpZ2luO2lmKCFsYXN0KXtzaWduYWwoZG9jLFwiaGlzdG9yeUFkZGVkXCIpO319ZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2Msb3JpZ2luLHByZXYsc2VsKXt2YXIgY2g9b3JpZ2luLmNoYXJBdCgwKTtyZXR1cm4gY2g9PVwiKlwifHxjaD09XCIrXCImJnByZXYucmFuZ2VzLmxlbmd0aD09c2VsLnJhbmdlcy5sZW5ndGgmJnByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKT09c2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkmJm5ldyBEYXRlKCktZG9jLmhpc3RvcnkubGFzdFNlbFRpbWU8PShkb2MuY20/ZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXk6NTAwKTt9Ly8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xuLy8gdGhlIHBlbmRpbmcgc2VsZWN0aW9uIGluIHRoZSBoaXN0b3J5LCBhbmQgcHVzaGVzIHRoZSBvbGQgcGVuZGluZ1xuLy8gc2VsZWN0aW9uIGludG8gdGhlICdkb25lJyBhcnJheSB3aGVuIGl0IHdhcyBzaWduaWZpY2FudGx5XG4vLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXG5mdW5jdGlvbiBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLHNlbCxvcElkLG9wdGlvbnMpe3ZhciBoaXN0PWRvYy5oaXN0b3J5LG9yaWdpbj1vcHRpb25zJiZvcHRpb25zLm9yaWdpbjsvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxuLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXG4vLyBzdGFydGluZyB3aXRoICogYXJlIGFsd2F5cyBtZXJnZWQsIHRob3NlIHN0YXJ0aW5nIHdpdGggKyBhcmVcbi8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXG5pZihvcElkPT1oaXN0Lmxhc3RTZWxPcHx8b3JpZ2luJiZoaXN0Lmxhc3RTZWxPcmlnaW49PW9yaWdpbiYmKGhpc3QubGFzdE1vZFRpbWU9PWhpc3QubGFzdFNlbFRpbWUmJmhpc3QubGFzdE9yaWdpbj09b3JpZ2lufHxzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYyxvcmlnaW4sbHN0KGhpc3QuZG9uZSksc2VsKSkpe2hpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoLTFdPXNlbDt9ZWxzZXtwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCxoaXN0LmRvbmUpO31oaXN0Lmxhc3RTZWxUaW1lPStuZXcgRGF0ZSgpO2hpc3QubGFzdFNlbE9yaWdpbj1vcmlnaW47aGlzdC5sYXN0U2VsT3A9b3BJZDtpZihvcHRpb25zJiZvcHRpb25zLmNsZWFyUmVkbyE9PWZhbHNlKXtjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSk7fX1mdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCxkZXN0KXt2YXIgdG9wPWxzdChkZXN0KTtpZighKHRvcCYmdG9wLnJhbmdlcyYmdG9wLmVxdWFscyhzZWwpKSl7ZGVzdC5wdXNoKHNlbCk7fX0vLyBVc2VkIHRvIHN0b3JlIG1hcmtlZCBzcGFuIGluZm9ybWF0aW9uIGluIHRoZSBoaXN0b3J5LlxuZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsY2hhbmdlLGZyb20sdG8pe3ZhciBleGlzdGluZz1jaGFuZ2VbXCJzcGFuc19cIitkb2MuaWRdLG49MDtkb2MuaXRlcihNYXRoLm1heChkb2MuZmlyc3QsZnJvbSksTWF0aC5taW4oZG9jLmZpcnN0K2RvYy5zaXplLHRvKSxmdW5jdGlvbihsaW5lKXtpZihsaW5lLm1hcmtlZFNwYW5zKXsoZXhpc3Rpbmd8fChleGlzdGluZz1jaGFuZ2VbXCJzcGFuc19cIitkb2MuaWRdPXt9KSlbbl09bGluZS5tYXJrZWRTcGFuczt9KytuO30pO30vLyBXaGVuIHVuL3JlLWRvaW5nIHJlc3RvcmVzIHRleHQgY29udGFpbmluZyBtYXJrZWQgc3BhbnMsIHRob3NlXG4vLyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IGNsZWFyZWQgc2hvdWxkIG5vdCBiZSByZXN0b3JlZC5cbmZ1bmN0aW9uIHJlbW92ZUNsZWFyZWRTcGFucyhzcGFucyl7aWYoIXNwYW5zKXtyZXR1cm4gbnVsbDt9dmFyIG91dDtmb3IodmFyIGk9MDtpPHNwYW5zLmxlbmd0aDsrK2kpe2lmKHNwYW5zW2ldLm1hcmtlci5leHBsaWNpdGx5Q2xlYXJlZCl7aWYoIW91dCl7b3V0PXNwYW5zLnNsaWNlKDAsaSk7fX1lbHNlIGlmKG91dCl7b3V0LnB1c2goc3BhbnNbaV0pO319cmV0dXJuIW91dD9zcGFuczpvdXQubGVuZ3RoP291dDpudWxsO30vLyBSZXRyaWV2ZSBhbmQgZmlsdGVyIHRoZSBvbGQgbWFya2VkIHNwYW5zIHN0b3JlZCBpbiBhIGNoYW5nZSBldmVudC5cbmZ1bmN0aW9uIGdldE9sZFNwYW5zKGRvYyxjaGFuZ2Upe3ZhciBmb3VuZD1jaGFuZ2VbXCJzcGFuc19cIitkb2MuaWRdO2lmKCFmb3VuZCl7cmV0dXJuIG51bGw7fXZhciBudz1bXTtmb3IodmFyIGk9MDtpPGNoYW5nZS50ZXh0Lmxlbmd0aDsrK2kpe253LnB1c2gocmVtb3ZlQ2xlYXJlZFNwYW5zKGZvdW5kW2ldKSk7fXJldHVybiBudzt9Ly8gVXNlZCBmb3IgdW4vcmUtZG9pbmcgY2hhbmdlcyBmcm9tIHRoZSBoaXN0b3J5LiBDb21iaW5lcyB0aGVcbi8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XG4vLyBleGlzdGVkIGluIHRoZSBoaXN0b3J5IChzbyB0aGF0IGRlbGV0aW5nIGFyb3VuZCBhIHNwYW4gYW5kIHRoZW5cbi8vIHVuZG9pbmcgYnJpbmdzIGJhY2sgdGhlIHNwYW4pLlxuZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsY2hhbmdlKXt2YXIgb2xkPWdldE9sZFNwYW5zKGRvYyxjaGFuZ2UpO3ZhciBzdHJldGNoZWQ9c3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsY2hhbmdlKTtpZighb2xkKXtyZXR1cm4gc3RyZXRjaGVkO31pZighc3RyZXRjaGVkKXtyZXR1cm4gb2xkO31mb3IodmFyIGk9MDtpPG9sZC5sZW5ndGg7KytpKXt2YXIgb2xkQ3VyPW9sZFtpXSxzdHJldGNoQ3VyPXN0cmV0Y2hlZFtpXTtpZihvbGRDdXImJnN0cmV0Y2hDdXIpe3NwYW5zOmZvcih2YXIgaj0wO2o8c3RyZXRjaEN1ci5sZW5ndGg7KytqKXt2YXIgc3Bhbj1zdHJldGNoQ3VyW2pdO2Zvcih2YXIgaz0wO2s8b2xkQ3VyLmxlbmd0aDsrK2spe2lmKG9sZEN1cltrXS5tYXJrZXI9PXNwYW4ubWFya2VyKXtjb250aW51ZSBzcGFuczt9fW9sZEN1ci5wdXNoKHNwYW4pO319ZWxzZSBpZihzdHJldGNoQ3VyKXtvbGRbaV09c3RyZXRjaEN1cjt9fXJldHVybiBvbGQ7fS8vIFVzZWQgYm90aCB0byBwcm92aWRlIGEgSlNPTi1zYWZlIG9iamVjdCBpbiAuZ2V0SGlzdG9yeSwgYW5kLCB3aGVuXG4vLyBkZXRhY2hpbmcgYSBkb2N1bWVudCwgdG8gc3BsaXQgdGhlIGhpc3RvcnkgaW4gdHdvXG5mdW5jdGlvbiBjb3B5SGlzdG9yeUFycmF5KGV2ZW50cyxuZXdHcm91cCxpbnN0YW50aWF0ZVNlbCl7dmFyIGNvcHk9W107Zm9yKHZhciBpPTA7aTxldmVudHMubGVuZ3RoOysraSl7dmFyIGV2ZW50PWV2ZW50c1tpXTtpZihldmVudC5yYW5nZXMpe2NvcHkucHVzaChpbnN0YW50aWF0ZVNlbD9TZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5LmNhbGwoZXZlbnQpOmV2ZW50KTtjb250aW51ZTt9dmFyIGNoYW5nZXM9ZXZlbnQuY2hhbmdlcyxuZXdDaGFuZ2VzPVtdO2NvcHkucHVzaCh7Y2hhbmdlczpuZXdDaGFuZ2VzfSk7Zm9yKHZhciBqPTA7ajxjaGFuZ2VzLmxlbmd0aDsrK2ope3ZhciBjaGFuZ2U9Y2hhbmdlc1tqXSxtPXZvaWQgMDtuZXdDaGFuZ2VzLnB1c2goe2Zyb206Y2hhbmdlLmZyb20sdG86Y2hhbmdlLnRvLHRleHQ6Y2hhbmdlLnRleHR9KTtpZihuZXdHcm91cCl7Zm9yKHZhciBwcm9wIGluIGNoYW5nZSl7aWYobT1wcm9wLm1hdGNoKC9ec3BhbnNfKFxcZCspJC8pKXtpZihpbmRleE9mKG5ld0dyb3VwLE51bWJlcihtWzFdKSk+LTEpe2xzdChuZXdDaGFuZ2VzKVtwcm9wXT1jaGFuZ2VbcHJvcF07ZGVsZXRlIGNoYW5nZVtwcm9wXTt9fX19fX1yZXR1cm4gY29weTt9Ly8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXG4vLyB0aGUgbmV3IGN1cnNvciBwb3NpdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyXG4vLyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbi5cbi8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXG4vLyBpbmNsdWRlIGEgZ2l2ZW4gcG9zaXRpb24gKGFuZCBvcHRpb25hbGx5IGEgc2Vjb25kIHBvc2l0aW9uKS5cbi8vIE90aGVyd2lzZSwgc2ltcGx5IHJldHVybnMgdGhlIHJhbmdlIGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbi8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXG5mdW5jdGlvbiBleHRlbmRSYW5nZShkb2MscmFuZ2UsaGVhZCxvdGhlcil7aWYoZG9jLmNtJiZkb2MuY20uZGlzcGxheS5zaGlmdHx8ZG9jLmV4dGVuZCl7dmFyIGFuY2hvcj1yYW5nZS5hbmNob3I7aWYob3RoZXIpe3ZhciBwb3NCZWZvcmU9Y21wKGhlYWQsYW5jaG9yKTwwO2lmKHBvc0JlZm9yZSE9Y21wKG90aGVyLGFuY2hvcik8MCl7YW5jaG9yPWhlYWQ7aGVhZD1vdGhlcjt9ZWxzZSBpZihwb3NCZWZvcmUhPWNtcChoZWFkLG90aGVyKTwwKXtoZWFkPW90aGVyO319cmV0dXJuIG5ldyBSYW5nZShhbmNob3IsaGVhZCk7fWVsc2V7cmV0dXJuIG5ldyBSYW5nZShvdGhlcnx8aGVhZCxoZWFkKTt9fS8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXG5mdW5jdGlvbiBleHRlbmRTZWxlY3Rpb24oZG9jLGhlYWQsb3RoZXIsb3B0aW9ucyl7c2V0U2VsZWN0aW9uKGRvYyxuZXcgU2VsZWN0aW9uKFtleHRlbmRSYW5nZShkb2MsZG9jLnNlbC5wcmltYXJ5KCksaGVhZCxvdGhlcildLDApLG9wdGlvbnMpO30vLyBFeHRlbmQgYWxsIHNlbGVjdGlvbnMgKHBvcyBpcyBhbiBhcnJheSBvZiBzZWxlY3Rpb25zIHdpdGggbGVuZ3RoXG4vLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHNlbGVjdGlvbnMpXG5mdW5jdGlvbiBleHRlbmRTZWxlY3Rpb25zKGRvYyxoZWFkcyxvcHRpb25zKXt2YXIgb3V0PVtdO2Zvcih2YXIgaT0wO2k8ZG9jLnNlbC5yYW5nZXMubGVuZ3RoO2krKyl7b3V0W2ldPWV4dGVuZFJhbmdlKGRvYyxkb2Muc2VsLnJhbmdlc1tpXSxoZWFkc1tpXSxudWxsKTt9dmFyIG5ld1NlbD1ub3JtYWxpemVTZWxlY3Rpb24ob3V0LGRvYy5zZWwucHJpbUluZGV4KTtzZXRTZWxlY3Rpb24oZG9jLG5ld1NlbCxvcHRpb25zKTt9Ly8gVXBkYXRlcyBhIHNpbmdsZSByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLlxuZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsaSxyYW5nZSxvcHRpb25zKXt2YXIgcmFuZ2VzPWRvYy5zZWwucmFuZ2VzLnNsaWNlKDApO3Jhbmdlc1tpXT1yYW5nZTtzZXRTZWxlY3Rpb24oZG9jLG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsZG9jLnNlbC5wcmltSW5kZXgpLG9wdGlvbnMpO30vLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxuZnVuY3Rpb24gc2V0U2ltcGxlU2VsZWN0aW9uKGRvYyxhbmNob3IsaGVhZCxvcHRpb25zKXtzZXRTZWxlY3Rpb24oZG9jLHNpbXBsZVNlbGVjdGlvbihhbmNob3IsaGVhZCksb3B0aW9ucyk7fS8vIEdpdmUgYmVmb3JlU2VsZWN0aW9uQ2hhbmdlIGhhbmRsZXJzIGEgY2hhbmdlIHRvIGluZmx1ZW5jZSBhXG4vLyBzZWxlY3Rpb24gdXBkYXRlLlxuZnVuY3Rpb24gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYyxzZWwsb3B0aW9ucyl7dmFyIG9iaj17cmFuZ2VzOnNlbC5yYW5nZXMsdXBkYXRlOmZ1bmN0aW9uKHJhbmdlcyl7dmFyIHRoaXMkMT10aGlzO3RoaXMucmFuZ2VzPVtdO2Zvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDtpKyspe3RoaXMkMS5yYW5nZXNbaV09bmV3IFJhbmdlKGNsaXBQb3MoZG9jLHJhbmdlc1tpXS5hbmNob3IpLGNsaXBQb3MoZG9jLHJhbmdlc1tpXS5oZWFkKSk7fX0sb3JpZ2luOm9wdGlvbnMmJm9wdGlvbnMub3JpZ2lufTtzaWduYWwoZG9jLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsZG9jLG9iaik7aWYoZG9jLmNtKXtzaWduYWwoZG9jLmNtLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsZG9jLmNtLG9iaik7fWlmKG9iai5yYW5nZXMhPXNlbC5yYW5nZXMpe3JldHVybiBub3JtYWxpemVTZWxlY3Rpb24ob2JqLnJhbmdlcyxvYmoucmFuZ2VzLmxlbmd0aC0xKTt9ZWxzZXtyZXR1cm4gc2VsO319ZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoZG9jLHNlbCxvcHRpb25zKXt2YXIgZG9uZT1kb2MuaGlzdG9yeS5kb25lLGxhc3Q9bHN0KGRvbmUpO2lmKGxhc3QmJmxhc3QucmFuZ2VzKXtkb25lW2RvbmUubGVuZ3RoLTFdPXNlbDtzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLHNlbCxvcHRpb25zKTt9ZWxzZXtzZXRTZWxlY3Rpb24oZG9jLHNlbCxvcHRpb25zKTt9fS8vIFNldCBhIG5ldyBzZWxlY3Rpb24uXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oZG9jLHNlbCxvcHRpb25zKXtzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLHNlbCxvcHRpb25zKTthZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLGRvYy5zZWwsZG9jLmNtP2RvYy5jbS5jdXJPcC5pZDpOYU4sb3B0aW9ucyk7fWZ1bmN0aW9uIHNldFNlbGVjdGlvbk5vVW5kbyhkb2Msc2VsLG9wdGlvbnMpe2lmKGhhc0hhbmRsZXIoZG9jLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpfHxkb2MuY20mJmhhc0hhbmRsZXIoZG9jLmNtLFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpKXtzZWw9ZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYyxzZWwsb3B0aW9ucyk7fXZhciBiaWFzPW9wdGlvbnMmJm9wdGlvbnMuYmlhc3x8KGNtcChzZWwucHJpbWFyeSgpLmhlYWQsZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCk8MD8tMToxKTtzZXRTZWxlY3Rpb25Jbm5lcihkb2Msc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYyxzZWwsYmlhcyx0cnVlKSk7aWYoIShvcHRpb25zJiZvcHRpb25zLnNjcm9sbD09PWZhbHNlKSYmZG9jLmNtKXtlbnN1cmVDdXJzb3JWaXNpYmxlKGRvYy5jbSk7fX1mdW5jdGlvbiBzZXRTZWxlY3Rpb25Jbm5lcihkb2Msc2VsKXtpZihzZWwuZXF1YWxzKGRvYy5zZWwpKXtyZXR1cm47fWRvYy5zZWw9c2VsO2lmKGRvYy5jbSl7ZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0PWRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPXRydWU7c2lnbmFsQ3Vyc29yQWN0aXZpdHkoZG9jLmNtKTt9c2lnbmFsTGF0ZXIoZG9jLFwiY3Vyc29yQWN0aXZpdHlcIixkb2MpO30vLyBWZXJpZnkgdGhhdCB0aGUgc2VsZWN0aW9uIGRvZXMgbm90IHBhcnRpYWxseSBzZWxlY3QgYW55IGF0b21pY1xuLy8gbWFya2VkIHJhbmdlcy5cbmZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKXtzZXRTZWxlY3Rpb25Jbm5lcihkb2Msc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYyxkb2Muc2VsLG51bGwsZmFsc2UpLHNlbF9kb250U2Nyb2xsKTt9Ly8gUmV0dXJuIGEgc2VsZWN0aW9uIHRoYXQgZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXG4vLyByYW5nZXMuXG5mdW5jdGlvbiBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLHNlbCxiaWFzLG1heUNsZWFyKXt2YXIgb3V0O2Zvcih2YXIgaT0wO2k8c2VsLnJhbmdlcy5sZW5ndGg7aSsrKXt2YXIgcmFuZ2U9c2VsLnJhbmdlc1tpXTt2YXIgb2xkPXNlbC5yYW5nZXMubGVuZ3RoPT1kb2Muc2VsLnJhbmdlcy5sZW5ndGgmJmRvYy5zZWwucmFuZ2VzW2ldO3ZhciBuZXdBbmNob3I9c2tpcEF0b21pYyhkb2MscmFuZ2UuYW5jaG9yLG9sZCYmb2xkLmFuY2hvcixiaWFzLG1heUNsZWFyKTt2YXIgbmV3SGVhZD1za2lwQXRvbWljKGRvYyxyYW5nZS5oZWFkLG9sZCYmb2xkLmhlYWQsYmlhcyxtYXlDbGVhcik7aWYob3V0fHxuZXdBbmNob3IhPXJhbmdlLmFuY2hvcnx8bmV3SGVhZCE9cmFuZ2UuaGVhZCl7aWYoIW91dCl7b3V0PXNlbC5yYW5nZXMuc2xpY2UoMCxpKTt9b3V0W2ldPW5ldyBSYW5nZShuZXdBbmNob3IsbmV3SGVhZCk7fX1yZXR1cm4gb3V0P25vcm1hbGl6ZVNlbGVjdGlvbihvdXQsc2VsLnByaW1JbmRleCk6c2VsO31mdW5jdGlvbiBza2lwQXRvbWljSW5uZXIoZG9jLHBvcyxvbGRQb3MsZGlyLG1heUNsZWFyKXt2YXIgbGluZT1nZXRMaW5lKGRvYyxwb3MubGluZSk7aWYobGluZS5tYXJrZWRTcGFucyl7Zm9yKHZhciBpPTA7aTxsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsrK2kpe3ZhciBzcD1saW5lLm1hcmtlZFNwYW5zW2ldLG09c3AubWFya2VyO2lmKChzcC5mcm9tPT1udWxsfHwobS5pbmNsdXNpdmVMZWZ0P3NwLmZyb208PXBvcy5jaDpzcC5mcm9tPHBvcy5jaCkpJiYoc3AudG89PW51bGx8fChtLmluY2x1c2l2ZVJpZ2h0P3NwLnRvPj1wb3MuY2g6c3AudG8+cG9zLmNoKSkpe2lmKG1heUNsZWFyKXtzaWduYWwobSxcImJlZm9yZUN1cnNvckVudGVyXCIpO2lmKG0uZXhwbGljaXRseUNsZWFyZWQpe2lmKCFsaW5lLm1hcmtlZFNwYW5zKXticmVhazt9ZWxzZXstLWk7Y29udGludWU7fX19aWYoIW0uYXRvbWljKXtjb250aW51ZTt9aWYob2xkUG9zKXt2YXIgbmVhcj1tLmZpbmQoZGlyPDA/MTotMSksZGlmZj12b2lkIDA7aWYoZGlyPDA/bS5pbmNsdXNpdmVSaWdodDptLmluY2x1c2l2ZUxlZnQpe25lYXI9bW92ZVBvcyhkb2MsbmVhciwtZGlyLG5lYXImJm5lYXIubGluZT09cG9zLmxpbmU/bGluZTpudWxsKTt9aWYobmVhciYmbmVhci5saW5lPT1wb3MubGluZSYmKGRpZmY9Y21wKG5lYXIsb2xkUG9zKSkmJihkaXI8MD9kaWZmPDA6ZGlmZj4wKSl7cmV0dXJuIHNraXBBdG9taWNJbm5lcihkb2MsbmVhcixwb3MsZGlyLG1heUNsZWFyKTt9fXZhciBmYXI9bS5maW5kKGRpcjwwPy0xOjEpO2lmKGRpcjwwP20uaW5jbHVzaXZlTGVmdDptLmluY2x1c2l2ZVJpZ2h0KXtmYXI9bW92ZVBvcyhkb2MsZmFyLGRpcixmYXIubGluZT09cG9zLmxpbmU/bGluZTpudWxsKTt9cmV0dXJuIGZhcj9za2lwQXRvbWljSW5uZXIoZG9jLGZhcixwb3MsZGlyLG1heUNsZWFyKTpudWxsO319fXJldHVybiBwb3M7fS8vIEVuc3VyZSBhIGdpdmVuIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYW4gYXRvbWljIHJhbmdlLlxuZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MscG9zLG9sZFBvcyxiaWFzLG1heUNsZWFyKXt2YXIgZGlyPWJpYXN8fDE7dmFyIGZvdW5kPXNraXBBdG9taWNJbm5lcihkb2MscG9zLG9sZFBvcyxkaXIsbWF5Q2xlYXIpfHwhbWF5Q2xlYXImJnNraXBBdG9taWNJbm5lcihkb2MscG9zLG9sZFBvcyxkaXIsdHJ1ZSl8fHNraXBBdG9taWNJbm5lcihkb2MscG9zLG9sZFBvcywtZGlyLG1heUNsZWFyKXx8IW1heUNsZWFyJiZza2lwQXRvbWljSW5uZXIoZG9jLHBvcyxvbGRQb3MsLWRpcix0cnVlKTtpZighZm91bmQpe2RvYy5jYW50RWRpdD10cnVlO3JldHVybiBQb3MoZG9jLmZpcnN0LDApO31yZXR1cm4gZm91bmQ7fWZ1bmN0aW9uIG1vdmVQb3MoZG9jLHBvcyxkaXIsbGluZSl7aWYoZGlyPDAmJnBvcy5jaD09MCl7aWYocG9zLmxpbmU+ZG9jLmZpcnN0KXtyZXR1cm4gY2xpcFBvcyhkb2MsUG9zKHBvcy5saW5lLTEpKTt9ZWxzZXtyZXR1cm4gbnVsbDt9fWVsc2UgaWYoZGlyPjAmJnBvcy5jaD09KGxpbmV8fGdldExpbmUoZG9jLHBvcy5saW5lKSkudGV4dC5sZW5ndGgpe2lmKHBvcy5saW5lPGRvYy5maXJzdCtkb2Muc2l6ZS0xKXtyZXR1cm4gUG9zKHBvcy5saW5lKzEsMCk7fWVsc2V7cmV0dXJuIG51bGw7fX1lbHNle3JldHVybiBuZXcgUG9zKHBvcy5saW5lLHBvcy5jaCtkaXIpO319ZnVuY3Rpb24gc2VsZWN0QWxsKGNtKXtjbS5zZXRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLDApLFBvcyhjbS5sYXN0TGluZSgpKSxzZWxfZG9udFNjcm9sbCk7fS8vIFVQREFUSU5HXG4vLyBBbGxvdyBcImJlZm9yZUNoYW5nZVwiIGV2ZW50IGhhbmRsZXJzIHRvIGluZmx1ZW5jZSBhIGNoYW5nZVxuZnVuY3Rpb24gZmlsdGVyQ2hhbmdlKGRvYyxjaGFuZ2UsdXBkYXRlKXt2YXIgb2JqPXtjYW5jZWxlZDpmYWxzZSxmcm9tOmNoYW5nZS5mcm9tLHRvOmNoYW5nZS50byx0ZXh0OmNoYW5nZS50ZXh0LG9yaWdpbjpjaGFuZ2Uub3JpZ2luLGNhbmNlbDpmdW5jdGlvbigpe3JldHVybiBvYmouY2FuY2VsZWQ9dHJ1ZTt9fTtpZih1cGRhdGUpe29iai51cGRhdGU9ZnVuY3Rpb24oZnJvbSx0byx0ZXh0LG9yaWdpbil7aWYoZnJvbSl7b2JqLmZyb209Y2xpcFBvcyhkb2MsZnJvbSk7fWlmKHRvKXtvYmoudG89Y2xpcFBvcyhkb2MsdG8pO31pZih0ZXh0KXtvYmoudGV4dD10ZXh0O31pZihvcmlnaW4hPT11bmRlZmluZWQpe29iai5vcmlnaW49b3JpZ2luO319O31zaWduYWwoZG9jLFwiYmVmb3JlQ2hhbmdlXCIsZG9jLG9iaik7aWYoZG9jLmNtKXtzaWduYWwoZG9jLmNtLFwiYmVmb3JlQ2hhbmdlXCIsZG9jLmNtLG9iaik7fWlmKG9iai5jYW5jZWxlZCl7cmV0dXJuIG51bGw7fXJldHVybntmcm9tOm9iai5mcm9tLHRvOm9iai50byx0ZXh0Om9iai50ZXh0LG9yaWdpbjpvYmoub3JpZ2lufTt9Ly8gQXBwbHkgYSBjaGFuZ2UgdG8gYSBkb2N1bWVudCwgYW5kIGFkZCBpdCB0byB0aGUgZG9jdW1lbnQnc1xuLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuZnVuY3Rpb24gbWFrZUNoYW5nZShkb2MsY2hhbmdlLGlnbm9yZVJlYWRPbmx5KXtpZihkb2MuY20pe2lmKCFkb2MuY20uY3VyT3Ape3JldHVybiBvcGVyYXRpb24oZG9jLmNtLG1ha2VDaGFuZ2UpKGRvYyxjaGFuZ2UsaWdub3JlUmVhZE9ubHkpO31pZihkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cyl7cmV0dXJuO319aWYoaGFzSGFuZGxlcihkb2MsXCJiZWZvcmVDaGFuZ2VcIil8fGRvYy5jbSYmaGFzSGFuZGxlcihkb2MuY20sXCJiZWZvcmVDaGFuZ2VcIikpe2NoYW5nZT1maWx0ZXJDaGFuZ2UoZG9jLGNoYW5nZSx0cnVlKTtpZighY2hhbmdlKXtyZXR1cm47fX0vLyBQb3NzaWJseSBzcGxpdCBvciBzdXBwcmVzcyB0aGUgdXBkYXRlIGJhc2VkIG9uIHRoZSBwcmVzZW5jZVxuLy8gb2YgcmVhZC1vbmx5IHNwYW5zIGluIGl0cyByYW5nZS5cbnZhciBzcGxpdD1zYXdSZWFkT25seVNwYW5zJiYhaWdub3JlUmVhZE9ubHkmJnJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYyxjaGFuZ2UuZnJvbSxjaGFuZ2UudG8pO2lmKHNwbGl0KXtmb3IodmFyIGk9c3BsaXQubGVuZ3RoLTE7aT49MDstLWkpe21ha2VDaGFuZ2VJbm5lcihkb2Mse2Zyb206c3BsaXRbaV0uZnJvbSx0bzpzcGxpdFtpXS50byx0ZXh0Omk/W1wiXCJdOmNoYW5nZS50ZXh0fSk7fX1lbHNle21ha2VDaGFuZ2VJbm5lcihkb2MsY2hhbmdlKTt9fWZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsY2hhbmdlKXtpZihjaGFuZ2UudGV4dC5sZW5ndGg9PTEmJmNoYW5nZS50ZXh0WzBdPT1cIlwiJiZjbXAoY2hhbmdlLmZyb20sY2hhbmdlLnRvKT09MCl7cmV0dXJuO312YXIgc2VsQWZ0ZXI9Y29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYyxjaGFuZ2UpO2FkZENoYW5nZVRvSGlzdG9yeShkb2MsY2hhbmdlLHNlbEFmdGVyLGRvYy5jbT9kb2MuY20uY3VyT3AuaWQ6TmFOKTttYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYyxjaGFuZ2Usc2VsQWZ0ZXIsc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsY2hhbmdlKSk7dmFyIHJlYmFzZWQ9W107bGlua2VkRG9jcyhkb2MsZnVuY3Rpb24oZG9jLHNoYXJlZEhpc3Qpe2lmKCFzaGFyZWRIaXN0JiZpbmRleE9mKHJlYmFzZWQsZG9jLmhpc3RvcnkpPT0tMSl7cmViYXNlSGlzdChkb2MuaGlzdG9yeSxjaGFuZ2UpO3JlYmFzZWQucHVzaChkb2MuaGlzdG9yeSk7fW1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLGNoYW5nZSxudWxsLHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLGNoYW5nZSkpO30pO30vLyBSZXZlcnQgYSBjaGFuZ2Ugc3RvcmVkIGluIGEgZG9jdW1lbnQncyBoaXN0b3J5LlxuZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYyx0eXBlLGFsbG93U2VsZWN0aW9uT25seSl7aWYoZG9jLmNtJiZkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cyYmIWFsbG93U2VsZWN0aW9uT25seSl7cmV0dXJuO312YXIgaGlzdD1kb2MuaGlzdG9yeSxldmVudCxzZWxBZnRlcj1kb2Muc2VsO3ZhciBzb3VyY2U9dHlwZT09XCJ1bmRvXCI/aGlzdC5kb25lOmhpc3QudW5kb25lLGRlc3Q9dHlwZT09XCJ1bmRvXCI/aGlzdC51bmRvbmU6aGlzdC5kb25lOy8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGEgdXNlYWJsZSBldmVudCAoc28gdGhhdCBjdHJsLXogd29uJ3Rcbi8vIG5lZWRsZXNzbHkgY2xlYXIgc2VsZWN0aW9uIGV2ZW50cylcbnZhciBpPTA7Zm9yKDtpPHNvdXJjZS5sZW5ndGg7aSsrKXtldmVudD1zb3VyY2VbaV07aWYoYWxsb3dTZWxlY3Rpb25Pbmx5P2V2ZW50LnJhbmdlcyYmIWV2ZW50LmVxdWFscyhkb2Muc2VsKTohZXZlbnQucmFuZ2VzKXticmVhazt9fWlmKGk9PXNvdXJjZS5sZW5ndGgpe3JldHVybjt9aGlzdC5sYXN0T3JpZ2luPWhpc3QubGFzdFNlbE9yaWdpbj1udWxsO2Zvcig7Oyl7ZXZlbnQ9c291cmNlLnBvcCgpO2lmKGV2ZW50LnJhbmdlcyl7cHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCxkZXN0KTtpZihhbGxvd1NlbGVjdGlvbk9ubHkmJiFldmVudC5lcXVhbHMoZG9jLnNlbCkpe3NldFNlbGVjdGlvbihkb2MsZXZlbnQse2NsZWFyUmVkbzpmYWxzZX0pO3JldHVybjt9c2VsQWZ0ZXI9ZXZlbnQ7fWVsc2V7YnJlYWs7fX0vLyBCdWlsZCB1cCBhIHJldmVyc2UgY2hhbmdlIG9iamVjdCB0byBhZGQgdG8gdGhlIG9wcG9zaXRlIGhpc3Rvcnlcbi8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxudmFyIGFudGlDaGFuZ2VzPVtdO3B1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsQWZ0ZXIsZGVzdCk7ZGVzdC5wdXNoKHtjaGFuZ2VzOmFudGlDaGFuZ2VzLGdlbmVyYXRpb246aGlzdC5nZW5lcmF0aW9ufSk7aGlzdC5nZW5lcmF0aW9uPWV2ZW50LmdlbmVyYXRpb258fCsraGlzdC5tYXhHZW5lcmF0aW9uO3ZhciBmaWx0ZXI9aGFzSGFuZGxlcihkb2MsXCJiZWZvcmVDaGFuZ2VcIil8fGRvYy5jbSYmaGFzSGFuZGxlcihkb2MuY20sXCJiZWZvcmVDaGFuZ2VcIik7dmFyIGxvb3A9ZnVuY3Rpb24oaSl7dmFyIGNoYW5nZT1ldmVudC5jaGFuZ2VzW2ldO2NoYW5nZS5vcmlnaW49dHlwZTtpZihmaWx0ZXImJiFmaWx0ZXJDaGFuZ2UoZG9jLGNoYW5nZSxmYWxzZSkpe3NvdXJjZS5sZW5ndGg9MDtyZXR1cm57fTt9YW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsY2hhbmdlKSk7dmFyIGFmdGVyPWk/Y29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYyxjaGFuZ2UpOmxzdChzb3VyY2UpO21ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLGNoYW5nZSxhZnRlcixtZXJnZU9sZFNwYW5zKGRvYyxjaGFuZ2UpKTtpZighaSYmZG9jLmNtKXtkb2MuY20uc2Nyb2xsSW50b1ZpZXcoe2Zyb206Y2hhbmdlLmZyb20sdG86Y2hhbmdlRW5kKGNoYW5nZSl9KTt9dmFyIHJlYmFzZWQ9W107Ly8gUHJvcGFnYXRlIHRvIHRoZSBsaW5rZWQgZG9jdW1lbnRzXG5saW5rZWREb2NzKGRvYyxmdW5jdGlvbihkb2Msc2hhcmVkSGlzdCl7aWYoIXNoYXJlZEhpc3QmJmluZGV4T2YocmViYXNlZCxkb2MuaGlzdG9yeSk9PS0xKXtyZWJhc2VIaXN0KGRvYy5oaXN0b3J5LGNoYW5nZSk7cmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTt9bWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsY2hhbmdlLG51bGwsbWVyZ2VPbGRTcGFucyhkb2MsY2hhbmdlKSk7fSk7fTtmb3IodmFyIGkkMT1ldmVudC5jaGFuZ2VzLmxlbmd0aC0xO2kkMT49MDstLWkkMSl7dmFyIHJldHVybmVkPWxvb3AoaSQxKTtpZihyZXR1cm5lZClyZXR1cm4gcmV0dXJuZWQudjt9fS8vIFN1Yi12aWV3cyBuZWVkIHRoZWlyIGxpbmUgbnVtYmVycyBzaGlmdGVkIHdoZW4gdGV4dCBpcyBhZGRlZFxuLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxuZnVuY3Rpb24gc2hpZnREb2MoZG9jLGRpc3RhbmNlKXtpZihkaXN0YW5jZT09MCl7cmV0dXJuO31kb2MuZmlyc3QrPWRpc3RhbmNlO2RvYy5zZWw9bmV3IFNlbGVjdGlvbihtYXAoZG9jLnNlbC5yYW5nZXMsZnVuY3Rpb24ocmFuZ2Upe3JldHVybiBuZXcgUmFuZ2UoUG9zKHJhbmdlLmFuY2hvci5saW5lK2Rpc3RhbmNlLHJhbmdlLmFuY2hvci5jaCksUG9zKHJhbmdlLmhlYWQubGluZStkaXN0YW5jZSxyYW5nZS5oZWFkLmNoKSk7fSksZG9jLnNlbC5wcmltSW5kZXgpO2lmKGRvYy5jbSl7cmVnQ2hhbmdlKGRvYy5jbSxkb2MuZmlyc3QsZG9jLmZpcnN0LWRpc3RhbmNlLGRpc3RhbmNlKTtmb3IodmFyIGQ9ZG9jLmNtLmRpc3BsYXksbD1kLnZpZXdGcm9tO2w8ZC52aWV3VG87bCsrKXtyZWdMaW5lQ2hhbmdlKGRvYy5jbSxsLFwiZ3V0dGVyXCIpO319fS8vIE1vcmUgbG93ZXItbGV2ZWwgY2hhbmdlIGZ1bmN0aW9uLCBoYW5kbGluZyBvbmx5IGEgc2luZ2xlIGRvY3VtZW50XG4vLyAobm90IGxpbmtlZCBvbmVzKS5cbmZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLGNoYW5nZSxzZWxBZnRlcixzcGFucyl7aWYoZG9jLmNtJiYhZG9jLmNtLmN1ck9wKXtyZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSxtYWtlQ2hhbmdlU2luZ2xlRG9jKShkb2MsY2hhbmdlLHNlbEFmdGVyLHNwYW5zKTt9aWYoY2hhbmdlLnRvLmxpbmU8ZG9jLmZpcnN0KXtzaGlmdERvYyhkb2MsY2hhbmdlLnRleHQubGVuZ3RoLTEtKGNoYW5nZS50by5saW5lLWNoYW5nZS5mcm9tLmxpbmUpKTtyZXR1cm47fWlmKGNoYW5nZS5mcm9tLmxpbmU+ZG9jLmxhc3RMaW5lKCkpe3JldHVybjt9Ly8gQ2xpcCB0aGUgY2hhbmdlIHRvIHRoZSBzaXplIG9mIHRoaXMgZG9jXG5pZihjaGFuZ2UuZnJvbS5saW5lPGRvYy5maXJzdCl7dmFyIHNoaWZ0PWNoYW5nZS50ZXh0Lmxlbmd0aC0xLShkb2MuZmlyc3QtY2hhbmdlLmZyb20ubGluZSk7c2hpZnREb2MoZG9jLHNoaWZ0KTtjaGFuZ2U9e2Zyb206UG9zKGRvYy5maXJzdCwwKSx0bzpQb3MoY2hhbmdlLnRvLmxpbmUrc2hpZnQsY2hhbmdlLnRvLmNoKSx0ZXh0Oltsc3QoY2hhbmdlLnRleHQpXSxvcmlnaW46Y2hhbmdlLm9yaWdpbn07fXZhciBsYXN0PWRvYy5sYXN0TGluZSgpO2lmKGNoYW5nZS50by5saW5lPmxhc3Qpe2NoYW5nZT17ZnJvbTpjaGFuZ2UuZnJvbSx0bzpQb3MobGFzdCxnZXRMaW5lKGRvYyxsYXN0KS50ZXh0Lmxlbmd0aCksdGV4dDpbY2hhbmdlLnRleHRbMF1dLG9yaWdpbjpjaGFuZ2Uub3JpZ2lufTt9Y2hhbmdlLnJlbW92ZWQ9Z2V0QmV0d2Vlbihkb2MsY2hhbmdlLmZyb20sY2hhbmdlLnRvKTtpZighc2VsQWZ0ZXIpe3NlbEFmdGVyPWNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsY2hhbmdlKTt9aWYoZG9jLmNtKXttYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLGNoYW5nZSxzcGFucyk7fWVsc2V7dXBkYXRlRG9jKGRvYyxjaGFuZ2Usc3BhbnMpO31zZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLHNlbEFmdGVyLHNlbF9kb250U2Nyb2xsKTt9Ly8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxuLy8gdGhhdCB0aGlzIGRvY3VtZW50IGlzIHBhcnQgb2YuXG5mdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sY2hhbmdlLHNwYW5zKXt2YXIgZG9jPWNtLmRvYyxkaXNwbGF5PWNtLmRpc3BsYXksZnJvbT1jaGFuZ2UuZnJvbSx0bz1jaGFuZ2UudG87dmFyIHJlY29tcHV0ZU1heExlbmd0aD1mYWxzZSxjaGVja1dpZHRoU3RhcnQ9ZnJvbS5saW5lO2lmKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyl7Y2hlY2tXaWR0aFN0YXJ0PWxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLGZyb20ubGluZSkpKTtkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsdG8ubGluZSsxLGZ1bmN0aW9uKGxpbmUpe2lmKGxpbmU9PWRpc3BsYXkubWF4TGluZSl7cmVjb21wdXRlTWF4TGVuZ3RoPXRydWU7cmV0dXJuIHRydWU7fX0pO31pZihkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLGNoYW5nZS50byk+LTEpe3NpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTt9dXBkYXRlRG9jKGRvYyxjaGFuZ2Usc3BhbnMsZXN0aW1hdGVIZWlnaHQoY20pKTtpZighY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpe2RvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCxmcm9tLmxpbmUrY2hhbmdlLnRleHQubGVuZ3RoLGZ1bmN0aW9uKGxpbmUpe3ZhciBsZW49bGluZUxlbmd0aChsaW5lKTtpZihsZW4+ZGlzcGxheS5tYXhMaW5lTGVuZ3RoKXtkaXNwbGF5Lm1heExpbmU9bGluZTtkaXNwbGF5Lm1heExpbmVMZW5ndGg9bGVuO2Rpc3BsYXkubWF4TGluZUNoYW5nZWQ9dHJ1ZTtyZWNvbXB1dGVNYXhMZW5ndGg9ZmFsc2U7fX0pO2lmKHJlY29tcHV0ZU1heExlbmd0aCl7Y20uY3VyT3AudXBkYXRlTWF4TGluZT10cnVlO319Ly8gQWRqdXN0IGZyb250aWVyLCBzY2hlZHVsZSB3b3JrZXJcbmRvYy5mcm9udGllcj1NYXRoLm1pbihkb2MuZnJvbnRpZXIsZnJvbS5saW5lKTtzdGFydFdvcmtlcihjbSw0MDApO3ZhciBsZW5kaWZmPWNoYW5nZS50ZXh0Lmxlbmd0aC0odG8ubGluZS1mcm9tLmxpbmUpLTE7Ly8gUmVtZW1iZXIgdGhhdCB0aGVzZSBsaW5lcyBjaGFuZ2VkLCBmb3IgdXBkYXRpbmcgdGhlIGRpc3BsYXlcbmlmKGNoYW5nZS5mdWxsKXtyZWdDaGFuZ2UoY20pO31lbHNlIGlmKGZyb20ubGluZT09dG8ubGluZSYmY2hhbmdlLnRleHQubGVuZ3RoPT0xJiYhaXNXaG9sZUxpbmVVcGRhdGUoY20uZG9jLGNoYW5nZSkpe3JlZ0xpbmVDaGFuZ2UoY20sZnJvbS5saW5lLFwidGV4dFwiKTt9ZWxzZXtyZWdDaGFuZ2UoY20sZnJvbS5saW5lLHRvLmxpbmUrMSxsZW5kaWZmKTt9dmFyIGNoYW5nZXNIYW5kbGVyPWhhc0hhbmRsZXIoY20sXCJjaGFuZ2VzXCIpLGNoYW5nZUhhbmRsZXI9aGFzSGFuZGxlcihjbSxcImNoYW5nZVwiKTtpZihjaGFuZ2VIYW5kbGVyfHxjaGFuZ2VzSGFuZGxlcil7dmFyIG9iaj17ZnJvbTpmcm9tLHRvOnRvLHRleHQ6Y2hhbmdlLnRleHQscmVtb3ZlZDpjaGFuZ2UucmVtb3ZlZCxvcmlnaW46Y2hhbmdlLm9yaWdpbn07aWYoY2hhbmdlSGFuZGxlcil7c2lnbmFsTGF0ZXIoY20sXCJjaGFuZ2VcIixjbSxvYmopO31pZihjaGFuZ2VzSGFuZGxlcil7KGNtLmN1ck9wLmNoYW5nZU9ianN8fChjbS5jdXJPcC5jaGFuZ2VPYmpzPVtdKSkucHVzaChvYmopO319Y20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudT1udWxsO31mdW5jdGlvbiByZXBsYWNlUmFuZ2UoZG9jLGNvZGUsZnJvbSx0byxvcmlnaW4pe2lmKCF0byl7dG89ZnJvbTt9aWYoY21wKHRvLGZyb20pPDApe3ZhciB0bXA9dG87dG89ZnJvbTtmcm9tPXRtcDt9aWYodHlwZW9mIGNvZGU9PVwic3RyaW5nXCIpe2NvZGU9ZG9jLnNwbGl0TGluZXMoY29kZSk7fW1ha2VDaGFuZ2UoZG9jLHtmcm9tOmZyb20sdG86dG8sdGV4dDpjb2RlLG9yaWdpbjpvcmlnaW59KTt9Ly8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXG5mdW5jdGlvbiByZWJhc2VIaXN0U2VsU2luZ2xlKHBvcyxmcm9tLHRvLGRpZmYpe2lmKHRvPHBvcy5saW5lKXtwb3MubGluZSs9ZGlmZjt9ZWxzZSBpZihmcm9tPHBvcy5saW5lKXtwb3MubGluZT1mcm9tO3Bvcy5jaD0wO319Ly8gVHJpZXMgdG8gcmViYXNlIGFuIGFycmF5IG9mIGhpc3RvcnkgZXZlbnRzIGdpdmVuIGEgY2hhbmdlIGluIHRoZVxuLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxuLy8gZXZlbnQsIGFuZCBldmVyeXRoaW5nICdiZWhpbmQnIGl0LCBpcyBkaXNjYXJkZWQuIElmIHRoZSBjaGFuZ2UgaXNcbi8vIGJlZm9yZSB0aGUgZXZlbnQsIHRoZSBldmVudCdzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZC4gVXNlcyBhXG4vLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXG4vLyByZWFsbG9jYXRlIHRoZW0gYWxsIG9uIGV2ZXJ5IHJlYmFzZSwgYnV0IGFsc28gYXZvaWQgcHJvYmxlbXMgd2l0aFxuLy8gc2hhcmVkIHBvc2l0aW9uIG9iamVjdHMgYmVpbmcgdW5zYWZlbHkgdXBkYXRlZC5cbmZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSxmcm9tLHRvLGRpZmYpe2Zvcih2YXIgaT0wO2k8YXJyYXkubGVuZ3RoOysraSl7dmFyIHN1Yj1hcnJheVtpXSxvaz10cnVlO2lmKHN1Yi5yYW5nZXMpe2lmKCFzdWIuY29waWVkKXtzdWI9YXJyYXlbaV09c3ViLmRlZXBDb3B5KCk7c3ViLmNvcGllZD10cnVlO31mb3IodmFyIGo9MDtqPHN1Yi5yYW5nZXMubGVuZ3RoO2orKyl7cmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmFuY2hvcixmcm9tLHRvLGRpZmYpO3JlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5oZWFkLGZyb20sdG8sZGlmZik7fWNvbnRpbnVlO31mb3IodmFyIGokMT0wO2okMTxzdWIuY2hhbmdlcy5sZW5ndGg7KytqJDEpe3ZhciBjdXI9c3ViLmNoYW5nZXNbaiQxXTtpZih0bzxjdXIuZnJvbS5saW5lKXtjdXIuZnJvbT1Qb3MoY3VyLmZyb20ubGluZStkaWZmLGN1ci5mcm9tLmNoKTtjdXIudG89UG9zKGN1ci50by5saW5lK2RpZmYsY3VyLnRvLmNoKTt9ZWxzZSBpZihmcm9tPD1jdXIudG8ubGluZSl7b2s9ZmFsc2U7YnJlYWs7fX1pZighb2spe2FycmF5LnNwbGljZSgwLGkrMSk7aT0wO319fWZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCxjaGFuZ2Upe3ZhciBmcm9tPWNoYW5nZS5mcm9tLmxpbmUsdG89Y2hhbmdlLnRvLmxpbmUsZGlmZj1jaGFuZ2UudGV4dC5sZW5ndGgtKHRvLWZyb20pLTE7cmViYXNlSGlzdEFycmF5KGhpc3QuZG9uZSxmcm9tLHRvLGRpZmYpO3JlYmFzZUhpc3RBcnJheShoaXN0LnVuZG9uZSxmcm9tLHRvLGRpZmYpO30vLyBVdGlsaXR5IGZvciBhcHBseWluZyBhIGNoYW5nZSB0byBhIGxpbmUgYnkgaGFuZGxlIG9yIG51bWJlcixcbi8vIHJldHVybmluZyB0aGUgbnVtYmVyIGFuZCBvcHRpb25hbGx5IHJlZ2lzdGVyaW5nIHRoZSBsaW5lIGFzXG4vLyBjaGFuZ2VkLlxuZnVuY3Rpb24gY2hhbmdlTGluZShkb2MsaGFuZGxlLGNoYW5nZVR5cGUsb3Ape3ZhciBubz1oYW5kbGUsbGluZT1oYW5kbGU7aWYodHlwZW9mIGhhbmRsZT09XCJudW1iZXJcIil7bGluZT1nZXRMaW5lKGRvYyxjbGlwTGluZShkb2MsaGFuZGxlKSk7fWVsc2V7bm89bGluZU5vKGhhbmRsZSk7fWlmKG5vPT1udWxsKXtyZXR1cm4gbnVsbDt9aWYob3AobGluZSxubykmJmRvYy5jbSl7cmVnTGluZUNoYW5nZShkb2MuY20sbm8sY2hhbmdlVHlwZSk7fXJldHVybiBsaW5lO30vLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxuLy8gY2h1bmsgb2YgbGluZXMgaW4gdGhlbSwgYW5kIGJyYW5jaGVzLCB3aXRoIHVwIHRvIHRlbiBsZWF2ZXMgb3Jcbi8vIG90aGVyIGJyYW5jaCBub2RlcyBiZWxvdyB0aGVtLiBUaGUgdG9wIG5vZGUgaXMgYWx3YXlzIGEgYnJhbmNoXG4vLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXG4vLyBhZGRpdGlvbmFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMpLlxuLy9cbi8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cbi8vIGxpbmUgbnVtYmVycyB0byBsaW5lIG9iamVjdHMsIGFuZCB0byBnbyBmcm9tIG9iamVjdHMgdG8gbnVtYmVycy5cbi8vIEl0IGFsc28gaW5kZXhlcyBieSBoZWlnaHQsIGFuZCBpcyB1c2VkIHRvIGNvbnZlcnQgYmV0d2VlbiBoZWlnaHRcbi8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXG4vL1xuLy8gU2VlIGFsc28gaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9ibG9nL2NvZGVtaXJyb3ItbGluZS10cmVlLmh0bWxcbmZ1bmN0aW9uIExlYWZDaHVuayhsaW5lcyl7dmFyIHRoaXMkMT10aGlzO3RoaXMubGluZXM9bGluZXM7dGhpcy5wYXJlbnQ9bnVsbDt2YXIgaGVpZ2h0PTA7Zm9yKHZhciBpPTA7aTxsaW5lcy5sZW5ndGg7KytpKXtsaW5lc1tpXS5wYXJlbnQ9dGhpcyQxO2hlaWdodCs9bGluZXNbaV0uaGVpZ2h0O310aGlzLmhlaWdodD1oZWlnaHQ7fUxlYWZDaHVuay5wcm90b3R5cGU9e2NodW5rU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmVzLmxlbmd0aDt9LC8vIFJlbW92ZSB0aGUgbiBsaW5lcyBhdCBvZmZzZXQgJ2F0Jy5cbnJlbW92ZUlubmVyOmZ1bmN0aW9uKGF0LG4pe3ZhciB0aGlzJDE9dGhpcztmb3IodmFyIGk9YXQsZT1hdCtuO2k8ZTsrK2kpe3ZhciBsaW5lPXRoaXMkMS5saW5lc1tpXTt0aGlzJDEuaGVpZ2h0LT1saW5lLmhlaWdodDtjbGVhblVwTGluZShsaW5lKTtzaWduYWxMYXRlcihsaW5lLFwiZGVsZXRlXCIpO310aGlzLmxpbmVzLnNwbGljZShhdCxuKTt9LC8vIEhlbHBlciB1c2VkIHRvIGNvbGxhcHNlIGEgc21hbGwgYnJhbmNoIGludG8gYSBzaW5nbGUgbGVhZi5cbmNvbGxhcHNlOmZ1bmN0aW9uKGxpbmVzKXtsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLHRoaXMubGluZXMpO30sLy8gSW5zZXJ0IHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcyBhdCBvZmZzZXQgJ2F0JywgY291bnQgdGhlbSBhc1xuLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXG5pbnNlcnRJbm5lcjpmdW5jdGlvbihhdCxsaW5lcyxoZWlnaHQpe3ZhciB0aGlzJDE9dGhpczt0aGlzLmhlaWdodCs9aGVpZ2h0O3RoaXMubGluZXM9dGhpcy5saW5lcy5zbGljZSgwLGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSk7Zm9yKHZhciBpPTA7aTxsaW5lcy5sZW5ndGg7KytpKXtsaW5lc1tpXS5wYXJlbnQ9dGhpcyQxO319LC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cbml0ZXJOOmZ1bmN0aW9uKGF0LG4sb3Ape3ZhciB0aGlzJDE9dGhpcztmb3IodmFyIGU9YXQrbjthdDxlOysrYXQpe2lmKG9wKHRoaXMkMS5saW5lc1thdF0pKXtyZXR1cm4gdHJ1ZTt9fX19O2Z1bmN0aW9uIEJyYW5jaENodW5rKGNoaWxkcmVuKXt2YXIgdGhpcyQxPXRoaXM7dGhpcy5jaGlsZHJlbj1jaGlsZHJlbjt2YXIgc2l6ZT0wLGhlaWdodD0wO2Zvcih2YXIgaT0wO2k8Y2hpbGRyZW4ubGVuZ3RoOysraSl7dmFyIGNoPWNoaWxkcmVuW2ldO3NpemUrPWNoLmNodW5rU2l6ZSgpO2hlaWdodCs9Y2guaGVpZ2h0O2NoLnBhcmVudD10aGlzJDE7fXRoaXMuc2l6ZT1zaXplO3RoaXMuaGVpZ2h0PWhlaWdodDt0aGlzLnBhcmVudD1udWxsO31CcmFuY2hDaHVuay5wcm90b3R5cGU9e2NodW5rU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemU7fSxyZW1vdmVJbm5lcjpmdW5jdGlvbihhdCxuKXt2YXIgdGhpcyQxPXRoaXM7dGhpcy5zaXplLT1uO2Zvcih2YXIgaT0wO2k8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KytpKXt2YXIgY2hpbGQ9dGhpcyQxLmNoaWxkcmVuW2ldLHN6PWNoaWxkLmNodW5rU2l6ZSgpO2lmKGF0PHN6KXt2YXIgcm09TWF0aC5taW4obixzei1hdCksb2xkSGVpZ2h0PWNoaWxkLmhlaWdodDtjaGlsZC5yZW1vdmVJbm5lcihhdCxybSk7dGhpcyQxLmhlaWdodC09b2xkSGVpZ2h0LWNoaWxkLmhlaWdodDtpZihzej09cm0pe3RoaXMkMS5jaGlsZHJlbi5zcGxpY2UoaS0tLDEpO2NoaWxkLnBhcmVudD1udWxsO31pZigobi09cm0pPT0wKXticmVhazt9YXQ9MDt9ZWxzZXthdC09c3o7fX0vLyBJZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhbiAyNSBsaW5lcywgZW5zdXJlIHRoYXQgaXQgaXMgYVxuLy8gc2luZ2xlIGxlYWYgbm9kZS5cbmlmKHRoaXMuc2l6ZS1uPDI1JiYodGhpcy5jaGlsZHJlbi5sZW5ndGg+MXx8ISh0aGlzLmNoaWxkcmVuWzBdaW5zdGFuY2VvZiBMZWFmQ2h1bmspKSl7dmFyIGxpbmVzPVtdO3RoaXMuY29sbGFwc2UobGluZXMpO3RoaXMuY2hpbGRyZW49W25ldyBMZWFmQ2h1bmsobGluZXMpXTt0aGlzLmNoaWxkcmVuWzBdLnBhcmVudD10aGlzO319LGNvbGxhcHNlOmZ1bmN0aW9uKGxpbmVzKXt2YXIgdGhpcyQxPXRoaXM7Zm9yKHZhciBpPTA7aTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsrK2kpe3RoaXMkMS5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcyk7fX0saW5zZXJ0SW5uZXI6ZnVuY3Rpb24oYXQsbGluZXMsaGVpZ2h0KXt2YXIgdGhpcyQxPXRoaXM7dGhpcy5zaXplKz1saW5lcy5sZW5ndGg7dGhpcy5oZWlnaHQrPWhlaWdodDtmb3IodmFyIGk9MDtpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOysraSl7dmFyIGNoaWxkPXRoaXMkMS5jaGlsZHJlbltpXSxzej1jaGlsZC5jaHVua1NpemUoKTtpZihhdDw9c3ope2NoaWxkLmluc2VydElubmVyKGF0LGxpbmVzLGhlaWdodCk7aWYoY2hpbGQubGluZXMmJmNoaWxkLmxpbmVzLmxlbmd0aD41MCl7Ly8gVG8gYXZvaWQgbWVtb3J5IHRocmFzaGluZyB3aGVuIGNoaWxkLmxpbmVzIGlzIGh1Z2UgKGUuZy4gZmlyc3QgdmlldyBvZiBhIGxhcmdlIGZpbGUpLCBpdCdzIG5ldmVyIHNwbGljZWQuXG4vLyBJbnN0ZWFkLCBzbWFsbCBzbGljZXMgYXJlIHRha2VuLiBUaGV5J3JlIHRha2VuIGluIG9yZGVyIGJlY2F1c2Ugc2VxdWVudGlhbCBtZW1vcnkgYWNjZXNzZXMgYXJlIGZhc3Rlc3QuXG52YXIgcmVtYWluaW5nPWNoaWxkLmxpbmVzLmxlbmd0aCUyNSsyNTtmb3IodmFyIHBvcz1yZW1haW5pbmc7cG9zPGNoaWxkLmxpbmVzLmxlbmd0aDspe3ZhciBsZWFmPW5ldyBMZWFmQ2h1bmsoY2hpbGQubGluZXMuc2xpY2UocG9zLHBvcys9MjUpKTtjaGlsZC5oZWlnaHQtPWxlYWYuaGVpZ2h0O3RoaXMkMS5jaGlsZHJlbi5zcGxpY2UoKytpLDAsbGVhZik7bGVhZi5wYXJlbnQ9dGhpcyQxO31jaGlsZC5saW5lcz1jaGlsZC5saW5lcy5zbGljZSgwLHJlbWFpbmluZyk7dGhpcyQxLm1heWJlU3BpbGwoKTt9YnJlYWs7fWF0LT1zejt9fSwvLyBXaGVuIGEgbm9kZSBoYXMgZ3Jvd24sIGNoZWNrIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHNwbGl0LlxubWF5YmVTcGlsbDpmdW5jdGlvbigpe2lmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoPD0xMCl7cmV0dXJuO312YXIgbWU9dGhpcztkb3t2YXIgc3BpbGxlZD1tZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoLTUsNSk7dmFyIHNpYmxpbmc9bmV3IEJyYW5jaENodW5rKHNwaWxsZWQpO2lmKCFtZS5wYXJlbnQpey8vIEJlY29tZSB0aGUgcGFyZW50IG5vZGVcbnZhciBjb3B5PW5ldyBCcmFuY2hDaHVuayhtZS5jaGlsZHJlbik7Y29weS5wYXJlbnQ9bWU7bWUuY2hpbGRyZW49W2NvcHksc2libGluZ107bWU9Y29weTt9ZWxzZXttZS5zaXplLT1zaWJsaW5nLnNpemU7bWUuaGVpZ2h0LT1zaWJsaW5nLmhlaWdodDt2YXIgbXlJbmRleD1pbmRleE9mKG1lLnBhcmVudC5jaGlsZHJlbixtZSk7bWUucGFyZW50LmNoaWxkcmVuLnNwbGljZShteUluZGV4KzEsMCxzaWJsaW5nKTt9c2libGluZy5wYXJlbnQ9bWUucGFyZW50O313aGlsZShtZS5jaGlsZHJlbi5sZW5ndGg+MTApO21lLnBhcmVudC5tYXliZVNwaWxsKCk7fSxpdGVyTjpmdW5jdGlvbihhdCxuLG9wKXt2YXIgdGhpcyQxPXRoaXM7Zm9yKHZhciBpPTA7aTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsrK2kpe3ZhciBjaGlsZD10aGlzJDEuY2hpbGRyZW5baV0sc3o9Y2hpbGQuY2h1bmtTaXplKCk7aWYoYXQ8c3ope3ZhciB1c2VkPU1hdGgubWluKG4sc3otYXQpO2lmKGNoaWxkLml0ZXJOKGF0LHVzZWQsb3ApKXtyZXR1cm4gdHJ1ZTt9aWYoKG4tPXVzZWQpPT0wKXticmVhazt9YXQ9MDt9ZWxzZXthdC09c3o7fX19fTsvLyBMaW5lIHdpZGdldHMgYXJlIGJsb2NrIGVsZW1lbnRzIGRpc3BsYXllZCBhYm92ZSBvciBiZWxvdyBhIGxpbmUuXG5mdW5jdGlvbiBMaW5lV2lkZ2V0KGRvYyxub2RlLG9wdGlvbnMpe3ZhciB0aGlzJDE9dGhpcztpZihvcHRpb25zKXtmb3IodmFyIG9wdCBpbiBvcHRpb25zKXtpZihvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpe3RoaXMkMVtvcHRdPW9wdGlvbnNbb3B0XTt9fX10aGlzLmRvYz1kb2M7dGhpcy5ub2RlPW5vZGU7fWV2ZW50TWl4aW4oTGluZVdpZGdldCk7ZnVuY3Rpb24gYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSxsaW5lLGRpZmYpe2lmKGhlaWdodEF0TGluZShsaW5lKTwoY20uY3VyT3AmJmNtLmN1ck9wLnNjcm9sbFRvcHx8Y20uZG9jLnNjcm9sbFRvcCkpe2FkZFRvU2Nyb2xsUG9zKGNtLG51bGwsZGlmZik7fX1MaW5lV2lkZ2V0LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3ZhciB0aGlzJDE9dGhpczt2YXIgY209dGhpcy5kb2MuY20sd3M9dGhpcy5saW5lLndpZGdldHMsbGluZT10aGlzLmxpbmUsbm89bGluZU5vKGxpbmUpO2lmKG5vPT1udWxsfHwhd3Mpe3JldHVybjt9Zm9yKHZhciBpPTA7aTx3cy5sZW5ndGg7KytpKXtpZih3c1tpXT09dGhpcyQxKXt3cy5zcGxpY2UoaS0tLDEpO319aWYoIXdzLmxlbmd0aCl7bGluZS53aWRnZXRzPW51bGw7fXZhciBoZWlnaHQ9d2lkZ2V0SGVpZ2h0KHRoaXMpO3VwZGF0ZUxpbmVIZWlnaHQobGluZSxNYXRoLm1heCgwLGxpbmUuaGVpZ2h0LWhlaWdodCkpO2lmKGNtKXtydW5Jbk9wKGNtLGZ1bmN0aW9uKCl7YWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSxsaW5lLC1oZWlnaHQpO3JlZ0xpbmVDaGFuZ2UoY20sbm8sXCJ3aWRnZXRcIik7fSk7fX07TGluZVdpZGdldC5wcm90b3R5cGUuY2hhbmdlZD1mdW5jdGlvbigpe3ZhciBvbGRIPXRoaXMuaGVpZ2h0LGNtPXRoaXMuZG9jLmNtLGxpbmU9dGhpcy5saW5lO3RoaXMuaGVpZ2h0PW51bGw7dmFyIGRpZmY9d2lkZ2V0SGVpZ2h0KHRoaXMpLW9sZEg7aWYoIWRpZmYpe3JldHVybjt9dXBkYXRlTGluZUhlaWdodChsaW5lLGxpbmUuaGVpZ2h0K2RpZmYpO2lmKGNtKXtydW5Jbk9wKGNtLGZ1bmN0aW9uKCl7Y20uY3VyT3AuZm9yY2VVcGRhdGU9dHJ1ZTthZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLGxpbmUsZGlmZik7fSk7fX07ZnVuY3Rpb24gYWRkTGluZVdpZGdldChkb2MsaGFuZGxlLG5vZGUsb3B0aW9ucyl7dmFyIHdpZGdldD1uZXcgTGluZVdpZGdldChkb2Msbm9kZSxvcHRpb25zKTt2YXIgY209ZG9jLmNtO2lmKGNtJiZ3aWRnZXQubm9IU2Nyb2xsKXtjbS5kaXNwbGF5LmFsaWduV2lkZ2V0cz10cnVlO31jaGFuZ2VMaW5lKGRvYyxoYW5kbGUsXCJ3aWRnZXRcIixmdW5jdGlvbihsaW5lKXt2YXIgd2lkZ2V0cz1saW5lLndpZGdldHN8fChsaW5lLndpZGdldHM9W10pO2lmKHdpZGdldC5pbnNlcnRBdD09bnVsbCl7d2lkZ2V0cy5wdXNoKHdpZGdldCk7fWVsc2V7d2lkZ2V0cy5zcGxpY2UoTWF0aC5taW4od2lkZ2V0cy5sZW5ndGgtMSxNYXRoLm1heCgwLHdpZGdldC5pbnNlcnRBdCkpLDAsd2lkZ2V0KTt9d2lkZ2V0LmxpbmU9bGluZTtpZihjbSYmIWxpbmVJc0hpZGRlbihkb2MsbGluZSkpe3ZhciBhYm92ZVZpc2libGU9aGVpZ2h0QXRMaW5lKGxpbmUpPGRvYy5zY3JvbGxUb3A7dXBkYXRlTGluZUhlaWdodChsaW5lLGxpbmUuaGVpZ2h0K3dpZGdldEhlaWdodCh3aWRnZXQpKTtpZihhYm92ZVZpc2libGUpe2FkZFRvU2Nyb2xsUG9zKGNtLG51bGwsd2lkZ2V0LmhlaWdodCk7fWNtLmN1ck9wLmZvcmNlVXBkYXRlPXRydWU7fXJldHVybiB0cnVlO30pO3JldHVybiB3aWRnZXQ7fS8vIFRFWFRNQVJLRVJTXG4vLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXG4vLyBoYW5kbGUgdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhciBvciBmaW5kIGEgbWFya2VkIHBvc2l0aW9uIGluIHRoZVxuLy8gZG9jdW1lbnQuIExpbmUgb2JqZWN0cyBob2xkIGFycmF5cyAobWFya2VkU3BhbnMpIGNvbnRhaW5pbmdcbi8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXG4vLyBpbmRpY2F0aW5nIHRoYXQgc3VjaCBhIG1hcmtlciBpcyBwcmVzZW50IG9uIHRoYXQgbGluZS4gTXVsdGlwbGVcbi8vIGxpbmVzIG1heSBwb2ludCB0byB0aGUgc2FtZSBtYXJrZXIgd2hlbiBpdCBzcGFucyBhY3Jvc3MgbGluZXMuXG4vLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxuLy8gbWFya2VyIGNvbnRpbnVlcyBiZXlvbmQgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgbGluZS4gTWFya2VycyBoYXZlXG4vLyBsaW5rcyBiYWNrIHRvIHRoZSBsaW5lcyB0aGV5IGN1cnJlbnRseSB0b3VjaC5cbi8vIENvbGxhcHNlZCBtYXJrZXJzIGhhdmUgdW5pcXVlIGlkcywgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBvcmRlclxuLy8gdGhlbSwgd2hpY2ggaXMgbmVlZGVkIGZvciB1bmlxdWVseSBkZXRlcm1pbmluZyBhbiBvdXRlciBtYXJrZXJcbi8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cbnZhciBuZXh0TWFya2VySWQ9MDtmdW5jdGlvbiBUZXh0TWFya2VyKGRvYyx0eXBlKXt0aGlzLmxpbmVzPVtdO3RoaXMudHlwZT10eXBlO3RoaXMuZG9jPWRvYzt0aGlzLmlkPSsrbmV4dE1hcmtlcklkO31ldmVudE1peGluKFRleHRNYXJrZXIpOy8vIENsZWFyIHRoZSBtYXJrZXIuXG5UZXh0TWFya2VyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3ZhciB0aGlzJDE9dGhpcztpZih0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKXtyZXR1cm47fXZhciBjbT10aGlzLmRvYy5jbSx3aXRoT3A9Y20mJiFjbS5jdXJPcDtpZih3aXRoT3Ape3N0YXJ0T3BlcmF0aW9uKGNtKTt9aWYoaGFzSGFuZGxlcih0aGlzLFwiY2xlYXJcIikpe3ZhciBmb3VuZD10aGlzLmZpbmQoKTtpZihmb3VuZCl7c2lnbmFsTGF0ZXIodGhpcyxcImNsZWFyXCIsZm91bmQuZnJvbSxmb3VuZC50byk7fX12YXIgbWluPW51bGwsbWF4PW51bGw7Zm9yKHZhciBpPTA7aTx0aGlzLmxpbmVzLmxlbmd0aDsrK2kpe3ZhciBsaW5lPXRoaXMkMS5saW5lc1tpXTt2YXIgc3Bhbj1nZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsdGhpcyQxKTtpZihjbSYmIXRoaXMkMS5jb2xsYXBzZWQpe3JlZ0xpbmVDaGFuZ2UoY20sbGluZU5vKGxpbmUpLFwidGV4dFwiKTt9ZWxzZSBpZihjbSl7aWYoc3Bhbi50byE9bnVsbCl7bWF4PWxpbmVObyhsaW5lKTt9aWYoc3Bhbi5mcm9tIT1udWxsKXttaW49bGluZU5vKGxpbmUpO319bGluZS5tYXJrZWRTcGFucz1yZW1vdmVNYXJrZWRTcGFuKGxpbmUubWFya2VkU3BhbnMsc3Bhbik7aWYoc3Bhbi5mcm9tPT1udWxsJiZ0aGlzJDEuY29sbGFwc2VkJiYhbGluZUlzSGlkZGVuKHRoaXMkMS5kb2MsbGluZSkmJmNtKXt1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsdGV4dEhlaWdodChjbS5kaXNwbGF5KSk7fX1pZihjbSYmdGhpcy5jb2xsYXBzZWQmJiFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyl7Zm9yKHZhciBpJDE9MDtpJDE8dGhpcy5saW5lcy5sZW5ndGg7KytpJDEpe3ZhciB2aXN1YWw9dmlzdWFsTGluZSh0aGlzJDEubGluZXNbaSQxXSksbGVuPWxpbmVMZW5ndGgodmlzdWFsKTtpZihsZW4+Y20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKXtjbS5kaXNwbGF5Lm1heExpbmU9dmlzdWFsO2NtLmRpc3BsYXkubWF4TGluZUxlbmd0aD1sZW47Y20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZD10cnVlO319fWlmKG1pbiE9bnVsbCYmY20mJnRoaXMuY29sbGFwc2VkKXtyZWdDaGFuZ2UoY20sbWluLG1heCsxKTt9dGhpcy5saW5lcy5sZW5ndGg9MDt0aGlzLmV4cGxpY2l0bHlDbGVhcmVkPXRydWU7aWYodGhpcy5hdG9taWMmJnRoaXMuZG9jLmNhbnRFZGl0KXt0aGlzLmRvYy5jYW50RWRpdD1mYWxzZTtpZihjbSl7cmVDaGVja1NlbGVjdGlvbihjbS5kb2MpO319aWYoY20pe3NpZ25hbExhdGVyKGNtLFwibWFya2VyQ2xlYXJlZFwiLGNtLHRoaXMpO31pZih3aXRoT3Ape2VuZE9wZXJhdGlvbihjbSk7fWlmKHRoaXMucGFyZW50KXt0aGlzLnBhcmVudC5jbGVhcigpO319Oy8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgaW4gdGhlIGRvY3VtZW50LiBSZXR1cm5zIGEge2Zyb20sXG4vLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXG4vLyAtLSAwIChib3RoKSwgLTEgKGxlZnQpLCBvciAxIChyaWdodCkuIFdoZW4gbGluZU9iaiBpcyB0cnVlLCB0aGVcbi8vIFBvcyBvYmplY3RzIHJldHVybmVkIGNvbnRhaW4gYSBsaW5lIG9iamVjdCwgcmF0aGVyIHRoYW4gYSBsaW5lXG4vLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxuVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihzaWRlLGxpbmVPYmope3ZhciB0aGlzJDE9dGhpcztpZihzaWRlPT1udWxsJiZ0aGlzLnR5cGU9PVwiYm9va21hcmtcIil7c2lkZT0xO312YXIgZnJvbSx0bztmb3IodmFyIGk9MDtpPHRoaXMubGluZXMubGVuZ3RoOysraSl7dmFyIGxpbmU9dGhpcyQxLmxpbmVzW2ldO3ZhciBzcGFuPWdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucyx0aGlzJDEpO2lmKHNwYW4uZnJvbSE9bnVsbCl7ZnJvbT1Qb3MobGluZU9iaj9saW5lOmxpbmVObyhsaW5lKSxzcGFuLmZyb20pO2lmKHNpZGU9PS0xKXtyZXR1cm4gZnJvbTt9fWlmKHNwYW4udG8hPW51bGwpe3RvPVBvcyhsaW5lT2JqP2xpbmU6bGluZU5vKGxpbmUpLHNwYW4udG8pO2lmKHNpZGU9PTEpe3JldHVybiB0bzt9fX1yZXR1cm4gZnJvbSYme2Zyb206ZnJvbSx0bzp0b307fTsvLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XG4vLyBzaG91bGQgYmUgcmVjb21wdXRlZC5cblRleHRNYXJrZXIucHJvdG90eXBlLmNoYW5nZWQ9ZnVuY3Rpb24oKXt2YXIgcG9zPXRoaXMuZmluZCgtMSx0cnVlKSx3aWRnZXQ9dGhpcyxjbT10aGlzLmRvYy5jbTtpZighcG9zfHwhY20pe3JldHVybjt9cnVuSW5PcChjbSxmdW5jdGlvbigpe3ZhciBsaW5lPXBvcy5saW5lLGxpbmVOPWxpbmVObyhwb3MubGluZSk7dmFyIHZpZXc9ZmluZFZpZXdGb3JMaW5lKGNtLGxpbmVOKTtpZih2aWV3KXtjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKHZpZXcpO2NtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQ9Y20uY3VyT3AuZm9yY2VVcGRhdGU9dHJ1ZTt9Y20uY3VyT3AudXBkYXRlTWF4TGluZT10cnVlO2lmKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYyxsaW5lKSYmd2lkZ2V0LmhlaWdodCE9bnVsbCl7dmFyIG9sZEhlaWdodD13aWRnZXQuaGVpZ2h0O3dpZGdldC5oZWlnaHQ9bnVsbDt2YXIgZEhlaWdodD13aWRnZXRIZWlnaHQod2lkZ2V0KS1vbGRIZWlnaHQ7aWYoZEhlaWdodCl7dXBkYXRlTGluZUhlaWdodChsaW5lLGxpbmUuaGVpZ2h0K2RIZWlnaHQpO319fSk7fTtUZXh0TWFya2VyLnByb3RvdHlwZS5hdHRhY2hMaW5lPWZ1bmN0aW9uKGxpbmUpe2lmKCF0aGlzLmxpbmVzLmxlbmd0aCYmdGhpcy5kb2MuY20pe3ZhciBvcD10aGlzLmRvYy5jbS5jdXJPcDtpZighb3AubWF5YmVIaWRkZW5NYXJrZXJzfHxpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2Vycyx0aGlzKT09LTEpeyhvcC5tYXliZVVuaGlkZGVuTWFya2Vyc3x8KG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzPVtdKSkucHVzaCh0aGlzKTt9fXRoaXMubGluZXMucHVzaChsaW5lKTt9O1RleHRNYXJrZXIucHJvdG90eXBlLmRldGFjaExpbmU9ZnVuY3Rpb24obGluZSl7dGhpcy5saW5lcy5zcGxpY2UoaW5kZXhPZih0aGlzLmxpbmVzLGxpbmUpLDEpO2lmKCF0aGlzLmxpbmVzLmxlbmd0aCYmdGhpcy5kb2MuY20pe3ZhciBvcD10aGlzLmRvYy5jbS5jdXJPcDsob3AubWF5YmVIaWRkZW5NYXJrZXJzfHwob3AubWF5YmVIaWRkZW5NYXJrZXJzPVtdKSkucHVzaCh0aGlzKTt9fTsvLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcbmZ1bmN0aW9uIG1hcmtUZXh0KGRvYyxmcm9tLHRvLG9wdGlvbnMsdHlwZSl7Ly8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XG4vLyAobWFya1RleHRTaGFyZWQgd2lsbCBjYWxsIG91dCB0byB0aGlzIGFnYWluLCBvbmNlIHBlclxuLy8gZG9jdW1lbnQpLlxuaWYob3B0aW9ucyYmb3B0aW9ucy5zaGFyZWQpe3JldHVybiBtYXJrVGV4dFNoYXJlZChkb2MsZnJvbSx0byxvcHRpb25zLHR5cGUpO30vLyBFbnN1cmUgd2UgYXJlIGluIGFuIG9wZXJhdGlvbi5cbmlmKGRvYy5jbSYmIWRvYy5jbS5jdXJPcCl7cmV0dXJuIG9wZXJhdGlvbihkb2MuY20sbWFya1RleHQpKGRvYyxmcm9tLHRvLG9wdGlvbnMsdHlwZSk7fXZhciBtYXJrZXI9bmV3IFRleHRNYXJrZXIoZG9jLHR5cGUpLGRpZmY9Y21wKGZyb20sdG8pO2lmKG9wdGlvbnMpe2NvcHlPYmoob3B0aW9ucyxtYXJrZXIsZmFsc2UpO30vLyBEb24ndCBjb25uZWN0IGVtcHR5IG1hcmtlcnMgdW5sZXNzIGNsZWFyV2hlbkVtcHR5IGlzIGZhbHNlXG5pZihkaWZmPjB8fGRpZmY9PTAmJm1hcmtlci5jbGVhcldoZW5FbXB0eSE9PWZhbHNlKXtyZXR1cm4gbWFya2VyO31pZihtYXJrZXIucmVwbGFjZWRXaXRoKXsvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcbm1hcmtlci5jb2xsYXBzZWQ9dHJ1ZTttYXJrZXIud2lkZ2V0Tm9kZT1lbHQoXCJzcGFuXCIsW21hcmtlci5yZXBsYWNlZFdpdGhdLFwiQ29kZU1pcnJvci13aWRnZXRcIik7aWYoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpe21hcmtlci53aWRnZXROb2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIixcInRydWVcIik7fWlmKG9wdGlvbnMuaW5zZXJ0TGVmdCl7bWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdD10cnVlO319aWYobWFya2VyLmNvbGxhcHNlZCl7aWYoY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsZnJvbS5saW5lLGZyb20sdG8sbWFya2VyKXx8ZnJvbS5saW5lIT10by5saW5lJiZjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYyx0by5saW5lLGZyb20sdG8sbWFya2VyKSl7dGhyb3cgbmV3IEVycm9yKFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVwiKTt9c2VlQ29sbGFwc2VkU3BhbnMoKTt9aWYobWFya2VyLmFkZFRvSGlzdG9yeSl7YWRkQ2hhbmdlVG9IaXN0b3J5KGRvYyx7ZnJvbTpmcm9tLHRvOnRvLG9yaWdpbjpcIm1hcmtUZXh0XCJ9LGRvYy5zZWwsTmFOKTt9dmFyIGN1ckxpbmU9ZnJvbS5saW5lLGNtPWRvYy5jbSx1cGRhdGVNYXhMaW5lO2RvYy5pdGVyKGN1ckxpbmUsdG8ubGluZSsxLGZ1bmN0aW9uKGxpbmUpe2lmKGNtJiZtYXJrZXIuY29sbGFwc2VkJiYhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcmJnZpc3VhbExpbmUobGluZSk9PWNtLmRpc3BsYXkubWF4TGluZSl7dXBkYXRlTWF4TGluZT10cnVlO31pZihtYXJrZXIuY29sbGFwc2VkJiZjdXJMaW5lIT1mcm9tLmxpbmUpe3VwZGF0ZUxpbmVIZWlnaHQobGluZSwwKTt9YWRkTWFya2VkU3BhbihsaW5lLG5ldyBNYXJrZWRTcGFuKG1hcmtlcixjdXJMaW5lPT1mcm9tLmxpbmU/ZnJvbS5jaDpudWxsLGN1ckxpbmU9PXRvLmxpbmU/dG8uY2g6bnVsbCkpOysrY3VyTGluZTt9KTsvLyBsaW5lSXNIaWRkZW4gZGVwZW5kcyBvbiB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNwYW5zLCBzbyBuZWVkcyBhIHNlY29uZCBwYXNzXG5pZihtYXJrZXIuY29sbGFwc2VkKXtkb2MuaXRlcihmcm9tLmxpbmUsdG8ubGluZSsxLGZ1bmN0aW9uKGxpbmUpe2lmKGxpbmVJc0hpZGRlbihkb2MsbGluZSkpe3VwZGF0ZUxpbmVIZWlnaHQobGluZSwwKTt9fSk7fWlmKG1hcmtlci5jbGVhck9uRW50ZXIpe29uKG1hcmtlcixcImJlZm9yZUN1cnNvckVudGVyXCIsZnVuY3Rpb24oKXtyZXR1cm4gbWFya2VyLmNsZWFyKCk7fSk7fWlmKG1hcmtlci5yZWFkT25seSl7c2VlUmVhZE9ubHlTcGFucygpO2lmKGRvYy5oaXN0b3J5LmRvbmUubGVuZ3RofHxkb2MuaGlzdG9yeS51bmRvbmUubGVuZ3RoKXtkb2MuY2xlYXJIaXN0b3J5KCk7fX1pZihtYXJrZXIuY29sbGFwc2VkKXttYXJrZXIuaWQ9KytuZXh0TWFya2VySWQ7bWFya2VyLmF0b21pYz10cnVlO31pZihjbSl7Ly8gU3luYyBlZGl0b3Igc3RhdGVcbmlmKHVwZGF0ZU1heExpbmUpe2NtLmN1ck9wLnVwZGF0ZU1heExpbmU9dHJ1ZTt9aWYobWFya2VyLmNvbGxhcHNlZCl7cmVnQ2hhbmdlKGNtLGZyb20ubGluZSx0by5saW5lKzEpO31lbHNlIGlmKG1hcmtlci5jbGFzc05hbWV8fG1hcmtlci50aXRsZXx8bWFya2VyLnN0YXJ0U3R5bGV8fG1hcmtlci5lbmRTdHlsZXx8bWFya2VyLmNzcyl7Zm9yKHZhciBpPWZyb20ubGluZTtpPD10by5saW5lO2krKyl7cmVnTGluZUNoYW5nZShjbSxpLFwidGV4dFwiKTt9fWlmKG1hcmtlci5hdG9taWMpe3JlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTt9c2lnbmFsTGF0ZXIoY20sXCJtYXJrZXJBZGRlZFwiLGNtLG1hcmtlcik7fXJldHVybiBtYXJrZXI7fS8vIFNIQVJFRCBURVhUTUFSS0VSU1xuLy8gQSBzaGFyZWQgbWFya2VyIHNwYW5zIG11bHRpcGxlIGxpbmtlZCBkb2N1bWVudHMuIEl0IGlzXG4vLyBpbXBsZW1lbnRlZCBhcyBhIG1ldGEtbWFya2VyLW9iamVjdCBjb250cm9sbGluZyBtdWx0aXBsZSBub3JtYWxcbi8vIG1hcmtlcnMuXG5mdW5jdGlvbiBTaGFyZWRUZXh0TWFya2VyKG1hcmtlcnMscHJpbWFyeSl7dmFyIHRoaXMkMT10aGlzO3RoaXMubWFya2Vycz1tYXJrZXJzO3RoaXMucHJpbWFyeT1wcmltYXJ5O2Zvcih2YXIgaT0wO2k8bWFya2Vycy5sZW5ndGg7KytpKXttYXJrZXJzW2ldLnBhcmVudD10aGlzJDE7fX1ldmVudE1peGluKFNoYXJlZFRleHRNYXJrZXIpO1NoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIHRoaXMkMT10aGlzO2lmKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpe3JldHVybjt9dGhpcy5leHBsaWNpdGx5Q2xlYXJlZD10cnVlO2Zvcih2YXIgaT0wO2k8dGhpcy5tYXJrZXJzLmxlbmd0aDsrK2kpe3RoaXMkMS5tYXJrZXJzW2ldLmNsZWFyKCk7fXNpZ25hbExhdGVyKHRoaXMsXCJjbGVhclwiKTt9O1NoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmZpbmQ9ZnVuY3Rpb24oc2lkZSxsaW5lT2JqKXtyZXR1cm4gdGhpcy5wcmltYXJ5LmZpbmQoc2lkZSxsaW5lT2JqKTt9O2Z1bmN0aW9uIG1hcmtUZXh0U2hhcmVkKGRvYyxmcm9tLHRvLG9wdGlvbnMsdHlwZSl7b3B0aW9ucz1jb3B5T2JqKG9wdGlvbnMpO29wdGlvbnMuc2hhcmVkPWZhbHNlO3ZhciBtYXJrZXJzPVttYXJrVGV4dChkb2MsZnJvbSx0byxvcHRpb25zLHR5cGUpXSxwcmltYXJ5PW1hcmtlcnNbMF07dmFyIHdpZGdldD1vcHRpb25zLndpZGdldE5vZGU7bGlua2VkRG9jcyhkb2MsZnVuY3Rpb24oZG9jKXtpZih3aWRnZXQpe29wdGlvbnMud2lkZ2V0Tm9kZT13aWRnZXQuY2xvbmVOb2RlKHRydWUpO31tYXJrZXJzLnB1c2gobWFya1RleHQoZG9jLGNsaXBQb3MoZG9jLGZyb20pLGNsaXBQb3MoZG9jLHRvKSxvcHRpb25zLHR5cGUpKTtmb3IodmFyIGk9MDtpPGRvYy5saW5rZWQubGVuZ3RoOysraSl7aWYoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCl7cmV0dXJuO319cHJpbWFyeT1sc3QobWFya2Vycyk7fSk7cmV0dXJuIG5ldyBTaGFyZWRUZXh0TWFya2VyKG1hcmtlcnMscHJpbWFyeSk7fWZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYyl7cmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwwKSxkb2MuY2xpcFBvcyhQb3MoZG9jLmxhc3RMaW5lKCkpKSxmdW5jdGlvbihtKXtyZXR1cm4gbS5wYXJlbnQ7fSk7fWZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYyxtYXJrZXJzKXtmb3IodmFyIGk9MDtpPG1hcmtlcnMubGVuZ3RoO2krKyl7dmFyIG1hcmtlcj1tYXJrZXJzW2ldLHBvcz1tYXJrZXIuZmluZCgpO3ZhciBtRnJvbT1kb2MuY2xpcFBvcyhwb3MuZnJvbSksbVRvPWRvYy5jbGlwUG9zKHBvcy50byk7aWYoY21wKG1Gcm9tLG1Ubykpe3ZhciBzdWJNYXJrPW1hcmtUZXh0KGRvYyxtRnJvbSxtVG8sbWFya2VyLnByaW1hcnksbWFya2VyLnByaW1hcnkudHlwZSk7bWFya2VyLm1hcmtlcnMucHVzaChzdWJNYXJrKTtzdWJNYXJrLnBhcmVudD1tYXJrZXI7fX19ZnVuY3Rpb24gZGV0YWNoU2hhcmVkTWFya2VycyhtYXJrZXJzKXt2YXIgbG9vcD1mdW5jdGlvbihpKXt2YXIgbWFya2VyPW1hcmtlcnNbaV0sbGlua2VkPVttYXJrZXIucHJpbWFyeS5kb2NdO2xpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLGZ1bmN0aW9uKGQpe3JldHVybiBsaW5rZWQucHVzaChkKTt9KTtmb3IodmFyIGo9MDtqPG1hcmtlci5tYXJrZXJzLmxlbmd0aDtqKyspe3ZhciBzdWJNYXJrZXI9bWFya2VyLm1hcmtlcnNbal07aWYoaW5kZXhPZihsaW5rZWQsc3ViTWFya2VyLmRvYyk9PS0xKXtzdWJNYXJrZXIucGFyZW50PW51bGw7bWFya2VyLm1hcmtlcnMuc3BsaWNlKGotLSwxKTt9fX07Zm9yKHZhciBpPTA7aTxtYXJrZXJzLmxlbmd0aDtpKyspbG9vcChpKTt9dmFyIG5leHREb2NJZD0wO3ZhciBEb2M9ZnVuY3Rpb24odGV4dCxtb2RlLGZpcnN0TGluZSxsaW5lU2VwKXtpZighKHRoaXMgaW5zdGFuY2VvZiBEb2MpKXtyZXR1cm4gbmV3IERvYyh0ZXh0LG1vZGUsZmlyc3RMaW5lLGxpbmVTZXApO31pZihmaXJzdExpbmU9PW51bGwpe2ZpcnN0TGluZT0wO31CcmFuY2hDaHVuay5jYWxsKHRoaXMsW25ldyBMZWFmQ2h1bmsoW25ldyBMaW5lKFwiXCIsbnVsbCldKV0pO3RoaXMuZmlyc3Q9Zmlyc3RMaW5lO3RoaXMuc2Nyb2xsVG9wPXRoaXMuc2Nyb2xsTGVmdD0wO3RoaXMuY2FudEVkaXQ9ZmFsc2U7dGhpcy5jbGVhbkdlbmVyYXRpb249MTt0aGlzLmZyb250aWVyPWZpcnN0TGluZTt2YXIgc3RhcnQ9UG9zKGZpcnN0TGluZSwwKTt0aGlzLnNlbD1zaW1wbGVTZWxlY3Rpb24oc3RhcnQpO3RoaXMuaGlzdG9yeT1uZXcgSGlzdG9yeShudWxsKTt0aGlzLmlkPSsrbmV4dERvY0lkO3RoaXMubW9kZU9wdGlvbj1tb2RlO3RoaXMubGluZVNlcD1saW5lU2VwO3RoaXMuZXh0ZW5kPWZhbHNlO2lmKHR5cGVvZiB0ZXh0PT1cInN0cmluZ1wiKXt0ZXh0PXRoaXMuc3BsaXRMaW5lcyh0ZXh0KTt9dXBkYXRlRG9jKHRoaXMse2Zyb206c3RhcnQsdG86c3RhcnQsdGV4dDp0ZXh0fSk7c2V0U2VsZWN0aW9uKHRoaXMsc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSxzZWxfZG9udFNjcm9sbCk7fTtEb2MucHJvdG90eXBlPWNyZWF0ZU9iaihCcmFuY2hDaHVuay5wcm90b3R5cGUse2NvbnN0cnVjdG9yOkRvYywvLyBJdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LiBTdXBwb3J0cyB0d28gZm9ybXMgLS0gd2l0aCBvbmx5IG9uZVxuLy8gYXJndW1lbnQsIGl0IGNhbGxzIHRoYXQgZm9yIGVhY2ggbGluZSBpbiB0aGUgZG9jdW1lbnQuIFdpdGhcbi8vIHRocmVlLCBpdCBpdGVyYXRlcyBvdmVyIHRoZSByYW5nZSBnaXZlbiBieSB0aGUgZmlyc3QgdHdvICh3aXRoXG4vLyB0aGUgc2Vjb25kIGJlaW5nIG5vbi1pbmNsdXNpdmUpLlxuaXRlcjpmdW5jdGlvbihmcm9tLHRvLG9wKXtpZihvcCl7dGhpcy5pdGVyTihmcm9tLXRoaXMuZmlyc3QsdG8tZnJvbSxvcCk7fWVsc2V7dGhpcy5pdGVyTih0aGlzLmZpcnN0LHRoaXMuZmlyc3QrdGhpcy5zaXplLGZyb20pO319LC8vIE5vbi1wdWJsaWMgaW50ZXJmYWNlIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGxpbmVzLlxuaW5zZXJ0OmZ1bmN0aW9uKGF0LGxpbmVzKXt2YXIgaGVpZ2h0PTA7Zm9yKHZhciBpPTA7aTxsaW5lcy5sZW5ndGg7KytpKXtoZWlnaHQrPWxpbmVzW2ldLmhlaWdodDt9dGhpcy5pbnNlcnRJbm5lcihhdC10aGlzLmZpcnN0LGxpbmVzLGhlaWdodCk7fSxyZW1vdmU6ZnVuY3Rpb24oYXQsbil7dGhpcy5yZW1vdmVJbm5lcihhdC10aGlzLmZpcnN0LG4pO30sLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxuLy8gYXJlIGFsc28gYXZhaWxhYmxlIGZyb20gQ29kZU1pcnJvciAoZWRpdG9yKSBpbnN0YW5jZXMuXG5nZXRWYWx1ZTpmdW5jdGlvbihsaW5lU2VwKXt2YXIgbGluZXM9Z2V0TGluZXModGhpcyx0aGlzLmZpcnN0LHRoaXMuZmlyc3QrdGhpcy5zaXplKTtpZihsaW5lU2VwPT09ZmFsc2Upe3JldHVybiBsaW5lczt9cmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcHx8dGhpcy5saW5lU2VwYXJhdG9yKCkpO30sc2V0VmFsdWU6ZG9jTWV0aG9kT3AoZnVuY3Rpb24oY29kZSl7dmFyIHRvcD1Qb3ModGhpcy5maXJzdCwwKSxsYXN0PXRoaXMuZmlyc3QrdGhpcy5zaXplLTE7bWFrZUNoYW5nZSh0aGlzLHtmcm9tOnRvcCx0bzpQb3MobGFzdCxnZXRMaW5lKHRoaXMsbGFzdCkudGV4dC5sZW5ndGgpLHRleHQ6dGhpcy5zcGxpdExpbmVzKGNvZGUpLG9yaWdpbjpcInNldFZhbHVlXCIsZnVsbDp0cnVlfSx0cnVlKTtzZXRTZWxlY3Rpb24odGhpcyxzaW1wbGVTZWxlY3Rpb24odG9wKSk7fSkscmVwbGFjZVJhbmdlOmZ1bmN0aW9uKGNvZGUsZnJvbSx0byxvcmlnaW4pe2Zyb209Y2xpcFBvcyh0aGlzLGZyb20pO3RvPXRvP2NsaXBQb3ModGhpcyx0byk6ZnJvbTtyZXBsYWNlUmFuZ2UodGhpcyxjb2RlLGZyb20sdG8sb3JpZ2luKTt9LGdldFJhbmdlOmZ1bmN0aW9uKGZyb20sdG8sbGluZVNlcCl7dmFyIGxpbmVzPWdldEJldHdlZW4odGhpcyxjbGlwUG9zKHRoaXMsZnJvbSksY2xpcFBvcyh0aGlzLHRvKSk7aWYobGluZVNlcD09PWZhbHNlKXtyZXR1cm4gbGluZXM7fXJldHVybiBsaW5lcy5qb2luKGxpbmVTZXB8fHRoaXMubGluZVNlcGFyYXRvcigpKTt9LGdldExpbmU6ZnVuY3Rpb24obGluZSl7dmFyIGw9dGhpcy5nZXRMaW5lSGFuZGxlKGxpbmUpO3JldHVybiBsJiZsLnRleHQ7fSxnZXRMaW5lSGFuZGxlOmZ1bmN0aW9uKGxpbmUpe2lmKGlzTGluZSh0aGlzLGxpbmUpKXtyZXR1cm4gZ2V0TGluZSh0aGlzLGxpbmUpO319LGdldExpbmVOdW1iZXI6ZnVuY3Rpb24obGluZSl7cmV0dXJuIGxpbmVObyhsaW5lKTt9LGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDpmdW5jdGlvbihsaW5lKXtpZih0eXBlb2YgbGluZT09XCJudW1iZXJcIil7bGluZT1nZXRMaW5lKHRoaXMsbGluZSk7fXJldHVybiB2aXN1YWxMaW5lKGxpbmUpO30sbGluZUNvdW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZTt9LGZpcnN0TGluZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZpcnN0O30sbGFzdExpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maXJzdCt0aGlzLnNpemUtMTt9LGNsaXBQb3M6ZnVuY3Rpb24ocG9zKXtyZXR1cm4gY2xpcFBvcyh0aGlzLHBvcyk7fSxnZXRDdXJzb3I6ZnVuY3Rpb24oc3RhcnQpe3ZhciByYW5nZT10aGlzLnNlbC5wcmltYXJ5KCkscG9zO2lmKHN0YXJ0PT1udWxsfHxzdGFydD09XCJoZWFkXCIpe3Bvcz1yYW5nZS5oZWFkO31lbHNlIGlmKHN0YXJ0PT1cImFuY2hvclwiKXtwb3M9cmFuZ2UuYW5jaG9yO31lbHNlIGlmKHN0YXJ0PT1cImVuZFwifHxzdGFydD09XCJ0b1wifHxzdGFydD09PWZhbHNlKXtwb3M9cmFuZ2UudG8oKTt9ZWxzZXtwb3M9cmFuZ2UuZnJvbSgpO31yZXR1cm4gcG9zO30sbGlzdFNlbGVjdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWwucmFuZ2VzO30sc29tZXRoaW5nU2VsZWN0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTt9LHNldEN1cnNvcjpkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLGNoLG9wdGlvbnMpe3NldFNpbXBsZVNlbGVjdGlvbih0aGlzLGNsaXBQb3ModGhpcyx0eXBlb2YgbGluZT09XCJudW1iZXJcIj9Qb3MobGluZSxjaHx8MCk6bGluZSksbnVsbCxvcHRpb25zKTt9KSxzZXRTZWxlY3Rpb246ZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLGhlYWQsb3B0aW9ucyl7c2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsY2xpcFBvcyh0aGlzLGFuY2hvciksY2xpcFBvcyh0aGlzLGhlYWR8fGFuY2hvciksb3B0aW9ucyk7fSksZXh0ZW5kU2VsZWN0aW9uOmRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWQsb3RoZXIsb3B0aW9ucyl7ZXh0ZW5kU2VsZWN0aW9uKHRoaXMsY2xpcFBvcyh0aGlzLGhlYWQpLG90aGVyJiZjbGlwUG9zKHRoaXMsb3RoZXIpLG9wdGlvbnMpO30pLGV4dGVuZFNlbGVjdGlvbnM6ZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZHMsb3B0aW9ucyl7ZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLGNsaXBQb3NBcnJheSh0aGlzLGhlYWRzKSxvcHRpb25zKTt9KSxleHRlbmRTZWxlY3Rpb25zQnk6ZG9jTWV0aG9kT3AoZnVuY3Rpb24oZixvcHRpb25zKXt2YXIgaGVhZHM9bWFwKHRoaXMuc2VsLnJhbmdlcyxmKTtleHRlbmRTZWxlY3Rpb25zKHRoaXMsY2xpcFBvc0FycmF5KHRoaXMsaGVhZHMpLG9wdGlvbnMpO30pLHNldFNlbGVjdGlvbnM6ZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLHByaW1hcnksb3B0aW9ucyl7dmFyIHRoaXMkMT10aGlzO2lmKCFyYW5nZXMubGVuZ3RoKXtyZXR1cm47fXZhciBvdXQ9W107Zm9yKHZhciBpPTA7aTxyYW5nZXMubGVuZ3RoO2krKyl7b3V0W2ldPW5ldyBSYW5nZShjbGlwUG9zKHRoaXMkMSxyYW5nZXNbaV0uYW5jaG9yKSxjbGlwUG9zKHRoaXMkMSxyYW5nZXNbaV0uaGVhZCkpO31pZihwcmltYXJ5PT1udWxsKXtwcmltYXJ5PU1hdGgubWluKHJhbmdlcy5sZW5ndGgtMSx0aGlzLnNlbC5wcmltSW5kZXgpO31zZXRTZWxlY3Rpb24odGhpcyxub3JtYWxpemVTZWxlY3Rpb24ob3V0LHByaW1hcnkpLG9wdGlvbnMpO30pLGFkZFNlbGVjdGlvbjpkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsaGVhZCxvcHRpb25zKXt2YXIgcmFuZ2VzPXRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKTtyYW5nZXMucHVzaChuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLGFuY2hvciksY2xpcFBvcyh0aGlzLGhlYWR8fGFuY2hvcikpKTtzZXRTZWxlY3Rpb24odGhpcyxub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLHJhbmdlcy5sZW5ndGgtMSksb3B0aW9ucyk7fSksZ2V0U2VsZWN0aW9uOmZ1bmN0aW9uKGxpbmVTZXApe3ZhciB0aGlzJDE9dGhpczt2YXIgcmFuZ2VzPXRoaXMuc2VsLnJhbmdlcyxsaW5lcztmb3IodmFyIGk9MDtpPHJhbmdlcy5sZW5ndGg7aSsrKXt2YXIgc2VsPWdldEJldHdlZW4odGhpcyQxLHJhbmdlc1tpXS5mcm9tKCkscmFuZ2VzW2ldLnRvKCkpO2xpbmVzPWxpbmVzP2xpbmVzLmNvbmNhdChzZWwpOnNlbDt9aWYobGluZVNlcD09PWZhbHNlKXtyZXR1cm4gbGluZXM7fWVsc2V7cmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcHx8dGhpcy5saW5lU2VwYXJhdG9yKCkpO319LGdldFNlbGVjdGlvbnM6ZnVuY3Rpb24obGluZVNlcCl7dmFyIHRoaXMkMT10aGlzO3ZhciBwYXJ0cz1bXSxyYW5nZXM9dGhpcy5zZWwucmFuZ2VzO2Zvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDtpKyspe3ZhciBzZWw9Z2V0QmV0d2Vlbih0aGlzJDEscmFuZ2VzW2ldLmZyb20oKSxyYW5nZXNbaV0udG8oKSk7aWYobGluZVNlcCE9PWZhbHNlKXtzZWw9c2VsLmpvaW4obGluZVNlcHx8dGhpcyQxLmxpbmVTZXBhcmF0b3IoKSk7fXBhcnRzW2ldPXNlbDt9cmV0dXJuIHBhcnRzO30scmVwbGFjZVNlbGVjdGlvbjpmdW5jdGlvbihjb2RlLGNvbGxhcHNlLG9yaWdpbil7dmFyIGR1cD1bXTtmb3IodmFyIGk9MDtpPHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7aSsrKXtkdXBbaV09Y29kZTt9dGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsY29sbGFwc2Usb3JpZ2lufHxcIitpbnB1dFwiKTt9LHJlcGxhY2VTZWxlY3Rpb25zOmRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUsY29sbGFwc2Usb3JpZ2luKXt2YXIgdGhpcyQxPXRoaXM7dmFyIGNoYW5nZXM9W10sc2VsPXRoaXMuc2VsO2Zvcih2YXIgaT0wO2k8c2VsLnJhbmdlcy5sZW5ndGg7aSsrKXt2YXIgcmFuZ2U9c2VsLnJhbmdlc1tpXTtjaGFuZ2VzW2ldPXtmcm9tOnJhbmdlLmZyb20oKSx0bzpyYW5nZS50bygpLHRleHQ6dGhpcyQxLnNwbGl0TGluZXMoY29kZVtpXSksb3JpZ2luOm9yaWdpbn07fXZhciBuZXdTZWw9Y29sbGFwc2UmJmNvbGxhcHNlIT1cImVuZFwiJiZjb21wdXRlUmVwbGFjZWRTZWwodGhpcyxjaGFuZ2VzLGNvbGxhcHNlKTtmb3IodmFyIGkkMT1jaGFuZ2VzLmxlbmd0aC0xO2kkMT49MDtpJDEtLSl7bWFrZUNoYW5nZSh0aGlzJDEsY2hhbmdlc1tpJDFdKTt9aWYobmV3U2VsKXtzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLG5ld1NlbCk7fWVsc2UgaWYodGhpcy5jbSl7ZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKTt9fSksdW5kbzpkb2NNZXRob2RPcChmdW5jdGlvbigpe21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLFwidW5kb1wiKTt9KSxyZWRvOmRvY01ldGhvZE9wKGZ1bmN0aW9uKCl7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsXCJyZWRvXCIpO30pLHVuZG9TZWxlY3Rpb246ZG9jTWV0aG9kT3AoZnVuY3Rpb24oKXttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcyxcInVuZG9cIix0cnVlKTt9KSxyZWRvU2VsZWN0aW9uOmRvY01ldGhvZE9wKGZ1bmN0aW9uKCl7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsXCJyZWRvXCIsdHJ1ZSk7fSksc2V0RXh0ZW5kaW5nOmZ1bmN0aW9uKHZhbCl7dGhpcy5leHRlbmQ9dmFsO30sZ2V0RXh0ZW5kaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXh0ZW5kO30saGlzdG9yeVNpemU6ZnVuY3Rpb24oKXt2YXIgaGlzdD10aGlzLmhpc3RvcnksZG9uZT0wLHVuZG9uZT0wO2Zvcih2YXIgaT0wO2k8aGlzdC5kb25lLmxlbmd0aDtpKyspe2lmKCFoaXN0LmRvbmVbaV0ucmFuZ2VzKXsrK2RvbmU7fX1mb3IodmFyIGkkMT0wO2kkMTxoaXN0LnVuZG9uZS5sZW5ndGg7aSQxKyspe2lmKCFoaXN0LnVuZG9uZVtpJDFdLnJhbmdlcyl7Kyt1bmRvbmU7fX1yZXR1cm57dW5kbzpkb25lLHJlZG86dW5kb25lfTt9LGNsZWFySGlzdG9yeTpmdW5jdGlvbigpe3RoaXMuaGlzdG9yeT1uZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkubWF4R2VuZXJhdGlvbik7fSxtYXJrQ2xlYW46ZnVuY3Rpb24oKXt0aGlzLmNsZWFuR2VuZXJhdGlvbj10aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSk7fSxjaGFuZ2VHZW5lcmF0aW9uOmZ1bmN0aW9uKGZvcmNlU3BsaXQpe2lmKGZvcmNlU3BsaXQpe3RoaXMuaGlzdG9yeS5sYXN0T3A9dGhpcy5oaXN0b3J5Lmxhc3RTZWxPcD10aGlzLmhpc3RvcnkubGFzdE9yaWdpbj1udWxsO31yZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb247fSxpc0NsZWFuOmZ1bmN0aW9uKGdlbil7cmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uPT0oZ2VufHx0aGlzLmNsZWFuR2VuZXJhdGlvbik7fSxnZXRIaXN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6Y29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSksdW5kb25lOmNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSl9O30sc2V0SGlzdG9yeTpmdW5jdGlvbihoaXN0RGF0YSl7dmFyIGhpc3Q9dGhpcy5oaXN0b3J5PW5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtoaXN0LmRvbmU9Y29weUhpc3RvcnlBcnJheShoaXN0RGF0YS5kb25lLnNsaWNlKDApLG51bGwsdHJ1ZSk7aGlzdC51bmRvbmU9Y29weUhpc3RvcnlBcnJheShoaXN0RGF0YS51bmRvbmUuc2xpY2UoMCksbnVsbCx0cnVlKTt9LGFkZExpbmVDbGFzczpkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsd2hlcmUsY2xzKXtyZXR1cm4gY2hhbmdlTGluZSh0aGlzLGhhbmRsZSx3aGVyZT09XCJndXR0ZXJcIj9cImd1dHRlclwiOlwiY2xhc3NcIixmdW5jdGlvbihsaW5lKXt2YXIgcHJvcD13aGVyZT09XCJ0ZXh0XCI/XCJ0ZXh0Q2xhc3NcIjp3aGVyZT09XCJiYWNrZ3JvdW5kXCI/XCJiZ0NsYXNzXCI6d2hlcmU9PVwiZ3V0dGVyXCI/XCJndXR0ZXJDbGFzc1wiOlwid3JhcENsYXNzXCI7aWYoIWxpbmVbcHJvcF0pe2xpbmVbcHJvcF09Y2xzO31lbHNlIGlmKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wXSkpe3JldHVybiBmYWxzZTt9ZWxzZXtsaW5lW3Byb3BdKz1cIiBcIitjbHM7fXJldHVybiB0cnVlO30pO30pLHJlbW92ZUxpbmVDbGFzczpkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsd2hlcmUsY2xzKXtyZXR1cm4gY2hhbmdlTGluZSh0aGlzLGhhbmRsZSx3aGVyZT09XCJndXR0ZXJcIj9cImd1dHRlclwiOlwiY2xhc3NcIixmdW5jdGlvbihsaW5lKXt2YXIgcHJvcD13aGVyZT09XCJ0ZXh0XCI/XCJ0ZXh0Q2xhc3NcIjp3aGVyZT09XCJiYWNrZ3JvdW5kXCI/XCJiZ0NsYXNzXCI6d2hlcmU9PVwiZ3V0dGVyXCI/XCJndXR0ZXJDbGFzc1wiOlwid3JhcENsYXNzXCI7dmFyIGN1cj1saW5lW3Byb3BdO2lmKCFjdXIpe3JldHVybiBmYWxzZTt9ZWxzZSBpZihjbHM9PW51bGwpe2xpbmVbcHJvcF09bnVsbDt9ZWxzZXt2YXIgZm91bmQ9Y3VyLm1hdGNoKGNsYXNzVGVzdChjbHMpKTtpZighZm91bmQpe3JldHVybiBmYWxzZTt9dmFyIGVuZD1mb3VuZC5pbmRleCtmb3VuZFswXS5sZW5ndGg7bGluZVtwcm9wXT1jdXIuc2xpY2UoMCxmb3VuZC5pbmRleCkrKCFmb3VuZC5pbmRleHx8ZW5kPT1jdXIubGVuZ3RoP1wiXCI6XCIgXCIpK2N1ci5zbGljZShlbmQpfHxudWxsO31yZXR1cm4gdHJ1ZTt9KTt9KSxhZGRMaW5lV2lkZ2V0OmRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSxub2RlLG9wdGlvbnMpe3JldHVybiBhZGRMaW5lV2lkZ2V0KHRoaXMsaGFuZGxlLG5vZGUsb3B0aW9ucyk7fSkscmVtb3ZlTGluZVdpZGdldDpmdW5jdGlvbih3aWRnZXQpe3dpZGdldC5jbGVhcigpO30sbWFya1RleHQ6ZnVuY3Rpb24oZnJvbSx0byxvcHRpb25zKXtyZXR1cm4gbWFya1RleHQodGhpcyxjbGlwUG9zKHRoaXMsZnJvbSksY2xpcFBvcyh0aGlzLHRvKSxvcHRpb25zLG9wdGlvbnMmJm9wdGlvbnMudHlwZXx8XCJyYW5nZVwiKTt9LHNldEJvb2ttYXJrOmZ1bmN0aW9uKHBvcyxvcHRpb25zKXt2YXIgcmVhbE9wdHM9e3JlcGxhY2VkV2l0aDpvcHRpb25zJiYob3B0aW9ucy5ub2RlVHlwZT09bnVsbD9vcHRpb25zLndpZGdldDpvcHRpb25zKSxpbnNlcnRMZWZ0Om9wdGlvbnMmJm9wdGlvbnMuaW5zZXJ0TGVmdCxjbGVhcldoZW5FbXB0eTpmYWxzZSxzaGFyZWQ6b3B0aW9ucyYmb3B0aW9ucy5zaGFyZWQsaGFuZGxlTW91c2VFdmVudHM6b3B0aW9ucyYmb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50c307cG9zPWNsaXBQb3ModGhpcyxwb3MpO3JldHVybiBtYXJrVGV4dCh0aGlzLHBvcyxwb3MscmVhbE9wdHMsXCJib29rbWFya1wiKTt9LGZpbmRNYXJrc0F0OmZ1bmN0aW9uKHBvcyl7cG9zPWNsaXBQb3ModGhpcyxwb3MpO3ZhciBtYXJrZXJzPVtdLHNwYW5zPWdldExpbmUodGhpcyxwb3MubGluZSkubWFya2VkU3BhbnM7aWYoc3BhbnMpe2Zvcih2YXIgaT0wO2k8c3BhbnMubGVuZ3RoOysraSl7dmFyIHNwYW49c3BhbnNbaV07aWYoKHNwYW4uZnJvbT09bnVsbHx8c3Bhbi5mcm9tPD1wb3MuY2gpJiYoc3Bhbi50bz09bnVsbHx8c3Bhbi50bz49cG9zLmNoKSl7bWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudHx8c3Bhbi5tYXJrZXIpO319fXJldHVybiBtYXJrZXJzO30sZmluZE1hcmtzOmZ1bmN0aW9uKGZyb20sdG8sZmlsdGVyKXtmcm9tPWNsaXBQb3ModGhpcyxmcm9tKTt0bz1jbGlwUG9zKHRoaXMsdG8pO3ZhciBmb3VuZD1bXSxsaW5lTm89ZnJvbS5saW5lO3RoaXMuaXRlcihmcm9tLmxpbmUsdG8ubGluZSsxLGZ1bmN0aW9uKGxpbmUpe3ZhciBzcGFucz1saW5lLm1hcmtlZFNwYW5zO2lmKHNwYW5zKXtmb3IodmFyIGk9MDtpPHNwYW5zLmxlbmd0aDtpKyspe3ZhciBzcGFuPXNwYW5zW2ldO2lmKCEoc3Bhbi50byE9bnVsbCYmbGluZU5vPT1mcm9tLmxpbmUmJmZyb20uY2g+PXNwYW4udG98fHNwYW4uZnJvbT09bnVsbCYmbGluZU5vIT1mcm9tLmxpbmV8fHNwYW4uZnJvbSE9bnVsbCYmbGluZU5vPT10by5saW5lJiZzcGFuLmZyb20+PXRvLmNoKSYmKCFmaWx0ZXJ8fGZpbHRlcihzcGFuLm1hcmtlcikpKXtmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudHx8c3Bhbi5tYXJrZXIpO319fSsrbGluZU5vO30pO3JldHVybiBmb3VuZDt9LGdldEFsbE1hcmtzOmZ1bmN0aW9uKCl7dmFyIG1hcmtlcnM9W107dGhpcy5pdGVyKGZ1bmN0aW9uKGxpbmUpe3ZhciBzcHM9bGluZS5tYXJrZWRTcGFucztpZihzcHMpe2Zvcih2YXIgaT0wO2k8c3BzLmxlbmd0aDsrK2kpe2lmKHNwc1tpXS5mcm9tIT1udWxsKXttYXJrZXJzLnB1c2goc3BzW2ldLm1hcmtlcik7fX19fSk7cmV0dXJuIG1hcmtlcnM7fSxwb3NGcm9tSW5kZXg6ZnVuY3Rpb24ob2ZmKXt2YXIgY2gsbGluZU5vPXRoaXMuZmlyc3Qsc2VwU2l6ZT10aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7dGhpcy5pdGVyKGZ1bmN0aW9uKGxpbmUpe3ZhciBzej1saW5lLnRleHQubGVuZ3RoK3NlcFNpemU7aWYoc3o+b2ZmKXtjaD1vZmY7cmV0dXJuIHRydWU7fW9mZi09c3o7KytsaW5lTm87fSk7cmV0dXJuIGNsaXBQb3ModGhpcyxQb3MobGluZU5vLGNoKSk7fSxpbmRleEZyb21Qb3M6ZnVuY3Rpb24oY29vcmRzKXtjb29yZHM9Y2xpcFBvcyh0aGlzLGNvb3Jkcyk7dmFyIGluZGV4PWNvb3Jkcy5jaDtpZihjb29yZHMubGluZTx0aGlzLmZpcnN0fHxjb29yZHMuY2g8MCl7cmV0dXJuIDA7fXZhciBzZXBTaXplPXRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDt0aGlzLml0ZXIodGhpcy5maXJzdCxjb29yZHMubGluZSxmdW5jdGlvbihsaW5lKXsvLyBpdGVyIGFib3J0cyB3aGVuIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWVcbmluZGV4Kz1saW5lLnRleHQubGVuZ3RoK3NlcFNpemU7fSk7cmV0dXJuIGluZGV4O30sY29weTpmdW5jdGlvbihjb3B5SGlzdG9yeSl7dmFyIGRvYz1uZXcgRG9jKGdldExpbmVzKHRoaXMsdGhpcy5maXJzdCx0aGlzLmZpcnN0K3RoaXMuc2l6ZSksdGhpcy5tb2RlT3B0aW9uLHRoaXMuZmlyc3QsdGhpcy5saW5lU2VwKTtkb2Muc2Nyb2xsVG9wPXRoaXMuc2Nyb2xsVG9wO2RvYy5zY3JvbGxMZWZ0PXRoaXMuc2Nyb2xsTGVmdDtkb2Muc2VsPXRoaXMuc2VsO2RvYy5leHRlbmQ9ZmFsc2U7aWYoY29weUhpc3Rvcnkpe2RvYy5oaXN0b3J5LnVuZG9EZXB0aD10aGlzLmhpc3RvcnkudW5kb0RlcHRoO2RvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKTt9cmV0dXJuIGRvYzt9LGxpbmtlZERvYzpmdW5jdGlvbihvcHRpb25zKXtpZighb3B0aW9ucyl7b3B0aW9ucz17fTt9dmFyIGZyb209dGhpcy5maXJzdCx0bz10aGlzLmZpcnN0K3RoaXMuc2l6ZTtpZihvcHRpb25zLmZyb20hPW51bGwmJm9wdGlvbnMuZnJvbT5mcm9tKXtmcm9tPW9wdGlvbnMuZnJvbTt9aWYob3B0aW9ucy50byE9bnVsbCYmb3B0aW9ucy50bzx0byl7dG89b3B0aW9ucy50bzt9dmFyIGNvcHk9bmV3IERvYyhnZXRMaW5lcyh0aGlzLGZyb20sdG8pLG9wdGlvbnMubW9kZXx8dGhpcy5tb2RlT3B0aW9uLGZyb20sdGhpcy5saW5lU2VwKTtpZihvcHRpb25zLnNoYXJlZEhpc3Qpe2NvcHkuaGlzdG9yeT10aGlzLmhpc3Rvcnk7fSh0aGlzLmxpbmtlZHx8KHRoaXMubGlua2VkPVtdKSkucHVzaCh7ZG9jOmNvcHksc2hhcmVkSGlzdDpvcHRpb25zLnNoYXJlZEhpc3R9KTtjb3B5LmxpbmtlZD1be2RvYzp0aGlzLGlzUGFyZW50OnRydWUsc2hhcmVkSGlzdDpvcHRpb25zLnNoYXJlZEhpc3R9XTtjb3B5U2hhcmVkTWFya2Vycyhjb3B5LGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtyZXR1cm4gY29weTt9LHVubGlua0RvYzpmdW5jdGlvbihvdGhlcil7dmFyIHRoaXMkMT10aGlzO2lmKG90aGVyIGluc3RhbmNlb2YgQ29kZU1pcnJvcil7b3RoZXI9b3RoZXIuZG9jO31pZih0aGlzLmxpbmtlZCl7Zm9yKHZhciBpPTA7aTx0aGlzLmxpbmtlZC5sZW5ndGg7KytpKXt2YXIgbGluaz10aGlzJDEubGlua2VkW2ldO2lmKGxpbmsuZG9jIT1vdGhlcil7Y29udGludWU7fXRoaXMkMS5saW5rZWQuc3BsaWNlKGksMSk7b3RoZXIudW5saW5rRG9jKHRoaXMkMSk7ZGV0YWNoU2hhcmVkTWFya2VycyhmaW5kU2hhcmVkTWFya2Vycyh0aGlzJDEpKTticmVhazt9fS8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cbmlmKG90aGVyLmhpc3Rvcnk9PXRoaXMuaGlzdG9yeSl7dmFyIHNwbGl0SWRzPVtvdGhlci5pZF07bGlua2VkRG9jcyhvdGhlcixmdW5jdGlvbihkb2Mpe3JldHVybiBzcGxpdElkcy5wdXNoKGRvYy5pZCk7fSx0cnVlKTtvdGhlci5oaXN0b3J5PW5ldyBIaXN0b3J5KG51bGwpO290aGVyLmhpc3RvcnkuZG9uZT1jb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lLHNwbGl0SWRzKTtvdGhlci5oaXN0b3J5LnVuZG9uZT1jb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsc3BsaXRJZHMpO319LGl0ZXJMaW5rZWREb2NzOmZ1bmN0aW9uKGYpe2xpbmtlZERvY3ModGhpcyxmKTt9LGdldE1vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlO30sZ2V0RWRpdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY207fSxzcGxpdExpbmVzOmZ1bmN0aW9uKHN0cil7aWYodGhpcy5saW5lU2VwKXtyZXR1cm4gc3RyLnNwbGl0KHRoaXMubGluZVNlcCk7fXJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpO30sbGluZVNlcGFyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmVTZXB8fFwiXFxuXCI7fX0pOy8vIFB1YmxpYyBhbGlhcy5cbkRvYy5wcm90b3R5cGUuZWFjaExpbmU9RG9jLnByb3RvdHlwZS5pdGVyOy8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xuLy8gcmUtZmlyZSBhIHNlcmllcyBvZiBkcmFnLXJlbGF0ZWQgZXZlbnRzIHJpZ2h0IGFmdGVyIHRoZSBkcm9wICgjMTU1MSlcbnZhciBsYXN0RHJvcD0wO2Z1bmN0aW9uIG9uRHJvcChlKXt2YXIgY209dGhpcztjbGVhckRyYWdDdXJzb3IoY20pO2lmKHNpZ25hbERPTUV2ZW50KGNtLGUpfHxldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksZSkpe3JldHVybjt9ZV9wcmV2ZW50RGVmYXVsdChlKTtpZihpZSl7bGFzdERyb3A9K25ldyBEYXRlKCk7fXZhciBwb3M9cG9zRnJvbU1vdXNlKGNtLGUsdHJ1ZSksZmlsZXM9ZS5kYXRhVHJhbnNmZXIuZmlsZXM7aWYoIXBvc3x8Y20uaXNSZWFkT25seSgpKXtyZXR1cm47fS8vIE1pZ2h0IGJlIGEgZmlsZSBkcm9wLCBpbiB3aGljaCBjYXNlIHdlIHNpbXBseSBleHRyYWN0IHRoZSB0ZXh0XG4vLyBhbmQgaW5zZXJ0IGl0LlxuaWYoZmlsZXMmJmZpbGVzLmxlbmd0aCYmd2luZG93LkZpbGVSZWFkZXImJndpbmRvdy5GaWxlKXt2YXIgbj1maWxlcy5sZW5ndGgsdGV4dD1BcnJheShuKSxyZWFkPTA7dmFyIGxvYWRGaWxlPWZ1bmN0aW9uKGZpbGUsaSl7aWYoY20ub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMmJmluZGV4T2YoY20ub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMsZmlsZS50eXBlKT09LTEpe3JldHVybjt9dmFyIHJlYWRlcj1uZXcgRmlsZVJlYWRlcigpO3JlYWRlci5vbmxvYWQ9b3BlcmF0aW9uKGNtLGZ1bmN0aW9uKCl7dmFyIGNvbnRlbnQ9cmVhZGVyLnJlc3VsdDtpZigvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKXtjb250ZW50PVwiXCI7fXRleHRbaV09Y29udGVudDtpZigrK3JlYWQ9PW4pe3Bvcz1jbGlwUG9zKGNtLmRvYyxwb3MpO3ZhciBjaGFuZ2U9e2Zyb206cG9zLHRvOnBvcyx0ZXh0OmNtLmRvYy5zcGxpdExpbmVzKHRleHQuam9pbihjbS5kb2MubGluZVNlcGFyYXRvcigpKSksb3JpZ2luOlwicGFzdGVcIn07bWFrZUNoYW5nZShjbS5kb2MsY2hhbmdlKTtzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShjbS5kb2Msc2ltcGxlU2VsZWN0aW9uKHBvcyxjaGFuZ2VFbmQoY2hhbmdlKSkpO319KTtyZWFkZXIucmVhZEFzVGV4dChmaWxlKTt9O2Zvcih2YXIgaT0wO2k8bjsrK2kpe2xvYWRGaWxlKGZpbGVzW2ldLGkpO319ZWxzZXsvLyBOb3JtYWwgZHJvcFxuLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cbmlmKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCYmY20uZG9jLnNlbC5jb250YWlucyhwb3MpPi0xKXtjbS5zdGF0ZS5kcmFnZ2luZ1RleHQoZSk7Ly8gRW5zdXJlIHRoZSBlZGl0b3IgaXMgcmUtZm9jdXNlZFxuc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7fSwyMCk7cmV0dXJuO310cnl7dmFyIHRleHQkMT1lLmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKTtpZih0ZXh0JDEpe3ZhciBzZWxlY3RlZDtpZihjbS5zdGF0ZS5kcmFnZ2luZ1RleHQmJiFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQuY29weSl7c2VsZWN0ZWQ9Y20ubGlzdFNlbGVjdGlvbnMoKTt9c2V0U2VsZWN0aW9uTm9VbmRvKGNtLmRvYyxzaW1wbGVTZWxlY3Rpb24ocG9zLHBvcykpO2lmKHNlbGVjdGVkKXtmb3IodmFyIGkkMT0wO2kkMTxzZWxlY3RlZC5sZW5ndGg7KytpJDEpe3JlcGxhY2VSYW5nZShjbS5kb2MsXCJcIixzZWxlY3RlZFtpJDFdLmFuY2hvcixzZWxlY3RlZFtpJDFdLmhlYWQsXCJkcmFnXCIpO319Y20ucmVwbGFjZVNlbGVjdGlvbih0ZXh0JDEsXCJhcm91bmRcIixcInBhc3RlXCIpO2NtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9fWNhdGNoKGUpe319fWZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGNtLGUpe2lmKGllJiYoIWNtLnN0YXRlLmRyYWdnaW5nVGV4dHx8K25ldyBEYXRlKCktbGFzdERyb3A8MTAwKSl7ZV9zdG9wKGUpO3JldHVybjt9aWYoc2lnbmFsRE9NRXZlbnQoY20sZSl8fGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSxlKSl7cmV0dXJuO31lLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLGNtLmdldFNlbGVjdGlvbigpKTtlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkPVwiY29weU1vdmVcIjsvLyBVc2UgZHVtbXkgaW1hZ2UgaW5zdGVhZCBvZiBkZWZhdWx0IGJyb3dzZXJzIGltYWdlLlxuLy8gUmVjZW50IFNhZmFyaSAofjYuMC4yKSBoYXZlIGEgdGVuZGVuY3kgdG8gc2VnZmF1bHQgd2hlbiB0aGlzIGhhcHBlbnMsIHNvIHdlIGRvbid0IGRvIGl0IHRoZXJlLlxuaWYoZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlJiYhc2FmYXJpKXt2YXIgaW1nPWVsdChcImltZ1wiLG51bGwsbnVsbCxcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtpbWcuc3JjPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtpZihwcmVzdG8pe2ltZy53aWR0aD1pbWcuaGVpZ2h0PTE7Y20uZGlzcGxheS53cmFwcGVyLmFwcGVuZENoaWxkKGltZyk7Ly8gRm9yY2UgYSByZWxheW91dCwgb3IgT3BlcmEgd29uJ3QgdXNlIG91ciBpbWFnZSBmb3Igc29tZSBvYnNjdXJlIHJlYXNvblxuaW1nLl90b3A9aW1nLm9mZnNldFRvcDt9ZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGltZywwLDApO2lmKHByZXN0byl7aW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTt9fX1mdW5jdGlvbiBvbkRyYWdPdmVyKGNtLGUpe3ZhciBwb3M9cG9zRnJvbU1vdXNlKGNtLGUpO2lmKCFwb3Mpe3JldHVybjt9dmFyIGZyYWc9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2RyYXdTZWxlY3Rpb25DdXJzb3IoY20scG9zLGZyYWcpO2lmKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3Ipe2NtLmRpc3BsYXkuZHJhZ0N1cnNvcj1lbHQoXCJkaXZcIixudWxsLFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcIik7Y20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcixjbS5kaXNwbGF5LmN1cnNvckRpdik7fXJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcixmcmFnKTt9ZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKXtpZihjbS5kaXNwbGF5LmRyYWdDdXJzb3Ipe2NtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcik7Y20uZGlzcGxheS5kcmFnQ3Vyc29yPW51bGw7fX0vLyBUaGVzZSBtdXN0IGJlIGhhbmRsZWQgY2FyZWZ1bGx5LCBiZWNhdXNlIG5haXZlbHkgcmVnaXN0ZXJpbmcgYVxuLy8gaGFuZGxlciBmb3IgZWFjaCBlZGl0b3Igd2lsbCBjYXVzZSB0aGUgZWRpdG9ycyB0byBuZXZlciBiZVxuLy8gZ2FyYmFnZSBjb2xsZWN0ZWQuXG5mdW5jdGlvbiBmb3JFYWNoQ29kZU1pcnJvcihmKXtpZighZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXtyZXR1cm47fXZhciBieUNsYXNzPWRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkNvZGVNaXJyb3JcIik7Zm9yKHZhciBpPTA7aTxieUNsYXNzLmxlbmd0aDtpKyspe3ZhciBjbT1ieUNsYXNzW2ldLkNvZGVNaXJyb3I7aWYoY20pe2YoY20pO319fXZhciBnbG9iYWxzUmVnaXN0ZXJlZD1mYWxzZTtmdW5jdGlvbiBlbnN1cmVHbG9iYWxIYW5kbGVycygpe2lmKGdsb2JhbHNSZWdpc3RlcmVkKXtyZXR1cm47fXJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKTtnbG9iYWxzUmVnaXN0ZXJlZD10cnVlO31mdW5jdGlvbiByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCl7Ly8gV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCBhY3RpdmUgZWRpdG9ycy5cbnZhciByZXNpemVUaW1lcjtvbih3aW5kb3csXCJyZXNpemVcIixmdW5jdGlvbigpe2lmKHJlc2l6ZVRpbWVyPT1udWxsKXtyZXNpemVUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmVzaXplVGltZXI9bnVsbDtmb3JFYWNoQ29kZU1pcnJvcihvblJlc2l6ZSk7fSwxMDApO319KTsvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcbm9uKHdpbmRvdyxcImJsdXJcIixmdW5jdGlvbigpe3JldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpO30pO30vLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcbmZ1bmN0aW9uIG9uUmVzaXplKGNtKXt2YXIgZD1jbS5kaXNwbGF5O2lmKGQubGFzdFdyYXBIZWlnaHQ9PWQud3JhcHBlci5jbGllbnRIZWlnaHQmJmQubGFzdFdyYXBXaWR0aD09ZC53cmFwcGVyLmNsaWVudFdpZHRoKXtyZXR1cm47fS8vIE1pZ2h0IGJlIGEgdGV4dCBzY2FsaW5nIG9wZXJhdGlvbiwgY2xlYXIgc2l6ZSBjYWNoZXMuXG5kLmNhY2hlZENoYXJXaWR0aD1kLmNhY2hlZFRleHRIZWlnaHQ9ZC5jYWNoZWRQYWRkaW5nSD1udWxsO2Quc2Nyb2xsYmFyc0NsaXBwZWQ9ZmFsc2U7Y20uc2V0U2l6ZSgpO312YXIga2V5TmFtZXM9ezM6XCJFbnRlclwiLDg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTM6XCJFbnRlclwiLDE2OlwiU2hpZnRcIiwxNzpcIkN0cmxcIiwxODpcIkFsdFwiLDE5OlwiUGF1c2VcIiwyMDpcIkNhcHNMb2NrXCIsMjc6XCJFc2NcIiwzMjpcIlNwYWNlXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkxlZnRcIiwzODpcIlVwXCIsMzk6XCJSaWdodFwiLDQwOlwiRG93blwiLDQ0OlwiUHJpbnRTY3JuXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDU5OlwiO1wiLDYxOlwiPVwiLDkxOlwiTW9kXCIsOTI6XCJNb2RcIiw5MzpcIk1vZFwiLDEwNjpcIipcIiwxMDc6XCI9XCIsMTA5OlwiLVwiLDExMDpcIi5cIiwxMTE6XCIvXCIsMTI3OlwiRGVsZXRlXCIsMTczOlwiLVwiLDE4NjpcIjtcIiwxODc6XCI9XCIsMTg4OlwiLFwiLDE4OTpcIi1cIiwxOTA6XCIuXCIsMTkxOlwiL1wiLDE5MjpcImBcIiwyMTk6XCJbXCIsMjIwOlwiXFxcXFwiLDIyMTpcIl1cIiwyMjI6XCInXCIsNjMyMzI6XCJVcFwiLDYzMjMzOlwiRG93blwiLDYzMjM0OlwiTGVmdFwiLDYzMjM1OlwiUmlnaHRcIiw2MzI3MjpcIkRlbGV0ZVwiLDYzMjczOlwiSG9tZVwiLDYzMjc1OlwiRW5kXCIsNjMyNzY6XCJQYWdlVXBcIiw2MzI3NzpcIlBhZ2VEb3duXCIsNjMzMDI6XCJJbnNlcnRcIn07Ly8gTnVtYmVyIGtleXNcbmZvcih2YXIgaT0wO2k8MTA7aSsrKXtrZXlOYW1lc1tpKzQ4XT1rZXlOYW1lc1tpKzk2XT1TdHJpbmcoaSk7fS8vIEFscGhhYmV0aWMga2V5c1xuZm9yKHZhciBpJDE9NjU7aSQxPD05MDtpJDErKyl7a2V5TmFtZXNbaSQxXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGkkMSk7fS8vIEZ1bmN0aW9uIGtleXNcbmZvcih2YXIgaSQyPTE7aSQyPD0xMjtpJDIrKyl7a2V5TmFtZXNbaSQyKzExMV09a2V5TmFtZXNbaSQyKzYzMjM1XT1cIkZcIitpJDI7fXZhciBrZXlNYXA9e307a2V5TWFwLmJhc2ljPXtcIkxlZnRcIjpcImdvQ2hhckxlZnRcIixcIlJpZ2h0XCI6XCJnb0NoYXJSaWdodFwiLFwiVXBcIjpcImdvTGluZVVwXCIsXCJEb3duXCI6XCJnb0xpbmVEb3duXCIsXCJFbmRcIjpcImdvTGluZUVuZFwiLFwiSG9tZVwiOlwiZ29MaW5lU3RhcnRTbWFydFwiLFwiUGFnZVVwXCI6XCJnb1BhZ2VVcFwiLFwiUGFnZURvd25cIjpcImdvUGFnZURvd25cIixcIkRlbGV0ZVwiOlwiZGVsQ2hhckFmdGVyXCIsXCJCYWNrc3BhY2VcIjpcImRlbENoYXJCZWZvcmVcIixcIlNoaWZ0LUJhY2tzcGFjZVwiOlwiZGVsQ2hhckJlZm9yZVwiLFwiVGFiXCI6XCJkZWZhdWx0VGFiXCIsXCJTaGlmdC1UYWJcIjpcImluZGVudEF1dG9cIixcIkVudGVyXCI6XCJuZXdsaW5lQW5kSW5kZW50XCIsXCJJbnNlcnRcIjpcInRvZ2dsZU92ZXJ3cml0ZVwiLFwiRXNjXCI6XCJzaW5nbGVTZWxlY3Rpb25cIn07Ly8gTm90ZSB0aGF0IHRoZSBzYXZlIGFuZCBmaW5kLXJlbGF0ZWQgY29tbWFuZHMgYXJlbid0IGRlZmluZWQgYnlcbi8vIGRlZmF1bHQuIFVzZXIgY29kZSBvciBhZGRvbnMgY2FuIGRlZmluZSB0aGVtLiBVbmtub3duIGNvbW1hbmRzXG4vLyBhcmUgc2ltcGx5IGlnbm9yZWQuXG5rZXlNYXAucGNEZWZhdWx0PXtcIkN0cmwtQVwiOlwic2VsZWN0QWxsXCIsXCJDdHJsLURcIjpcImRlbGV0ZUxpbmVcIixcIkN0cmwtWlwiOlwidW5kb1wiLFwiU2hpZnQtQ3RybC1aXCI6XCJyZWRvXCIsXCJDdHJsLVlcIjpcInJlZG9cIixcIkN0cmwtSG9tZVwiOlwiZ29Eb2NTdGFydFwiLFwiQ3RybC1FbmRcIjpcImdvRG9jRW5kXCIsXCJDdHJsLVVwXCI6XCJnb0xpbmVVcFwiLFwiQ3RybC1Eb3duXCI6XCJnb0xpbmVEb3duXCIsXCJDdHJsLUxlZnRcIjpcImdvR3JvdXBMZWZ0XCIsXCJDdHJsLVJpZ2h0XCI6XCJnb0dyb3VwUmlnaHRcIixcIkFsdC1MZWZ0XCI6XCJnb0xpbmVTdGFydFwiLFwiQWx0LVJpZ2h0XCI6XCJnb0xpbmVFbmRcIixcIkN0cmwtQmFja3NwYWNlXCI6XCJkZWxHcm91cEJlZm9yZVwiLFwiQ3RybC1EZWxldGVcIjpcImRlbEdyb3VwQWZ0ZXJcIixcIkN0cmwtU1wiOlwic2F2ZVwiLFwiQ3RybC1GXCI6XCJmaW5kXCIsXCJDdHJsLUdcIjpcImZpbmROZXh0XCIsXCJTaGlmdC1DdHJsLUdcIjpcImZpbmRQcmV2XCIsXCJTaGlmdC1DdHJsLUZcIjpcInJlcGxhY2VcIixcIlNoaWZ0LUN0cmwtUlwiOlwicmVwbGFjZUFsbFwiLFwiQ3RybC1bXCI6XCJpbmRlbnRMZXNzXCIsXCJDdHJsLV1cIjpcImluZGVudE1vcmVcIixcIkN0cmwtVVwiOlwidW5kb1NlbGVjdGlvblwiLFwiU2hpZnQtQ3RybC1VXCI6XCJyZWRvU2VsZWN0aW9uXCIsXCJBbHQtVVwiOlwicmVkb1NlbGVjdGlvblwiLGZhbGx0aHJvdWdoOlwiYmFzaWNcIn07Ly8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cbmtleU1hcC5lbWFjc3k9e1wiQ3RybC1GXCI6XCJnb0NoYXJSaWdodFwiLFwiQ3RybC1CXCI6XCJnb0NoYXJMZWZ0XCIsXCJDdHJsLVBcIjpcImdvTGluZVVwXCIsXCJDdHJsLU5cIjpcImdvTGluZURvd25cIixcIkFsdC1GXCI6XCJnb1dvcmRSaWdodFwiLFwiQWx0LUJcIjpcImdvV29yZExlZnRcIixcIkN0cmwtQVwiOlwiZ29MaW5lU3RhcnRcIixcIkN0cmwtRVwiOlwiZ29MaW5lRW5kXCIsXCJDdHJsLVZcIjpcImdvUGFnZURvd25cIixcIlNoaWZ0LUN0cmwtVlwiOlwiZ29QYWdlVXBcIixcIkN0cmwtRFwiOlwiZGVsQ2hhckFmdGVyXCIsXCJDdHJsLUhcIjpcImRlbENoYXJCZWZvcmVcIixcIkFsdC1EXCI6XCJkZWxXb3JkQWZ0ZXJcIixcIkFsdC1CYWNrc3BhY2VcIjpcImRlbFdvcmRCZWZvcmVcIixcIkN0cmwtS1wiOlwia2lsbExpbmVcIixcIkN0cmwtVFwiOlwidHJhbnNwb3NlQ2hhcnNcIixcIkN0cmwtT1wiOlwib3BlbkxpbmVcIn07a2V5TWFwLm1hY0RlZmF1bHQ9e1wiQ21kLUFcIjpcInNlbGVjdEFsbFwiLFwiQ21kLURcIjpcImRlbGV0ZUxpbmVcIixcIkNtZC1aXCI6XCJ1bmRvXCIsXCJTaGlmdC1DbWQtWlwiOlwicmVkb1wiLFwiQ21kLVlcIjpcInJlZG9cIixcIkNtZC1Ib21lXCI6XCJnb0RvY1N0YXJ0XCIsXCJDbWQtVXBcIjpcImdvRG9jU3RhcnRcIixcIkNtZC1FbmRcIjpcImdvRG9jRW5kXCIsXCJDbWQtRG93blwiOlwiZ29Eb2NFbmRcIixcIkFsdC1MZWZ0XCI6XCJnb0dyb3VwTGVmdFwiLFwiQWx0LVJpZ2h0XCI6XCJnb0dyb3VwUmlnaHRcIixcIkNtZC1MZWZ0XCI6XCJnb0xpbmVMZWZ0XCIsXCJDbWQtUmlnaHRcIjpcImdvTGluZVJpZ2h0XCIsXCJBbHQtQmFja3NwYWNlXCI6XCJkZWxHcm91cEJlZm9yZVwiLFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6XCJkZWxHcm91cEFmdGVyXCIsXCJBbHQtRGVsZXRlXCI6XCJkZWxHcm91cEFmdGVyXCIsXCJDbWQtU1wiOlwic2F2ZVwiLFwiQ21kLUZcIjpcImZpbmRcIixcIkNtZC1HXCI6XCJmaW5kTmV4dFwiLFwiU2hpZnQtQ21kLUdcIjpcImZpbmRQcmV2XCIsXCJDbWQtQWx0LUZcIjpcInJlcGxhY2VcIixcIlNoaWZ0LUNtZC1BbHQtRlwiOlwicmVwbGFjZUFsbFwiLFwiQ21kLVtcIjpcImluZGVudExlc3NcIixcIkNtZC1dXCI6XCJpbmRlbnRNb3JlXCIsXCJDbWQtQmFja3NwYWNlXCI6XCJkZWxXcmFwcGVkTGluZUxlZnRcIixcIkNtZC1EZWxldGVcIjpcImRlbFdyYXBwZWRMaW5lUmlnaHRcIixcIkNtZC1VXCI6XCJ1bmRvU2VsZWN0aW9uXCIsXCJTaGlmdC1DbWQtVVwiOlwicmVkb1NlbGVjdGlvblwiLFwiQ3RybC1VcFwiOlwiZ29Eb2NTdGFydFwiLFwiQ3RybC1Eb3duXCI6XCJnb0RvY0VuZFwiLGZhbGx0aHJvdWdoOltcImJhc2ljXCIsXCJlbWFjc3lcIl19O2tleU1hcFtcImRlZmF1bHRcIl09bWFjP2tleU1hcC5tYWNEZWZhdWx0OmtleU1hcC5wY0RlZmF1bHQ7Ly8gS0VZTUFQIERJU1BBVENIXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpe3ZhciBwYXJ0cz1uYW1lLnNwbGl0KC8tKD8hJCkvKTtuYW1lPXBhcnRzW3BhcnRzLmxlbmd0aC0xXTt2YXIgYWx0LGN0cmwsc2hpZnQsY21kO2Zvcih2YXIgaT0wO2k8cGFydHMubGVuZ3RoLTE7aSsrKXt2YXIgbW9kPXBhcnRzW2ldO2lmKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSl7Y21kPXRydWU7fWVsc2UgaWYoL15hKGx0KT8kL2kudGVzdChtb2QpKXthbHQ9dHJ1ZTt9ZWxzZSBpZigvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKXtjdHJsPXRydWU7fWVsc2UgaWYoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpe3NoaWZ0PXRydWU7fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiK21vZCk7fX1pZihhbHQpe25hbWU9XCJBbHQtXCIrbmFtZTt9aWYoY3RybCl7bmFtZT1cIkN0cmwtXCIrbmFtZTt9aWYoY21kKXtuYW1lPVwiQ21kLVwiK25hbWU7fWlmKHNoaWZ0KXtuYW1lPVwiU2hpZnQtXCIrbmFtZTt9cmV0dXJuIG5hbWU7fS8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8ga2VlcCBrZXltYXBzIG1vc3RseSB3b3JraW5nIGFzIHJhdyBvYmplY3RzXG4vLyAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpIHdoaWxlIGF0IHRoZSBzYW1lIHRpbWUgc3VwcG9ydCBmZWF0dXJlc1xuLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXG4vLyBuZXcgbm9ybWFsaXplZCBrZXltYXAsIGFuZCB0aGVuIHVwZGF0ZXMgdGhlIG9sZCBvYmplY3QgdG8gcmVmbGVjdFxuLy8gdGhpcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU1hcChrZXltYXApe3ZhciBjb3B5PXt9O2Zvcih2YXIga2V5bmFtZSBpbiBrZXltYXApe2lmKGtleW1hcC5oYXNPd25Qcm9wZXJ0eShrZXluYW1lKSl7dmFyIHZhbHVlPWtleW1hcFtrZXluYW1lXTtpZigvXihuYW1lfGZhbGx0aHJvdWdofChkZXxhdCl0YWNoKSQvLnRlc3Qoa2V5bmFtZSkpe2NvbnRpbnVlO31pZih2YWx1ZT09XCIuLi5cIil7ZGVsZXRlIGtleW1hcFtrZXluYW1lXTtjb250aW51ZTt9dmFyIGtleXM9bWFwKGtleW5hbWUuc3BsaXQoXCIgXCIpLG5vcm1hbGl6ZUtleU5hbWUpO2Zvcih2YXIgaT0wO2k8a2V5cy5sZW5ndGg7aSsrKXt2YXIgdmFsPXZvaWQgMCxuYW1lPXZvaWQgMDtpZihpPT1rZXlzLmxlbmd0aC0xKXtuYW1lPWtleXMuam9pbihcIiBcIik7dmFsPXZhbHVlO31lbHNle25hbWU9a2V5cy5zbGljZSgwLGkrMSkuam9pbihcIiBcIik7dmFsPVwiLi4uXCI7fXZhciBwcmV2PWNvcHlbbmFtZV07aWYoIXByZXYpe2NvcHlbbmFtZV09dmFsO31lbHNlIGlmKHByZXYhPXZhbCl7dGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IGJpbmRpbmdzIGZvciBcIituYW1lKTt9fWRlbGV0ZSBrZXltYXBba2V5bmFtZV07fX1mb3IodmFyIHByb3AgaW4gY29weSl7a2V5bWFwW3Byb3BdPWNvcHlbcHJvcF07fXJldHVybiBrZXltYXA7fWZ1bmN0aW9uIGxvb2t1cEtleShrZXksbWFwLGhhbmRsZSxjb250ZXh0KXttYXA9Z2V0S2V5TWFwKG1hcCk7dmFyIGZvdW5kPW1hcC5jYWxsP21hcC5jYWxsKGtleSxjb250ZXh0KTptYXBba2V5XTtpZihmb3VuZD09PWZhbHNlKXtyZXR1cm5cIm5vdGhpbmdcIjt9aWYoZm91bmQ9PT1cIi4uLlwiKXtyZXR1cm5cIm11bHRpXCI7fWlmKGZvdW5kIT1udWxsJiZoYW5kbGUoZm91bmQpKXtyZXR1cm5cImhhbmRsZWRcIjt9aWYobWFwLmZhbGx0aHJvdWdoKXtpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWFwLmZhbGx0aHJvdWdoKSE9XCJbb2JqZWN0IEFycmF5XVwiKXtyZXR1cm4gbG9va3VwS2V5KGtleSxtYXAuZmFsbHRocm91Z2gsaGFuZGxlLGNvbnRleHQpO31mb3IodmFyIGk9MDtpPG1hcC5mYWxsdGhyb3VnaC5sZW5ndGg7aSsrKXt2YXIgcmVzdWx0PWxvb2t1cEtleShrZXksbWFwLmZhbGx0aHJvdWdoW2ldLGhhbmRsZSxjb250ZXh0KTtpZihyZXN1bHQpe3JldHVybiByZXN1bHQ7fX19fS8vIE1vZGlmaWVyIGtleSBwcmVzc2VzIGRvbid0IGNvdW50IGFzICdyZWFsJyBrZXkgcHJlc3NlcyBmb3IgdGhlXG4vLyBwdXJwb3NlIG9mIGtleW1hcCBmYWxsdGhyb3VnaC5cbmZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkodmFsdWUpe3ZhciBuYW1lPXR5cGVvZiB2YWx1ZT09XCJzdHJpbmdcIj92YWx1ZTprZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXTtyZXR1cm4gbmFtZT09XCJDdHJsXCJ8fG5hbWU9PVwiQWx0XCJ8fG5hbWU9PVwiU2hpZnRcInx8bmFtZT09XCJNb2RcIjt9Ly8gTG9vayB1cCB0aGUgbmFtZSBvZiBhIGtleSBhcyBpbmRpY2F0ZWQgYnkgYW4gZXZlbnQgb2JqZWN0LlxuZnVuY3Rpb24ga2V5TmFtZShldmVudCxub1NoaWZ0KXtpZihwcmVzdG8mJmV2ZW50LmtleUNvZGU9PTM0JiZldmVudFtcImNoYXJcIl0pe3JldHVybiBmYWxzZTt9dmFyIGJhc2U9a2V5TmFtZXNbZXZlbnQua2V5Q29kZV0sbmFtZT1iYXNlO2lmKG5hbWU9PW51bGx8fGV2ZW50LmFsdEdyYXBoS2V5KXtyZXR1cm4gZmFsc2U7fWlmKGV2ZW50LmFsdEtleSYmYmFzZSE9XCJBbHRcIil7bmFtZT1cIkFsdC1cIituYW1lO31pZigoZmxpcEN0cmxDbWQ/ZXZlbnQubWV0YUtleTpldmVudC5jdHJsS2V5KSYmYmFzZSE9XCJDdHJsXCIpe25hbWU9XCJDdHJsLVwiK25hbWU7fWlmKChmbGlwQ3RybENtZD9ldmVudC5jdHJsS2V5OmV2ZW50Lm1ldGFLZXkpJiZiYXNlIT1cIkNtZFwiKXtuYW1lPVwiQ21kLVwiK25hbWU7fWlmKCFub1NoaWZ0JiZldmVudC5zaGlmdEtleSYmYmFzZSE9XCJTaGlmdFwiKXtuYW1lPVwiU2hpZnQtXCIrbmFtZTt9cmV0dXJuIG5hbWU7fWZ1bmN0aW9uIGdldEtleU1hcCh2YWwpe3JldHVybiB0eXBlb2YgdmFsPT1cInN0cmluZ1wiP2tleU1hcFt2YWxdOnZhbDt9Ly8gSGVscGVyIGZvciBkZWxldGluZyB0ZXh0IG5lYXIgdGhlIHNlbGVjdGlvbihzKSwgdXNlZCB0byBpbXBsZW1lbnRcbi8vIGJhY2tzcGFjZSwgZGVsZXRlLCBhbmQgc2ltaWxhciBmdW5jdGlvbmFsaXR5LlxuZnVuY3Rpb24gZGVsZXRlTmVhclNlbGVjdGlvbihjbSxjb21wdXRlKXt2YXIgcmFuZ2VzPWNtLmRvYy5zZWwucmFuZ2VzLGtpbGw9W107Ly8gQnVpbGQgdXAgYSBzZXQgb2YgcmFuZ2VzIHRvIGtpbGwgZmlyc3QsIG1lcmdpbmcgb3ZlcmxhcHBpbmdcbi8vIHJhbmdlcy5cbmZvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDtpKyspe3ZhciB0b0tpbGw9Y29tcHV0ZShyYW5nZXNbaV0pO3doaWxlKGtpbGwubGVuZ3RoJiZjbXAodG9LaWxsLmZyb20sbHN0KGtpbGwpLnRvKTw9MCl7dmFyIHJlcGxhY2VkPWtpbGwucG9wKCk7aWYoY21wKHJlcGxhY2VkLmZyb20sdG9LaWxsLmZyb20pPDApe3RvS2lsbC5mcm9tPXJlcGxhY2VkLmZyb207YnJlYWs7fX1raWxsLnB1c2godG9LaWxsKTt9Ly8gTmV4dCwgcmVtb3ZlIHRob3NlIGFjdHVhbCByYW5nZXMuXG5ydW5Jbk9wKGNtLGZ1bmN0aW9uKCl7Zm9yKHZhciBpPWtpbGwubGVuZ3RoLTE7aT49MDtpLS0pe3JlcGxhY2VSYW5nZShjbS5kb2MsXCJcIixraWxsW2ldLmZyb20sa2lsbFtpXS50byxcIitkZWxldGVcIik7fWVuc3VyZUN1cnNvclZpc2libGUoY20pO30pO30vLyBDb21tYW5kcyBhcmUgcGFyYW1ldGVyLWxlc3MgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgb24gYW5cbi8vIGVkaXRvciwgbW9zdGx5IHVzZWQgZm9yIGtleWJpbmRpbmdzLlxudmFyIGNvbW1hbmRzPXtzZWxlY3RBbGw6c2VsZWN0QWxsLHNpbmdsZVNlbGVjdGlvbjpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoXCJhbmNob3JcIiksY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKSxzZWxfZG9udFNjcm9sbCk7fSxraWxsTGluZTpmdW5jdGlvbihjbSl7cmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sZnVuY3Rpb24ocmFuZ2Upe2lmKHJhbmdlLmVtcHR5KCkpe3ZhciBsZW49Z2V0TGluZShjbS5kb2MscmFuZ2UuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aDtpZihyYW5nZS5oZWFkLmNoPT1sZW4mJnJhbmdlLmhlYWQubGluZTxjbS5sYXN0TGluZSgpKXtyZXR1cm57ZnJvbTpyYW5nZS5oZWFkLHRvOlBvcyhyYW5nZS5oZWFkLmxpbmUrMSwwKX07fWVsc2V7cmV0dXJue2Zyb206cmFuZ2UuaGVhZCx0bzpQb3MocmFuZ2UuaGVhZC5saW5lLGxlbil9O319ZWxzZXtyZXR1cm57ZnJvbTpyYW5nZS5mcm9tKCksdG86cmFuZ2UudG8oKX07fX0pO30sZGVsZXRlTGluZTpmdW5jdGlvbihjbSl7cmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sZnVuY3Rpb24ocmFuZ2Upe3JldHVybntmcm9tOlBvcyhyYW5nZS5mcm9tKCkubGluZSwwKSx0bzpjbGlwUG9zKGNtLmRvYyxQb3MocmFuZ2UudG8oKS5saW5lKzEsMCkpfTt9KTt9LGRlbExpbmVMZWZ0OmZ1bmN0aW9uKGNtKXtyZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSxmdW5jdGlvbihyYW5nZSl7cmV0dXJue2Zyb206UG9zKHJhbmdlLmZyb20oKS5saW5lLDApLHRvOnJhbmdlLmZyb20oKX07fSk7fSxkZWxXcmFwcGVkTGluZUxlZnQ6ZnVuY3Rpb24oY20pe3JldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLGZ1bmN0aW9uKHJhbmdlKXt2YXIgdG9wPWNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCxcImRpdlwiKS50b3ArNTt2YXIgbGVmdFBvcz1jbS5jb29yZHNDaGFyKHtsZWZ0OjAsdG9wOnRvcH0sXCJkaXZcIik7cmV0dXJue2Zyb206bGVmdFBvcyx0bzpyYW5nZS5mcm9tKCl9O30pO30sZGVsV3JhcHBlZExpbmVSaWdodDpmdW5jdGlvbihjbSl7cmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sZnVuY3Rpb24ocmFuZ2Upe3ZhciB0b3A9Y20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLFwiZGl2XCIpLnRvcCs1O3ZhciByaWdodFBvcz1jbS5jb29yZHNDaGFyKHtsZWZ0OmNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCsxMDAsdG9wOnRvcH0sXCJkaXZcIik7cmV0dXJue2Zyb206cmFuZ2UuZnJvbSgpLHRvOnJpZ2h0UG9zfTt9KTt9LHVuZG86ZnVuY3Rpb24oY20pe3JldHVybiBjbS51bmRvKCk7fSxyZWRvOmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20ucmVkbygpO30sdW5kb1NlbGVjdGlvbjpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLnVuZG9TZWxlY3Rpb24oKTt9LHJlZG9TZWxlY3Rpb246ZnVuY3Rpb24oY20pe3JldHVybiBjbS5yZWRvU2VsZWN0aW9uKCk7fSxnb0RvY1N0YXJ0OmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwwKSk7fSxnb0RvY0VuZDpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbihQb3MoY20ubGFzdExpbmUoKSkpO30sZ29MaW5lU3RhcnQ6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2Upe3JldHVybiBsaW5lU3RhcnQoY20scmFuZ2UuaGVhZC5saW5lKTt9LHtvcmlnaW46XCIrbW92ZVwiLGJpYXM6MX0pO30sZ29MaW5lU3RhcnRTbWFydDpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSl7cmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLHJhbmdlLmhlYWQpO30se29yaWdpbjpcIittb3ZlXCIsYmlhczoxfSk7fSxnb0xpbmVFbmQ6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2Upe3JldHVybiBsaW5lRW5kKGNtLHJhbmdlLmhlYWQubGluZSk7fSx7b3JpZ2luOlwiK21vdmVcIixiaWFzOi0xfSk7fSxnb0xpbmVSaWdodDpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSl7dmFyIHRvcD1jbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsXCJkaXZcIikudG9wKzU7cmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6Y20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoKzEwMCx0b3A6dG9wfSxcImRpdlwiKTt9LHNlbF9tb3ZlKTt9LGdvTGluZUxlZnQ6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2Upe3ZhciB0b3A9Y20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLFwiZGl2XCIpLnRvcCs1O3JldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OjAsdG9wOnRvcH0sXCJkaXZcIik7fSxzZWxfbW92ZSk7fSxnb0xpbmVMZWZ0U21hcnQ6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2Upe3ZhciB0b3A9Y20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLFwiZGl2XCIpLnRvcCs1O3ZhciBwb3M9Y20uY29vcmRzQ2hhcih7bGVmdDowLHRvcDp0b3B9LFwiZGl2XCIpO2lmKHBvcy5jaDxjbS5nZXRMaW5lKHBvcy5saW5lKS5zZWFyY2goL1xcUy8pKXtyZXR1cm4gbGluZVN0YXJ0U21hcnQoY20scmFuZ2UuaGVhZCk7fXJldHVybiBwb3M7fSxzZWxfbW92ZSk7fSxnb0xpbmVVcDpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLm1vdmVWKC0xLFwibGluZVwiKTt9LGdvTGluZURvd246ZnVuY3Rpb24oY20pe3JldHVybiBjbS5tb3ZlVigxLFwibGluZVwiKTt9LGdvUGFnZVVwOmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20ubW92ZVYoLTEsXCJwYWdlXCIpO30sZ29QYWdlRG93bjpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLm1vdmVWKDEsXCJwYWdlXCIpO30sZ29DaGFyTGVmdDpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLm1vdmVIKC0xLFwiY2hhclwiKTt9LGdvQ2hhclJpZ2h0OmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20ubW92ZUgoMSxcImNoYXJcIik7fSxnb0NvbHVtbkxlZnQ6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5tb3ZlSCgtMSxcImNvbHVtblwiKTt9LGdvQ29sdW1uUmlnaHQ6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5tb3ZlSCgxLFwiY29sdW1uXCIpO30sZ29Xb3JkTGVmdDpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLm1vdmVIKC0xLFwid29yZFwiKTt9LGdvR3JvdXBSaWdodDpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLm1vdmVIKDEsXCJncm91cFwiKTt9LGdvR3JvdXBMZWZ0OmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20ubW92ZUgoLTEsXCJncm91cFwiKTt9LGdvV29yZFJpZ2h0OmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20ubW92ZUgoMSxcIndvcmRcIik7fSxkZWxDaGFyQmVmb3JlOmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20uZGVsZXRlSCgtMSxcImNoYXJcIik7fSxkZWxDaGFyQWZ0ZXI6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5kZWxldGVIKDEsXCJjaGFyXCIpO30sZGVsV29yZEJlZm9yZTpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLmRlbGV0ZUgoLTEsXCJ3b3JkXCIpO30sZGVsV29yZEFmdGVyOmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20uZGVsZXRlSCgxLFwid29yZFwiKTt9LGRlbEdyb3VwQmVmb3JlOmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20uZGVsZXRlSCgtMSxcImdyb3VwXCIpO30sZGVsR3JvdXBBZnRlcjpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLmRlbGV0ZUgoMSxcImdyb3VwXCIpO30saW5kZW50QXV0bzpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpO30saW5kZW50TW9yZTpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcImFkZFwiKTt9LGluZGVudExlc3M6ZnVuY3Rpb24oY20pe3JldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKTt9LGluc2VydFRhYjpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIik7fSxpbnNlcnRTb2Z0VGFiOmZ1bmN0aW9uKGNtKXt2YXIgc3BhY2VzPVtdLHJhbmdlcz1jbS5saXN0U2VsZWN0aW9ucygpLHRhYlNpemU9Y20ub3B0aW9ucy50YWJTaXplO2Zvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDtpKyspe3ZhciBwb3M9cmFuZ2VzW2ldLmZyb20oKTt2YXIgY29sPWNvdW50Q29sdW1uKGNtLmdldExpbmUocG9zLmxpbmUpLHBvcy5jaCx0YWJTaXplKTtzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplLWNvbCV0YWJTaXplKSk7fWNtLnJlcGxhY2VTZWxlY3Rpb25zKHNwYWNlcyk7fSxkZWZhdWx0VGFiOmZ1bmN0aW9uKGNtKXtpZihjbS5zb21ldGhpbmdTZWxlY3RlZCgpKXtjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7fWVsc2V7Y20uZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIik7fX0sLy8gU3dhcCB0aGUgdHdvIGNoYXJzIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggc2VsZWN0aW9uJ3MgaGVhZC5cbi8vIE1vdmUgY3Vyc29yIGJlaGluZCB0aGUgdHdvIHN3YXBwZWQgY2hhcmFjdGVycyBhZnRlcndhcmRzLlxuLy9cbi8vIERvZXNuJ3QgY29uc2lkZXIgbGluZSBmZWVkcyBhIGNoYXJhY3Rlci5cbi8vIERvZXNuJ3Qgc2NhbiBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgdG8gZmluZCBhIGNoYXJhY3Rlci5cbi8vIERvZXNuJ3QgZG8gYW55dGhpbmcgb24gYW4gZW1wdHkgbGluZS5cbi8vIERvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBub24tZW1wdHkgc2VsZWN0aW9ucy5cbnRyYW5zcG9zZUNoYXJzOmZ1bmN0aW9uKGNtKXtyZXR1cm4gcnVuSW5PcChjbSxmdW5jdGlvbigpe3ZhciByYW5nZXM9Y20ubGlzdFNlbGVjdGlvbnMoKSxuZXdTZWw9W107Zm9yKHZhciBpPTA7aTxyYW5nZXMubGVuZ3RoO2krKyl7aWYoIXJhbmdlc1tpXS5lbXB0eSgpKXtjb250aW51ZTt9dmFyIGN1cj1yYW5nZXNbaV0uaGVhZCxsaW5lPWdldExpbmUoY20uZG9jLGN1ci5saW5lKS50ZXh0O2lmKGxpbmUpe2lmKGN1ci5jaD09bGluZS5sZW5ndGgpe2N1cj1uZXcgUG9zKGN1ci5saW5lLGN1ci5jaC0xKTt9aWYoY3VyLmNoPjApe2N1cj1uZXcgUG9zKGN1ci5saW5lLGN1ci5jaCsxKTtjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoLTEpK2xpbmUuY2hhckF0KGN1ci5jaC0yKSxQb3MoY3VyLmxpbmUsY3VyLmNoLTIpLGN1cixcIit0cmFuc3Bvc2VcIik7fWVsc2UgaWYoY3VyLmxpbmU+Y20uZG9jLmZpcnN0KXt2YXIgcHJldj1nZXRMaW5lKGNtLmRvYyxjdXIubGluZS0xKS50ZXh0O2lmKHByZXYpe2N1cj1uZXcgUG9zKGN1ci5saW5lLDEpO2NtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdCgwKStjbS5kb2MubGluZVNlcGFyYXRvcigpK3ByZXYuY2hhckF0KHByZXYubGVuZ3RoLTEpLFBvcyhjdXIubGluZS0xLHByZXYubGVuZ3RoLTEpLGN1cixcIit0cmFuc3Bvc2VcIik7fX19bmV3U2VsLnB1c2gobmV3IFJhbmdlKGN1cixjdXIpKTt9Y20uc2V0U2VsZWN0aW9ucyhuZXdTZWwpO30pO30sbmV3bGluZUFuZEluZGVudDpmdW5jdGlvbihjbSl7cmV0dXJuIHJ1bkluT3AoY20sZnVuY3Rpb24oKXt2YXIgc2Vscz1jbS5saXN0U2VsZWN0aW9ucygpO2Zvcih2YXIgaT1zZWxzLmxlbmd0aC0xO2k+PTA7aS0tKXtjbS5yZXBsYWNlUmFuZ2UoY20uZG9jLmxpbmVTZXBhcmF0b3IoKSxzZWxzW2ldLmFuY2hvcixzZWxzW2ldLmhlYWQsXCIraW5wdXRcIik7fXNlbHM9Y20ubGlzdFNlbGVjdGlvbnMoKTtmb3IodmFyIGkkMT0wO2kkMTxzZWxzLmxlbmd0aDtpJDErKyl7Y20uaW5kZW50TGluZShzZWxzW2kkMV0uZnJvbSgpLmxpbmUsbnVsbCx0cnVlKTt9ZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7fSk7fSxvcGVuTGluZTpmdW5jdGlvbihjbSl7cmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXG5cIixcInN0YXJ0XCIpO30sdG9nZ2xlT3ZlcndyaXRlOmZ1bmN0aW9uKGNtKXtyZXR1cm4gY20udG9nZ2xlT3ZlcndyaXRlKCk7fX07ZnVuY3Rpb24gbGluZVN0YXJ0KGNtLGxpbmVOKXt2YXIgbGluZT1nZXRMaW5lKGNtLmRvYyxsaW5lTik7dmFyIHZpc3VhbD12aXN1YWxMaW5lKGxpbmUpO2lmKHZpc3VhbCE9bGluZSl7bGluZU49bGluZU5vKHZpc3VhbCk7fXZhciBvcmRlcj1nZXRPcmRlcih2aXN1YWwpO3ZhciBjaD0hb3JkZXI/MDpvcmRlclswXS5sZXZlbCUyP2xpbmVSaWdodCh2aXN1YWwpOmxpbmVMZWZ0KHZpc3VhbCk7cmV0dXJuIFBvcyhsaW5lTixjaCk7fWZ1bmN0aW9uIGxpbmVFbmQoY20sbGluZU4pe3ZhciBtZXJnZWQsbGluZT1nZXRMaW5lKGNtLmRvYyxsaW5lTik7d2hpbGUobWVyZ2VkPWNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSl7bGluZT1tZXJnZWQuZmluZCgxLHRydWUpLmxpbmU7bGluZU49bnVsbDt9dmFyIG9yZGVyPWdldE9yZGVyKGxpbmUpO3ZhciBjaD0hb3JkZXI/bGluZS50ZXh0Lmxlbmd0aDpvcmRlclswXS5sZXZlbCUyP2xpbmVMZWZ0KGxpbmUpOmxpbmVSaWdodChsaW5lKTtyZXR1cm4gUG9zKGxpbmVOPT1udWxsP2xpbmVObyhsaW5lKTpsaW5lTixjaCk7fWZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLHBvcyl7dmFyIHN0YXJ0PWxpbmVTdGFydChjbSxwb3MubGluZSk7dmFyIGxpbmU9Z2V0TGluZShjbS5kb2Msc3RhcnQubGluZSk7dmFyIG9yZGVyPWdldE9yZGVyKGxpbmUpO2lmKCFvcmRlcnx8b3JkZXJbMF0ubGV2ZWw9PTApe3ZhciBmaXJzdE5vbldTPU1hdGgubWF4KDAsbGluZS50ZXh0LnNlYXJjaCgvXFxTLykpO3ZhciBpbldTPXBvcy5saW5lPT1zdGFydC5saW5lJiZwb3MuY2g8PWZpcnN0Tm9uV1MmJnBvcy5jaDtyZXR1cm4gUG9zKHN0YXJ0LmxpbmUsaW5XUz8wOmZpcnN0Tm9uV1MpO31yZXR1cm4gc3RhcnQ7fS8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXG5mdW5jdGlvbiBkb0hhbmRsZUJpbmRpbmcoY20sYm91bmQsZHJvcFNoaWZ0KXtpZih0eXBlb2YgYm91bmQ9PVwic3RyaW5nXCIpe2JvdW5kPWNvbW1hbmRzW2JvdW5kXTtpZighYm91bmQpe3JldHVybiBmYWxzZTt9fS8vIEVuc3VyZSBwcmV2aW91cyBpbnB1dCBoYXMgYmVlbiByZWFkLCBzbyB0aGF0IHRoZSBoYW5kbGVyIHNlZXMgYVxuLy8gY29uc2lzdGVudCB2aWV3IG9mIHRoZSBkb2N1bWVudFxuY20uZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKTt2YXIgcHJldlNoaWZ0PWNtLmRpc3BsYXkuc2hpZnQsZG9uZT1mYWxzZTt0cnl7aWYoY20uaXNSZWFkT25seSgpKXtjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzPXRydWU7fWlmKGRyb3BTaGlmdCl7Y20uZGlzcGxheS5zaGlmdD1mYWxzZTt9ZG9uZT1ib3VuZChjbSkhPVBhc3M7fWZpbmFsbHl7Y20uZGlzcGxheS5zaGlmdD1wcmV2U2hpZnQ7Y20uc3RhdGUuc3VwcHJlc3NFZGl0cz1mYWxzZTt9cmV0dXJuIGRvbmU7fWZ1bmN0aW9uIGxvb2t1cEtleUZvckVkaXRvcihjbSxuYW1lLGhhbmRsZSl7Zm9yKHZhciBpPTA7aTxjbS5zdGF0ZS5rZXlNYXBzLmxlbmd0aDtpKyspe3ZhciByZXN1bHQ9bG9va3VwS2V5KG5hbWUsY20uc3RhdGUua2V5TWFwc1tpXSxoYW5kbGUsY20pO2lmKHJlc3VsdCl7cmV0dXJuIHJlc3VsdDt9fXJldHVybiBjbS5vcHRpb25zLmV4dHJhS2V5cyYmbG9va3VwS2V5KG5hbWUsY20ub3B0aW9ucy5leHRyYUtleXMsaGFuZGxlLGNtKXx8bG9va3VwS2V5KG5hbWUsY20ub3B0aW9ucy5rZXlNYXAsaGFuZGxlLGNtKTt9dmFyIHN0b3BTZXE9bmV3IERlbGF5ZWQoKTtmdW5jdGlvbiBkaXNwYXRjaEtleShjbSxuYW1lLGUsaGFuZGxlKXt2YXIgc2VxPWNtLnN0YXRlLmtleVNlcTtpZihzZXEpe2lmKGlzTW9kaWZpZXJLZXkobmFtZSkpe3JldHVyblwiaGFuZGxlZFwiO31zdG9wU2VxLnNldCg1MCxmdW5jdGlvbigpe2lmKGNtLnN0YXRlLmtleVNlcT09c2VxKXtjbS5zdGF0ZS5rZXlTZXE9bnVsbDtjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7fX0pO25hbWU9c2VxK1wiIFwiK25hbWU7fXZhciByZXN1bHQ9bG9va3VwS2V5Rm9yRWRpdG9yKGNtLG5hbWUsaGFuZGxlKTtpZihyZXN1bHQ9PVwibXVsdGlcIil7Y20uc3RhdGUua2V5U2VxPW5hbWU7fWlmKHJlc3VsdD09XCJoYW5kbGVkXCIpe3NpZ25hbExhdGVyKGNtLFwia2V5SGFuZGxlZFwiLGNtLG5hbWUsZSk7fWlmKHJlc3VsdD09XCJoYW5kbGVkXCJ8fHJlc3VsdD09XCJtdWx0aVwiKXtlX3ByZXZlbnREZWZhdWx0KGUpO3Jlc3RhcnRCbGluayhjbSk7fWlmKHNlcSYmIXJlc3VsdCYmL1xcJyQvLnRlc3QobmFtZSkpe2VfcHJldmVudERlZmF1bHQoZSk7cmV0dXJuIHRydWU7fXJldHVybiEhcmVzdWx0O30vLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5ZG93biBldmVudC5cbmZ1bmN0aW9uIGhhbmRsZUtleUJpbmRpbmcoY20sZSl7dmFyIG5hbWU9a2V5TmFtZShlLHRydWUpO2lmKCFuYW1lKXtyZXR1cm4gZmFsc2U7fWlmKGUuc2hpZnRLZXkmJiFjbS5zdGF0ZS5rZXlTZXEpey8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xuLy8gdGhhdCwgc2VlIGlmIHRoZXJlIGlzIGEgY3Vyc29yLW1vdGlvbiBjb21tYW5kIChzdGFydGluZyB3aXRoXG4vLyAnZ28nKSBib3VuZCB0byB0aGUga2V5bmFtZSB3aXRob3V0ICdTaGlmdC0nLlxucmV0dXJuIGRpc3BhdGNoS2V5KGNtLFwiU2hpZnQtXCIrbmFtZSxlLGZ1bmN0aW9uKGIpe3JldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sYix0cnVlKTt9KXx8ZGlzcGF0Y2hLZXkoY20sbmFtZSxlLGZ1bmN0aW9uKGIpe2lmKHR5cGVvZiBiPT1cInN0cmluZ1wiPy9eZ29bQS1aXS8udGVzdChiKTpiLm1vdGlvbil7cmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSxiKTt9fSk7fWVsc2V7cmV0dXJuIGRpc3BhdGNoS2V5KGNtLG5hbWUsZSxmdW5jdGlvbihiKXtyZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLGIpO30pO319Ly8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleXByZXNzIGV2ZW50XG5mdW5jdGlvbiBoYW5kbGVDaGFyQmluZGluZyhjbSxlLGNoKXtyZXR1cm4gZGlzcGF0Y2hLZXkoY20sXCInXCIrY2grXCInXCIsZSxmdW5jdGlvbihiKXtyZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLGIsdHJ1ZSk7fSk7fXZhciBsYXN0U3RvcHBlZEtleT1udWxsO2Z1bmN0aW9uIG9uS2V5RG93bihlKXt2YXIgY209dGhpcztjbS5jdXJPcC5mb2N1cz1hY3RpdmVFbHQoKTtpZihzaWduYWxET01FdmVudChjbSxlKSl7cmV0dXJuO30vLyBJRSBkb2VzIHN0cmFuZ2UgdGhpbmdzIHdpdGggZXNjYXBlLlxuaWYoaWUmJmllX3ZlcnNpb248MTEmJmUua2V5Q29kZT09Mjcpe2UucmV0dXJuVmFsdWU9ZmFsc2U7fXZhciBjb2RlPWUua2V5Q29kZTtjbS5kaXNwbGF5LnNoaWZ0PWNvZGU9PTE2fHxlLnNoaWZ0S2V5O3ZhciBoYW5kbGVkPWhhbmRsZUtleUJpbmRpbmcoY20sZSk7aWYocHJlc3RvKXtsYXN0U3RvcHBlZEtleT1oYW5kbGVkP2NvZGU6bnVsbDsvLyBPcGVyYSBoYXMgbm8gY3V0IGV2ZW50Li4uIHdlIHRyeSB0byBhdCBsZWFzdCBjYXRjaCB0aGUga2V5IGNvbWJvXG5pZighaGFuZGxlZCYmY29kZT09ODgmJiFoYXNDb3B5RXZlbnQmJihtYWM/ZS5tZXRhS2V5OmUuY3RybEtleSkpe2NtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiY3V0XCIpO319Ly8gVHVybiBtb3VzZSBpbnRvIGNyb3NzaGFpciB3aGVuIEFsdCBpcyBoZWxkIG9uIE1hYy5cbmlmKGNvZGU9PTE4JiYhL1xcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxiLy50ZXN0KGNtLmRpc3BsYXkubGluZURpdi5jbGFzc05hbWUpKXtzaG93Q3Jvc3NIYWlyKGNtKTt9fWZ1bmN0aW9uIHNob3dDcm9zc0hhaXIoY20pe3ZhciBsaW5lRGl2PWNtLmRpc3BsYXkubGluZURpdjthZGRDbGFzcyhsaW5lRGl2LFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIik7ZnVuY3Rpb24gdXAoZSl7aWYoZS5rZXlDb2RlPT0xOHx8IWUuYWx0S2V5KXtybUNsYXNzKGxpbmVEaXYsXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtvZmYoZG9jdW1lbnQsXCJrZXl1cFwiLHVwKTtvZmYoZG9jdW1lbnQsXCJtb3VzZW92ZXJcIix1cCk7fX1vbihkb2N1bWVudCxcImtleXVwXCIsdXApO29uKGRvY3VtZW50LFwibW91c2VvdmVyXCIsdXApO31mdW5jdGlvbiBvbktleVVwKGUpe2lmKGUua2V5Q29kZT09MTYpe3RoaXMuZG9jLnNlbC5zaGlmdD1mYWxzZTt9c2lnbmFsRE9NRXZlbnQodGhpcyxlKTt9ZnVuY3Rpb24gb25LZXlQcmVzcyhlKXt2YXIgY209dGhpcztpZihldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksZSl8fHNpZ25hbERPTUV2ZW50KGNtLGUpfHxlLmN0cmxLZXkmJiFlLmFsdEtleXx8bWFjJiZlLm1ldGFLZXkpe3JldHVybjt9dmFyIGtleUNvZGU9ZS5rZXlDb2RlLGNoYXJDb2RlPWUuY2hhckNvZGU7aWYocHJlc3RvJiZrZXlDb2RlPT1sYXN0U3RvcHBlZEtleSl7bGFzdFN0b3BwZWRLZXk9bnVsbDtlX3ByZXZlbnREZWZhdWx0KGUpO3JldHVybjt9aWYocHJlc3RvJiYoIWUud2hpY2h8fGUud2hpY2g8MTApJiZoYW5kbGVLZXlCaW5kaW5nKGNtLGUpKXtyZXR1cm47fXZhciBjaD1TdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlPT1udWxsP2tleUNvZGU6Y2hhckNvZGUpOy8vIFNvbWUgYnJvd3NlcnMgZmlyZSBrZXlwcmVzcyBldmVudHMgZm9yIGJhY2tzcGFjZVxuaWYoY2g9PVwiXFx4MDhcIil7cmV0dXJuO31pZihoYW5kbGVDaGFyQmluZGluZyhjbSxlLGNoKSl7cmV0dXJuO31jbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSk7fS8vIEEgbW91c2UgZG93biBjYW4gYmUgYSBzaW5nbGUgY2xpY2ssIGRvdWJsZSBjbGljaywgdHJpcGxlIGNsaWNrLFxuLy8gc3RhcnQgb2Ygc2VsZWN0aW9uIGRyYWcsIHN0YXJ0IG9mIHRleHQgZHJhZywgbmV3IGN1cnNvclxuLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXG4vLyBtaWRkbGUtY2xpY2stcGFzdGUuIE9yIGl0IG1pZ2h0IGJlIGEgY2xpY2sgb24gc29tZXRoaW5nIHdlIHNob3VsZFxuLy8gbm90IGludGVyZmVyZSB3aXRoLCBzdWNoIGFzIGEgc2Nyb2xsYmFyIG9yIHdpZGdldC5cbmZ1bmN0aW9uIG9uTW91c2VEb3duKGUpe3ZhciBjbT10aGlzLGRpc3BsYXk9Y20uZGlzcGxheTtpZihzaWduYWxET01FdmVudChjbSxlKXx8ZGlzcGxheS5hY3RpdmVUb3VjaCYmZGlzcGxheS5pbnB1dC5zdXBwb3J0c1RvdWNoKCkpe3JldHVybjt9ZGlzcGxheS5zaGlmdD1lLnNoaWZ0S2V5O2lmKGV2ZW50SW5XaWRnZXQoZGlzcGxheSxlKSl7aWYoIXdlYmtpdCl7Ly8gQnJpZWZseSB0dXJuIG9mZiBkcmFnZ2FiaWxpdHksIHRvIGFsbG93IHdpZGdldHMgdG8gZG9cbi8vIG5vcm1hbCBkcmFnZ2luZyB0aGluZ3MuXG5kaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZT1mYWxzZTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlPXRydWU7fSwxMDApO31yZXR1cm47fWlmKGNsaWNrSW5HdXR0ZXIoY20sZSkpe3JldHVybjt9dmFyIHN0YXJ0PXBvc0Zyb21Nb3VzZShjbSxlKTt3aW5kb3cuZm9jdXMoKTtzd2l0Y2goZV9idXR0b24oZSkpe2Nhc2UgMTovLyAjMzI2MTogbWFrZSBzdXJlLCB0aGF0IHdlJ3JlIG5vdCBzdGFydGluZyBhIHNlY29uZCBzZWxlY3Rpb25cbmlmKGNtLnN0YXRlLnNlbGVjdGluZ1RleHQpe2NtLnN0YXRlLnNlbGVjdGluZ1RleHQoZSk7fWVsc2UgaWYoc3RhcnQpe2xlZnRCdXR0b25Eb3duKGNtLGUsc3RhcnQpO31lbHNlIGlmKGVfdGFyZ2V0KGUpPT1kaXNwbGF5LnNjcm9sbGVyKXtlX3ByZXZlbnREZWZhdWx0KGUpO31icmVhaztjYXNlIDI6aWYod2Via2l0KXtjbS5zdGF0ZS5sYXN0TWlkZGxlRG93bj0rbmV3IERhdGUoKTt9aWYoc3RhcnQpe2V4dGVuZFNlbGVjdGlvbihjbS5kb2Msc3RhcnQpO31zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LDIwKTtlX3ByZXZlbnREZWZhdWx0KGUpO2JyZWFrO2Nhc2UgMzppZihjYXB0dXJlUmlnaHRDbGljayl7b25Db250ZXh0TWVudShjbSxlKTt9ZWxzZXtkZWxheUJsdXJFdmVudChjbSk7fWJyZWFrO319dmFyIGxhc3RDbGljazt2YXIgbGFzdERvdWJsZUNsaWNrO2Z1bmN0aW9uIGxlZnRCdXR0b25Eb3duKGNtLGUsc3RhcnQpe2lmKGllKXtzZXRUaW1lb3V0KGJpbmQoZW5zdXJlRm9jdXMsY20pLDApO31lbHNle2NtLmN1ck9wLmZvY3VzPWFjdGl2ZUVsdCgpO312YXIgbm93PStuZXcgRGF0ZSgpLHR5cGU7aWYobGFzdERvdWJsZUNsaWNrJiZsYXN0RG91YmxlQ2xpY2sudGltZT5ub3ctNDAwJiZjbXAobGFzdERvdWJsZUNsaWNrLnBvcyxzdGFydCk9PTApe3R5cGU9XCJ0cmlwbGVcIjt9ZWxzZSBpZihsYXN0Q2xpY2smJmxhc3RDbGljay50aW1lPm5vdy00MDAmJmNtcChsYXN0Q2xpY2sucG9zLHN0YXJ0KT09MCl7dHlwZT1cImRvdWJsZVwiO2xhc3REb3VibGVDbGljaz17dGltZTpub3cscG9zOnN0YXJ0fTt9ZWxzZXt0eXBlPVwic2luZ2xlXCI7bGFzdENsaWNrPXt0aW1lOm5vdyxwb3M6c3RhcnR9O312YXIgc2VsPWNtLmRvYy5zZWwsbW9kaWZpZXI9bWFjP2UubWV0YUtleTplLmN0cmxLZXksY29udGFpbmVkO2lmKGNtLm9wdGlvbnMuZHJhZ0Ryb3AmJmRyYWdBbmREcm9wJiYhY20uaXNSZWFkT25seSgpJiZ0eXBlPT1cInNpbmdsZVwiJiYoY29udGFpbmVkPXNlbC5jb250YWlucyhzdGFydCkpPi0xJiYoY21wKChjb250YWluZWQ9c2VsLnJhbmdlc1tjb250YWluZWRdKS5mcm9tKCksc3RhcnQpPDB8fHN0YXJ0LnhSZWw+MCkmJihjbXAoY29udGFpbmVkLnRvKCksc3RhcnQpPjB8fHN0YXJ0LnhSZWw8MCkpe2xlZnRCdXR0b25TdGFydERyYWcoY20sZSxzdGFydCxtb2RpZmllcik7fWVsc2V7bGVmdEJ1dHRvblNlbGVjdChjbSxlLHN0YXJ0LHR5cGUsbW9kaWZpZXIpO319Ly8gU3RhcnQgYSB0ZXh0IGRyYWcuIFdoZW4gaXQgZW5kcywgc2VlIGlmIGFueSBkcmFnZ2luZyBhY3R1YWxseVxuLy8gaGFwcGVuLCBhbmQgdHJlYXQgYXMgYSBjbGljayBpZiBpdCBkaWRuJ3QuXG5mdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLGUsc3RhcnQsbW9kaWZpZXIpe3ZhciBkaXNwbGF5PWNtLmRpc3BsYXksc3RhcnRUaW1lPStuZXcgRGF0ZSgpO3ZhciBkcmFnRW5kPW9wZXJhdGlvbihjbSxmdW5jdGlvbihlMil7aWYod2Via2l0KXtkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZT1mYWxzZTt9Y20uc3RhdGUuZHJhZ2dpbmdUZXh0PWZhbHNlO29mZihkb2N1bWVudCxcIm1vdXNldXBcIixkcmFnRW5kKTtvZmYoZGlzcGxheS5zY3JvbGxlcixcImRyb3BcIixkcmFnRW5kKTtpZihNYXRoLmFicyhlLmNsaWVudFgtZTIuY2xpZW50WCkrTWF0aC5hYnMoZS5jbGllbnRZLWUyLmNsaWVudFkpPDEwKXtlX3ByZXZlbnREZWZhdWx0KGUyKTtpZighbW9kaWZpZXImJituZXcgRGF0ZSgpLTIwMDxzdGFydFRpbWUpe2V4dGVuZFNlbGVjdGlvbihjbS5kb2Msc3RhcnQpO30vLyBXb3JrIGFyb3VuZCB1bmV4cGxhaW5hYmxlIGZvY3VzIHByb2JsZW0gaW4gSUU5ICgjMjEyNykgYW5kIENocm9tZSAoIzMwODEpXG5pZih3ZWJraXR8fGllJiZpZV92ZXJzaW9uPT05KXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZG9jdW1lbnQuYm9keS5mb2N1cygpO2Rpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LDIwKTt9ZWxzZXtkaXNwbGF5LmlucHV0LmZvY3VzKCk7fX19KTsvLyBMZXQgdGhlIGRyYWcgaGFuZGxlciBoYW5kbGUgdGhpcy5cbmlmKHdlYmtpdCl7ZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGU9dHJ1ZTt9Y20uc3RhdGUuZHJhZ2dpbmdUZXh0PWRyYWdFbmQ7ZHJhZ0VuZC5jb3B5PW1hYz9lLmFsdEtleTplLmN0cmxLZXk7Ly8gSUUncyBhcHByb2FjaCB0byBkcmFnZ2FibGVcbmlmKGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3Ape2Rpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKTt9b24oZG9jdW1lbnQsXCJtb3VzZXVwXCIsZHJhZ0VuZCk7b24oZGlzcGxheS5zY3JvbGxlcixcImRyb3BcIixkcmFnRW5kKTt9Ly8gTm9ybWFsIHNlbGVjdGlvbiwgYXMgb3Bwb3NlZCB0byB0ZXh0IGRyYWdnaW5nLlxuZnVuY3Rpb24gbGVmdEJ1dHRvblNlbGVjdChjbSxlLHN0YXJ0LHR5cGUsYWRkTmV3KXt2YXIgZGlzcGxheT1jbS5kaXNwbGF5LGRvYz1jbS5kb2M7ZV9wcmV2ZW50RGVmYXVsdChlKTt2YXIgb3VyUmFuZ2Usb3VySW5kZXgsc3RhcnRTZWw9ZG9jLnNlbCxyYW5nZXM9c3RhcnRTZWwucmFuZ2VzO2lmKGFkZE5ldyYmIWUuc2hpZnRLZXkpe291ckluZGV4PWRvYy5zZWwuY29udGFpbnMoc3RhcnQpO2lmKG91ckluZGV4Pi0xKXtvdXJSYW5nZT1yYW5nZXNbb3VySW5kZXhdO31lbHNle291clJhbmdlPW5ldyBSYW5nZShzdGFydCxzdGFydCk7fX1lbHNle291clJhbmdlPWRvYy5zZWwucHJpbWFyeSgpO291ckluZGV4PWRvYy5zZWwucHJpbUluZGV4O31pZihjaHJvbWVPUz9lLnNoaWZ0S2V5JiZlLm1ldGFLZXk6ZS5hbHRLZXkpe3R5cGU9XCJyZWN0XCI7aWYoIWFkZE5ldyl7b3VyUmFuZ2U9bmV3IFJhbmdlKHN0YXJ0LHN0YXJ0KTt9c3RhcnQ9cG9zRnJvbU1vdXNlKGNtLGUsdHJ1ZSx0cnVlKTtvdXJJbmRleD0tMTt9ZWxzZSBpZih0eXBlPT1cImRvdWJsZVwiKXt2YXIgd29yZD1jbS5maW5kV29yZEF0KHN0YXJ0KTtpZihjbS5kaXNwbGF5LnNoaWZ0fHxkb2MuZXh0ZW5kKXtvdXJSYW5nZT1leHRlbmRSYW5nZShkb2Msb3VyUmFuZ2Usd29yZC5hbmNob3Isd29yZC5oZWFkKTt9ZWxzZXtvdXJSYW5nZT13b3JkO319ZWxzZSBpZih0eXBlPT1cInRyaXBsZVwiKXt2YXIgbGluZT1uZXcgUmFuZ2UoUG9zKHN0YXJ0LmxpbmUsMCksY2xpcFBvcyhkb2MsUG9zKHN0YXJ0LmxpbmUrMSwwKSkpO2lmKGNtLmRpc3BsYXkuc2hpZnR8fGRvYy5leHRlbmQpe291clJhbmdlPWV4dGVuZFJhbmdlKGRvYyxvdXJSYW5nZSxsaW5lLmFuY2hvcixsaW5lLmhlYWQpO31lbHNle291clJhbmdlPWxpbmU7fX1lbHNle291clJhbmdlPWV4dGVuZFJhbmdlKGRvYyxvdXJSYW5nZSxzdGFydCk7fWlmKCFhZGROZXcpe291ckluZGV4PTA7c2V0U2VsZWN0aW9uKGRvYyxuZXcgU2VsZWN0aW9uKFtvdXJSYW5nZV0sMCksc2VsX21vdXNlKTtzdGFydFNlbD1kb2Muc2VsO31lbHNlIGlmKG91ckluZGV4PT0tMSl7b3VySW5kZXg9cmFuZ2VzLmxlbmd0aDtzZXRTZWxlY3Rpb24oZG9jLG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuY29uY2F0KFtvdXJSYW5nZV0pLG91ckluZGV4KSx7c2Nyb2xsOmZhbHNlLG9yaWdpbjpcIiptb3VzZVwifSk7fWVsc2UgaWYocmFuZ2VzLmxlbmd0aD4xJiZyYW5nZXNbb3VySW5kZXhdLmVtcHR5KCkmJnR5cGU9PVwic2luZ2xlXCImJiFlLnNoaWZ0S2V5KXtzZXRTZWxlY3Rpb24oZG9jLG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuc2xpY2UoMCxvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCsxKSksMCkse3Njcm9sbDpmYWxzZSxvcmlnaW46XCIqbW91c2VcIn0pO3N0YXJ0U2VsPWRvYy5zZWw7fWVsc2V7cmVwbGFjZU9uZVNlbGVjdGlvbihkb2Msb3VySW5kZXgsb3VyUmFuZ2Usc2VsX21vdXNlKTt9dmFyIGxhc3RQb3M9c3RhcnQ7ZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKXtpZihjbXAobGFzdFBvcyxwb3MpPT0wKXtyZXR1cm47fWxhc3RQb3M9cG9zO2lmKHR5cGU9PVwicmVjdFwiKXt2YXIgcmFuZ2VzPVtdLHRhYlNpemU9Y20ub3B0aW9ucy50YWJTaXplO3ZhciBzdGFydENvbD1jb3VudENvbHVtbihnZXRMaW5lKGRvYyxzdGFydC5saW5lKS50ZXh0LHN0YXJ0LmNoLHRhYlNpemUpO3ZhciBwb3NDb2w9Y291bnRDb2x1bW4oZ2V0TGluZShkb2MscG9zLmxpbmUpLnRleHQscG9zLmNoLHRhYlNpemUpO3ZhciBsZWZ0PU1hdGgubWluKHN0YXJ0Q29sLHBvc0NvbCkscmlnaHQ9TWF0aC5tYXgoc3RhcnRDb2wscG9zQ29sKTtmb3IodmFyIGxpbmU9TWF0aC5taW4oc3RhcnQubGluZSxwb3MubGluZSksZW5kPU1hdGgubWluKGNtLmxhc3RMaW5lKCksTWF0aC5tYXgoc3RhcnQubGluZSxwb3MubGluZSkpO2xpbmU8PWVuZDtsaW5lKyspe3ZhciB0ZXh0PWdldExpbmUoZG9jLGxpbmUpLnRleHQsbGVmdFBvcz1maW5kQ29sdW1uKHRleHQsbGVmdCx0YWJTaXplKTtpZihsZWZ0PT1yaWdodCl7cmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLGxlZnRQb3MpLFBvcyhsaW5lLGxlZnRQb3MpKSk7fWVsc2UgaWYodGV4dC5sZW5ndGg+bGVmdFBvcyl7cmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLGxlZnRQb3MpLFBvcyhsaW5lLGZpbmRDb2x1bW4odGV4dCxyaWdodCx0YWJTaXplKSkpKTt9fWlmKCFyYW5nZXMubGVuZ3RoKXtyYW5nZXMucHVzaChuZXcgUmFuZ2Uoc3RhcnQsc3RhcnQpKTt9c2V0U2VsZWN0aW9uKGRvYyxub3JtYWxpemVTZWxlY3Rpb24oc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDAsb3VySW5kZXgpLmNvbmNhdChyYW5nZXMpLG91ckluZGV4KSx7b3JpZ2luOlwiKm1vdXNlXCIsc2Nyb2xsOmZhbHNlfSk7Y20uc2Nyb2xsSW50b1ZpZXcocG9zKTt9ZWxzZXt2YXIgb2xkUmFuZ2U9b3VyUmFuZ2U7dmFyIGFuY2hvcj1vbGRSYW5nZS5hbmNob3IsaGVhZD1wb3M7aWYodHlwZSE9XCJzaW5nbGVcIil7dmFyIHJhbmdlO2lmKHR5cGU9PVwiZG91YmxlXCIpe3JhbmdlPWNtLmZpbmRXb3JkQXQocG9zKTt9ZWxzZXtyYW5nZT1uZXcgUmFuZ2UoUG9zKHBvcy5saW5lLDApLGNsaXBQb3MoZG9jLFBvcyhwb3MubGluZSsxLDApKSk7fWlmKGNtcChyYW5nZS5hbmNob3IsYW5jaG9yKT4wKXtoZWFkPXJhbmdlLmhlYWQ7YW5jaG9yPW1pblBvcyhvbGRSYW5nZS5mcm9tKCkscmFuZ2UuYW5jaG9yKTt9ZWxzZXtoZWFkPXJhbmdlLmFuY2hvcjthbmNob3I9bWF4UG9zKG9sZFJhbmdlLnRvKCkscmFuZ2UuaGVhZCk7fX12YXIgcmFuZ2VzJDE9c3RhcnRTZWwucmFuZ2VzLnNsaWNlKDApO3JhbmdlcyQxW291ckluZGV4XT1uZXcgUmFuZ2UoY2xpcFBvcyhkb2MsYW5jaG9yKSxoZWFkKTtzZXRTZWxlY3Rpb24oZG9jLG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMkMSxvdXJJbmRleCksc2VsX21vdXNlKTt9fXZhciBlZGl0b3JTaXplPWRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsvLyBVc2VkIHRvIGVuc3VyZSB0aW1lb3V0IHJlLXRyaWVzIGRvbid0IGZpcmUgd2hlbiBhbm90aGVyIGV4dGVuZFxuLy8gaGFwcGVuZWQgaW4gdGhlIG1lYW50aW1lIChjbGVhclRpbWVvdXQgaXNuJ3QgcmVsaWFibGUgLS0gYXRcbi8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcbi8vIGlmIHRoZSBjbGVhciBoYXBwZW5zIGFmdGVyIHRoZWlyIHNjaGVkdWxlZCBmaXJpbmcgdGltZSkuXG52YXIgY291bnRlcj0wO2Z1bmN0aW9uIGV4dGVuZChlKXt2YXIgY3VyQ291bnQ9Kytjb3VudGVyO3ZhciBjdXI9cG9zRnJvbU1vdXNlKGNtLGUsdHJ1ZSx0eXBlPT1cInJlY3RcIik7aWYoIWN1cil7cmV0dXJuO31pZihjbXAoY3VyLGxhc3RQb3MpIT0wKXtjbS5jdXJPcC5mb2N1cz1hY3RpdmVFbHQoKTtleHRlbmRUbyhjdXIpO3ZhciB2aXNpYmxlPXZpc2libGVMaW5lcyhkaXNwbGF5LGRvYyk7aWYoY3VyLmxpbmU+PXZpc2libGUudG98fGN1ci5saW5lPHZpc2libGUuZnJvbSl7c2V0VGltZW91dChvcGVyYXRpb24oY20sZnVuY3Rpb24oKXtpZihjb3VudGVyPT1jdXJDb3VudCl7ZXh0ZW5kKGUpO319KSwxNTApO319ZWxzZXt2YXIgb3V0c2lkZT1lLmNsaWVudFk8ZWRpdG9yU2l6ZS50b3A/LTIwOmUuY2xpZW50WT5lZGl0b3JTaXplLmJvdHRvbT8yMDowO2lmKG91dHNpZGUpe3NldFRpbWVvdXQob3BlcmF0aW9uKGNtLGZ1bmN0aW9uKCl7aWYoY291bnRlciE9Y3VyQ291bnQpe3JldHVybjt9ZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3ArPW91dHNpZGU7ZXh0ZW5kKGUpO30pLDUwKTt9fX1mdW5jdGlvbiBkb25lKGUpe2NtLnN0YXRlLnNlbGVjdGluZ1RleHQ9ZmFsc2U7Y291bnRlcj1JbmZpbml0eTtlX3ByZXZlbnREZWZhdWx0KGUpO2Rpc3BsYXkuaW5wdXQuZm9jdXMoKTtvZmYoZG9jdW1lbnQsXCJtb3VzZW1vdmVcIixtb3ZlKTtvZmYoZG9jdW1lbnQsXCJtb3VzZXVwXCIsdXApO2RvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW49bnVsbDt9dmFyIG1vdmU9b3BlcmF0aW9uKGNtLGZ1bmN0aW9uKGUpe2lmKCFlX2J1dHRvbihlKSl7ZG9uZShlKTt9ZWxzZXtleHRlbmQoZSk7fX0pO3ZhciB1cD1vcGVyYXRpb24oY20sZG9uZSk7Y20uc3RhdGUuc2VsZWN0aW5nVGV4dD11cDtvbihkb2N1bWVudCxcIm1vdXNlbW92ZVwiLG1vdmUpO29uKGRvY3VtZW50LFwibW91c2V1cFwiLHVwKTt9Ly8gRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGV2ZW50IGhhcHBlbmVkIGluIHRoZSBndXR0ZXIsIGFuZCBmaXJlcyB0aGVcbi8vIGhhbmRsZXJzIGZvciB0aGUgY29ycmVzcG9uZGluZyBldmVudC5cbmZ1bmN0aW9uIGd1dHRlckV2ZW50KGNtLGUsdHlwZSxwcmV2ZW50KXt2YXIgbVgsbVk7dHJ5e21YPWUuY2xpZW50WDttWT1lLmNsaWVudFk7fWNhdGNoKGUpe3JldHVybiBmYWxzZTt9aWYobVg+PU1hdGguZmxvb3IoY20uZGlzcGxheS5ndXR0ZXJzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KSl7cmV0dXJuIGZhbHNlO31pZihwcmV2ZW50KXtlX3ByZXZlbnREZWZhdWx0KGUpO312YXIgZGlzcGxheT1jbS5kaXNwbGF5O3ZhciBsaW5lQm94PWRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihtWT5saW5lQm94LmJvdHRvbXx8IWhhc0hhbmRsZXIoY20sdHlwZSkpe3JldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSk7fW1ZLT1saW5lQm94LnRvcC1kaXNwbGF5LnZpZXdPZmZzZXQ7Zm9yKHZhciBpPTA7aTxjbS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOysraSl7dmFyIGc9ZGlzcGxheS5ndXR0ZXJzLmNoaWxkTm9kZXNbaV07aWYoZyYmZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodD49bVgpe3ZhciBsaW5lPWxpbmVBdEhlaWdodChjbS5kb2MsbVkpO3ZhciBndXR0ZXI9Y20ub3B0aW9ucy5ndXR0ZXJzW2ldO3NpZ25hbChjbSx0eXBlLGNtLGxpbmUsZ3V0dGVyLGUpO3JldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSk7fX19ZnVuY3Rpb24gY2xpY2tJbkd1dHRlcihjbSxlKXtyZXR1cm4gZ3V0dGVyRXZlbnQoY20sZSxcImd1dHRlckNsaWNrXCIsdHJ1ZSk7fS8vIENPTlRFWFQgTUVOVSBIQU5ETElOR1xuLy8gVG8gbWFrZSB0aGUgY29udGV4dCBtZW51IHdvcmssIHdlIG5lZWQgdG8gYnJpZWZseSB1bmhpZGUgdGhlXG4vLyB0ZXh0YXJlYSAobWFraW5nIGl0IGFzIHVub2J0cnVzaXZlIGFzIHBvc3NpYmxlKSB0byBsZXQgdGhlXG4vLyByaWdodC1jbGljayB0YWtlIGVmZmVjdCBvbiBpdC5cbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoY20sZSl7aWYoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LGUpfHxjb250ZXh0TWVudUluR3V0dGVyKGNtLGUpKXtyZXR1cm47fWlmKHNpZ25hbERPTUV2ZW50KGNtLGUsXCJjb250ZXh0bWVudVwiKSl7cmV0dXJuO31jbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7fWZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sZSl7aWYoIWhhc0hhbmRsZXIoY20sXCJndXR0ZXJDb250ZXh0TWVudVwiKSl7cmV0dXJuIGZhbHNlO31yZXR1cm4gZ3V0dGVyRXZlbnQoY20sZSxcImd1dHRlckNvbnRleHRNZW51XCIsZmFsc2UpO31mdW5jdGlvbiB0aGVtZUNoYW5nZWQoY20pe2NtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWU9Y20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqY20tcy1cXFMrL2csXCJcIikrY20ub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXHMpXFxzKi9nLFwiIGNtLXMtXCIpO2NsZWFyQ2FjaGVzKGNtKTt9dmFyIEluaXQ9e3RvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJDb2RlTWlycm9yLkluaXRcIjt9fTt2YXIgZGVmYXVsdHM9e307dmFyIG9wdGlvbkhhbmRsZXJzPXt9O2Z1bmN0aW9uIGRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcil7dmFyIG9wdGlvbkhhbmRsZXJzPUNvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnM7ZnVuY3Rpb24gb3B0aW9uKG5hbWUsZGVmbHQsaGFuZGxlLG5vdE9uSW5pdCl7Q29kZU1pcnJvci5kZWZhdWx0c1tuYW1lXT1kZWZsdDtpZihoYW5kbGUpe29wdGlvbkhhbmRsZXJzW25hbWVdPW5vdE9uSW5pdD9mdW5jdGlvbihjbSx2YWwsb2xkKXtpZihvbGQhPUluaXQpe2hhbmRsZShjbSx2YWwsb2xkKTt9fTpoYW5kbGU7fX1Db2RlTWlycm9yLmRlZmluZU9wdGlvbj1vcHRpb247Ly8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cbkNvZGVNaXJyb3IuSW5pdD1Jbml0Oy8vIFRoZXNlIHR3byBhcmUsIG9uIGluaXQsIGNhbGxlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlIHRoZXlcbi8vIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHRoZSBlZGl0b3IgY2FuIHN0YXJ0IGF0IGFsbC5cbm9wdGlvbihcInZhbHVlXCIsXCJcIixmdW5jdGlvbihjbSx2YWwpe3JldHVybiBjbS5zZXRWYWx1ZSh2YWwpO30sdHJ1ZSk7b3B0aW9uKFwibW9kZVwiLG51bGwsZnVuY3Rpb24oY20sdmFsKXtjbS5kb2MubW9kZU9wdGlvbj12YWw7bG9hZE1vZGUoY20pO30sdHJ1ZSk7b3B0aW9uKFwiaW5kZW50VW5pdFwiLDIsbG9hZE1vZGUsdHJ1ZSk7b3B0aW9uKFwiaW5kZW50V2l0aFRhYnNcIixmYWxzZSk7b3B0aW9uKFwic21hcnRJbmRlbnRcIix0cnVlKTtvcHRpb24oXCJ0YWJTaXplXCIsNCxmdW5jdGlvbihjbSl7cmVzZXRNb2RlU3RhdGUoY20pO2NsZWFyQ2FjaGVzKGNtKTtyZWdDaGFuZ2UoY20pO30sdHJ1ZSk7b3B0aW9uKFwibGluZVNlcGFyYXRvclwiLG51bGwsZnVuY3Rpb24oY20sdmFsKXtjbS5kb2MubGluZVNlcD12YWw7aWYoIXZhbCl7cmV0dXJuO312YXIgbmV3QnJlYWtzPVtdLGxpbmVObz1jbS5kb2MuZmlyc3Q7Y20uZG9jLml0ZXIoZnVuY3Rpb24obGluZSl7Zm9yKHZhciBwb3M9MDs7KXt2YXIgZm91bmQ9bGluZS50ZXh0LmluZGV4T2YodmFsLHBvcyk7aWYoZm91bmQ9PS0xKXticmVhazt9cG9zPWZvdW5kK3ZhbC5sZW5ndGg7bmV3QnJlYWtzLnB1c2goUG9zKGxpbmVObyxmb3VuZCkpO31saW5lTm8rKzt9KTtmb3IodmFyIGk9bmV3QnJlYWtzLmxlbmd0aC0xO2k+PTA7aS0tKXtyZXBsYWNlUmFuZ2UoY20uZG9jLHZhbCxuZXdCcmVha3NbaV0sUG9zKG5ld0JyZWFrc1tpXS5saW5lLG5ld0JyZWFrc1tpXS5jaCt2YWwubGVuZ3RoKSk7fX0pO29wdGlvbihcInNwZWNpYWxDaGFyc1wiLC9bXFx1MDAwMC1cXHUwMDFmXFx1MDA3ZlxcdTAwYWRcXHUyMDBiLVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdWZlZmZdL2csZnVuY3Rpb24oY20sdmFsLG9sZCl7Y20uc3RhdGUuc3BlY2lhbENoYXJzPW5ldyBSZWdFeHAodmFsLnNvdXJjZSsodmFsLnRlc3QoXCJcXHRcIik/XCJcIjpcInxcXHRcIiksXCJnXCIpO2lmKG9sZCE9SW5pdCl7Y20ucmVmcmVzaCgpO319KTtvcHRpb24oXCJzcGVjaWFsQ2hhclBsYWNlaG9sZGVyXCIsZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsZnVuY3Rpb24oY20pe3JldHVybiBjbS5yZWZyZXNoKCk7fSx0cnVlKTtvcHRpb24oXCJlbGVjdHJpY0NoYXJzXCIsdHJ1ZSk7b3B0aW9uKFwiaW5wdXRTdHlsZVwiLG1vYmlsZT9cImNvbnRlbnRlZGl0YWJsZVwiOlwidGV4dGFyZWFcIixmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcImlucHV0U3R5bGUgY2FuIG5vdCAoeWV0KSBiZSBjaGFuZ2VkIGluIGEgcnVubmluZyBlZGl0b3JcIik7Ly8gRklYTUVcbn0sdHJ1ZSk7b3B0aW9uKFwic3BlbGxjaGVja1wiLGZhbHNlLGZ1bmN0aW9uKGNtLHZhbCl7cmV0dXJuIGNtLmdldElucHV0RmllbGQoKS5zcGVsbGNoZWNrPXZhbDt9LHRydWUpO29wdGlvbihcInJ0bE1vdmVWaXN1YWxseVwiLCF3aW5kb3dzKTtvcHRpb24oXCJ3aG9sZUxpbmVVcGRhdGVCZWZvcmVcIix0cnVlKTtvcHRpb24oXCJ0aGVtZVwiLFwiZGVmYXVsdFwiLGZ1bmN0aW9uKGNtKXt0aGVtZUNoYW5nZWQoY20pO2d1dHRlcnNDaGFuZ2VkKGNtKTt9LHRydWUpO29wdGlvbihcImtleU1hcFwiLFwiZGVmYXVsdFwiLGZ1bmN0aW9uKGNtLHZhbCxvbGQpe3ZhciBuZXh0PWdldEtleU1hcCh2YWwpO3ZhciBwcmV2PW9sZCE9SW5pdCYmZ2V0S2V5TWFwKG9sZCk7aWYocHJldiYmcHJldi5kZXRhY2gpe3ByZXYuZGV0YWNoKGNtLG5leHQpO31pZihuZXh0LmF0dGFjaCl7bmV4dC5hdHRhY2goY20scHJldnx8bnVsbCk7fX0pO29wdGlvbihcImV4dHJhS2V5c1wiLG51bGwpO29wdGlvbihcImxpbmVXcmFwcGluZ1wiLGZhbHNlLHdyYXBwaW5nQ2hhbmdlZCx0cnVlKTtvcHRpb24oXCJndXR0ZXJzXCIsW10sZnVuY3Rpb24oY20pe3NldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhjbS5vcHRpb25zKTtndXR0ZXJzQ2hhbmdlZChjbSk7fSx0cnVlKTtvcHRpb24oXCJmaXhlZEd1dHRlclwiLHRydWUsZnVuY3Rpb24oY20sdmFsKXtjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdD12YWw/Y29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkrXCJweFwiOlwiMFwiO2NtLnJlZnJlc2goKTt9LHRydWUpO29wdGlvbihcImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyXCIsZmFsc2UsZnVuY3Rpb24oY20pe3JldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTt9LHRydWUpO29wdGlvbihcInNjcm9sbGJhclN0eWxlXCIsXCJuYXRpdmVcIixmdW5jdGlvbihjbSl7aW5pdFNjcm9sbGJhcnMoY20pO3VwZGF0ZVNjcm9sbGJhcnMoY20pO2NtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoY20uZG9jLnNjcm9sbFRvcCk7Y20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoY20uZG9jLnNjcm9sbExlZnQpO30sdHJ1ZSk7b3B0aW9uKFwibGluZU51bWJlcnNcIixmYWxzZSxmdW5jdGlvbihjbSl7c2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKGNtLm9wdGlvbnMpO2d1dHRlcnNDaGFuZ2VkKGNtKTt9LHRydWUpO29wdGlvbihcImZpcnN0TGluZU51bWJlclwiLDEsZ3V0dGVyc0NoYW5nZWQsdHJ1ZSk7b3B0aW9uKFwibGluZU51bWJlckZvcm1hdHRlclwiLGZ1bmN0aW9uKGludGVnZXIpe3JldHVybiBpbnRlZ2VyO30sZ3V0dGVyc0NoYW5nZWQsdHJ1ZSk7b3B0aW9uKFwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmdcIixmYWxzZSx1cGRhdGVTZWxlY3Rpb24sdHJ1ZSk7b3B0aW9uKFwicmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51XCIsdHJ1ZSk7b3B0aW9uKFwibGluZVdpc2VDb3B5Q3V0XCIsdHJ1ZSk7b3B0aW9uKFwicmVhZE9ubHlcIixmYWxzZSxmdW5jdGlvbihjbSx2YWwpe2lmKHZhbD09XCJub2N1cnNvclwiKXtvbkJsdXIoY20pO2NtLmRpc3BsYXkuaW5wdXQuYmx1cigpO2NtLmRpc3BsYXkuZGlzYWJsZWQ9dHJ1ZTt9ZWxzZXtjbS5kaXNwbGF5LmRpc2FibGVkPWZhbHNlO31jbS5kaXNwbGF5LmlucHV0LnJlYWRPbmx5Q2hhbmdlZCh2YWwpO30pO29wdGlvbihcImRpc2FibGVJbnB1dFwiLGZhbHNlLGZ1bmN0aW9uKGNtLHZhbCl7aWYoIXZhbCl7Y20uZGlzcGxheS5pbnB1dC5yZXNldCgpO319LHRydWUpO29wdGlvbihcImRyYWdEcm9wXCIsdHJ1ZSxkcmFnRHJvcENoYW5nZWQpO29wdGlvbihcImFsbG93RHJvcEZpbGVUeXBlc1wiLG51bGwpO29wdGlvbihcImN1cnNvckJsaW5rUmF0ZVwiLDUzMCk7b3B0aW9uKFwiY3Vyc29yU2Nyb2xsTWFyZ2luXCIsMCk7b3B0aW9uKFwiY3Vyc29ySGVpZ2h0XCIsMSx1cGRhdGVTZWxlY3Rpb24sdHJ1ZSk7b3B0aW9uKFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVwiLHRydWUsdXBkYXRlU2VsZWN0aW9uLHRydWUpO29wdGlvbihcIndvcmtUaW1lXCIsMTAwKTtvcHRpb24oXCJ3b3JrRGVsYXlcIiwxMDApO29wdGlvbihcImZsYXR0ZW5TcGFuc1wiLHRydWUscmVzZXRNb2RlU3RhdGUsdHJ1ZSk7b3B0aW9uKFwiYWRkTW9kZUNsYXNzXCIsZmFsc2UscmVzZXRNb2RlU3RhdGUsdHJ1ZSk7b3B0aW9uKFwicG9sbEludGVydmFsXCIsMTAwKTtvcHRpb24oXCJ1bmRvRGVwdGhcIiwyMDAsZnVuY3Rpb24oY20sdmFsKXtyZXR1cm4gY20uZG9jLmhpc3RvcnkudW5kb0RlcHRoPXZhbDt9KTtvcHRpb24oXCJoaXN0b3J5RXZlbnREZWxheVwiLDEyNTApO29wdGlvbihcInZpZXdwb3J0TWFyZ2luXCIsMTAsZnVuY3Rpb24oY20pe3JldHVybiBjbS5yZWZyZXNoKCk7fSx0cnVlKTtvcHRpb24oXCJtYXhIaWdobGlnaHRMZW5ndGhcIiwxMDAwMCxyZXNldE1vZGVTdGF0ZSx0cnVlKTtvcHRpb24oXCJtb3ZlSW5wdXRXaXRoQ3Vyc29yXCIsdHJ1ZSxmdW5jdGlvbihjbSx2YWwpe2lmKCF2YWwpe2NtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpO319KTtvcHRpb24oXCJ0YWJpbmRleFwiLG51bGwsZnVuY3Rpb24oY20sdmFsKXtyZXR1cm4gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4PXZhbHx8XCJcIjt9KTtvcHRpb24oXCJhdXRvZm9jdXNcIixudWxsKTt9ZnVuY3Rpb24gZ3V0dGVyc0NoYW5nZWQoY20pe3VwZGF0ZUd1dHRlcnMoY20pO3JlZ0NoYW5nZShjbSk7c2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBhbGlnbkhvcml6b250YWxseShjbSk7fSwyMCk7fWZ1bmN0aW9uIGRyYWdEcm9wQ2hhbmdlZChjbSx2YWx1ZSxvbGQpe3ZhciB3YXNPbj1vbGQmJm9sZCE9SW5pdDtpZighdmFsdWUhPSF3YXNPbil7dmFyIGZ1bmNzPWNtLmRpc3BsYXkuZHJhZ0Z1bmN0aW9uczt2YXIgdG9nZ2xlPXZhbHVlP29uOm9mZjt0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlcixcImRyYWdzdGFydFwiLGZ1bmNzLnN0YXJ0KTt0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlcixcImRyYWdlbnRlclwiLGZ1bmNzLmVudGVyKTt0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlcixcImRyYWdvdmVyXCIsZnVuY3Mub3Zlcik7dG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsXCJkcmFnbGVhdmVcIixmdW5jcy5sZWF2ZSk7dG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsXCJkcm9wXCIsZnVuY3MuZHJvcCk7fX1mdW5jdGlvbiB3cmFwcGluZ0NoYW5nZWQoY20pe2lmKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKXthZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsXCJDb2RlTWlycm9yLXdyYXBcIik7Y20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aD1cIlwiO2NtLmRpc3BsYXkuc2l6ZXJXaWR0aD1udWxsO31lbHNle3JtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLFwiQ29kZU1pcnJvci13cmFwXCIpO2ZpbmRNYXhMaW5lKGNtKTt9ZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7cmVnQ2hhbmdlKGNtKTtjbGVhckNhY2hlcyhjbSk7c2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTt9LDEwMCk7fS8vIEEgQ29kZU1pcnJvciBpbnN0YW5jZSByZXByZXNlbnRzIGFuIGVkaXRvci4gVGhpcyBpcyB0aGUgb2JqZWN0XG4vLyB0aGF0IHVzZXIgY29kZSBpcyB1c3VhbGx5IGRlYWxpbmcgd2l0aC5cbmZ1bmN0aW9uIENvZGVNaXJyb3IocGxhY2Usb3B0aW9ucyl7dmFyIHRoaXMkMT10aGlzO2lmKCEodGhpcyBpbnN0YW5jZW9mIENvZGVNaXJyb3IpKXtyZXR1cm4gbmV3IENvZGVNaXJyb3IocGxhY2Usb3B0aW9ucyk7fXRoaXMub3B0aW9ucz1vcHRpb25zPW9wdGlvbnM/Y29weU9iaihvcHRpb25zKTp7fTsvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIG9wdGlvbnMgYmFzZWQgb24gZ2l2ZW4gdmFsdWVzIGFuZCBkZWZhdWx0cy5cbmNvcHlPYmooZGVmYXVsdHMsb3B0aW9ucyxmYWxzZSk7c2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpO3ZhciBkb2M9b3B0aW9ucy52YWx1ZTtpZih0eXBlb2YgZG9jPT1cInN0cmluZ1wiKXtkb2M9bmV3IERvYyhkb2Msb3B0aW9ucy5tb2RlLG51bGwsb3B0aW9ucy5saW5lU2VwYXJhdG9yKTt9dGhpcy5kb2M9ZG9jO3ZhciBpbnB1dD1uZXcgQ29kZU1pcnJvci5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO3ZhciBkaXNwbGF5PXRoaXMuZGlzcGxheT1uZXcgRGlzcGxheShwbGFjZSxkb2MsaW5wdXQpO2Rpc3BsYXkud3JhcHBlci5Db2RlTWlycm9yPXRoaXM7dXBkYXRlR3V0dGVycyh0aGlzKTt0aGVtZUNoYW5nZWQodGhpcyk7aWYob3B0aW9ucy5saW5lV3JhcHBpbmcpe3RoaXMuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSs9XCIgQ29kZU1pcnJvci13cmFwXCI7fWlmKG9wdGlvbnMuYXV0b2ZvY3VzJiYhbW9iaWxlKXtkaXNwbGF5LmlucHV0LmZvY3VzKCk7fWluaXRTY3JvbGxiYXJzKHRoaXMpO3RoaXMuc3RhdGU9e2tleU1hcHM6W10sLy8gc3RvcmVzIG1hcHMgYWRkZWQgYnkgYWRkS2V5TWFwXG5vdmVybGF5czpbXSwvLyBoaWdobGlnaHRpbmcgb3ZlcmxheXMsIGFzIGFkZGVkIGJ5IGFkZE92ZXJsYXlcbm1vZGVHZW46MCwvLyBidW1wZWQgd2hlbiBtb2RlL292ZXJsYXkgY2hhbmdlcywgdXNlZCB0byBpbnZhbGlkYXRlIGhpZ2hsaWdodGluZyBpbmZvXG5vdmVyd3JpdGU6ZmFsc2UsZGVsYXlpbmdCbHVyRXZlbnQ6ZmFsc2UsZm9jdXNlZDpmYWxzZSxzdXBwcmVzc0VkaXRzOmZhbHNlLC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXG5wYXN0ZUluY29taW5nOmZhbHNlLGN1dEluY29taW5nOmZhbHNlLC8vIGhlbHAgcmVjb2duaXplIHBhc3RlL2N1dCBlZGl0cyBpbiBpbnB1dC5wb2xsXG5zZWxlY3RpbmdUZXh0OmZhbHNlLGRyYWdnaW5nVGV4dDpmYWxzZSxoaWdobGlnaHQ6bmV3IERlbGF5ZWQoKSwvLyBzdG9yZXMgaGlnaGxpZ2h0IHdvcmtlciB0aW1lb3V0XG5rZXlTZXE6bnVsbCwvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxuc3BlY2lhbENoYXJzOm51bGx9Oy8vIE92ZXJyaWRlIG1hZ2ljIHRleHRhcmVhIGNvbnRlbnQgcmVzdG9yZSB0aGF0IElFIHNvbWV0aW1lcyBkb2VzXG4vLyBvbiBvdXIgaGlkZGVuIHRleHRhcmVhIG9uIHJlbG9hZFxuaWYoaWUmJmllX3ZlcnNpb248MTEpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcyQxLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7fSwyMCk7fXJlZ2lzdGVyRXZlbnRIYW5kbGVycyh0aGlzKTtlbnN1cmVHbG9iYWxIYW5kbGVycygpO3N0YXJ0T3BlcmF0aW9uKHRoaXMpO3RoaXMuY3VyT3AuZm9yY2VVcGRhdGU9dHJ1ZTthdHRhY2hEb2ModGhpcyxkb2MpO2lmKG9wdGlvbnMuYXV0b2ZvY3VzJiYhbW9iaWxlfHx0aGlzLmhhc0ZvY3VzKCkpe3NldFRpbWVvdXQoYmluZChvbkZvY3VzLHRoaXMpLDIwKTt9ZWxzZXtvbkJsdXIodGhpcyk7fWZvcih2YXIgb3B0IGluIG9wdGlvbkhhbmRsZXJzKXtpZihvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHQpKXtvcHRpb25IYW5kbGVyc1tvcHRdKHRoaXMkMSxvcHRpb25zW29wdF0sSW5pdCk7fX1tYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCh0aGlzKTtpZihvcHRpb25zLmZpbmlzaEluaXQpe29wdGlvbnMuZmluaXNoSW5pdCh0aGlzKTt9Zm9yKHZhciBpPTA7aTxpbml0SG9va3MubGVuZ3RoOysraSl7aW5pdEhvb2tzW2ldKHRoaXMkMSk7fWVuZE9wZXJhdGlvbih0aGlzKTsvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxuLy8gbWVhc3VyaW5nIG9uIGxpbmUgd3JhcHBpbmcgYm91bmRhcmllcy5cbmlmKHdlYmtpdCYmb3B0aW9ucy5saW5lV3JhcHBpbmcmJmdldENvbXB1dGVkU3R5bGUoZGlzcGxheS5saW5lRGl2KS50ZXh0UmVuZGVyaW5nPT1cIm9wdGltaXplbGVnaWJpbGl0eVwiKXtkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZz1cImF1dG9cIjt9fS8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbkNvZGVNaXJyb3IuZGVmYXVsdHM9ZGVmYXVsdHM7Ly8gRnVuY3Rpb25zIHRvIHJ1biB3aGVuIG9wdGlvbnMgYXJlIGNoYW5nZWQuXG5Db2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzPW9wdGlvbkhhbmRsZXJzOy8vIEF0dGFjaCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBlZGl0b3JcbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyhjbSl7dmFyIGQ9Y20uZGlzcGxheTtvbihkLnNjcm9sbGVyLFwibW91c2Vkb3duXCIsb3BlcmF0aW9uKGNtLG9uTW91c2VEb3duKSk7Ly8gT2xkZXIgSUUncyB3aWxsIG5vdCBmaXJlIGEgc2Vjb25kIG1vdXNlZG93biBmb3IgYSBkb3VibGUgY2xpY2tcbmlmKGllJiZpZV92ZXJzaW9uPDExKXtvbihkLnNjcm9sbGVyLFwiZGJsY2xpY2tcIixvcGVyYXRpb24oY20sZnVuY3Rpb24oZSl7aWYoc2lnbmFsRE9NRXZlbnQoY20sZSkpe3JldHVybjt9dmFyIHBvcz1wb3NGcm9tTW91c2UoY20sZSk7aWYoIXBvc3x8Y2xpY2tJbkd1dHRlcihjbSxlKXx8ZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LGUpKXtyZXR1cm47fWVfcHJldmVudERlZmF1bHQoZSk7dmFyIHdvcmQ9Y20uZmluZFdvcmRBdChwb3MpO2V4dGVuZFNlbGVjdGlvbihjbS5kb2Msd29yZC5hbmNob3Isd29yZC5oZWFkKTt9KSk7fWVsc2V7b24oZC5zY3JvbGxlcixcImRibGNsaWNrXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLGUpfHxlX3ByZXZlbnREZWZhdWx0KGUpO30pO30vLyBTb21lIGJyb3dzZXJzIGZpcmUgY29udGV4dG1lbnUgKmFmdGVyKiBvcGVuaW5nIHRoZSBtZW51LCBhdFxuLy8gd2hpY2ggcG9pbnQgd2UgY2FuJ3QgbWVzcyB3aXRoIGl0IGFueW1vcmUuIENvbnRleHQgbWVudSBpc1xuLy8gaGFuZGxlZCBpbiBvbk1vdXNlRG93biBmb3IgdGhlc2UgYnJvd3NlcnMuXG5pZighY2FwdHVyZVJpZ2h0Q2xpY2spe29uKGQuc2Nyb2xsZXIsXCJjb250ZXh0bWVudVwiLGZ1bmN0aW9uKGUpe3JldHVybiBvbkNvbnRleHRNZW51KGNtLGUpO30pO30vLyBVc2VkIHRvIHN1cHByZXNzIG1vdXNlIGV2ZW50IGhhbmRsaW5nIHdoZW4gYSB0b3VjaCBoYXBwZW5zXG52YXIgdG91Y2hGaW5pc2hlZCxwcmV2VG91Y2g9e2VuZDowfTtmdW5jdGlvbiBmaW5pc2hUb3VjaCgpe2lmKGQuYWN0aXZlVG91Y2gpe3RvdWNoRmluaXNoZWQ9c2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiBkLmFjdGl2ZVRvdWNoPW51bGw7fSwxMDAwKTtwcmV2VG91Y2g9ZC5hY3RpdmVUb3VjaDtwcmV2VG91Y2guZW5kPStuZXcgRGF0ZSgpO319ZnVuY3Rpb24gaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpe2lmKGUudG91Y2hlcy5sZW5ndGghPTEpe3JldHVybiBmYWxzZTt9dmFyIHRvdWNoPWUudG91Y2hlc1swXTtyZXR1cm4gdG91Y2gucmFkaXVzWDw9MSYmdG91Y2gucmFkaXVzWTw9MTt9ZnVuY3Rpb24gZmFyQXdheSh0b3VjaCxvdGhlcil7aWYob3RoZXIubGVmdD09bnVsbCl7cmV0dXJuIHRydWU7fXZhciBkeD1vdGhlci5sZWZ0LXRvdWNoLmxlZnQsZHk9b3RoZXIudG9wLXRvdWNoLnRvcDtyZXR1cm4gZHgqZHgrZHkqZHk+MjAqMjA7fW9uKGQuc2Nyb2xsZXIsXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oZSl7aWYoIXNpZ25hbERPTUV2ZW50KGNtLGUpJiYhaXNNb3VzZUxpa2VUb3VjaEV2ZW50KGUpKXtjbGVhclRpbWVvdXQodG91Y2hGaW5pc2hlZCk7dmFyIG5vdz0rbmV3IERhdGUoKTtkLmFjdGl2ZVRvdWNoPXtzdGFydDpub3csbW92ZWQ6ZmFsc2UscHJldjpub3ctcHJldlRvdWNoLmVuZDw9MzAwP3ByZXZUb3VjaDpudWxsfTtpZihlLnRvdWNoZXMubGVuZ3RoPT0xKXtkLmFjdGl2ZVRvdWNoLmxlZnQ9ZS50b3VjaGVzWzBdLnBhZ2VYO2QuYWN0aXZlVG91Y2gudG9wPWUudG91Y2hlc1swXS5wYWdlWTt9fX0pO29uKGQuc2Nyb2xsZXIsXCJ0b3VjaG1vdmVcIixmdW5jdGlvbigpe2lmKGQuYWN0aXZlVG91Y2gpe2QuYWN0aXZlVG91Y2gubW92ZWQ9dHJ1ZTt9fSk7b24oZC5zY3JvbGxlcixcInRvdWNoZW5kXCIsZnVuY3Rpb24oZSl7dmFyIHRvdWNoPWQuYWN0aXZlVG91Y2g7aWYodG91Y2gmJiFldmVudEluV2lkZ2V0KGQsZSkmJnRvdWNoLmxlZnQhPW51bGwmJiF0b3VjaC5tb3ZlZCYmbmV3IERhdGUoKS10b3VjaC5zdGFydDwzMDApe3ZhciBwb3M9Y20uY29vcmRzQ2hhcihkLmFjdGl2ZVRvdWNoLFwicGFnZVwiKSxyYW5nZTtpZighdG91Y2gucHJldnx8ZmFyQXdheSh0b3VjaCx0b3VjaC5wcmV2KSkvLyBTaW5nbGUgdGFwXG57cmFuZ2U9bmV3IFJhbmdlKHBvcyxwb3MpO31lbHNlIGlmKCF0b3VjaC5wcmV2LnByZXZ8fGZhckF3YXkodG91Y2gsdG91Y2gucHJldi5wcmV2KSkvLyBEb3VibGUgdGFwXG57cmFuZ2U9Y20uZmluZFdvcmRBdChwb3MpO31lbHNlLy8gVHJpcGxlIHRhcFxue3JhbmdlPW5ldyBSYW5nZShQb3MocG9zLmxpbmUsMCksY2xpcFBvcyhjbS5kb2MsUG9zKHBvcy5saW5lKzEsMCkpKTt9Y20uc2V0U2VsZWN0aW9uKHJhbmdlLmFuY2hvcixyYW5nZS5oZWFkKTtjbS5mb2N1cygpO2VfcHJldmVudERlZmF1bHQoZSk7fWZpbmlzaFRvdWNoKCk7fSk7b24oZC5zY3JvbGxlcixcInRvdWNoY2FuY2VsXCIsZmluaXNoVG91Y2gpOy8vIFN5bmMgc2Nyb2xsaW5nIGJldHdlZW4gZmFrZSBzY3JvbGxiYXJzIGFuZCByZWFsIHNjcm9sbGFibGVcbi8vIGFyZWEsIGVuc3VyZSB2aWV3cG9ydCBpcyB1cGRhdGVkIHdoZW4gc2Nyb2xsaW5nLlxub24oZC5zY3JvbGxlcixcInNjcm9sbFwiLGZ1bmN0aW9uKCl7aWYoZC5zY3JvbGxlci5jbGllbnRIZWlnaHQpe3NldFNjcm9sbFRvcChjbSxkLnNjcm9sbGVyLnNjcm9sbFRvcCk7c2V0U2Nyb2xsTGVmdChjbSxkLnNjcm9sbGVyLnNjcm9sbExlZnQsdHJ1ZSk7c2lnbmFsKGNtLFwic2Nyb2xsXCIsY20pO319KTsvLyBMaXN0ZW4gdG8gd2hlZWwgZXZlbnRzIGluIG9yZGVyIHRvIHRyeSBhbmQgdXBkYXRlIHRoZSB2aWV3cG9ydCBvbiB0aW1lLlxub24oZC5zY3JvbGxlcixcIm1vdXNld2hlZWxcIixmdW5jdGlvbihlKXtyZXR1cm4gb25TY3JvbGxXaGVlbChjbSxlKTt9KTtvbihkLnNjcm9sbGVyLFwiRE9NTW91c2VTY3JvbGxcIixmdW5jdGlvbihlKXtyZXR1cm4gb25TY3JvbGxXaGVlbChjbSxlKTt9KTsvLyBQcmV2ZW50IHdyYXBwZXIgZnJvbSBldmVyIHNjcm9sbGluZ1xub24oZC53cmFwcGVyLFwic2Nyb2xsXCIsZnVuY3Rpb24oKXtyZXR1cm4gZC53cmFwcGVyLnNjcm9sbFRvcD1kLndyYXBwZXIuc2Nyb2xsTGVmdD0wO30pO2QuZHJhZ0Z1bmN0aW9ucz17ZW50ZXI6ZnVuY3Rpb24oZSl7aWYoIXNpZ25hbERPTUV2ZW50KGNtLGUpKXtlX3N0b3AoZSk7fX0sb3ZlcjpmdW5jdGlvbihlKXtpZighc2lnbmFsRE9NRXZlbnQoY20sZSkpe29uRHJhZ092ZXIoY20sZSk7ZV9zdG9wKGUpO319LHN0YXJ0OmZ1bmN0aW9uKGUpe3JldHVybiBvbkRyYWdTdGFydChjbSxlKTt9LGRyb3A6b3BlcmF0aW9uKGNtLG9uRHJvcCksbGVhdmU6ZnVuY3Rpb24oZSl7aWYoIXNpZ25hbERPTUV2ZW50KGNtLGUpKXtjbGVhckRyYWdDdXJzb3IoY20pO319fTt2YXIgaW5wPWQuaW5wdXQuZ2V0RmllbGQoKTtvbihpbnAsXCJrZXl1cFwiLGZ1bmN0aW9uKGUpe3JldHVybiBvbktleVVwLmNhbGwoY20sZSk7fSk7b24oaW5wLFwia2V5ZG93blwiLG9wZXJhdGlvbihjbSxvbktleURvd24pKTtvbihpbnAsXCJrZXlwcmVzc1wiLG9wZXJhdGlvbihjbSxvbktleVByZXNzKSk7b24oaW5wLFwiZm9jdXNcIixmdW5jdGlvbihlKXtyZXR1cm4gb25Gb2N1cyhjbSxlKTt9KTtvbihpbnAsXCJibHVyXCIsZnVuY3Rpb24oZSl7cmV0dXJuIG9uQmx1cihjbSxlKTt9KTt9dmFyIGluaXRIb29rcz1bXTtDb2RlTWlycm9yLmRlZmluZUluaXRIb29rPWZ1bmN0aW9uKGYpe3JldHVybiBpbml0SG9va3MucHVzaChmKTt9Oy8vIEluZGVudCB0aGUgZ2l2ZW4gbGluZS4gVGhlIGhvdyBwYXJhbWV0ZXIgY2FuIGJlIFwic21hcnRcIixcbi8vIFwiYWRkXCIvbnVsbCwgXCJzdWJ0cmFjdFwiLCBvciBcInByZXZcIi4gV2hlbiBhZ2dyZXNzaXZlIGlzIGZhbHNlXG4vLyAodHlwaWNhbGx5IHNldCB0byB0cnVlIGZvciBmb3JjZWQgc2luZ2xlLWxpbmUgaW5kZW50cyksIGVtcHR5XG4vLyBsaW5lcyBhcmUgbm90IGluZGVudGVkLCBhbmQgcGxhY2VzIHdoZXJlIHRoZSBtb2RlIHJldHVybnMgUGFzc1xuLy8gYXJlIGxlZnQgYWxvbmUuXG5mdW5jdGlvbiBpbmRlbnRMaW5lKGNtLG4saG93LGFnZ3Jlc3NpdmUpe3ZhciBkb2M9Y20uZG9jLHN0YXRlO2lmKGhvdz09bnVsbCl7aG93PVwiYWRkXCI7fWlmKGhvdz09XCJzbWFydFwiKXsvLyBGYWxsIGJhY2sgdG8gXCJwcmV2XCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cbi8vIG1ldGhvZC5cbmlmKCFkb2MubW9kZS5pbmRlbnQpe2hvdz1cInByZXZcIjt9ZWxzZXtzdGF0ZT1nZXRTdGF0ZUJlZm9yZShjbSxuKTt9fXZhciB0YWJTaXplPWNtLm9wdGlvbnMudGFiU2l6ZTt2YXIgbGluZT1nZXRMaW5lKGRvYyxuKSxjdXJTcGFjZT1jb3VudENvbHVtbihsaW5lLnRleHQsbnVsbCx0YWJTaXplKTtpZihsaW5lLnN0YXRlQWZ0ZXIpe2xpbmUuc3RhdGVBZnRlcj1udWxsO312YXIgY3VyU3BhY2VTdHJpbmc9bGluZS50ZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLGluZGVudGF0aW9uO2lmKCFhZ2dyZXNzaXZlJiYhL1xcUy8udGVzdChsaW5lLnRleHQpKXtpbmRlbnRhdGlvbj0wO2hvdz1cIm5vdFwiO31lbHNlIGlmKGhvdz09XCJzbWFydFwiKXtpbmRlbnRhdGlvbj1kb2MubW9kZS5pbmRlbnQoc3RhdGUsbGluZS50ZXh0LnNsaWNlKGN1clNwYWNlU3RyaW5nLmxlbmd0aCksbGluZS50ZXh0KTtpZihpbmRlbnRhdGlvbj09UGFzc3x8aW5kZW50YXRpb24+MTUwKXtpZighYWdncmVzc2l2ZSl7cmV0dXJuO31ob3c9XCJwcmV2XCI7fX1pZihob3c9PVwicHJldlwiKXtpZihuPmRvYy5maXJzdCl7aW5kZW50YXRpb249Y291bnRDb2x1bW4oZ2V0TGluZShkb2Msbi0xKS50ZXh0LG51bGwsdGFiU2l6ZSk7fWVsc2V7aW5kZW50YXRpb249MDt9fWVsc2UgaWYoaG93PT1cImFkZFwiKXtpbmRlbnRhdGlvbj1jdXJTcGFjZStjbS5vcHRpb25zLmluZGVudFVuaXQ7fWVsc2UgaWYoaG93PT1cInN1YnRyYWN0XCIpe2luZGVudGF0aW9uPWN1clNwYWNlLWNtLm9wdGlvbnMuaW5kZW50VW5pdDt9ZWxzZSBpZih0eXBlb2YgaG93PT1cIm51bWJlclwiKXtpbmRlbnRhdGlvbj1jdXJTcGFjZStob3c7fWluZGVudGF0aW9uPU1hdGgubWF4KDAsaW5kZW50YXRpb24pO3ZhciBpbmRlbnRTdHJpbmc9XCJcIixwb3M9MDtpZihjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKXtmb3IodmFyIGk9TWF0aC5mbG9vcihpbmRlbnRhdGlvbi90YWJTaXplKTtpOy0taSl7cG9zKz10YWJTaXplO2luZGVudFN0cmluZys9XCJcXHRcIjt9fWlmKHBvczxpbmRlbnRhdGlvbil7aW5kZW50U3RyaW5nKz1zcGFjZVN0cihpbmRlbnRhdGlvbi1wb3MpO31pZihpbmRlbnRTdHJpbmchPWN1clNwYWNlU3RyaW5nKXtyZXBsYWNlUmFuZ2UoZG9jLGluZGVudFN0cmluZyxQb3MobiwwKSxQb3MobixjdXJTcGFjZVN0cmluZy5sZW5ndGgpLFwiK2lucHV0XCIpO2xpbmUuc3RhdGVBZnRlcj1udWxsO3JldHVybiB0cnVlO31lbHNley8vIEVuc3VyZSB0aGF0LCBpZiB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnRcbi8vIG9mIHRoZSBsaW5lLCBpdCBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoYXQgc3BhY2UuXG5mb3IodmFyIGkkMT0wO2kkMTxkb2Muc2VsLnJhbmdlcy5sZW5ndGg7aSQxKyspe3ZhciByYW5nZT1kb2Muc2VsLnJhbmdlc1tpJDFdO2lmKHJhbmdlLmhlYWQubGluZT09biYmcmFuZ2UuaGVhZC5jaDxjdXJTcGFjZVN0cmluZy5sZW5ndGgpe3ZhciBwb3MkMT1Qb3MobixjdXJTcGFjZVN0cmluZy5sZW5ndGgpO3JlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLGkkMSxuZXcgUmFuZ2UocG9zJDEscG9zJDEpKTticmVhazt9fX19Ly8gVGhpcyB3aWxsIGJlIHNldCB0byBhIHtsaW5lV2lzZTogYm9vbCwgdGV4dDogW3N0cmluZ119IG9iamVjdCwgc29cbi8vIHRoYXQsIHdoZW4gcGFzdGluZywgd2Uga25vdyB3aGF0IGtpbmQgb2Ygc2VsZWN0aW9ucyB0aGUgY29waWVkXG4vLyB0ZXh0IHdhcyBtYWRlIG91dCBvZi5cbnZhciBsYXN0Q29waWVkPW51bGw7ZnVuY3Rpb24gc2V0TGFzdENvcGllZChuZXdMYXN0Q29waWVkKXtsYXN0Q29waWVkPW5ld0xhc3RDb3BpZWQ7fWZ1bmN0aW9uIGFwcGx5VGV4dElucHV0KGNtLGluc2VydGVkLGRlbGV0ZWQsc2VsLG9yaWdpbil7dmFyIGRvYz1jbS5kb2M7Y20uZGlzcGxheS5zaGlmdD1mYWxzZTtpZighc2VsKXtzZWw9ZG9jLnNlbDt9dmFyIHBhc3RlPWNtLnN0YXRlLnBhc3RlSW5jb21pbmd8fG9yaWdpbj09XCJwYXN0ZVwiO3ZhciB0ZXh0TGluZXM9c3BsaXRMaW5lc0F1dG8oaW5zZXJ0ZWQpLG11bHRpUGFzdGU9bnVsbDsvLyBXaGVuIHBhc2luZyBOIGxpbmVzIGludG8gTiBzZWxlY3Rpb25zLCBpbnNlcnQgb25lIGxpbmUgcGVyIHNlbGVjdGlvblxuaWYocGFzdGUmJnNlbC5yYW5nZXMubGVuZ3RoPjEpe2lmKGxhc3RDb3BpZWQmJmxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpPT1pbnNlcnRlZCl7aWYoc2VsLnJhbmdlcy5sZW5ndGglbGFzdENvcGllZC50ZXh0Lmxlbmd0aD09MCl7bXVsdGlQYXN0ZT1bXTtmb3IodmFyIGk9MDtpPGxhc3RDb3BpZWQudGV4dC5sZW5ndGg7aSsrKXttdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2ldKSk7fX19ZWxzZSBpZih0ZXh0TGluZXMubGVuZ3RoPT1zZWwucmFuZ2VzLmxlbmd0aCl7bXVsdGlQYXN0ZT1tYXAodGV4dExpbmVzLGZ1bmN0aW9uKGwpe3JldHVybltsXTt9KTt9fXZhciB1cGRhdGVJbnB1dDsvLyBOb3JtYWwgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IHRoZSBuZXcgdGV4dCBpbnRvIGV2ZXJ5IHNlbGVjdGlvblxuZm9yKHZhciBpJDE9c2VsLnJhbmdlcy5sZW5ndGgtMTtpJDE+PTA7aSQxLS0pe3ZhciByYW5nZT1zZWwucmFuZ2VzW2kkMV07dmFyIGZyb209cmFuZ2UuZnJvbSgpLHRvPXJhbmdlLnRvKCk7aWYocmFuZ2UuZW1wdHkoKSl7aWYoZGVsZXRlZCYmZGVsZXRlZD4wKS8vIEhhbmRsZSBkZWxldGlvblxue2Zyb209UG9zKGZyb20ubGluZSxmcm9tLmNoLWRlbGV0ZWQpO31lbHNlIGlmKGNtLnN0YXRlLm92ZXJ3cml0ZSYmIXBhc3RlKS8vIEhhbmRsZSBvdmVyd3JpdGVcbnt0bz1Qb3ModG8ubGluZSxNYXRoLm1pbihnZXRMaW5lKGRvYyx0by5saW5lKS50ZXh0Lmxlbmd0aCx0by5jaCtsc3QodGV4dExpbmVzKS5sZW5ndGgpKTt9ZWxzZSBpZihsYXN0Q29waWVkJiZsYXN0Q29waWVkLmxpbmVXaXNlJiZsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKT09aW5zZXJ0ZWQpe2Zyb209dG89UG9zKGZyb20ubGluZSwwKTt9fXVwZGF0ZUlucHV0PWNtLmN1ck9wLnVwZGF0ZUlucHV0O3ZhciBjaGFuZ2VFdmVudD17ZnJvbTpmcm9tLHRvOnRvLHRleHQ6bXVsdGlQYXN0ZT9tdWx0aVBhc3RlW2kkMSVtdWx0aVBhc3RlLmxlbmd0aF06dGV4dExpbmVzLG9yaWdpbjpvcmlnaW58fChwYXN0ZT9cInBhc3RlXCI6Y20uc3RhdGUuY3V0SW5jb21pbmc/XCJjdXRcIjpcIitpbnB1dFwiKX07bWFrZUNoYW5nZShjbS5kb2MsY2hhbmdlRXZlbnQpO3NpZ25hbExhdGVyKGNtLFwiaW5wdXRSZWFkXCIsY20sY2hhbmdlRXZlbnQpO31pZihpbnNlcnRlZCYmIXBhc3RlKXt0cmlnZ2VyRWxlY3RyaWMoY20saW5zZXJ0ZWQpO31lbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtjbS5jdXJPcC51cGRhdGVJbnB1dD11cGRhdGVJbnB1dDtjbS5jdXJPcC50eXBpbmc9dHJ1ZTtjbS5zdGF0ZS5wYXN0ZUluY29taW5nPWNtLnN0YXRlLmN1dEluY29taW5nPWZhbHNlO31mdW5jdGlvbiBoYW5kbGVQYXN0ZShlLGNtKXt2YXIgcGFzdGVkPWUuY2xpcGJvYXJkRGF0YSYmZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO2lmKHBhc3RlZCl7ZS5wcmV2ZW50RGVmYXVsdCgpO2lmKCFjbS5pc1JlYWRPbmx5KCkmJiFjbS5vcHRpb25zLmRpc2FibGVJbnB1dCl7cnVuSW5PcChjbSxmdW5jdGlvbigpe3JldHVybiBhcHBseVRleHRJbnB1dChjbSxwYXN0ZWQsMCxudWxsLFwicGFzdGVcIik7fSk7fXJldHVybiB0cnVlO319ZnVuY3Rpb24gdHJpZ2dlckVsZWN0cmljKGNtLGluc2VydGVkKXsvLyBXaGVuIGFuICdlbGVjdHJpYycgY2hhcmFjdGVyIGlzIGluc2VydGVkLCBpbW1lZGlhdGVseSB0cmlnZ2VyIGEgcmVpbmRlbnRcbmlmKCFjbS5vcHRpb25zLmVsZWN0cmljQ2hhcnN8fCFjbS5vcHRpb25zLnNtYXJ0SW5kZW50KXtyZXR1cm47fXZhciBzZWw9Y20uZG9jLnNlbDtmb3IodmFyIGk9c2VsLnJhbmdlcy5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIHJhbmdlPXNlbC5yYW5nZXNbaV07aWYocmFuZ2UuaGVhZC5jaD4xMDB8fGkmJnNlbC5yYW5nZXNbaS0xXS5oZWFkLmxpbmU9PXJhbmdlLmhlYWQubGluZSl7Y29udGludWU7fXZhciBtb2RlPWNtLmdldE1vZGVBdChyYW5nZS5oZWFkKTt2YXIgaW5kZW50ZWQ9ZmFsc2U7aWYobW9kZS5lbGVjdHJpY0NoYXJzKXtmb3IodmFyIGo9MDtqPG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7aisrKXtpZihpbnNlcnRlZC5pbmRleE9mKG1vZGUuZWxlY3RyaWNDaGFycy5jaGFyQXQoaikpPi0xKXtpbmRlbnRlZD1pbmRlbnRMaW5lKGNtLHJhbmdlLmhlYWQubGluZSxcInNtYXJ0XCIpO2JyZWFrO319fWVsc2UgaWYobW9kZS5lbGVjdHJpY0lucHV0KXtpZihtb2RlLmVsZWN0cmljSW5wdXQudGVzdChnZXRMaW5lKGNtLmRvYyxyYW5nZS5oZWFkLmxpbmUpLnRleHQuc2xpY2UoMCxyYW5nZS5oZWFkLmNoKSkpe2luZGVudGVkPWluZGVudExpbmUoY20scmFuZ2UuaGVhZC5saW5lLFwic21hcnRcIik7fX1pZihpbmRlbnRlZCl7c2lnbmFsTGF0ZXIoY20sXCJlbGVjdHJpY0lucHV0XCIsY20scmFuZ2UuaGVhZC5saW5lKTt9fX1mdW5jdGlvbiBjb3B5YWJsZVJhbmdlcyhjbSl7dmFyIHRleHQ9W10scmFuZ2VzPVtdO2Zvcih2YXIgaT0wO2k8Y20uZG9jLnNlbC5yYW5nZXMubGVuZ3RoO2krKyl7dmFyIGxpbmU9Y20uZG9jLnNlbC5yYW5nZXNbaV0uaGVhZC5saW5lO3ZhciBsaW5lUmFuZ2U9e2FuY2hvcjpQb3MobGluZSwwKSxoZWFkOlBvcyhsaW5lKzEsMCl9O3Jhbmdlcy5wdXNoKGxpbmVSYW5nZSk7dGV4dC5wdXNoKGNtLmdldFJhbmdlKGxpbmVSYW5nZS5hbmNob3IsbGluZVJhbmdlLmhlYWQpKTt9cmV0dXJue3RleHQ6dGV4dCxyYW5nZXM6cmFuZ2VzfTt9ZnVuY3Rpb24gZGlzYWJsZUJyb3dzZXJNYWdpYyhmaWVsZCxzcGVsbGNoZWNrKXtmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLFwib2ZmXCIpO2ZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsXCJvZmZcIik7ZmllbGQuc2V0QXR0cmlidXRlKFwic3BlbGxjaGVja1wiLCEhc3BlbGxjaGVjayk7fWZ1bmN0aW9uIGhpZGRlblRleHRhcmVhKCl7dmFyIHRlPWVsdChcInRleHRhcmVhXCIsbnVsbCxudWxsLFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IC0xZW07IHBhZGRpbmc6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMWVtOyBvdXRsaW5lOiBub25lXCIpO3ZhciBkaXY9ZWx0KFwiZGl2XCIsW3RlXSxudWxsLFwib3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB3aWR0aDogM3B4OyBoZWlnaHQ6IDBweDtcIik7Ly8gVGhlIHRleHRhcmVhIGlzIGtlcHQgcG9zaXRpb25lZCBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCB0aGVcbi8vIGZhY3QgdGhhdCBpdCdsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgb24gaW5wdXQgZnJvbSBzY3JvbGxpbmdcbi8vIG91ciBmYWtlIGN1cnNvciBvdXQgb2Ygdmlldy4gT24gd2Via2l0LCB3aGVuIHdyYXA9b2ZmLCBwYXN0ZSBpc1xuLy8gdmVyeSBzbG93LiBTbyBtYWtlIHRoZSBhcmVhIHdpZGUgaW5zdGVhZC5cbmlmKHdlYmtpdCl7dGUuc3R5bGUud2lkdGg9XCIxMDAwcHhcIjt9ZWxzZXt0ZS5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsXCJvZmZcIik7fS8vIElmIGJvcmRlcjogMDsgLS0gaU9TIGZhaWxzIHRvIG9wZW4ga2V5Ym9hcmQgKGlzc3VlICMxMjg3KVxuaWYoaW9zKXt0ZS5zdHlsZS5ib3JkZXI9XCIxcHggc29saWQgYmxhY2tcIjt9ZGlzYWJsZUJyb3dzZXJNYWdpYyh0ZSk7cmV0dXJuIGRpdjt9Ly8gVGhlIHB1YmxpY2x5IHZpc2libGUgQVBJLiBOb3RlIHRoYXQgbWV0aG9kT3AoZikgbWVhbnNcbi8vICd3cmFwIGYgaW4gYW4gb3BlcmF0aW9uLCBwZXJmb3JtZWQgb24gaXRzIGB0aGlzYCBwYXJhbWV0ZXInLlxuLy8gVGhpcyBpcyBub3QgdGhlIGNvbXBsZXRlIHNldCBvZiBlZGl0b3IgbWV0aG9kcy4gTW9zdCBvZiB0aGVcbi8vIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRG9jIHR5cGUgYXJlIGFsc28gaW5qZWN0ZWQgaW50b1xuLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcbi8vIGNvbnZlbmllbmNlLlxuZnVuY3Rpb24gYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKXt2YXIgb3B0aW9uSGFuZGxlcnM9Q29kZU1pcnJvci5vcHRpb25IYW5kbGVyczt2YXIgaGVscGVycz1Db2RlTWlycm9yLmhlbHBlcnM9e307Q29kZU1pcnJvci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOkNvZGVNaXJyb3IsZm9jdXM6ZnVuY3Rpb24oKXt3aW5kb3cuZm9jdXMoKTt0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LHNldE9wdGlvbjpmdW5jdGlvbihvcHRpb24sdmFsdWUpe3ZhciBvcHRpb25zPXRoaXMub3B0aW9ucyxvbGQ9b3B0aW9uc1tvcHRpb25dO2lmKG9wdGlvbnNbb3B0aW9uXT09dmFsdWUmJm9wdGlvbiE9XCJtb2RlXCIpe3JldHVybjt9b3B0aW9uc1tvcHRpb25dPXZhbHVlO2lmKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdGlvbikpe29wZXJhdGlvbih0aGlzLG9wdGlvbkhhbmRsZXJzW29wdGlvbl0pKHRoaXMsdmFsdWUsb2xkKTt9fSxnZXRPcHRpb246ZnVuY3Rpb24ob3B0aW9uKXtyZXR1cm4gdGhpcy5vcHRpb25zW29wdGlvbl07fSxnZXREb2M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb2M7fSxhZGRLZXlNYXA6ZnVuY3Rpb24obWFwLGJvdHRvbSl7dGhpcy5zdGF0ZS5rZXlNYXBzW2JvdHRvbT9cInB1c2hcIjpcInVuc2hpZnRcIl0oZ2V0S2V5TWFwKG1hcCkpO30scmVtb3ZlS2V5TWFwOmZ1bmN0aW9uKG1hcCl7dmFyIG1hcHM9dGhpcy5zdGF0ZS5rZXlNYXBzO2Zvcih2YXIgaT0wO2k8bWFwcy5sZW5ndGg7KytpKXtpZihtYXBzW2ldPT1tYXB8fG1hcHNbaV0ubmFtZT09bWFwKXttYXBzLnNwbGljZShpLDEpO3JldHVybiB0cnVlO319fSxhZGRPdmVybGF5Om1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsb3B0aW9ucyl7dmFyIG1vZGU9c3BlYy50b2tlbj9zcGVjOkNvZGVNaXJyb3IuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsc3BlYyk7aWYobW9kZS5zdGFydFN0YXRlKXt0aHJvdyBuZXcgRXJyb3IoXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlwiKTt9aW5zZXJ0U29ydGVkKHRoaXMuc3RhdGUub3ZlcmxheXMse21vZGU6bW9kZSxtb2RlU3BlYzpzcGVjLG9wYXF1ZTpvcHRpb25zJiZvcHRpb25zLm9wYXF1ZSxwcmlvcml0eTpvcHRpb25zJiZvcHRpb25zLnByaW9yaXR5fHwwfSxmdW5jdGlvbihvdmVybGF5KXtyZXR1cm4gb3ZlcmxheS5wcmlvcml0eTt9KTt0aGlzLnN0YXRlLm1vZGVHZW4rKztyZWdDaGFuZ2UodGhpcyk7fSkscmVtb3ZlT3ZlcmxheTptZXRob2RPcChmdW5jdGlvbihzcGVjKXt2YXIgdGhpcyQxPXRoaXM7dmFyIG92ZXJsYXlzPXRoaXMuc3RhdGUub3ZlcmxheXM7Zm9yKHZhciBpPTA7aTxvdmVybGF5cy5sZW5ndGg7KytpKXt2YXIgY3VyPW92ZXJsYXlzW2ldLm1vZGVTcGVjO2lmKGN1cj09c3BlY3x8dHlwZW9mIHNwZWM9PVwic3RyaW5nXCImJmN1ci5uYW1lPT1zcGVjKXtvdmVybGF5cy5zcGxpY2UoaSwxKTt0aGlzJDEuc3RhdGUubW9kZUdlbisrO3JlZ0NoYW5nZSh0aGlzJDEpO3JldHVybjt9fX0pLGluZGVudExpbmU6bWV0aG9kT3AoZnVuY3Rpb24obixkaXIsYWdncmVzc2l2ZSl7aWYodHlwZW9mIGRpciE9XCJzdHJpbmdcIiYmdHlwZW9mIGRpciE9XCJudW1iZXJcIil7aWYoZGlyPT1udWxsKXtkaXI9dGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50P1wic21hcnRcIjpcInByZXZcIjt9ZWxzZXtkaXI9ZGlyP1wiYWRkXCI6XCJzdWJ0cmFjdFwiO319aWYoaXNMaW5lKHRoaXMuZG9jLG4pKXtpbmRlbnRMaW5lKHRoaXMsbixkaXIsYWdncmVzc2l2ZSk7fX0pLGluZGVudFNlbGVjdGlvbjptZXRob2RPcChmdW5jdGlvbihob3cpe3ZhciB0aGlzJDE9dGhpczt2YXIgcmFuZ2VzPXRoaXMuZG9jLnNlbC5yYW5nZXMsZW5kPS0xO2Zvcih2YXIgaT0wO2k8cmFuZ2VzLmxlbmd0aDtpKyspe3ZhciByYW5nZT1yYW5nZXNbaV07aWYoIXJhbmdlLmVtcHR5KCkpe3ZhciBmcm9tPXJhbmdlLmZyb20oKSx0bz1yYW5nZS50bygpO3ZhciBzdGFydD1NYXRoLm1heChlbmQsZnJvbS5saW5lKTtlbmQ9TWF0aC5taW4odGhpcyQxLmxhc3RMaW5lKCksdG8ubGluZS0odG8uY2g/MDoxKSkrMTtmb3IodmFyIGo9c3RhcnQ7ajxlbmQ7KytqKXtpbmRlbnRMaW5lKHRoaXMkMSxqLGhvdyk7fXZhciBuZXdSYW5nZXM9dGhpcyQxLmRvYy5zZWwucmFuZ2VzO2lmKGZyb20uY2g9PTAmJnJhbmdlcy5sZW5ndGg9PW5ld1Jhbmdlcy5sZW5ndGgmJm5ld1Jhbmdlc1tpXS5mcm9tKCkuY2g+MCl7cmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzJDEuZG9jLGksbmV3IFJhbmdlKGZyb20sbmV3UmFuZ2VzW2ldLnRvKCkpLHNlbF9kb250U2Nyb2xsKTt9fWVsc2UgaWYocmFuZ2UuaGVhZC5saW5lPmVuZCl7aW5kZW50TGluZSh0aGlzJDEscmFuZ2UuaGVhZC5saW5lLGhvdyx0cnVlKTtlbmQ9cmFuZ2UuaGVhZC5saW5lO2lmKGk9PXRoaXMkMS5kb2Muc2VsLnByaW1JbmRleCl7ZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzJDEpO319fX0pLC8vIEZldGNoIHRoZSBwYXJzZXIgdG9rZW4gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLiBVc2VmdWwgZm9yIGhhY2tzXG4vLyB0aGF0IHdhbnQgdG8gaW5zcGVjdCB0aGUgbW9kZSBzdGF0ZSAoc2F5LCBmb3IgY29tcGxldGlvbikuXG5nZXRUb2tlbkF0OmZ1bmN0aW9uKHBvcyxwcmVjaXNlKXtyZXR1cm4gdGFrZVRva2VuKHRoaXMscG9zLHByZWNpc2UpO30sZ2V0TGluZVRva2VuczpmdW5jdGlvbihsaW5lLHByZWNpc2Upe3JldHVybiB0YWtlVG9rZW4odGhpcyxQb3MobGluZSkscHJlY2lzZSx0cnVlKTt9LGdldFRva2VuVHlwZUF0OmZ1bmN0aW9uKHBvcyl7cG9zPWNsaXBQb3ModGhpcy5kb2MscG9zKTt2YXIgc3R5bGVzPWdldExpbmVTdHlsZXModGhpcyxnZXRMaW5lKHRoaXMuZG9jLHBvcy5saW5lKSk7dmFyIGJlZm9yZT0wLGFmdGVyPShzdHlsZXMubGVuZ3RoLTEpLzIsY2g9cG9zLmNoO3ZhciB0eXBlO2lmKGNoPT0wKXt0eXBlPXN0eWxlc1syXTt9ZWxzZXtmb3IoOzspe3ZhciBtaWQ9YmVmb3JlK2FmdGVyPj4xO2lmKChtaWQ/c3R5bGVzW21pZCoyLTFdOjApPj1jaCl7YWZ0ZXI9bWlkO31lbHNlIGlmKHN0eWxlc1ttaWQqMisxXTxjaCl7YmVmb3JlPW1pZCsxO31lbHNle3R5cGU9c3R5bGVzW21pZCoyKzJdO2JyZWFrO319fXZhciBjdXQ9dHlwZT90eXBlLmluZGV4T2YoXCJvdmVybGF5IFwiKTotMTtyZXR1cm4gY3V0PDA/dHlwZTpjdXQ9PTA/bnVsbDp0eXBlLnNsaWNlKDAsY3V0LTEpO30sZ2V0TW9kZUF0OmZ1bmN0aW9uKHBvcyl7dmFyIG1vZGU9dGhpcy5kb2MubW9kZTtpZighbW9kZS5pbm5lck1vZGUpe3JldHVybiBtb2RlO31yZXR1cm4gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSx0aGlzLmdldFRva2VuQXQocG9zKS5zdGF0ZSkubW9kZTt9LGdldEhlbHBlcjpmdW5jdGlvbihwb3MsdHlwZSl7cmV0dXJuIHRoaXMuZ2V0SGVscGVycyhwb3MsdHlwZSlbMF07fSxnZXRIZWxwZXJzOmZ1bmN0aW9uKHBvcyx0eXBlKXt2YXIgdGhpcyQxPXRoaXM7dmFyIGZvdW5kPVtdO2lmKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKXtyZXR1cm4gZm91bmQ7fXZhciBoZWxwPWhlbHBlcnNbdHlwZV0sbW9kZT10aGlzLmdldE1vZGVBdChwb3MpO2lmKHR5cGVvZiBtb2RlW3R5cGVdPT1cInN0cmluZ1wiKXtpZihoZWxwW21vZGVbdHlwZV1dKXtmb3VuZC5wdXNoKGhlbHBbbW9kZVt0eXBlXV0pO319ZWxzZSBpZihtb2RlW3R5cGVdKXtmb3IodmFyIGk9MDtpPG1vZGVbdHlwZV0ubGVuZ3RoO2krKyl7dmFyIHZhbD1oZWxwW21vZGVbdHlwZV1baV1dO2lmKHZhbCl7Zm91bmQucHVzaCh2YWwpO319fWVsc2UgaWYobW9kZS5oZWxwZXJUeXBlJiZoZWxwW21vZGUuaGVscGVyVHlwZV0pe2ZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKTt9ZWxzZSBpZihoZWxwW21vZGUubmFtZV0pe2ZvdW5kLnB1c2goaGVscFttb2RlLm5hbWVdKTt9Zm9yKHZhciBpJDE9MDtpJDE8aGVscC5fZ2xvYmFsLmxlbmd0aDtpJDErKyl7dmFyIGN1cj1oZWxwLl9nbG9iYWxbaSQxXTtpZihjdXIucHJlZChtb2RlLHRoaXMkMSkmJmluZGV4T2YoZm91bmQsY3VyLnZhbCk9PS0xKXtmb3VuZC5wdXNoKGN1ci52YWwpO319cmV0dXJuIGZvdW5kO30sZ2V0U3RhdGVBZnRlcjpmdW5jdGlvbihsaW5lLHByZWNpc2Upe3ZhciBkb2M9dGhpcy5kb2M7bGluZT1jbGlwTGluZShkb2MsbGluZT09bnVsbD9kb2MuZmlyc3QrZG9jLnNpemUtMTpsaW5lKTtyZXR1cm4gZ2V0U3RhdGVCZWZvcmUodGhpcyxsaW5lKzEscHJlY2lzZSk7fSxjdXJzb3JDb29yZHM6ZnVuY3Rpb24oc3RhcnQsbW9kZSl7dmFyIHBvcyxyYW5nZT10aGlzLmRvYy5zZWwucHJpbWFyeSgpO2lmKHN0YXJ0PT1udWxsKXtwb3M9cmFuZ2UuaGVhZDt9ZWxzZSBpZih0eXBlb2Ygc3RhcnQ9PVwib2JqZWN0XCIpe3Bvcz1jbGlwUG9zKHRoaXMuZG9jLHN0YXJ0KTt9ZWxzZXtwb3M9c3RhcnQ/cmFuZ2UuZnJvbSgpOnJhbmdlLnRvKCk7fXJldHVybiBjdXJzb3JDb29yZHModGhpcyxwb3MsbW9kZXx8XCJwYWdlXCIpO30sY2hhckNvb3JkczpmdW5jdGlvbihwb3MsbW9kZSl7cmV0dXJuIGNoYXJDb29yZHModGhpcyxjbGlwUG9zKHRoaXMuZG9jLHBvcyksbW9kZXx8XCJwYWdlXCIpO30sY29vcmRzQ2hhcjpmdW5jdGlvbihjb29yZHMsbW9kZSl7Y29vcmRzPWZyb21Db29yZFN5c3RlbSh0aGlzLGNvb3Jkcyxtb2RlfHxcInBhZ2VcIik7cmV0dXJuIGNvb3Jkc0NoYXIodGhpcyxjb29yZHMubGVmdCxjb29yZHMudG9wKTt9LGxpbmVBdEhlaWdodDpmdW5jdGlvbihoZWlnaHQsbW9kZSl7aGVpZ2h0PWZyb21Db29yZFN5c3RlbSh0aGlzLHt0b3A6aGVpZ2h0LGxlZnQ6MH0sbW9kZXx8XCJwYWdlXCIpLnRvcDtyZXR1cm4gbGluZUF0SGVpZ2h0KHRoaXMuZG9jLGhlaWdodCt0aGlzLmRpc3BsYXkudmlld09mZnNldCk7fSxoZWlnaHRBdExpbmU6ZnVuY3Rpb24obGluZSxtb2RlKXt2YXIgZW5kPWZhbHNlLGxpbmVPYmo7aWYodHlwZW9mIGxpbmU9PVwibnVtYmVyXCIpe3ZhciBsYXN0PXRoaXMuZG9jLmZpcnN0K3RoaXMuZG9jLnNpemUtMTtpZihsaW5lPHRoaXMuZG9jLmZpcnN0KXtsaW5lPXRoaXMuZG9jLmZpcnN0O31lbHNlIGlmKGxpbmU+bGFzdCl7bGluZT1sYXN0O2VuZD10cnVlO31saW5lT2JqPWdldExpbmUodGhpcy5kb2MsbGluZSk7fWVsc2V7bGluZU9iaj1saW5lO31yZXR1cm4gaW50b0Nvb3JkU3lzdGVtKHRoaXMsbGluZU9iaix7dG9wOjAsbGVmdDowfSxtb2RlfHxcInBhZ2VcIikudG9wKyhlbmQ/dGhpcy5kb2MuaGVpZ2h0LWhlaWdodEF0TGluZShsaW5lT2JqKTowKTt9LGRlZmF1bHRUZXh0SGVpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KTt9LGRlZmF1bHRDaGFyV2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gY2hhcldpZHRoKHRoaXMuZGlzcGxheSk7fSxzZXRHdXR0ZXJNYXJrZXI6bWV0aG9kT3AoZnVuY3Rpb24obGluZSxndXR0ZXJJRCx2YWx1ZSl7cmV0dXJuIGNoYW5nZUxpbmUodGhpcy5kb2MsbGluZSxcImd1dHRlclwiLGZ1bmN0aW9uKGxpbmUpe3ZhciBtYXJrZXJzPWxpbmUuZ3V0dGVyTWFya2Vyc3x8KGxpbmUuZ3V0dGVyTWFya2Vycz17fSk7bWFya2Vyc1tndXR0ZXJJRF09dmFsdWU7aWYoIXZhbHVlJiZpc0VtcHR5KG1hcmtlcnMpKXtsaW5lLmd1dHRlck1hcmtlcnM9bnVsbDt9cmV0dXJuIHRydWU7fSk7fSksY2xlYXJHdXR0ZXI6bWV0aG9kT3AoZnVuY3Rpb24oZ3V0dGVySUQpe3ZhciB0aGlzJDE9dGhpczt2YXIgZG9jPXRoaXMuZG9jLGk9ZG9jLmZpcnN0O2RvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpe2lmKGxpbmUuZ3V0dGVyTWFya2VycyYmbGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXSl7bGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXT1udWxsO3JlZ0xpbmVDaGFuZ2UodGhpcyQxLGksXCJndXR0ZXJcIik7aWYoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKXtsaW5lLmd1dHRlck1hcmtlcnM9bnVsbDt9fSsraTt9KTt9KSxsaW5lSW5mbzpmdW5jdGlvbihsaW5lKXt2YXIgbjtpZih0eXBlb2YgbGluZT09XCJudW1iZXJcIil7aWYoIWlzTGluZSh0aGlzLmRvYyxsaW5lKSl7cmV0dXJuIG51bGw7fW49bGluZTtsaW5lPWdldExpbmUodGhpcy5kb2MsbGluZSk7aWYoIWxpbmUpe3JldHVybiBudWxsO319ZWxzZXtuPWxpbmVObyhsaW5lKTtpZihuPT1udWxsKXtyZXR1cm4gbnVsbDt9fXJldHVybntsaW5lOm4saGFuZGxlOmxpbmUsdGV4dDpsaW5lLnRleHQsZ3V0dGVyTWFya2VyczpsaW5lLmd1dHRlck1hcmtlcnMsdGV4dENsYXNzOmxpbmUudGV4dENsYXNzLGJnQ2xhc3M6bGluZS5iZ0NsYXNzLHdyYXBDbGFzczpsaW5lLndyYXBDbGFzcyx3aWRnZXRzOmxpbmUud2lkZ2V0c307fSxnZXRWaWV3cG9ydDpmdW5jdGlvbigpe3JldHVybntmcm9tOnRoaXMuZGlzcGxheS52aWV3RnJvbSx0bzp0aGlzLmRpc3BsYXkudmlld1RvfTt9LGFkZFdpZGdldDpmdW5jdGlvbihwb3Msbm9kZSxzY3JvbGwsdmVydCxob3Jpeil7dmFyIGRpc3BsYXk9dGhpcy5kaXNwbGF5O3Bvcz1jdXJzb3JDb29yZHModGhpcyxjbGlwUG9zKHRoaXMuZG9jLHBvcykpO3ZhciB0b3A9cG9zLmJvdHRvbSxsZWZ0PXBvcy5sZWZ0O25vZGUuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiO25vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLFwidHJ1ZVwiKTt0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtkaXNwbGF5LnNpemVyLmFwcGVuZENoaWxkKG5vZGUpO2lmKHZlcnQ9PVwib3ZlclwiKXt0b3A9cG9zLnRvcDt9ZWxzZSBpZih2ZXJ0PT1cImFib3ZlXCJ8fHZlcnQ9PVwibmVhclwiKXt2YXIgdnNwYWNlPU1hdGgubWF4KGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsdGhpcy5kb2MuaGVpZ2h0KSxoc3BhY2U9TWF0aC5tYXgoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCxkaXNwbGF5LmxpbmVTcGFjZS5jbGllbnRXaWR0aCk7Ly8gRGVmYXVsdCB0byBwb3NpdGlvbmluZyBhYm92ZSAoaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZSk7IG90aGVyd2lzZSBkZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGJlbG93XG5pZigodmVydD09J2Fib3ZlJ3x8cG9zLmJvdHRvbStub2RlLm9mZnNldEhlaWdodD52c3BhY2UpJiZwb3MudG9wPm5vZGUub2Zmc2V0SGVpZ2h0KXt0b3A9cG9zLnRvcC1ub2RlLm9mZnNldEhlaWdodDt9ZWxzZSBpZihwb3MuYm90dG9tK25vZGUub2Zmc2V0SGVpZ2h0PD12c3BhY2Upe3RvcD1wb3MuYm90dG9tO31pZihsZWZ0K25vZGUub2Zmc2V0V2lkdGg+aHNwYWNlKXtsZWZ0PWhzcGFjZS1ub2RlLm9mZnNldFdpZHRoO319bm9kZS5zdHlsZS50b3A9dG9wK1wicHhcIjtub2RlLnN0eWxlLmxlZnQ9bm9kZS5zdHlsZS5yaWdodD1cIlwiO2lmKGhvcml6PT1cInJpZ2h0XCIpe2xlZnQ9ZGlzcGxheS5zaXplci5jbGllbnRXaWR0aC1ub2RlLm9mZnNldFdpZHRoO25vZGUuc3R5bGUucmlnaHQ9XCIwcHhcIjt9ZWxzZXtpZihob3Jpej09XCJsZWZ0XCIpe2xlZnQ9MDt9ZWxzZSBpZihob3Jpej09XCJtaWRkbGVcIil7bGVmdD0oZGlzcGxheS5zaXplci5jbGllbnRXaWR0aC1ub2RlLm9mZnNldFdpZHRoKS8yO31ub2RlLnN0eWxlLmxlZnQ9bGVmdCtcInB4XCI7fWlmKHNjcm9sbCl7c2Nyb2xsSW50b1ZpZXcodGhpcyxsZWZ0LHRvcCxsZWZ0K25vZGUub2Zmc2V0V2lkdGgsdG9wK25vZGUub2Zmc2V0SGVpZ2h0KTt9fSx0cmlnZ2VyT25LZXlEb3duOm1ldGhvZE9wKG9uS2V5RG93biksdHJpZ2dlck9uS2V5UHJlc3M6bWV0aG9kT3Aob25LZXlQcmVzcyksdHJpZ2dlck9uS2V5VXA6b25LZXlVcCxleGVjQ29tbWFuZDpmdW5jdGlvbihjbWQpe2lmKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpe3JldHVybiBjb21tYW5kc1tjbWRdLmNhbGwobnVsbCx0aGlzKTt9fSx0cmlnZ2VyRWxlY3RyaWM6bWV0aG9kT3AoZnVuY3Rpb24odGV4dCl7dHJpZ2dlckVsZWN0cmljKHRoaXMsdGV4dCk7fSksZmluZFBvc0g6ZnVuY3Rpb24oZnJvbSxhbW91bnQsdW5pdCx2aXN1YWxseSl7dmFyIHRoaXMkMT10aGlzO3ZhciBkaXI9MTtpZihhbW91bnQ8MCl7ZGlyPS0xO2Ftb3VudD0tYW1vdW50O312YXIgY3VyPWNsaXBQb3ModGhpcy5kb2MsZnJvbSk7Zm9yKHZhciBpPTA7aTxhbW91bnQ7KytpKXtjdXI9ZmluZFBvc0godGhpcyQxLmRvYyxjdXIsZGlyLHVuaXQsdmlzdWFsbHkpO2lmKGN1ci5oaXRTaWRlKXticmVhazt9fXJldHVybiBjdXI7fSxtb3ZlSDptZXRob2RPcChmdW5jdGlvbihkaXIsdW5pdCl7dmFyIHRoaXMkMT10aGlzO3RoaXMuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKXtpZih0aGlzJDEuZGlzcGxheS5zaGlmdHx8dGhpcyQxLmRvYy5leHRlbmR8fHJhbmdlLmVtcHR5KCkpe3JldHVybiBmaW5kUG9zSCh0aGlzJDEuZG9jLHJhbmdlLmhlYWQsZGlyLHVuaXQsdGhpcyQxLm9wdGlvbnMucnRsTW92ZVZpc3VhbGx5KTt9ZWxzZXtyZXR1cm4gZGlyPDA/cmFuZ2UuZnJvbSgpOnJhbmdlLnRvKCk7fX0sc2VsX21vdmUpO30pLGRlbGV0ZUg6bWV0aG9kT3AoZnVuY3Rpb24oZGlyLHVuaXQpe3ZhciBzZWw9dGhpcy5kb2Muc2VsLGRvYz10aGlzLmRvYztpZihzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSl7ZG9jLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiK2RlbGV0ZVwiKTt9ZWxzZXtkZWxldGVOZWFyU2VsZWN0aW9uKHRoaXMsZnVuY3Rpb24ocmFuZ2Upe3ZhciBvdGhlcj1maW5kUG9zSChkb2MscmFuZ2UuaGVhZCxkaXIsdW5pdCxmYWxzZSk7cmV0dXJuIGRpcjwwP3tmcm9tOm90aGVyLHRvOnJhbmdlLmhlYWR9Ontmcm9tOnJhbmdlLmhlYWQsdG86b3RoZXJ9O30pO319KSxmaW5kUG9zVjpmdW5jdGlvbihmcm9tLGFtb3VudCx1bml0LGdvYWxDb2x1bW4pe3ZhciB0aGlzJDE9dGhpczt2YXIgZGlyPTEseD1nb2FsQ29sdW1uO2lmKGFtb3VudDwwKXtkaXI9LTE7YW1vdW50PS1hbW91bnQ7fXZhciBjdXI9Y2xpcFBvcyh0aGlzLmRvYyxmcm9tKTtmb3IodmFyIGk9MDtpPGFtb3VudDsrK2kpe3ZhciBjb29yZHM9Y3Vyc29yQ29vcmRzKHRoaXMkMSxjdXIsXCJkaXZcIik7aWYoeD09bnVsbCl7eD1jb29yZHMubGVmdDt9ZWxzZXtjb29yZHMubGVmdD14O31jdXI9ZmluZFBvc1YodGhpcyQxLGNvb3JkcyxkaXIsdW5pdCk7aWYoY3VyLmhpdFNpZGUpe2JyZWFrO319cmV0dXJuIGN1cjt9LG1vdmVWOm1ldGhvZE9wKGZ1bmN0aW9uKGRpcix1bml0KXt2YXIgdGhpcyQxPXRoaXM7dmFyIGRvYz10aGlzLmRvYyxnb2Fscz1bXTt2YXIgY29sbGFwc2U9IXRoaXMuZGlzcGxheS5zaGlmdCYmIWRvYy5leHRlbmQmJmRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTtkb2MuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKXtpZihjb2xsYXBzZSl7cmV0dXJuIGRpcjwwP3JhbmdlLmZyb20oKTpyYW5nZS50bygpO312YXIgaGVhZFBvcz1jdXJzb3JDb29yZHModGhpcyQxLHJhbmdlLmhlYWQsXCJkaXZcIik7aWYocmFuZ2UuZ29hbENvbHVtbiE9bnVsbCl7aGVhZFBvcy5sZWZ0PXJhbmdlLmdvYWxDb2x1bW47fWdvYWxzLnB1c2goaGVhZFBvcy5sZWZ0KTt2YXIgcG9zPWZpbmRQb3NWKHRoaXMkMSxoZWFkUG9zLGRpcix1bml0KTtpZih1bml0PT1cInBhZ2VcIiYmcmFuZ2U9PWRvYy5zZWwucHJpbWFyeSgpKXthZGRUb1Njcm9sbFBvcyh0aGlzJDEsbnVsbCxjaGFyQ29vcmRzKHRoaXMkMSxwb3MsXCJkaXZcIikudG9wLWhlYWRQb3MudG9wKTt9cmV0dXJuIHBvczt9LHNlbF9tb3ZlKTtpZihnb2Fscy5sZW5ndGgpe2Zvcih2YXIgaT0wO2k8ZG9jLnNlbC5yYW5nZXMubGVuZ3RoO2krKyl7ZG9jLnNlbC5yYW5nZXNbaV0uZ29hbENvbHVtbj1nb2Fsc1tpXTt9fX0pLC8vIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIChhcyByZXR1cm5lZCBieSBjb29yZHNDaGFyKS5cbmZpbmRXb3JkQXQ6ZnVuY3Rpb24ocG9zKXt2YXIgZG9jPXRoaXMuZG9jLGxpbmU9Z2V0TGluZShkb2MscG9zLmxpbmUpLnRleHQ7dmFyIHN0YXJ0PXBvcy5jaCxlbmQ9cG9zLmNoO2lmKGxpbmUpe3ZhciBoZWxwZXI9dGhpcy5nZXRIZWxwZXIocG9zLFwid29yZENoYXJzXCIpO2lmKChwb3MueFJlbDwwfHxlbmQ9PWxpbmUubGVuZ3RoKSYmc3RhcnQpey0tc3RhcnQ7fWVsc2V7KytlbmQ7fXZhciBzdGFydENoYXI9bGluZS5jaGFyQXQoc3RhcnQpO3ZhciBjaGVjaz1pc1dvcmRDaGFyKHN0YXJ0Q2hhcixoZWxwZXIpP2Z1bmN0aW9uKGNoKXtyZXR1cm4gaXNXb3JkQ2hhcihjaCxoZWxwZXIpO306L1xccy8udGVzdChzdGFydENoYXIpP2Z1bmN0aW9uKGNoKXtyZXR1cm4gL1xccy8udGVzdChjaCk7fTpmdW5jdGlvbihjaCl7cmV0dXJuIS9cXHMvLnRlc3QoY2gpJiYhaXNXb3JkQ2hhcihjaCk7fTt3aGlsZShzdGFydD4wJiZjaGVjayhsaW5lLmNoYXJBdChzdGFydC0xKSkpey0tc3RhcnQ7fXdoaWxlKGVuZDxsaW5lLmxlbmd0aCYmY2hlY2sobGluZS5jaGFyQXQoZW5kKSkpeysrZW5kO319cmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsc3RhcnQpLFBvcyhwb3MubGluZSxlbmQpKTt9LHRvZ2dsZU92ZXJ3cml0ZTpmdW5jdGlvbih2YWx1ZSl7aWYodmFsdWUhPW51bGwmJnZhbHVlPT10aGlzLnN0YXRlLm92ZXJ3cml0ZSl7cmV0dXJuO31pZih0aGlzLnN0YXRlLm92ZXJ3cml0ZT0hdGhpcy5zdGF0ZS5vdmVyd3JpdGUpe2FkZENsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTt9ZWxzZXtybUNsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTt9c2lnbmFsKHRoaXMsXCJvdmVyd3JpdGVUb2dnbGVcIix0aGlzLHRoaXMuc3RhdGUub3ZlcndyaXRlKTt9LGhhc0ZvY3VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpPT1hY3RpdmVFbHQoKTt9LGlzUmVhZE9ubHk6ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLm9wdGlvbnMucmVhZE9ubHl8fHRoaXMuZG9jLmNhbnRFZGl0KTt9LHNjcm9sbFRvOm1ldGhvZE9wKGZ1bmN0aW9uKHgseSl7aWYoeCE9bnVsbHx8eSE9bnVsbCl7cmVzb2x2ZVNjcm9sbFRvUG9zKHRoaXMpO31pZih4IT1udWxsKXt0aGlzLmN1ck9wLnNjcm9sbExlZnQ9eDt9aWYoeSE9bnVsbCl7dGhpcy5jdXJPcC5zY3JvbGxUb3A9eTt9fSksZ2V0U2Nyb2xsSW5mbzpmdW5jdGlvbigpe3ZhciBzY3JvbGxlcj10aGlzLmRpc3BsYXkuc2Nyb2xsZXI7cmV0dXJue2xlZnQ6c2Nyb2xsZXIuc2Nyb2xsTGVmdCx0b3A6c2Nyb2xsZXIuc2Nyb2xsVG9wLGhlaWdodDpzY3JvbGxlci5zY3JvbGxIZWlnaHQtc2Nyb2xsR2FwKHRoaXMpLXRoaXMuZGlzcGxheS5iYXJIZWlnaHQsd2lkdGg6c2Nyb2xsZXIuc2Nyb2xsV2lkdGgtc2Nyb2xsR2FwKHRoaXMpLXRoaXMuZGlzcGxheS5iYXJXaWR0aCxjbGllbnRIZWlnaHQ6ZGlzcGxheUhlaWdodCh0aGlzKSxjbGllbnRXaWR0aDpkaXNwbGF5V2lkdGgodGhpcyl9O30sc2Nyb2xsSW50b1ZpZXc6bWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2UsbWFyZ2luKXtpZihyYW5nZT09bnVsbCl7cmFuZ2U9e2Zyb206dGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLHRvOm51bGx9O2lmKG1hcmdpbj09bnVsbCl7bWFyZ2luPXRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47fX1lbHNlIGlmKHR5cGVvZiByYW5nZT09XCJudW1iZXJcIil7cmFuZ2U9e2Zyb206UG9zKHJhbmdlLDApLHRvOm51bGx9O31lbHNlIGlmKHJhbmdlLmZyb209PW51bGwpe3JhbmdlPXtmcm9tOnJhbmdlLHRvOm51bGx9O31pZighcmFuZ2UudG8pe3JhbmdlLnRvPXJhbmdlLmZyb207fXJhbmdlLm1hcmdpbj1tYXJnaW58fDA7aWYocmFuZ2UuZnJvbS5saW5lIT1udWxsKXtyZXNvbHZlU2Nyb2xsVG9Qb3ModGhpcyk7dGhpcy5jdXJPcC5zY3JvbGxUb1Bvcz1yYW5nZTt9ZWxzZXt2YXIgc1Bvcz1jYWxjdWxhdGVTY3JvbGxQb3ModGhpcyxNYXRoLm1pbihyYW5nZS5mcm9tLmxlZnQscmFuZ2UudG8ubGVmdCksTWF0aC5taW4ocmFuZ2UuZnJvbS50b3AscmFuZ2UudG8udG9wKS1yYW5nZS5tYXJnaW4sTWF0aC5tYXgocmFuZ2UuZnJvbS5yaWdodCxyYW5nZS50by5yaWdodCksTWF0aC5tYXgocmFuZ2UuZnJvbS5ib3R0b20scmFuZ2UudG8uYm90dG9tKStyYW5nZS5tYXJnaW4pO3RoaXMuc2Nyb2xsVG8oc1Bvcy5zY3JvbGxMZWZ0LHNQb3Muc2Nyb2xsVG9wKTt9fSksc2V0U2l6ZTptZXRob2RPcChmdW5jdGlvbih3aWR0aCxoZWlnaHQpe3ZhciB0aGlzJDE9dGhpczt2YXIgaW50ZXJwcmV0PWZ1bmN0aW9uKHZhbCl7cmV0dXJuIHR5cGVvZiB2YWw9PVwibnVtYmVyXCJ8fC9eXFxkKyQvLnRlc3QoU3RyaW5nKHZhbCkpP3ZhbCtcInB4XCI6dmFsO307aWYod2lkdGghPW51bGwpe3RoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoPWludGVycHJldCh3aWR0aCk7fWlmKGhlaWdodCE9bnVsbCl7dGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0PWludGVycHJldChoZWlnaHQpO31pZih0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nKXtjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKHRoaXMpO312YXIgbGluZU5vPXRoaXMuZGlzcGxheS52aWV3RnJvbTt0aGlzLmRvYy5pdGVyKGxpbmVObyx0aGlzLmRpc3BsYXkudmlld1RvLGZ1bmN0aW9uKGxpbmUpe2lmKGxpbmUud2lkZ2V0cyl7Zm9yKHZhciBpPTA7aTxsaW5lLndpZGdldHMubGVuZ3RoO2krKyl7aWYobGluZS53aWRnZXRzW2ldLm5vSFNjcm9sbCl7cmVnTGluZUNoYW5nZSh0aGlzJDEsbGluZU5vLFwid2lkZ2V0XCIpO2JyZWFrO319fSsrbGluZU5vO30pO3RoaXMuY3VyT3AuZm9yY2VVcGRhdGU9dHJ1ZTtzaWduYWwodGhpcyxcInJlZnJlc2hcIix0aGlzKTt9KSxvcGVyYXRpb246ZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcyxmKTt9LHJlZnJlc2g6bWV0aG9kT3AoZnVuY3Rpb24oKXt2YXIgb2xkSGVpZ2h0PXRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O3JlZ0NoYW5nZSh0aGlzKTt0aGlzLmN1ck9wLmZvcmNlVXBkYXRlPXRydWU7Y2xlYXJDYWNoZXModGhpcyk7dGhpcy5zY3JvbGxUbyh0aGlzLmRvYy5zY3JvbGxMZWZ0LHRoaXMuZG9jLnNjcm9sbFRvcCk7dXBkYXRlR3V0dGVyU3BhY2UodGhpcyk7aWYob2xkSGVpZ2h0PT1udWxsfHxNYXRoLmFicyhvbGRIZWlnaHQtdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpKT4uNSl7ZXN0aW1hdGVMaW5lSGVpZ2h0cyh0aGlzKTt9c2lnbmFsKHRoaXMsXCJyZWZyZXNoXCIsdGhpcyk7fSksc3dhcERvYzptZXRob2RPcChmdW5jdGlvbihkb2Mpe3ZhciBvbGQ9dGhpcy5kb2M7b2xkLmNtPW51bGw7YXR0YWNoRG9jKHRoaXMsZG9jKTtjbGVhckNhY2hlcyh0aGlzKTt0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKTt0aGlzLnNjcm9sbFRvKGRvYy5zY3JvbGxMZWZ0LGRvYy5zY3JvbGxUb3ApO3RoaXMuY3VyT3AuZm9yY2VTY3JvbGw9dHJ1ZTtzaWduYWxMYXRlcih0aGlzLFwic3dhcERvY1wiLHRoaXMsb2xkKTtyZXR1cm4gb2xkO30pLGdldElucHV0RmllbGQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCk7fSxnZXRXcmFwcGVyRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcjt9LGdldFNjcm9sbGVyRWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuc2Nyb2xsZXI7fSxnZXRHdXR0ZXJFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5ndXR0ZXJzO319O2V2ZW50TWl4aW4oQ29kZU1pcnJvcik7Q29kZU1pcnJvci5yZWdpc3RlckhlbHBlcj1mdW5jdGlvbih0eXBlLG5hbWUsdmFsdWUpe2lmKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKXtoZWxwZXJzW3R5cGVdPUNvZGVNaXJyb3JbdHlwZV09e19nbG9iYWw6W119O31oZWxwZXJzW3R5cGVdW25hbWVdPXZhbHVlO307Q29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlcj1mdW5jdGlvbih0eXBlLG5hbWUscHJlZGljYXRlLHZhbHVlKXtDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsbmFtZSx2YWx1ZSk7aGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6cHJlZGljYXRlLHZhbDp2YWx1ZX0pO307fS8vIFVzZWQgZm9yIGhvcml6b250YWwgcmVsYXRpdmUgbW90aW9uLiBEaXIgaXMgLTEgb3IgMSAobGVmdCBvclxuLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcImNoYXJcIiwgXCJjb2x1bW5cIiAobGlrZSBjaGFyLCBidXQgZG9lc24ndFxuLy8gY3Jvc3MgbGluZSBib3VuZGFyaWVzKSwgXCJ3b3JkXCIgKGFjcm9zcyBuZXh0IHdvcmQpLCBvciBcImdyb3VwXCIgKHRvXG4vLyB0aGUgc3RhcnQgb2YgbmV4dCBncm91cCBvZiB3b3JkIG9yIG5vbi13b3JkLW5vbi13aGl0ZXNwYWNlXG4vLyBjaGFycykuIFRoZSB2aXN1YWxseSBwYXJhbSBjb250cm9scyB3aGV0aGVyLCBpbiByaWdodC10by1sZWZ0XG4vLyB0ZXh0LCBkaXJlY3Rpb24gMSBtZWFucyB0byBtb3ZlIHRvd2FyZHMgdGhlIG5leHQgaW5kZXggaW4gdGhlXG4vLyBzdHJpbmcsIG9yIHRvd2FyZHMgdGhlIGNoYXJhY3RlciB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnRcbi8vIHBvc2l0aW9uLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxuLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbmZ1bmN0aW9uIGZpbmRQb3NIKGRvYyxwb3MsZGlyLHVuaXQsdmlzdWFsbHkpe3ZhciBsaW5lPXBvcy5saW5lLGNoPXBvcy5jaCxvcmlnRGlyPWRpcjt2YXIgbGluZU9iaj1nZXRMaW5lKGRvYyxsaW5lKTtmdW5jdGlvbiBmaW5kTmV4dExpbmUoKXt2YXIgbD1saW5lK2RpcjtpZihsPGRvYy5maXJzdHx8bD49ZG9jLmZpcnN0K2RvYy5zaXplKXtyZXR1cm4gZmFsc2U7fWxpbmU9bDtyZXR1cm4gbGluZU9iaj1nZXRMaW5lKGRvYyxsKTt9ZnVuY3Rpb24gbW92ZU9uY2UoYm91bmRUb0xpbmUpe3ZhciBuZXh0PSh2aXN1YWxseT9tb3ZlVmlzdWFsbHk6bW92ZUxvZ2ljYWxseSkobGluZU9iaixjaCxkaXIsdHJ1ZSk7aWYobmV4dD09bnVsbCl7aWYoIWJvdW5kVG9MaW5lJiZmaW5kTmV4dExpbmUoKSl7aWYodmlzdWFsbHkpe2NoPShkaXI8MD9saW5lUmlnaHQ6bGluZUxlZnQpKGxpbmVPYmopO31lbHNle2NoPWRpcjwwP2xpbmVPYmoudGV4dC5sZW5ndGg6MDt9fWVsc2V7cmV0dXJuIGZhbHNlO319ZWxzZXtjaD1uZXh0O31yZXR1cm4gdHJ1ZTt9aWYodW5pdD09XCJjaGFyXCIpe21vdmVPbmNlKCk7fWVsc2UgaWYodW5pdD09XCJjb2x1bW5cIil7bW92ZU9uY2UodHJ1ZSk7fWVsc2UgaWYodW5pdD09XCJ3b3JkXCJ8fHVuaXQ9PVwiZ3JvdXBcIil7dmFyIHNhd1R5cGU9bnVsbCxncm91cD11bml0PT1cImdyb3VwXCI7dmFyIGhlbHBlcj1kb2MuY20mJmRvYy5jbS5nZXRIZWxwZXIocG9zLFwid29yZENoYXJzXCIpO2Zvcih2YXIgZmlyc3Q9dHJ1ZTs7Zmlyc3Q9ZmFsc2Upe2lmKGRpcjwwJiYhbW92ZU9uY2UoIWZpcnN0KSl7YnJlYWs7fXZhciBjdXI9bGluZU9iai50ZXh0LmNoYXJBdChjaCl8fFwiXFxuXCI7dmFyIHR5cGU9aXNXb3JkQ2hhcihjdXIsaGVscGVyKT9cIndcIjpncm91cCYmY3VyPT1cIlxcblwiP1wiblwiOiFncm91cHx8L1xccy8udGVzdChjdXIpP251bGw6XCJwXCI7aWYoZ3JvdXAmJiFmaXJzdCYmIXR5cGUpe3R5cGU9XCJzXCI7fWlmKHNhd1R5cGUmJnNhd1R5cGUhPXR5cGUpe2lmKGRpcjwwKXtkaXI9MTttb3ZlT25jZSgpO31icmVhazt9aWYodHlwZSl7c2F3VHlwZT10eXBlO31pZihkaXI+MCYmIW1vdmVPbmNlKCFmaXJzdCkpe2JyZWFrO319fXZhciByZXN1bHQ9c2tpcEF0b21pYyhkb2MsUG9zKGxpbmUsY2gpLHBvcyxvcmlnRGlyLHRydWUpO2lmKCFjbXAocG9zLHJlc3VsdCkpe3Jlc3VsdC5oaXRTaWRlPXRydWU7fXJldHVybiByZXN1bHQ7fS8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxuLy8gXCJwYWdlXCIgb3IgXCJsaW5lXCIuIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXG4vLyBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gZmluZFBvc1YoY20scG9zLGRpcix1bml0KXt2YXIgZG9jPWNtLmRvYyx4PXBvcy5sZWZ0LHk7aWYodW5pdD09XCJwYWdlXCIpe3ZhciBwYWdlU2l6ZT1NYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7dmFyIG1vdmVBbW91bnQ9TWF0aC5tYXgocGFnZVNpemUtLjUqdGV4dEhlaWdodChjbS5kaXNwbGF5KSwzKTt5PShkaXI+MD9wb3MuYm90dG9tOnBvcy50b3ApK2Rpciptb3ZlQW1vdW50O31lbHNlIGlmKHVuaXQ9PVwibGluZVwiKXt5PWRpcj4wP3Bvcy5ib3R0b20rMzpwb3MudG9wLTM7fXZhciB0YXJnZXQ7Zm9yKDs7KXt0YXJnZXQ9Y29vcmRzQ2hhcihjbSx4LHkpO2lmKCF0YXJnZXQub3V0c2lkZSl7YnJlYWs7fWlmKGRpcjwwP3k8PTA6eT49ZG9jLmhlaWdodCl7dGFyZ2V0LmhpdFNpZGU9dHJ1ZTticmVhazt9eSs9ZGlyKjU7fXJldHVybiB0YXJnZXQ7fS8vIENPTlRFTlRFRElUQUJMRSBJTlBVVCBTVFlMRVxuZnVuY3Rpb24gQ29udGVudEVkaXRhYmxlSW5wdXQoY20pe3RoaXMuY209Y207dGhpcy5sYXN0QW5jaG9yTm9kZT10aGlzLmxhc3RBbmNob3JPZmZzZXQ9dGhpcy5sYXN0Rm9jdXNOb2RlPXRoaXMubGFzdEZvY3VzT2Zmc2V0PW51bGw7dGhpcy5wb2xsaW5nPW5ldyBEZWxheWVkKCk7dGhpcy5ncmFjZVBlcmlvZD1mYWxzZTt9Q29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlPWNvcHlPYmooe2luaXQ6ZnVuY3Rpb24oZGlzcGxheSl7dmFyIGlucHV0PXRoaXMsY209aW5wdXQuY207dmFyIGRpdj1pbnB1dC5kaXY9ZGlzcGxheS5saW5lRGl2O2Rpc2FibGVCcm93c2VyTWFnaWMoZGl2LGNtLm9wdGlvbnMuc3BlbGxjaGVjayk7b24oZGl2LFwicGFzdGVcIixmdW5jdGlvbihlKXtpZihzaWduYWxET01FdmVudChjbSxlKXx8aGFuZGxlUGFzdGUoZSxjbSkpe3JldHVybjt9Ly8gSUUgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50cywgc28gd2Ugc2NoZWR1bGUgYSByZWFkIGZvciB0aGUgcGFzdGVkIGNvbnRlbnQgaW4gdGhpcyB3YXlcbmlmKGllX3ZlcnNpb248PTExKXtzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSxmdW5jdGlvbigpe2lmKCFpbnB1dC5wb2xsQ29udGVudCgpKXtyZWdDaGFuZ2UoY20pO319KSwyMCk7fX0pO29uKGRpdixcImNvbXBvc2l0aW9uc3RhcnRcIixmdW5jdGlvbihlKXt2YXIgZGF0YT1lLmRhdGE7aW5wdXQuY29tcG9zaW5nPXtzZWw6Y20uZG9jLnNlbCxkYXRhOmRhdGEsc3RhcnREYXRhOmRhdGF9O2lmKCFkYXRhKXtyZXR1cm47fXZhciBwcmltPWNtLmRvYy5zZWwucHJpbWFyeSgpO3ZhciBsaW5lPWNtLmdldExpbmUocHJpbS5oZWFkLmxpbmUpO3ZhciBmb3VuZD1saW5lLmluZGV4T2YoZGF0YSxNYXRoLm1heCgwLHByaW0uaGVhZC5jaC1kYXRhLmxlbmd0aCkpO2lmKGZvdW5kPi0xJiZmb3VuZDw9cHJpbS5oZWFkLmNoKXtpbnB1dC5jb21wb3Npbmcuc2VsPXNpbXBsZVNlbGVjdGlvbihQb3MocHJpbS5oZWFkLmxpbmUsZm91bmQpLFBvcyhwcmltLmhlYWQubGluZSxmb3VuZCtkYXRhLmxlbmd0aCkpO319KTtvbihkaXYsXCJjb21wb3NpdGlvbnVwZGF0ZVwiLGZ1bmN0aW9uKGUpe3JldHVybiBpbnB1dC5jb21wb3NpbmcuZGF0YT1lLmRhdGE7fSk7b24oZGl2LFwiY29tcG9zaXRpb25lbmRcIixmdW5jdGlvbihlKXt2YXIgb3Vycz1pbnB1dC5jb21wb3Npbmc7aWYoIW91cnMpe3JldHVybjt9aWYoZS5kYXRhIT1vdXJzLnN0YXJ0RGF0YSYmIS9cXHUyMDBiLy50ZXN0KGUuZGF0YSkpe291cnMuZGF0YT1lLmRhdGE7fS8vIE5lZWQgYSBzbWFsbCBkZWxheSB0byBwcmV2ZW50IG90aGVyIGNvZGUgKGlucHV0IGV2ZW50LFxuLy8gc2VsZWN0aW9uIHBvbGxpbmcpIGZyb20gZG9pbmcgZGFtYWdlIHdoZW4gZmlyZWQgcmlnaHQgYWZ0ZXJcbi8vIGNvbXBvc2l0aW9uZW5kLlxuc2V0VGltZW91dChmdW5jdGlvbigpe2lmKCFvdXJzLmhhbmRsZWQpe2lucHV0LmFwcGx5Q29tcG9zaXRpb24ob3Vycyk7fWlmKGlucHV0LmNvbXBvc2luZz09b3Vycyl7aW5wdXQuY29tcG9zaW5nPW51bGw7fX0sNTApO30pO29uKGRpdixcInRvdWNoc3RhcnRcIixmdW5jdGlvbigpe3JldHVybiBpbnB1dC5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7fSk7b24oZGl2LFwiaW5wdXRcIixmdW5jdGlvbigpe2lmKGlucHV0LmNvbXBvc2luZyl7cmV0dXJuO31pZihjbS5pc1JlYWRPbmx5KCl8fCFpbnB1dC5wb2xsQ29udGVudCgpKXtydW5Jbk9wKGlucHV0LmNtLGZ1bmN0aW9uKCl7cmV0dXJuIHJlZ0NoYW5nZShjbSk7fSk7fX0pO2Z1bmN0aW9uIG9uQ29weUN1dChlKXtpZihzaWduYWxET01FdmVudChjbSxlKSl7cmV0dXJuO31pZihjbS5zb21ldGhpbmdTZWxlY3RlZCgpKXtzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTpmYWxzZSx0ZXh0OmNtLmdldFNlbGVjdGlvbnMoKX0pO2lmKGUudHlwZT09XCJjdXRcIil7Y20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLG51bGwsXCJjdXRcIik7fX1lbHNlIGlmKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCl7cmV0dXJuO31lbHNle3ZhciByYW5nZXM9Y29weWFibGVSYW5nZXMoY20pO3NldExhc3RDb3BpZWQoe2xpbmVXaXNlOnRydWUsdGV4dDpyYW5nZXMudGV4dH0pO2lmKGUudHlwZT09XCJjdXRcIil7Y20ub3BlcmF0aW9uKGZ1bmN0aW9uKCl7Y20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLDAsc2VsX2RvbnRTY3JvbGwpO2NtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIixudWxsLFwiY3V0XCIpO30pO319aWYoZS5jbGlwYm9hcmREYXRhKXtlLmNsaXBib2FyZERhdGEuY2xlYXJEYXRhKCk7dmFyIGNvbnRlbnQ9bGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIik7Ly8gaU9TIGV4cG9zZXMgdGhlIGNsaXBib2FyZCBBUEksIGJ1dCBzZWVtcyB0byBkaXNjYXJkIGNvbnRlbnQgaW5zZXJ0ZWQgaW50byBpdFxuZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsY29udGVudCk7aWYoZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpPT1jb250ZW50KXtlLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuO319Ly8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xudmFyIGtsdWRnZT1oaWRkZW5UZXh0YXJlYSgpLHRlPWtsdWRnZS5maXJzdENoaWxkO2NtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShrbHVkZ2UsY20uZGlzcGxheS5saW5lU3BhY2UuZmlyc3RDaGlsZCk7dGUudmFsdWU9bGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIik7dmFyIGhhZEZvY3VzPWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7c2VsZWN0SW5wdXQodGUpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpO2hhZEZvY3VzLmZvY3VzKCk7aWYoaGFkRm9jdXM9PWRpdil7aW5wdXQuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKTt9fSw1MCk7fW9uKGRpdixcImNvcHlcIixvbkNvcHlDdXQpO29uKGRpdixcImN1dFwiLG9uQ29weUN1dCk7fSxwcmVwYXJlU2VsZWN0aW9uOmZ1bmN0aW9uKCl7dmFyIHJlc3VsdD1wcmVwYXJlU2VsZWN0aW9uKHRoaXMuY20sZmFsc2UpO3Jlc3VsdC5mb2N1cz10aGlzLmNtLnN0YXRlLmZvY3VzZWQ7cmV0dXJuIHJlc3VsdDt9LHNob3dTZWxlY3Rpb246ZnVuY3Rpb24oaW5mbyx0YWtlRm9jdXMpe2lmKCFpbmZvfHwhdGhpcy5jbS5kaXNwbGF5LnZpZXcubGVuZ3RoKXtyZXR1cm47fWlmKGluZm8uZm9jdXN8fHRha2VGb2N1cyl7dGhpcy5zaG93UHJpbWFyeVNlbGVjdGlvbigpO310aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoaW5mbyk7fSxzaG93UHJpbWFyeVNlbGVjdGlvbjpmdW5jdGlvbigpe3ZhciBzZWw9d2luZG93LmdldFNlbGVjdGlvbigpLHByaW09dGhpcy5jbS5kb2Muc2VsLnByaW1hcnkoKTt2YXIgY3VyQW5jaG9yPWRvbVRvUG9zKHRoaXMuY20sc2VsLmFuY2hvck5vZGUsc2VsLmFuY2hvck9mZnNldCk7dmFyIGN1ckZvY3VzPWRvbVRvUG9zKHRoaXMuY20sc2VsLmZvY3VzTm9kZSxzZWwuZm9jdXNPZmZzZXQpO2lmKGN1ckFuY2hvciYmIWN1ckFuY2hvci5iYWQmJmN1ckZvY3VzJiYhY3VyRm9jdXMuYmFkJiZjbXAobWluUG9zKGN1ckFuY2hvcixjdXJGb2N1cykscHJpbS5mcm9tKCkpPT0wJiZjbXAobWF4UG9zKGN1ckFuY2hvcixjdXJGb2N1cykscHJpbS50bygpKT09MCl7cmV0dXJuO312YXIgc3RhcnQ9cG9zVG9ET00odGhpcy5jbSxwcmltLmZyb20oKSk7dmFyIGVuZD1wb3NUb0RPTSh0aGlzLmNtLHByaW0udG8oKSk7aWYoIXN0YXJ0JiYhZW5kKXtyZXR1cm47fXZhciB2aWV3PXRoaXMuY20uZGlzcGxheS52aWV3O3ZhciBvbGQ9c2VsLnJhbmdlQ291bnQmJnNlbC5nZXRSYW5nZUF0KDApO2lmKCFzdGFydCl7c3RhcnQ9e25vZGU6dmlld1swXS5tZWFzdXJlLm1hcFsyXSxvZmZzZXQ6MH07fWVsc2UgaWYoIWVuZCl7Ly8gRklYTUUgZGFuZ2Vyb3VzbHkgaGFja3lcbnZhciBtZWFzdXJlPXZpZXdbdmlldy5sZW5ndGgtMV0ubWVhc3VyZTt2YXIgbWFwPW1lYXN1cmUubWFwcz9tZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aC0xXTptZWFzdXJlLm1hcDtlbmQ9e25vZGU6bWFwW21hcC5sZW5ndGgtMV0sb2Zmc2V0Om1hcFttYXAubGVuZ3RoLTJdLW1hcFttYXAubGVuZ3RoLTNdfTt9dmFyIHJuZzt0cnl7cm5nPXJhbmdlKHN0YXJ0Lm5vZGUsc3RhcnQub2Zmc2V0LGVuZC5vZmZzZXQsZW5kLm5vZGUpO31jYXRjaChlKXt9Ly8gT3VyIG1vZGVsIG9mIHRoZSBET00gbWlnaHQgYmUgb3V0ZGF0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIHJhbmdlIHdlIHRyeSB0byBzZXQgY2FuIGJlIGltcG9zc2libGVcbmlmKHJuZyl7aWYoIWdlY2tvJiZ0aGlzLmNtLnN0YXRlLmZvY3VzZWQpe3NlbC5jb2xsYXBzZShzdGFydC5ub2RlLHN0YXJ0Lm9mZnNldCk7aWYoIXJuZy5jb2xsYXBzZWQpe3NlbC5yZW1vdmVBbGxSYW5nZXMoKTtzZWwuYWRkUmFuZ2Uocm5nKTt9fWVsc2V7c2VsLnJlbW92ZUFsbFJhbmdlcygpO3NlbC5hZGRSYW5nZShybmcpO31pZihvbGQmJnNlbC5hbmNob3JOb2RlPT1udWxsKXtzZWwuYWRkUmFuZ2Uob2xkKTt9ZWxzZSBpZihnZWNrbyl7dGhpcy5zdGFydEdyYWNlUGVyaW9kKCk7fX10aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7fSxzdGFydEdyYWNlUGVyaW9kOmZ1bmN0aW9uKCl7dmFyIHRoaXMkMT10aGlzO2NsZWFyVGltZW91dCh0aGlzLmdyYWNlUGVyaW9kKTt0aGlzLmdyYWNlUGVyaW9kPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aGlzJDEuZ3JhY2VQZXJpb2Q9ZmFsc2U7aWYodGhpcyQxLnNlbGVjdGlvbkNoYW5nZWQoKSl7dGhpcyQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbigpe3JldHVybiB0aGlzJDEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZD10cnVlO30pO319LDIwKTt9LHNob3dNdWx0aXBsZVNlbGVjdGlvbnM6ZnVuY3Rpb24oaW5mbyl7cmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LmN1cnNvckRpdixpbmZvLmN1cnNvcnMpO3JlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsaW5mby5zZWxlY3Rpb24pO30scmVtZW1iZXJTZWxlY3Rpb246ZnVuY3Rpb24oKXt2YXIgc2VsPXdpbmRvdy5nZXRTZWxlY3Rpb24oKTt0aGlzLmxhc3RBbmNob3JOb2RlPXNlbC5hbmNob3JOb2RlO3RoaXMubGFzdEFuY2hvck9mZnNldD1zZWwuYW5jaG9yT2Zmc2V0O3RoaXMubGFzdEZvY3VzTm9kZT1zZWwuZm9jdXNOb2RlO3RoaXMubGFzdEZvY3VzT2Zmc2V0PXNlbC5mb2N1c09mZnNldDt9LHNlbGVjdGlvbkluRWRpdG9yOmZ1bmN0aW9uKCl7dmFyIHNlbD13aW5kb3cuZ2V0U2VsZWN0aW9uKCk7aWYoIXNlbC5yYW5nZUNvdW50KXtyZXR1cm4gZmFsc2U7fXZhciBub2RlPXNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO3JldHVybiBjb250YWlucyh0aGlzLmRpdixub2RlKTt9LGZvY3VzOmZ1bmN0aW9uKCl7aWYodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5IT1cIm5vY3Vyc29yXCIpe3RoaXMuZGl2LmZvY3VzKCk7fX0sYmx1cjpmdW5jdGlvbigpe3RoaXMuZGl2LmJsdXIoKTt9LGdldEZpZWxkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGl2O30sc3VwcG9ydHNUb3VjaDpmdW5jdGlvbigpe3JldHVybiB0cnVlO30scmVjZWl2ZWRGb2N1czpmdW5jdGlvbigpe3ZhciBpbnB1dD10aGlzO2lmKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSl7dGhpcy5wb2xsU2VsZWN0aW9uKCk7fWVsc2V7cnVuSW5PcCh0aGlzLmNtLGZ1bmN0aW9uKCl7cmV0dXJuIGlucHV0LmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQ9dHJ1ZTt9KTt9ZnVuY3Rpb24gcG9sbCgpe2lmKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpe2lucHV0LnBvbGxTZWxlY3Rpb24oKTtpbnB1dC5wb2xsaW5nLnNldChpbnB1dC5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCxwb2xsKTt9fXRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCxwb2xsKTt9LHNlbGVjdGlvbkNoYW5nZWQ6ZnVuY3Rpb24oKXt2YXIgc2VsPXdpbmRvdy5nZXRTZWxlY3Rpb24oKTtyZXR1cm4gc2VsLmFuY2hvck5vZGUhPXRoaXMubGFzdEFuY2hvck5vZGV8fHNlbC5hbmNob3JPZmZzZXQhPXRoaXMubGFzdEFuY2hvck9mZnNldHx8c2VsLmZvY3VzTm9kZSE9dGhpcy5sYXN0Rm9jdXNOb2RlfHxzZWwuZm9jdXNPZmZzZXQhPXRoaXMubGFzdEZvY3VzT2Zmc2V0O30scG9sbFNlbGVjdGlvbjpmdW5jdGlvbigpe2lmKCF0aGlzLmNvbXBvc2luZyYmIXRoaXMuZ3JhY2VQZXJpb2QmJnRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKXt2YXIgc2VsPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjbT10aGlzLmNtO3RoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTt2YXIgYW5jaG9yPWRvbVRvUG9zKGNtLHNlbC5hbmNob3JOb2RlLHNlbC5hbmNob3JPZmZzZXQpO3ZhciBoZWFkPWRvbVRvUG9zKGNtLHNlbC5mb2N1c05vZGUsc2VsLmZvY3VzT2Zmc2V0KTtpZihhbmNob3ImJmhlYWQpe3J1bkluT3AoY20sZnVuY3Rpb24oKXtzZXRTZWxlY3Rpb24oY20uZG9jLHNpbXBsZVNlbGVjdGlvbihhbmNob3IsaGVhZCksc2VsX2RvbnRTY3JvbGwpO2lmKGFuY2hvci5iYWR8fGhlYWQuYmFkKXtjbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkPXRydWU7fX0pO319fSxwb2xsQ29udGVudDpmdW5jdGlvbigpe3ZhciBjbT10aGlzLmNtLGRpc3BsYXk9Y20uZGlzcGxheSxzZWw9Y20uZG9jLnNlbC5wcmltYXJ5KCk7dmFyIGZyb209c2VsLmZyb20oKSx0bz1zZWwudG8oKTtpZihmcm9tLmxpbmU8ZGlzcGxheS52aWV3RnJvbXx8dG8ubGluZT5kaXNwbGF5LnZpZXdUby0xKXtyZXR1cm4gZmFsc2U7fXZhciBmcm9tSW5kZXgsZnJvbUxpbmUsZnJvbU5vZGU7aWYoZnJvbS5saW5lPT1kaXNwbGF5LnZpZXdGcm9tfHwoZnJvbUluZGV4PWZpbmRWaWV3SW5kZXgoY20sZnJvbS5saW5lKSk9PTApe2Zyb21MaW5lPWxpbmVObyhkaXNwbGF5LnZpZXdbMF0ubGluZSk7ZnJvbU5vZGU9ZGlzcGxheS52aWV3WzBdLm5vZGU7fWVsc2V7ZnJvbUxpbmU9bGluZU5vKGRpc3BsYXkudmlld1tmcm9tSW5kZXhdLmxpbmUpO2Zyb21Ob2RlPWRpc3BsYXkudmlld1tmcm9tSW5kZXgtMV0ubm9kZS5uZXh0U2libGluZzt9dmFyIHRvSW5kZXg9ZmluZFZpZXdJbmRleChjbSx0by5saW5lKTt2YXIgdG9MaW5lLHRvTm9kZTtpZih0b0luZGV4PT1kaXNwbGF5LnZpZXcubGVuZ3RoLTEpe3RvTGluZT1kaXNwbGF5LnZpZXdUby0xO3RvTm9kZT1kaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkO31lbHNle3RvTGluZT1saW5lTm8oZGlzcGxheS52aWV3W3RvSW5kZXgrMV0ubGluZSktMTt0b05vZGU9ZGlzcGxheS52aWV3W3RvSW5kZXgrMV0ubm9kZS5wcmV2aW91c1NpYmxpbmc7fXZhciBuZXdUZXh0PWNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLGZyb21Ob2RlLHRvTm9kZSxmcm9tTGluZSx0b0xpbmUpKTt2YXIgb2xkVGV4dD1nZXRCZXR3ZWVuKGNtLmRvYyxQb3MoZnJvbUxpbmUsMCksUG9zKHRvTGluZSxnZXRMaW5lKGNtLmRvYyx0b0xpbmUpLnRleHQubGVuZ3RoKSk7d2hpbGUobmV3VGV4dC5sZW5ndGg+MSYmb2xkVGV4dC5sZW5ndGg+MSl7aWYobHN0KG5ld1RleHQpPT1sc3Qob2xkVGV4dCkpe25ld1RleHQucG9wKCk7b2xkVGV4dC5wb3AoKTt0b0xpbmUtLTt9ZWxzZSBpZihuZXdUZXh0WzBdPT1vbGRUZXh0WzBdKXtuZXdUZXh0LnNoaWZ0KCk7b2xkVGV4dC5zaGlmdCgpO2Zyb21MaW5lKys7fWVsc2V7YnJlYWs7fX12YXIgY3V0RnJvbnQ9MCxjdXRFbmQ9MDt2YXIgbmV3VG9wPW5ld1RleHRbMF0sb2xkVG9wPW9sZFRleHRbMF0sbWF4Q3V0RnJvbnQ9TWF0aC5taW4obmV3VG9wLmxlbmd0aCxvbGRUb3AubGVuZ3RoKTt3aGlsZShjdXRGcm9udDxtYXhDdXRGcm9udCYmbmV3VG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpPT1vbGRUb3AuY2hhckNvZGVBdChjdXRGcm9udCkpeysrY3V0RnJvbnQ7fXZhciBuZXdCb3Q9bHN0KG5ld1RleHQpLG9sZEJvdD1sc3Qob2xkVGV4dCk7dmFyIG1heEN1dEVuZD1NYXRoLm1pbihuZXdCb3QubGVuZ3RoLShuZXdUZXh0Lmxlbmd0aD09MT9jdXRGcm9udDowKSxvbGRCb3QubGVuZ3RoLShvbGRUZXh0Lmxlbmd0aD09MT9jdXRGcm9udDowKSk7d2hpbGUoY3V0RW5kPG1heEN1dEVuZCYmbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aC1jdXRFbmQtMSk9PW9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGgtY3V0RW5kLTEpKXsrK2N1dEVuZDt9bmV3VGV4dFtuZXdUZXh0Lmxlbmd0aC0xXT1uZXdCb3Quc2xpY2UoMCxuZXdCb3QubGVuZ3RoLWN1dEVuZCk7bmV3VGV4dFswXT1uZXdUZXh0WzBdLnNsaWNlKGN1dEZyb250KTt2YXIgY2hGcm9tPVBvcyhmcm9tTGluZSxjdXRGcm9udCk7dmFyIGNoVG89UG9zKHRvTGluZSxvbGRUZXh0Lmxlbmd0aD9sc3Qob2xkVGV4dCkubGVuZ3RoLWN1dEVuZDowKTtpZihuZXdUZXh0Lmxlbmd0aD4xfHxuZXdUZXh0WzBdfHxjbXAoY2hGcm9tLGNoVG8pKXtyZXBsYWNlUmFuZ2UoY20uZG9jLG5ld1RleHQsY2hGcm9tLGNoVG8sXCIraW5wdXRcIik7cmV0dXJuIHRydWU7fX0sZW5zdXJlUG9sbGVkOmZ1bmN0aW9uKCl7dGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7fSxyZXNldDpmdW5jdGlvbigpe3RoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO30sZm9yY2VDb21wb3NpdGlvbkVuZDpmdW5jdGlvbigpe2lmKCF0aGlzLmNvbXBvc2luZ3x8dGhpcy5jb21wb3NpbmcuaGFuZGxlZCl7cmV0dXJuO310aGlzLmFwcGx5Q29tcG9zaXRpb24odGhpcy5jb21wb3NpbmcpO3RoaXMuY29tcG9zaW5nLmhhbmRsZWQ9dHJ1ZTt0aGlzLmRpdi5ibHVyKCk7dGhpcy5kaXYuZm9jdXMoKTt9LGFwcGx5Q29tcG9zaXRpb246ZnVuY3Rpb24oY29tcG9zaW5nKXtpZih0aGlzLmNtLmlzUmVhZE9ubHkoKSl7b3BlcmF0aW9uKHRoaXMuY20scmVnQ2hhbmdlKSh0aGlzLmNtKTt9ZWxzZSBpZihjb21wb3NpbmcuZGF0YSYmY29tcG9zaW5nLmRhdGEhPWNvbXBvc2luZy5zdGFydERhdGEpe29wZXJhdGlvbih0aGlzLmNtLGFwcGx5VGV4dElucHV0KSh0aGlzLmNtLGNvbXBvc2luZy5kYXRhLDAsY29tcG9zaW5nLnNlbCk7fX0sc2V0VW5lZGl0YWJsZTpmdW5jdGlvbihub2RlKXtub2RlLmNvbnRlbnRFZGl0YWJsZT1cImZhbHNlXCI7fSxvbktleVByZXNzOmZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTtpZighdGhpcy5jbS5pc1JlYWRPbmx5KCkpe29wZXJhdGlvbih0aGlzLmNtLGFwcGx5VGV4dElucHV0KSh0aGlzLmNtLFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZT09bnVsbD9lLmtleUNvZGU6ZS5jaGFyQ29kZSksMCk7fX0scmVhZE9ubHlDaGFuZ2VkOmZ1bmN0aW9uKHZhbCl7dGhpcy5kaXYuY29udGVudEVkaXRhYmxlPVN0cmluZyh2YWwhPVwibm9jdXJzb3JcIik7fSxvbkNvbnRleHRNZW51Om5vdGhpbmcscmVzZXRQb3NpdGlvbjpub3RoaW5nLG5lZWRzQ29udGVudEF0dHJpYnV0ZTp0cnVlfSxDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUpO2Z1bmN0aW9uIHBvc1RvRE9NKGNtLHBvcyl7dmFyIHZpZXc9ZmluZFZpZXdGb3JMaW5lKGNtLHBvcy5saW5lKTtpZighdmlld3x8dmlldy5oaWRkZW4pe3JldHVybiBudWxsO312YXIgbGluZT1nZXRMaW5lKGNtLmRvYyxwb3MubGluZSk7dmFyIGluZm89bWFwRnJvbUxpbmVWaWV3KHZpZXcsbGluZSxwb3MubGluZSk7dmFyIG9yZGVyPWdldE9yZGVyKGxpbmUpLHNpZGU9XCJsZWZ0XCI7aWYob3JkZXIpe3ZhciBwYXJ0UG9zPWdldEJpZGlQYXJ0QXQob3JkZXIscG9zLmNoKTtzaWRlPXBhcnRQb3MlMj9cInJpZ2h0XCI6XCJsZWZ0XCI7fXZhciByZXN1bHQ9bm9kZUFuZE9mZnNldEluTGluZU1hcChpbmZvLm1hcCxwb3MuY2gsc2lkZSk7cmVzdWx0Lm9mZnNldD1yZXN1bHQuY29sbGFwc2U9PVwicmlnaHRcIj9yZXN1bHQuZW5kOnJlc3VsdC5zdGFydDtyZXR1cm4gcmVzdWx0O31mdW5jdGlvbiBiYWRQb3MocG9zLGJhZCl7aWYoYmFkKXtwb3MuYmFkPXRydWU7fXJldHVybiBwb3M7fWZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLGZyb20sdG8sZnJvbUxpbmUsdG9MaW5lKXt2YXIgdGV4dD1cIlwiLGNsb3Npbmc9ZmFsc2UsbGluZVNlcD1jbS5kb2MubGluZVNlcGFyYXRvcigpO2Z1bmN0aW9uIHJlY29nbml6ZU1hcmtlcihpZCl7cmV0dXJuIGZ1bmN0aW9uKG1hcmtlcil7cmV0dXJuIG1hcmtlci5pZD09aWQ7fTt9ZnVuY3Rpb24gd2Fsayhub2RlKXtpZihub2RlLm5vZGVUeXBlPT0xKXt2YXIgY21UZXh0PW5vZGUuZ2V0QXR0cmlidXRlKFwiY20tdGV4dFwiKTtpZihjbVRleHQhPW51bGwpe2lmKGNtVGV4dD09XCJcIil7Y21UZXh0PW5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXFx1MjAwYi9nLFwiXCIpO310ZXh0Kz1jbVRleHQ7cmV0dXJuO312YXIgbWFya2VySUQ9bm9kZS5nZXRBdHRyaWJ1dGUoXCJjbS1tYXJrZXJcIikscmFuZ2U7aWYobWFya2VySUQpe3ZhciBmb3VuZD1jbS5maW5kTWFya3MoUG9zKGZyb21MaW5lLDApLFBvcyh0b0xpbmUrMSwwKSxyZWNvZ25pemVNYXJrZXIoK21hcmtlcklEKSk7aWYoZm91bmQubGVuZ3RoJiYocmFuZ2U9Zm91bmRbMF0uZmluZCgpKSl7dGV4dCs9Z2V0QmV0d2VlbihjbS5kb2MscmFuZ2UuZnJvbSxyYW5nZS50bykuam9pbihsaW5lU2VwKTt9cmV0dXJuO31pZihub2RlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKT09XCJmYWxzZVwiKXtyZXR1cm47fWZvcih2YXIgaT0wO2k8bm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtpKyspe3dhbGsobm9kZS5jaGlsZE5vZGVzW2ldKTt9aWYoL14ocHJlfGRpdnxwKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpKXtjbG9zaW5nPXRydWU7fX1lbHNlIGlmKG5vZGUubm9kZVR5cGU9PTMpe3ZhciB2YWw9bm9kZS5ub2RlVmFsdWU7aWYoIXZhbCl7cmV0dXJuO31pZihjbG9zaW5nKXt0ZXh0Kz1saW5lU2VwO2Nsb3Npbmc9ZmFsc2U7fXRleHQrPXZhbDt9fWZvcig7Oyl7d2Fsayhmcm9tKTtpZihmcm9tPT10byl7YnJlYWs7fWZyb209ZnJvbS5uZXh0U2libGluZzt9cmV0dXJuIHRleHQ7fWZ1bmN0aW9uIGRvbVRvUG9zKGNtLG5vZGUsb2Zmc2V0KXt2YXIgbGluZU5vZGU7aWYobm9kZT09Y20uZGlzcGxheS5saW5lRGl2KXtsaW5lTm9kZT1jbS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tvZmZzZXRdO2lmKCFsaW5lTm9kZSl7cmV0dXJuIGJhZFBvcyhjbS5jbGlwUG9zKFBvcyhjbS5kaXNwbGF5LnZpZXdUby0xKSksdHJ1ZSk7fW5vZGU9bnVsbDtvZmZzZXQ9MDt9ZWxzZXtmb3IobGluZU5vZGU9bm9kZTs7bGluZU5vZGU9bGluZU5vZGUucGFyZW50Tm9kZSl7aWYoIWxpbmVOb2RlfHxsaW5lTm9kZT09Y20uZGlzcGxheS5saW5lRGl2KXtyZXR1cm4gbnVsbDt9aWYobGluZU5vZGUucGFyZW50Tm9kZSYmbGluZU5vZGUucGFyZW50Tm9kZT09Y20uZGlzcGxheS5saW5lRGl2KXticmVhazt9fX1mb3IodmFyIGk9MDtpPGNtLmRpc3BsYXkudmlldy5sZW5ndGg7aSsrKXt2YXIgbGluZVZpZXc9Y20uZGlzcGxheS52aWV3W2ldO2lmKGxpbmVWaWV3Lm5vZGU9PWxpbmVOb2RlKXtyZXR1cm4gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsbm9kZSxvZmZzZXQpO319fWZ1bmN0aW9uIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LG5vZGUsb2Zmc2V0KXt2YXIgd3JhcHBlcj1saW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQsYmFkPWZhbHNlO2lmKCFub2RlfHwhY29udGFpbnMod3JhcHBlcixub2RlKSl7cmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmVWaWV3LmxpbmUpLDApLHRydWUpO31pZihub2RlPT13cmFwcGVyKXtiYWQ9dHJ1ZTtub2RlPXdyYXBwZXIuY2hpbGROb2Rlc1tvZmZzZXRdO29mZnNldD0wO2lmKCFub2RlKXt2YXIgbGluZT1saW5lVmlldy5yZXN0P2xzdChsaW5lVmlldy5yZXN0KTpsaW5lVmlldy5saW5lO3JldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lKSxsaW5lLnRleHQubGVuZ3RoKSxiYWQpO319dmFyIHRleHROb2RlPW5vZGUubm9kZVR5cGU9PTM/bm9kZTpudWxsLHRvcE5vZGU9bm9kZTtpZighdGV4dE5vZGUmJm5vZGUuY2hpbGROb2Rlcy5sZW5ndGg9PTEmJm5vZGUuZmlyc3RDaGlsZC5ub2RlVHlwZT09Myl7dGV4dE5vZGU9bm9kZS5maXJzdENoaWxkO2lmKG9mZnNldCl7b2Zmc2V0PXRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7fX13aGlsZSh0b3BOb2RlLnBhcmVudE5vZGUhPXdyYXBwZXIpe3RvcE5vZGU9dG9wTm9kZS5wYXJlbnROb2RlO312YXIgbWVhc3VyZT1saW5lVmlldy5tZWFzdXJlLG1hcHM9bWVhc3VyZS5tYXBzO2Z1bmN0aW9uIGZpbmQodGV4dE5vZGUsdG9wTm9kZSxvZmZzZXQpe2Zvcih2YXIgaT0tMTtpPChtYXBzP21hcHMubGVuZ3RoOjApO2krKyl7dmFyIG1hcD1pPDA/bWVhc3VyZS5tYXA6bWFwc1tpXTtmb3IodmFyIGo9MDtqPG1hcC5sZW5ndGg7ais9Myl7dmFyIGN1ck5vZGU9bWFwW2orMl07aWYoY3VyTm9kZT09dGV4dE5vZGV8fGN1ck5vZGU9PXRvcE5vZGUpe3ZhciBsaW5lPWxpbmVObyhpPDA/bGluZVZpZXcubGluZTpsaW5lVmlldy5yZXN0W2ldKTt2YXIgY2g9bWFwW2pdK29mZnNldDtpZihvZmZzZXQ8MHx8Y3VyTm9kZSE9dGV4dE5vZGUpe2NoPW1hcFtqKyhvZmZzZXQ/MTowKV07fXJldHVybiBQb3MobGluZSxjaCk7fX19fXZhciBmb3VuZD1maW5kKHRleHROb2RlLHRvcE5vZGUsb2Zmc2V0KTtpZihmb3VuZCl7cmV0dXJuIGJhZFBvcyhmb3VuZCxiYWQpO30vLyBGSVhNRSB0aGlzIGlzIGFsbCByZWFsbHkgc2hha3kuIG1pZ2h0IGhhbmRsZSB0aGUgZmV3IGNhc2VzIGl0IG5lZWRzIHRvIGhhbmRsZSwgYnV0IGxpa2VseSB0byBjYXVzZSBwcm9ibGVtc1xuZm9yKHZhciBhZnRlcj10b3BOb2RlLm5leHRTaWJsaW5nLGRpc3Q9dGV4dE5vZGU/dGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aC1vZmZzZXQ6MDthZnRlcjthZnRlcj1hZnRlci5uZXh0U2libGluZyl7Zm91bmQ9ZmluZChhZnRlcixhZnRlci5maXJzdENoaWxkLDApO2lmKGZvdW5kKXtyZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLGZvdW5kLmNoLWRpc3QpLGJhZCk7fWVsc2V7ZGlzdCs9YWZ0ZXIudGV4dENvbnRlbnQubGVuZ3RoO319Zm9yKHZhciBiZWZvcmU9dG9wTm9kZS5wcmV2aW91c1NpYmxpbmcsZGlzdCQxPW9mZnNldDtiZWZvcmU7YmVmb3JlPWJlZm9yZS5wcmV2aW91c1NpYmxpbmcpe2ZvdW5kPWZpbmQoYmVmb3JlLGJlZm9yZS5maXJzdENoaWxkLC0xKTtpZihmb3VuZCl7cmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSxmb3VuZC5jaCtkaXN0JDEpLGJhZCk7fWVsc2V7ZGlzdCQxKz1iZWZvcmUudGV4dENvbnRlbnQubGVuZ3RoO319fS8vIFRFWFRBUkVBIElOUFVUIFNUWUxFXG5mdW5jdGlvbiBUZXh0YXJlYUlucHV0KGNtKXt0aGlzLmNtPWNtOy8vIFNlZSBpbnB1dC5wb2xsIGFuZCBpbnB1dC5yZXNldFxudGhpcy5wcmV2SW5wdXQ9XCJcIjsvLyBGbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgd2UgZXhwZWN0IGlucHV0IHRvIGFwcGVhciByZWFsIHNvb25cbi8vIG5vdyAoYWZ0ZXIgc29tZSBldmVudCBsaWtlICdrZXlwcmVzcycgb3IgJ2lucHV0JykgYW5kIGFyZVxuLy8gcG9sbGluZyBpbnRlbnNpdmVseS5cbnRoaXMucG9sbGluZ0Zhc3Q9ZmFsc2U7Ly8gU2VsZi1yZXNldHRpbmcgdGltZW91dCBmb3IgdGhlIHBvbGxlclxudGhpcy5wb2xsaW5nPW5ldyBEZWxheWVkKCk7Ly8gVHJhY2tzIHdoZW4gaW5wdXQucmVzZXQgaGFzIHB1bnRlZCB0byBqdXN0IHB1dHRpbmcgYSBzaG9ydFxuLy8gc3RyaW5nIGludG8gdGhlIHRleHRhcmVhIGluc3RlYWQgb2YgdGhlIGZ1bGwgc2VsZWN0aW9uLlxudGhpcy5pbmFjY3VyYXRlU2VsZWN0aW9uPWZhbHNlOy8vIFVzZWQgdG8gd29yayBhcm91bmQgSUUgaXNzdWUgd2l0aCBzZWxlY3Rpb24gYmVpbmcgZm9yZ290dGVuIHdoZW4gZm9jdXMgbW92ZXMgYXdheSBmcm9tIHRleHRhcmVhXG50aGlzLmhhc1NlbGVjdGlvbj1mYWxzZTt0aGlzLmNvbXBvc2luZz1udWxsO31UZXh0YXJlYUlucHV0LnByb3RvdHlwZT1jb3B5T2JqKHtpbml0OmZ1bmN0aW9uKGRpc3BsYXkpe3ZhciB0aGlzJDE9dGhpczt2YXIgaW5wdXQ9dGhpcyxjbT10aGlzLmNtOy8vIFdyYXBzIGFuZCBoaWRlcyBpbnB1dCB0ZXh0YXJlYVxudmFyIGRpdj10aGlzLndyYXBwZXI9aGlkZGVuVGV4dGFyZWEoKTsvLyBUaGUgc2VtaWhpZGRlbiB0ZXh0YXJlYSB0aGF0IGlzIGZvY3VzZWQgd2hlbiB0aGUgZWRpdG9yIGlzXG4vLyBmb2N1c2VkLCBhbmQgcmVjZWl2ZXMgaW5wdXQuXG52YXIgdGU9dGhpcy50ZXh0YXJlYT1kaXYuZmlyc3RDaGlsZDtkaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKGRpdixkaXNwbGF5LndyYXBwZXIuZmlyc3RDaGlsZCk7Ly8gTmVlZGVkIHRvIGhpZGUgYmlnIGJsdWUgYmxpbmtpbmcgY3Vyc29yIG9uIE1vYmlsZSBTYWZhcmkgKGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIGlPUyA4IGFueW1vcmUpXG5pZihpb3Mpe3RlLnN0eWxlLndpZHRoPVwiMHB4XCI7fW9uKHRlLFwiaW5wdXRcIixmdW5jdGlvbigpe2lmKGllJiZpZV92ZXJzaW9uPj05JiZ0aGlzJDEuaGFzU2VsZWN0aW9uKXt0aGlzJDEuaGFzU2VsZWN0aW9uPW51bGw7fWlucHV0LnBvbGwoKTt9KTtvbih0ZSxcInBhc3RlXCIsZnVuY3Rpb24oZSl7aWYoc2lnbmFsRE9NRXZlbnQoY20sZSl8fGhhbmRsZVBhc3RlKGUsY20pKXtyZXR1cm47fWNtLnN0YXRlLnBhc3RlSW5jb21pbmc9dHJ1ZTtpbnB1dC5mYXN0UG9sbCgpO30pO2Z1bmN0aW9uIHByZXBhcmVDb3B5Q3V0KGUpe2lmKHNpZ25hbERPTUV2ZW50KGNtLGUpKXtyZXR1cm47fWlmKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpe3NldExhc3RDb3BpZWQoe2xpbmVXaXNlOmZhbHNlLHRleHQ6Y20uZ2V0U2VsZWN0aW9ucygpfSk7aWYoaW5wdXQuaW5hY2N1cmF0ZVNlbGVjdGlvbil7aW5wdXQucHJldklucHV0PVwiXCI7aW5wdXQuaW5hY2N1cmF0ZVNlbGVjdGlvbj1mYWxzZTt0ZS52YWx1ZT1sYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKTtzZWxlY3RJbnB1dCh0ZSk7fX1lbHNlIGlmKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCl7cmV0dXJuO31lbHNle3ZhciByYW5nZXM9Y29weWFibGVSYW5nZXMoY20pO3NldExhc3RDb3BpZWQoe2xpbmVXaXNlOnRydWUsdGV4dDpyYW5nZXMudGV4dH0pO2lmKGUudHlwZT09XCJjdXRcIil7Y20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLG51bGwsc2VsX2RvbnRTY3JvbGwpO31lbHNle2lucHV0LnByZXZJbnB1dD1cIlwiO3RlLnZhbHVlPXJhbmdlcy50ZXh0LmpvaW4oXCJcXG5cIik7c2VsZWN0SW5wdXQodGUpO319aWYoZS50eXBlPT1cImN1dFwiKXtjbS5zdGF0ZS5jdXRJbmNvbWluZz10cnVlO319b24odGUsXCJjdXRcIixwcmVwYXJlQ29weUN1dCk7b24odGUsXCJjb3B5XCIscHJlcGFyZUNvcHlDdXQpO29uKGRpc3BsYXkuc2Nyb2xsZXIsXCJwYXN0ZVwiLGZ1bmN0aW9uKGUpe2lmKGV2ZW50SW5XaWRnZXQoZGlzcGxheSxlKXx8c2lnbmFsRE9NRXZlbnQoY20sZSkpe3JldHVybjt9Y20uc3RhdGUucGFzdGVJbmNvbWluZz10cnVlO2lucHV0LmZvY3VzKCk7fSk7Ly8gUHJldmVudCBub3JtYWwgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgKHdlIGhhbmRsZSBvdXIgb3duKVxub24oZGlzcGxheS5saW5lU3BhY2UsXCJzZWxlY3RzdGFydFwiLGZ1bmN0aW9uKGUpe2lmKCFldmVudEluV2lkZ2V0KGRpc3BsYXksZSkpe2VfcHJldmVudERlZmF1bHQoZSk7fX0pO29uKHRlLFwiY29tcG9zaXRpb25zdGFydFwiLGZ1bmN0aW9uKCl7dmFyIHN0YXJ0PWNtLmdldEN1cnNvcihcImZyb21cIik7aWYoaW5wdXQuY29tcG9zaW5nKXtpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTt9aW5wdXQuY29tcG9zaW5nPXtzdGFydDpzdGFydCxyYW5nZTpjbS5tYXJrVGV4dChzdGFydCxjbS5nZXRDdXJzb3IoXCJ0b1wiKSx7Y2xhc3NOYW1lOlwiQ29kZU1pcnJvci1jb21wb3NpbmdcIn0pfTt9KTtvbih0ZSxcImNvbXBvc2l0aW9uZW5kXCIsZnVuY3Rpb24oKXtpZihpbnB1dC5jb21wb3Npbmcpe2lucHV0LnBvbGwoKTtpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtpbnB1dC5jb21wb3Npbmc9bnVsbDt9fSk7fSxwcmVwYXJlU2VsZWN0aW9uOmZ1bmN0aW9uKCl7Ly8gUmVkcmF3IHRoZSBzZWxlY3Rpb24gYW5kL29yIGN1cnNvclxudmFyIGNtPXRoaXMuY20sZGlzcGxheT1jbS5kaXNwbGF5LGRvYz1jbS5kb2M7dmFyIHJlc3VsdD1wcmVwYXJlU2VsZWN0aW9uKGNtKTsvLyBNb3ZlIHRoZSBoaWRkZW4gdGV4dGFyZWEgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgc2Nyb2xsaW5nIGFydGlmYWN0c1xuaWYoY20ub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKXt2YXIgaGVhZFBvcz1jdXJzb3JDb29yZHMoY20sZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCxcImRpdlwiKTt2YXIgd3JhcE9mZj1kaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbGluZU9mZj1kaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmVzdWx0LnRlVG9wPU1hdGgubWF4KDAsTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodC0xMCxoZWFkUG9zLnRvcCtsaW5lT2ZmLnRvcC13cmFwT2ZmLnRvcCkpO3Jlc3VsdC50ZUxlZnQ9TWF0aC5tYXgoMCxNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGgtMTAsaGVhZFBvcy5sZWZ0K2xpbmVPZmYubGVmdC13cmFwT2ZmLmxlZnQpKTt9cmV0dXJuIHJlc3VsdDt9LHNob3dTZWxlY3Rpb246ZnVuY3Rpb24oZHJhd24pe3ZhciBjbT10aGlzLmNtLGRpc3BsYXk9Y20uZGlzcGxheTtyZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LmN1cnNvckRpdixkcmF3bi5jdXJzb3JzKTtyZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LnNlbGVjdGlvbkRpdixkcmF3bi5zZWxlY3Rpb24pO2lmKGRyYXduLnRlVG9wIT1udWxsKXt0aGlzLndyYXBwZXIuc3R5bGUudG9wPWRyYXduLnRlVG9wK1wicHhcIjt0aGlzLndyYXBwZXIuc3R5bGUubGVmdD1kcmF3bi50ZUxlZnQrXCJweFwiO319LC8vIFJlc2V0IHRoZSBpbnB1dCB0byBjb3JyZXNwb25kIHRvIHRoZSBzZWxlY3Rpb24gKG9yIHRvIGJlIGVtcHR5LFxuLy8gd2hlbiBub3QgdHlwaW5nIGFuZCBub3RoaW5nIGlzIHNlbGVjdGVkKVxucmVzZXQ6ZnVuY3Rpb24odHlwaW5nKXtpZih0aGlzLmNvbnRleHRNZW51UGVuZGluZyl7cmV0dXJuO312YXIgbWluaW1hbCxzZWxlY3RlZCxjbT10aGlzLmNtLGRvYz1jbS5kb2M7aWYoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSl7dGhpcy5wcmV2SW5wdXQ9XCJcIjt2YXIgcmFuZ2U9ZG9jLnNlbC5wcmltYXJ5KCk7bWluaW1hbD1oYXNDb3B5RXZlbnQmJihyYW5nZS50bygpLmxpbmUtcmFuZ2UuZnJvbSgpLmxpbmU+MTAwfHwoc2VsZWN0ZWQ9Y20uZ2V0U2VsZWN0aW9uKCkpLmxlbmd0aD4xMDAwKTt2YXIgY29udGVudD1taW5pbWFsP1wiLVwiOnNlbGVjdGVkfHxjbS5nZXRTZWxlY3Rpb24oKTt0aGlzLnRleHRhcmVhLnZhbHVlPWNvbnRlbnQ7aWYoY20uc3RhdGUuZm9jdXNlZCl7c2VsZWN0SW5wdXQodGhpcy50ZXh0YXJlYSk7fWlmKGllJiZpZV92ZXJzaW9uPj05KXt0aGlzLmhhc1NlbGVjdGlvbj1jb250ZW50O319ZWxzZSBpZighdHlwaW5nKXt0aGlzLnByZXZJbnB1dD10aGlzLnRleHRhcmVhLnZhbHVlPVwiXCI7aWYoaWUmJmllX3ZlcnNpb24+PTkpe3RoaXMuaGFzU2VsZWN0aW9uPW51bGw7fX10aGlzLmluYWNjdXJhdGVTZWxlY3Rpb249bWluaW1hbDt9LGdldEZpZWxkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dGFyZWE7fSxzdXBwb3J0c1RvdWNoOmZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlO30sZm9jdXM6ZnVuY3Rpb24oKXtpZih0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkhPVwibm9jdXJzb3JcIiYmKCFtb2JpbGV8fGFjdGl2ZUVsdCgpIT10aGlzLnRleHRhcmVhKSl7dHJ5e3RoaXMudGV4dGFyZWEuZm9jdXMoKTt9Y2F0Y2goZSl7fS8vIElFOCB3aWxsIHRocm93IGlmIHRoZSB0ZXh0YXJlYSBpcyBkaXNwbGF5OiBub25lIG9yIG5vdCBpbiBET01cbn19LGJsdXI6ZnVuY3Rpb24oKXt0aGlzLnRleHRhcmVhLmJsdXIoKTt9LHJlc2V0UG9zaXRpb246ZnVuY3Rpb24oKXt0aGlzLndyYXBwZXIuc3R5bGUudG9wPXRoaXMud3JhcHBlci5zdHlsZS5sZWZ0PTA7fSxyZWNlaXZlZEZvY3VzOmZ1bmN0aW9uKCl7dGhpcy5zbG93UG9sbCgpO30sLy8gUG9sbCBmb3IgaW5wdXQgY2hhbmdlcywgdXNpbmcgdGhlIG5vcm1hbCByYXRlIG9mIHBvbGxpbmcuIFRoaXNcbi8vIHJ1bnMgYXMgbG9uZyBhcyB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXG5zbG93UG9sbDpmdW5jdGlvbigpe3ZhciB0aGlzJDE9dGhpcztpZih0aGlzLnBvbGxpbmdGYXN0KXtyZXR1cm47fXRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCxmdW5jdGlvbigpe3RoaXMkMS5wb2xsKCk7aWYodGhpcyQxLmNtLnN0YXRlLmZvY3VzZWQpe3RoaXMkMS5zbG93UG9sbCgpO319KTt9LC8vIFdoZW4gYW4gZXZlbnQgaGFzIGp1c3QgY29tZSBpbiB0aGF0IGlzIGxpa2VseSB0byBhZGQgb3IgY2hhbmdlXG4vLyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHRhcmVhLCB3ZSBwb2xsIGZhc3RlciwgdG8gZW5zdXJlIHRoYXRcbi8vIHRoZSBjaGFuZ2UgYXBwZWFycyBvbiB0aGUgc2NyZWVuIHF1aWNrbHkuXG5mYXN0UG9sbDpmdW5jdGlvbigpe3ZhciBtaXNzZWQ9ZmFsc2UsaW5wdXQ9dGhpcztpbnB1dC5wb2xsaW5nRmFzdD10cnVlO2Z1bmN0aW9uIHAoKXt2YXIgY2hhbmdlZD1pbnB1dC5wb2xsKCk7aWYoIWNoYW5nZWQmJiFtaXNzZWQpe21pc3NlZD10cnVlO2lucHV0LnBvbGxpbmcuc2V0KDYwLHApO31lbHNle2lucHV0LnBvbGxpbmdGYXN0PWZhbHNlO2lucHV0LnNsb3dQb2xsKCk7fX1pbnB1dC5wb2xsaW5nLnNldCgyMCxwKTt9LC8vIFJlYWQgaW5wdXQgZnJvbSB0aGUgdGV4dGFyZWEsIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHRvIG1hdGNoLlxuLy8gV2hlbiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsIGl0IGlzIHByZXNlbnQgaW4gdGhlIHRleHRhcmVhLCBhbmRcbi8vIHNlbGVjdGVkICh1bmxlc3MgaXQgaXMgaHVnZSwgaW4gd2hpY2ggY2FzZSBhIHBsYWNlaG9sZGVyIGlzXG4vLyB1c2VkKS4gV2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLCB0aGUgY3Vyc29yIHNpdHMgYWZ0ZXIgcHJldmlvdXNseVxuLy8gc2VlbiB0ZXh0IChjYW4gYmUgZW1wdHkpLCB3aGljaCBpcyBzdG9yZWQgaW4gcHJldklucHV0ICh3ZSBtdXN0XG4vLyBub3QgcmVzZXQgdGhlIHRleHRhcmVhIHdoZW4gdHlwaW5nLCBiZWNhdXNlIHRoYXQgYnJlYWtzIElNRSkuXG5wb2xsOmZ1bmN0aW9uKCl7dmFyIHRoaXMkMT10aGlzO3ZhciBjbT10aGlzLmNtLGlucHV0PXRoaXMudGV4dGFyZWEscHJldklucHV0PXRoaXMucHJldklucHV0Oy8vIFNpbmNlIHRoaXMgaXMgY2FsbGVkIGEgKmxvdCosIHRyeSB0byBiYWlsIG91dCBhcyBjaGVhcGx5IGFzXG4vLyBwb3NzaWJsZSB3aGVuIGl0IGlzIGNsZWFyIHRoYXQgbm90aGluZyBoYXBwZW5lZC4gaGFzU2VsZWN0aW9uXG4vLyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBsb3Qgb2YgdGV4dCBpbiB0aGUgdGV4dGFyZWEsXG4vLyBpbiB3aGljaCBjYXNlIHJlYWRpbmcgaXRzIHZhbHVlIHdvdWxkIGJlIGV4cGVuc2l2ZS5cbmlmKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nfHwhY20uc3RhdGUuZm9jdXNlZHx8aGFzU2VsZWN0aW9uKGlucHV0KSYmIXByZXZJbnB1dCYmIXRoaXMuY29tcG9zaW5nfHxjbS5pc1JlYWRPbmx5KCl8fGNtLm9wdGlvbnMuZGlzYWJsZUlucHV0fHxjbS5zdGF0ZS5rZXlTZXEpe3JldHVybiBmYWxzZTt9dmFyIHRleHQ9aW5wdXQudmFsdWU7Ly8gSWYgbm90aGluZyBjaGFuZ2VkLCBiYWlsLlxuaWYodGV4dD09cHJldklucHV0JiYhY20uc29tZXRoaW5nU2VsZWN0ZWQoKSl7cmV0dXJuIGZhbHNlO30vLyBXb3JrIGFyb3VuZCBub25zZW5zaWNhbCBzZWxlY3Rpb24gcmVzZXR0aW5nIGluIElFOS8xMCwgYW5kXG4vLyBpbmV4cGxpY2FibGUgYXBwZWFyYW5jZSBvZiBwcml2YXRlIGFyZWEgdW5pY29kZSBjaGFyYWN0ZXJzIG9uXG4vLyBzb21lIGtleSBjb21ib3MgaW4gTWFjICgjMjY4OSkuXG5pZihpZSYmaWVfdmVyc2lvbj49OSYmdGhpcy5oYXNTZWxlY3Rpb249PT10ZXh0fHxtYWMmJi9bXFx1ZjcwMC1cXHVmN2ZmXS8udGVzdCh0ZXh0KSl7Y20uZGlzcGxheS5pbnB1dC5yZXNldCgpO3JldHVybiBmYWxzZTt9aWYoY20uZG9jLnNlbD09Y20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSl7dmFyIGZpcnN0PXRleHQuY2hhckNvZGVBdCgwKTtpZihmaXJzdD09MHgyMDBiJiYhcHJldklucHV0KXtwcmV2SW5wdXQ9XCJcXHUyMDBiXCI7fWlmKGZpcnN0PT0weDIxZGEpe3RoaXMucmVzZXQoKTtyZXR1cm4gdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIik7fX0vLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xudmFyIHNhbWU9MCxsPU1hdGgubWluKHByZXZJbnB1dC5sZW5ndGgsdGV4dC5sZW5ndGgpO3doaWxlKHNhbWU8bCYmcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSk9PXRleHQuY2hhckNvZGVBdChzYW1lKSl7KytzYW1lO31ydW5Jbk9wKGNtLGZ1bmN0aW9uKCl7YXBwbHlUZXh0SW5wdXQoY20sdGV4dC5zbGljZShzYW1lKSxwcmV2SW5wdXQubGVuZ3RoLXNhbWUsbnVsbCx0aGlzJDEuY29tcG9zaW5nP1wiKmNvbXBvc2VcIjpudWxsKTsvLyBEb24ndCBsZWF2ZSBsb25nIHRleHQgaW4gdGhlIHRleHRhcmVhLCBzaW5jZSBpdCBtYWtlcyBmdXJ0aGVyIHBvbGxpbmcgc2xvd1xuaWYodGV4dC5sZW5ndGg+MTAwMHx8dGV4dC5pbmRleE9mKFwiXFxuXCIpPi0xKXtpbnB1dC52YWx1ZT10aGlzJDEucHJldklucHV0PVwiXCI7fWVsc2V7dGhpcyQxLnByZXZJbnB1dD10ZXh0O31pZih0aGlzJDEuY29tcG9zaW5nKXt0aGlzJDEuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7dGhpcyQxLmNvbXBvc2luZy5yYW5nZT1jbS5tYXJrVGV4dCh0aGlzJDEuY29tcG9zaW5nLnN0YXJ0LGNtLmdldEN1cnNvcihcInRvXCIpLHtjbGFzc05hbWU6XCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSk7fX0pO3JldHVybiB0cnVlO30sZW5zdXJlUG9sbGVkOmZ1bmN0aW9uKCl7aWYodGhpcy5wb2xsaW5nRmFzdCYmdGhpcy5wb2xsKCkpe3RoaXMucG9sbGluZ0Zhc3Q9ZmFsc2U7fX0sb25LZXlQcmVzczpmdW5jdGlvbigpe2lmKGllJiZpZV92ZXJzaW9uPj05KXt0aGlzLmhhc1NlbGVjdGlvbj1udWxsO310aGlzLmZhc3RQb2xsKCk7fSxvbkNvbnRleHRNZW51OmZ1bmN0aW9uKGUpe3ZhciBpbnB1dD10aGlzLGNtPWlucHV0LmNtLGRpc3BsYXk9Y20uZGlzcGxheSx0ZT1pbnB1dC50ZXh0YXJlYTt2YXIgcG9zPXBvc0Zyb21Nb3VzZShjbSxlKSxzY3JvbGxQb3M9ZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7aWYoIXBvc3x8cHJlc3RvKXtyZXR1cm47fS8vIE9wZXJhIGlzIGRpZmZpY3VsdC5cbi8vIFJlc2V0IHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIG9ubHkgaWYgdGhlIGNsaWNrIGlzIGRvbmUgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uXG4vLyBhbmQgJ3Jlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudScgb3B0aW9uIGlzIHRydWUuXG52YXIgcmVzZXQ9Y20ub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnU7aWYocmVzZXQmJmNtLmRvYy5zZWwuY29udGFpbnMocG9zKT09LTEpe29wZXJhdGlvbihjbSxzZXRTZWxlY3Rpb24pKGNtLmRvYyxzaW1wbGVTZWxlY3Rpb24ocG9zKSxzZWxfZG9udFNjcm9sbCk7fXZhciBvbGRDU1M9dGUuc3R5bGUuY3NzVGV4dCxvbGRXcmFwcGVyQ1NTPWlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dDtpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjogYWJzb2x1dGVcIjt2YXIgd3JhcHBlckJveD1pbnB1dC53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3RlLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7XFxuICAgICAgdG9wOiBcIisoZS5jbGllbnRZLXdyYXBwZXJCb3gudG9wLTUpK1wicHg7IGxlZnQ6IFwiKyhlLmNsaWVudFgtd3JhcHBlckJveC5sZWZ0LTUpK1wicHg7XFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIrKGllP1wicmdiYSgyNTUsIDI1NSwgMjU1LCAuMDUpXCI6XCJ0cmFuc3BhcmVudFwiKStcIjtcXG4gICAgICBvdXRsaW5lOiBub25lOyBib3JkZXItd2lkdGg6IDA7IG91dGxpbmU6IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IC4wNTsgZmlsdGVyOiBhbHBoYShvcGFjaXR5PTUpO1wiO3ZhciBvbGRTY3JvbGxZO2lmKHdlYmtpdCl7b2xkU2Nyb2xsWT13aW5kb3cuc2Nyb2xsWTt9Ly8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlICgjMjcxMilcbmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtpZih3ZWJraXQpe3dpbmRvdy5zY3JvbGxUbyhudWxsLG9sZFNjcm9sbFkpO31kaXNwbGF5LmlucHV0LnJlc2V0KCk7Ly8gQWRkcyBcIlNlbGVjdCBhbGxcIiB0byBjb250ZXh0IG1lbnUgaW4gRkZcbmlmKCFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKXt0ZS52YWx1ZT1pbnB1dC5wcmV2SW5wdXQ9XCIgXCI7fWlucHV0LmNvbnRleHRNZW51UGVuZGluZz10cnVlO2Rpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnU9Y20uZG9jLnNlbDtjbGVhclRpbWVvdXQoZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwpOy8vIFNlbGVjdC1hbGwgd2lsbCBiZSBncmV5ZWQgb3V0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzZWxlY3QsIHNvXG4vLyB0aGlzIGFkZHMgYSB6ZXJvLXdpZHRoIHNwYWNlIHNvIHRoYXQgd2UgY2FuIGxhdGVyIGNoZWNrIHdoZXRoZXJcbi8vIGl0IGdvdCBzZWxlY3RlZC5cbmZ1bmN0aW9uIHByZXBhcmVTZWxlY3RBbGxIYWNrKCl7aWYodGUuc2VsZWN0aW9uU3RhcnQhPW51bGwpe3ZhciBzZWxlY3RlZD1jbS5zb21ldGhpbmdTZWxlY3RlZCgpO3ZhciBleHR2YWw9XCJcXHUyMDBiXCIrKHNlbGVjdGVkP3RlLnZhbHVlOlwiXCIpO3RlLnZhbHVlPVwiXFx1MjFkYVwiOy8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cbnRlLnZhbHVlPWV4dHZhbDtpbnB1dC5wcmV2SW5wdXQ9c2VsZWN0ZWQ/XCJcIjpcIlxcdTIwMGJcIjt0ZS5zZWxlY3Rpb25TdGFydD0xO3RlLnNlbGVjdGlvbkVuZD1leHR2YWwubGVuZ3RoOy8vIFJlLXNldCB0aGlzLCBpbiBjYXNlIHNvbWUgb3RoZXIgaGFuZGxlciB0b3VjaGVkIHRoZVxuLy8gc2VsZWN0aW9uIGluIHRoZSBtZWFudGltZS5cbmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnU9Y20uZG9jLnNlbDt9fWZ1bmN0aW9uIHJlaGlkZSgpe2lucHV0LmNvbnRleHRNZW51UGVuZGluZz1mYWxzZTtpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQ9b2xkV3JhcHBlckNTUzt0ZS5zdHlsZS5jc3NUZXh0PW9sZENTUztpZihpZSYmaWVfdmVyc2lvbjw5KXtkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wPXNjcm9sbFBvcyk7fS8vIFRyeSB0byBkZXRlY3QgdGhlIHVzZXIgY2hvb3Npbmcgc2VsZWN0LWFsbFxuaWYodGUuc2VsZWN0aW9uU3RhcnQhPW51bGwpe2lmKCFpZXx8aWUmJmllX3ZlcnNpb248OSl7cHJlcGFyZVNlbGVjdEFsbEhhY2soKTt9dmFyIGk9MCxwb2xsPWZ1bmN0aW9uKCl7aWYoZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudT09Y20uZG9jLnNlbCYmdGUuc2VsZWN0aW9uU3RhcnQ9PTAmJnRlLnNlbGVjdGlvbkVuZD4wJiZpbnB1dC5wcmV2SW5wdXQ9PVwiXFx1MjAwYlwiKXtvcGVyYXRpb24oY20sc2VsZWN0QWxsKShjbSk7fWVsc2UgaWYoaSsrPDEwKXtkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbD1zZXRUaW1lb3V0KHBvbGwsNTAwKTt9ZWxzZXtkaXNwbGF5LmlucHV0LnJlc2V0KCk7fX07ZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGw9c2V0VGltZW91dChwb2xsLDIwMCk7fX1pZihpZSYmaWVfdmVyc2lvbj49OSl7cHJlcGFyZVNlbGVjdEFsbEhhY2soKTt9aWYoY2FwdHVyZVJpZ2h0Q2xpY2spe2Vfc3RvcChlKTt2YXIgbW91c2V1cD1mdW5jdGlvbigpe29mZih3aW5kb3csXCJtb3VzZXVwXCIsbW91c2V1cCk7c2V0VGltZW91dChyZWhpZGUsMjApO307b24od2luZG93LFwibW91c2V1cFwiLG1vdXNldXApO31lbHNle3NldFRpbWVvdXQocmVoaWRlLDUwKTt9fSxyZWFkT25seUNoYW5nZWQ6ZnVuY3Rpb24odmFsKXtpZighdmFsKXt0aGlzLnJlc2V0KCk7fX0sc2V0VW5lZGl0YWJsZTpub3RoaW5nLG5lZWRzQ29udGVudEF0dHJpYnV0ZTpmYWxzZX0sVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUpO2Z1bmN0aW9uIGZyb21UZXh0QXJlYSh0ZXh0YXJlYSxvcHRpb25zKXtvcHRpb25zPW9wdGlvbnM/Y29weU9iaihvcHRpb25zKTp7fTtvcHRpb25zLnZhbHVlPXRleHRhcmVhLnZhbHVlO2lmKCFvcHRpb25zLnRhYmluZGV4JiZ0ZXh0YXJlYS50YWJJbmRleCl7b3B0aW9ucy50YWJpbmRleD10ZXh0YXJlYS50YWJJbmRleDt9aWYoIW9wdGlvbnMucGxhY2Vob2xkZXImJnRleHRhcmVhLnBsYWNlaG9sZGVyKXtvcHRpb25zLnBsYWNlaG9sZGVyPXRleHRhcmVhLnBsYWNlaG9sZGVyO30vLyBTZXQgYXV0b2ZvY3VzIHRvIHRydWUgaWYgdGhpcyB0ZXh0YXJlYSBpcyBmb2N1c2VkLCBvciBpZiBpdCBoYXNcbi8vIGF1dG9mb2N1cyBhbmQgbm8gb3RoZXIgZWxlbWVudCBpcyBmb2N1c2VkLlxuaWYob3B0aW9ucy5hdXRvZm9jdXM9PW51bGwpe3ZhciBoYXNGb2N1cz1hY3RpdmVFbHQoKTtvcHRpb25zLmF1dG9mb2N1cz1oYXNGb2N1cz09dGV4dGFyZWF8fHRleHRhcmVhLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSE9bnVsbCYmaGFzRm9jdXM9PWRvY3VtZW50LmJvZHk7fWZ1bmN0aW9uIHNhdmUoKXt0ZXh0YXJlYS52YWx1ZT1jbS5nZXRWYWx1ZSgpO312YXIgcmVhbFN1Ym1pdDtpZih0ZXh0YXJlYS5mb3JtKXtvbih0ZXh0YXJlYS5mb3JtLFwic3VibWl0XCIsc2F2ZSk7Ly8gRGVwbG9yYWJsZSBoYWNrIHRvIG1ha2UgdGhlIHN1Ym1pdCBtZXRob2QgZG8gdGhlIHJpZ2h0IHRoaW5nLlxuaWYoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSl7dmFyIGZvcm09dGV4dGFyZWEuZm9ybTtyZWFsU3VibWl0PWZvcm0uc3VibWl0O3RyeXt2YXIgd3JhcHBlZFN1Ym1pdD1mb3JtLnN1Ym1pdD1mdW5jdGlvbigpe3NhdmUoKTtmb3JtLnN1Ym1pdD1yZWFsU3VibWl0O2Zvcm0uc3VibWl0KCk7Zm9ybS5zdWJtaXQ9d3JhcHBlZFN1Ym1pdDt9O31jYXRjaChlKXt9fX1vcHRpb25zLmZpbmlzaEluaXQ9ZnVuY3Rpb24oY20pe2NtLnNhdmU9c2F2ZTtjbS5nZXRUZXh0QXJlYT1mdW5jdGlvbigpe3JldHVybiB0ZXh0YXJlYTt9O2NtLnRvVGV4dEFyZWE9ZnVuY3Rpb24oKXtjbS50b1RleHRBcmVhPWlzTmFOOy8vIFByZXZlbnQgdGhpcyBmcm9tIGJlaW5nIHJhbiB0d2ljZVxuc2F2ZSgpO3RleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY20uZ2V0V3JhcHBlckVsZW1lbnQoKSk7dGV4dGFyZWEuc3R5bGUuZGlzcGxheT1cIlwiO2lmKHRleHRhcmVhLmZvcm0pe29mZih0ZXh0YXJlYS5mb3JtLFwic3VibWl0XCIsc2F2ZSk7aWYodHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0PT1cImZ1bmN0aW9uXCIpe3RleHRhcmVhLmZvcm0uc3VibWl0PXJlYWxTdWJtaXQ7fX19O307dGV4dGFyZWEuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjt2YXIgY209Q29kZU1pcnJvcihmdW5jdGlvbihub2RlKXtyZXR1cm4gdGV4dGFyZWEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSx0ZXh0YXJlYS5uZXh0U2libGluZyk7fSxvcHRpb25zKTtyZXR1cm4gY207fWZ1bmN0aW9uIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3Ipe0NvZGVNaXJyb3Iub2ZmPW9mZjtDb2RlTWlycm9yLm9uPW9uO0NvZGVNaXJyb3Iud2hlZWxFdmVudFBpeGVscz13aGVlbEV2ZW50UGl4ZWxzO0NvZGVNaXJyb3IuRG9jPURvYztDb2RlTWlycm9yLnNwbGl0TGluZXM9c3BsaXRMaW5lc0F1dG87Q29kZU1pcnJvci5jb3VudENvbHVtbj1jb3VudENvbHVtbjtDb2RlTWlycm9yLmZpbmRDb2x1bW49ZmluZENvbHVtbjtDb2RlTWlycm9yLmlzV29yZENoYXI9aXNXb3JkQ2hhckJhc2ljO0NvZGVNaXJyb3IuUGFzcz1QYXNzO0NvZGVNaXJyb3Iuc2lnbmFsPXNpZ25hbDtDb2RlTWlycm9yLkxpbmU9TGluZTtDb2RlTWlycm9yLmNoYW5nZUVuZD1jaGFuZ2VFbmQ7Q29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbD1zY3JvbGxiYXJNb2RlbDtDb2RlTWlycm9yLlBvcz1Qb3M7Q29kZU1pcnJvci5jbXBQb3M9Y21wO0NvZGVNaXJyb3IubW9kZXM9bW9kZXM7Q29kZU1pcnJvci5taW1lTW9kZXM9bWltZU1vZGVzO0NvZGVNaXJyb3IucmVzb2x2ZU1vZGU9cmVzb2x2ZU1vZGU7Q29kZU1pcnJvci5nZXRNb2RlPWdldE1vZGU7Q29kZU1pcnJvci5tb2RlRXh0ZW5zaW9ucz1tb2RlRXh0ZW5zaW9ucztDb2RlTWlycm9yLmV4dGVuZE1vZGU9ZXh0ZW5kTW9kZTtDb2RlTWlycm9yLmNvcHlTdGF0ZT1jb3B5U3RhdGU7Q29kZU1pcnJvci5zdGFydFN0YXRlPXN0YXJ0U3RhdGU7Q29kZU1pcnJvci5pbm5lck1vZGU9aW5uZXJNb2RlO0NvZGVNaXJyb3IuY29tbWFuZHM9Y29tbWFuZHM7Q29kZU1pcnJvci5rZXlNYXA9a2V5TWFwO0NvZGVNaXJyb3Iua2V5TmFtZT1rZXlOYW1lO0NvZGVNaXJyb3IuaXNNb2RpZmllcktleT1pc01vZGlmaWVyS2V5O0NvZGVNaXJyb3IubG9va3VwS2V5PWxvb2t1cEtleTtDb2RlTWlycm9yLm5vcm1hbGl6ZUtleU1hcD1ub3JtYWxpemVLZXlNYXA7Q29kZU1pcnJvci5TdHJpbmdTdHJlYW09U3RyaW5nU3RyZWFtO0NvZGVNaXJyb3IuU2hhcmVkVGV4dE1hcmtlcj1TaGFyZWRUZXh0TWFya2VyO0NvZGVNaXJyb3IuVGV4dE1hcmtlcj1UZXh0TWFya2VyO0NvZGVNaXJyb3IuTGluZVdpZGdldD1MaW5lV2lkZ2V0O0NvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdD1lX3ByZXZlbnREZWZhdWx0O0NvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb249ZV9zdG9wUHJvcGFnYXRpb247Q29kZU1pcnJvci5lX3N0b3A9ZV9zdG9wO0NvZGVNaXJyb3IuYWRkQ2xhc3M9YWRkQ2xhc3M7Q29kZU1pcnJvci5jb250YWlucz1jb250YWlucztDb2RlTWlycm9yLnJtQ2xhc3M9cm1DbGFzcztDb2RlTWlycm9yLmtleU5hbWVzPWtleU5hbWVzO30vLyBFRElUT1IgQ09OU1RSVUNUT1JcbmRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcik7YWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKTsvLyBTZXQgdXAgbWV0aG9kcyBvbiBDb2RlTWlycm9yJ3MgcHJvdG90eXBlIHRvIHJlZGlyZWN0IHRvIHRoZSBlZGl0b3IncyBkb2N1bWVudC5cbnZhciBkb250RGVsZWdhdGU9XCJpdGVyIGluc2VydCByZW1vdmUgY29weSBnZXRFZGl0b3IgY29uc3RydWN0b3JcIi5zcGxpdChcIiBcIik7Zm9yKHZhciBwcm9wIGluIERvYy5wcm90b3R5cGUpe2lmKERvYy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkmJmluZGV4T2YoZG9udERlbGVnYXRlLHByb3ApPDApe0NvZGVNaXJyb3IucHJvdG90eXBlW3Byb3BdPWZ1bmN0aW9uKG1ldGhvZCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLmRvYyxhcmd1bWVudHMpO307fShEb2MucHJvdG90eXBlW3Byb3BdKTt9fWV2ZW50TWl4aW4oRG9jKTsvLyBJTlBVVCBIQU5ETElOR1xuQ29kZU1pcnJvci5pbnB1dFN0eWxlcz17XCJ0ZXh0YXJlYVwiOlRleHRhcmVhSW5wdXQsXCJjb250ZW50ZWRpdGFibGVcIjpDb250ZW50RWRpdGFibGVJbnB1dH07Ly8gTU9ERSBERUZJTklUSU9OIEFORCBRVUVSWUlOR1xuLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4vLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XG4vLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbkNvZGVNaXJyb3IuZGVmaW5lTW9kZT1mdW5jdGlvbihuYW1lLyosIG1vZGUsIOKApiovKXtpZighQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlJiZuYW1lIT1cIm51bGxcIil7Q29kZU1pcnJvci5kZWZhdWx0cy5tb2RlPW5hbWU7fWRlZmluZU1vZGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO307Q29kZU1pcnJvci5kZWZpbmVNSU1FPWRlZmluZU1JTUU7Ly8gTWluaW1hbCBkZWZhdWx0IG1vZGUuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJudWxsXCIsZnVuY3Rpb24oKXtyZXR1cm57dG9rZW46ZnVuY3Rpb24oc3RyZWFtKXtyZXR1cm4gc3RyZWFtLnNraXBUb0VuZCgpO319O30pO0NvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvcGxhaW5cIixcIm51bGxcIik7Ly8gRVhURU5TSU9OU1xuQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb249ZnVuY3Rpb24obmFtZSxmdW5jKXtDb2RlTWlycm9yLnByb3RvdHlwZVtuYW1lXT1mdW5jO307Q29kZU1pcnJvci5kZWZpbmVEb2NFeHRlbnNpb249ZnVuY3Rpb24obmFtZSxmdW5jKXtEb2MucHJvdG90eXBlW25hbWVdPWZ1bmM7fTtDb2RlTWlycm9yLmZyb21UZXh0QXJlYT1mcm9tVGV4dEFyZWE7YWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcik7Q29kZU1pcnJvci52ZXJzaW9uPVwiNS4yMC4yXCI7cmV0dXJuIENvZGVNaXJyb3I7fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMiAyMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9');
},56:function(module,exports,__webpack_require__){eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function (mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(55), __webpack_require__(57), __webpack_require__(54), __webpack_require__(58));else if (typeof define == "function" && define.amd) // AMD\n    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  "use strict";\n\n  var defaultTags = {\n    script: [["lang", /(javascript|babel)/i, "javascript"], ["type", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i, "javascript"], ["type", /./, "text/plain"], [null, null, "javascript"]],\n    style: [["lang", /^css$/i, "css"], ["type", /^(text\\/)?(x-)?(stylesheet|css)$/i, "css"], ["type", /./, "text/plain"], [null, null, "css"]]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(),\n        close = cur.search(pat);\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n\n  var attrRegexpCache = {};\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp("\\\\s+" + attr + "\\\\s*=\\\\s*(\'|\\")?([^\'\\"]+)(\'|\\")?\\\\s*");\n  }\n\n  function getAttrValue(text, attr) {\n    var match = text.match(getAttrRegexp(attr));\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : "";\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? "^" : "") + "<\\/\\s*" + tagName + "\\s*>", "i");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n      for (var i = source.length - 1; i >= 0; i--) dest.unshift(source[i]);\n    }\n  }\n\n  function findMatchingMode(tagInfo, tagText) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: "xml",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag\n    });\n\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags,\n        configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--) tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);\n\n    function html(stream, state) {\n      var style = htmlMode.token(stream, state.htmlState),\n          tag = /\\btag\\b/.test(style),\n          tagName;\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {\n        state.inTag = tagName + " ";\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag);\n        state.inTag = null;\n        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);\n        var mode = CodeMirror.getMode(config, modeSpec);\n        var endTagA = getTagRegexp(inTag[1], true),\n            endTag = getTagRegexp(inTag[1], false);\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""));\n      } else if (state.inTag) {\n        state.inTag += stream.current();\n        if (stream.eol()) state.inTag += " ";\n      }\n      return style;\n    };\n\n    return {\n      startState: function () {\n        var state = CodeMirror.startState(htmlMode);\n        return { token: html, inTag: null, localMode: null, localState: null, htmlState: state };\n      },\n\n      copyState: function (state) {\n        var local;\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n        return { token: state.token, inTag: state.inTag,\n          localMode: state.localMode, localState: local,\n          htmlState: CodeMirror.copyState(htmlMode, state.htmlState) };\n      },\n\n      token: function (stream, state) {\n        return state.token(stream, state);\n      },\n\n      indent: function (state, textAfter) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter)) return htmlMode.indent(state.htmlState, textAfter);else if (state.localMode.indent) return state.localMode.indent(state.localState, textAfter);else return CodeMirror.Pass;\n      },\n\n      innerMode: function (state) {\n        return { state: state.localState || state.htmlState, mode: state.localMode || htmlMode };\n      }\n    };\n  }, "xml", "javascript", "css");\n\n  CodeMirror.defineMIME("text/html", "htmlmixed");\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvZGVtaXJyb3IvbW9kZS9odG1sbWl4ZWQvaHRtbG1peGVkLmpzPzQyZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24gKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL3htbC94bWxcIiksIHJlcXVpcmUoXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIiksIHJlcXVpcmUoXCIuLi9jc3MvY3NzXCIpKTtlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi94bWwveG1sXCIsIFwiLi4vamF2YXNjcmlwdC9qYXZhc2NyaXB0XCIsIFwiLi4vY3NzL2Nzc1wiXSwgbW9kKTtlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24gKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGRlZmF1bHRUYWdzID0ge1xuICAgIHNjcmlwdDogW1tcImxhbmdcIiwgLyhqYXZhc2NyaXB0fGJhYmVsKS9pLCBcImphdmFzY3JpcHRcIl0sIFtcInR5cGVcIiwgL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcLyg/OngtKT8oPzpqYXZhfGVjbWEpc2NyaXB0JHxeJC9pLCBcImphdmFzY3JpcHRcIl0sIFtcInR5cGVcIiwgLy4vLCBcInRleHQvcGxhaW5cIl0sIFtudWxsLCBudWxsLCBcImphdmFzY3JpcHRcIl1dLFxuICAgIHN0eWxlOiBbW1wibGFuZ1wiLCAvXmNzcyQvaSwgXCJjc3NcIl0sIFtcInR5cGVcIiwgL14odGV4dFxcLyk/KHgtKT8oc3R5bGVzaGVldHxjc3MpJC9pLCBcImNzc1wiXSwgW1widHlwZVwiLCAvLi8sIFwidGV4dC9wbGFpblwiXSwgW251bGwsIG51bGwsIFwiY3NzXCJdXVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlQmFja3VwKHN0cmVhbSwgcGF0LCBzdHlsZSkge1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpLFxuICAgICAgICBjbG9zZSA9IGN1ci5zZWFyY2gocGF0KTtcbiAgICBpZiAoY2xvc2UgPiAtMSkge1xuICAgICAgc3RyZWFtLmJhY2tVcChjdXIubGVuZ3RoIC0gY2xvc2UpO1xuICAgIH0gZWxzZSBpZiAoY3VyLm1hdGNoKC88XFwvPyQvKSkge1xuICAgICAgc3RyZWFtLmJhY2tVcChjdXIubGVuZ3RoKTtcbiAgICAgIGlmICghc3RyZWFtLm1hdGNoKHBhdCwgZmFsc2UpKSBzdHJlYW0ubWF0Y2goY3VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgdmFyIGF0dHJSZWdleHBDYWNoZSA9IHt9O1xuICBmdW5jdGlvbiBnZXRBdHRyUmVnZXhwKGF0dHIpIHtcbiAgICB2YXIgcmVnZXhwID0gYXR0clJlZ2V4cENhY2hlW2F0dHJdO1xuICAgIGlmIChyZWdleHApIHJldHVybiByZWdleHA7XG4gICAgcmV0dXJuIGF0dHJSZWdleHBDYWNoZVthdHRyXSA9IG5ldyBSZWdFeHAoXCJcXFxccytcIiArIGF0dHIgKyBcIlxcXFxzKj1cXFxccyooJ3xcXFwiKT8oW14nXFxcIl0rKSgnfFxcXCIpP1xcXFxzKlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF0dHJWYWx1ZSh0ZXh0LCBhdHRyKSB7XG4gICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaChnZXRBdHRyUmVnZXhwKGF0dHIpKTtcbiAgICByZXR1cm4gbWF0Y2ggPyAvXlxccyooLio/KVxccyokLy5leGVjKG1hdGNoWzJdKVsxXSA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYWdSZWdleHAodGFnTmFtZSwgYW5jaG9yZWQpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgoYW5jaG9yZWQgPyBcIl5cIiA6IFwiXCIpICsgXCI8XFwvXFxzKlwiICsgdGFnTmFtZSArIFwiXFxzKj5cIiwgXCJpXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVGFncyhmcm9tLCB0bykge1xuICAgIGZvciAodmFyIHRhZyBpbiBmcm9tKSB7XG4gICAgICB2YXIgZGVzdCA9IHRvW3RhZ10gfHwgKHRvW3RhZ10gPSBbXSk7XG4gICAgICB2YXIgc291cmNlID0gZnJvbVt0YWddO1xuICAgICAgZm9yICh2YXIgaSA9IHNvdXJjZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgZGVzdC51bnNoaWZ0KHNvdXJjZVtpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZE1hdGNoaW5nTW9kZSh0YWdJbmZvLCB0YWdUZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3BlYyA9IHRhZ0luZm9baV07XG4gICAgICBpZiAoIXNwZWNbMF0gfHwgc3BlY1sxXS50ZXN0KGdldEF0dHJWYWx1ZSh0YWdUZXh0LCBzcGVjWzBdKSkpIHJldHVybiBzcGVjWzJdO1xuICAgIH1cbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImh0bWxtaXhlZFwiLCBmdW5jdGlvbiAoY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgICB2YXIgaHRtbE1vZGUgPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCB7XG4gICAgICBuYW1lOiBcInhtbFwiLFxuICAgICAgaHRtbE1vZGU6IHRydWUsXG4gICAgICBtdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3I6IHBhcnNlckNvbmZpZy5tdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3IsXG4gICAgICBtdWx0aWxpbmVUYWdJbmRlbnRQYXN0VGFnOiBwYXJzZXJDb25maWcubXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZ1xuICAgIH0pO1xuXG4gICAgdmFyIHRhZ3MgPSB7fTtcbiAgICB2YXIgY29uZmlnVGFncyA9IHBhcnNlckNvbmZpZyAmJiBwYXJzZXJDb25maWcudGFncyxcbiAgICAgICAgY29uZmlnU2NyaXB0ID0gcGFyc2VyQ29uZmlnICYmIHBhcnNlckNvbmZpZy5zY3JpcHRUeXBlcztcbiAgICBhZGRUYWdzKGRlZmF1bHRUYWdzLCB0YWdzKTtcbiAgICBpZiAoY29uZmlnVGFncykgYWRkVGFncyhjb25maWdUYWdzLCB0YWdzKTtcbiAgICBpZiAoY29uZmlnU2NyaXB0KSBmb3IgKHZhciBpID0gY29uZmlnU2NyaXB0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB0YWdzLnNjcmlwdC51bnNoaWZ0KFtcInR5cGVcIiwgY29uZmlnU2NyaXB0W2ldLm1hdGNoZXMsIGNvbmZpZ1NjcmlwdFtpXS5tb2RlXSk7XG5cbiAgICBmdW5jdGlvbiBodG1sKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGh0bWxNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuaHRtbFN0YXRlKSxcbiAgICAgICAgICB0YWcgPSAvXFxidGFnXFxiLy50ZXN0KHN0eWxlKSxcbiAgICAgICAgICB0YWdOYW1lO1xuICAgICAgaWYgKHRhZyAmJiAhL1s8Plxcc1xcL10vLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkgJiYgKHRhZ05hbWUgPSBzdGF0ZS5odG1sU3RhdGUudGFnTmFtZSAmJiBzdGF0ZS5odG1sU3RhdGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiB0YWdzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgIHN0YXRlLmluVGFnID0gdGFnTmFtZSArIFwiIFwiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5pblRhZyAmJiB0YWcgJiYgLz4kLy50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgIHZhciBpblRhZyA9IC9eKFtcXFNdKykgKC4qKS8uZXhlYyhzdGF0ZS5pblRhZyk7XG4gICAgICAgIHN0YXRlLmluVGFnID0gbnVsbDtcbiAgICAgICAgdmFyIG1vZGVTcGVjID0gc3RyZWFtLmN1cnJlbnQoKSA9PSBcIj5cIiAmJiBmaW5kTWF0Y2hpbmdNb2RlKHRhZ3NbaW5UYWdbMV1dLCBpblRhZ1syXSk7XG4gICAgICAgIHZhciBtb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgbW9kZVNwZWMpO1xuICAgICAgICB2YXIgZW5kVGFnQSA9IGdldFRhZ1JlZ2V4cChpblRhZ1sxXSwgdHJ1ZSksXG4gICAgICAgICAgICBlbmRUYWcgPSBnZXRUYWdSZWdleHAoaW5UYWdbMV0sIGZhbHNlKTtcbiAgICAgICAgc3RhdGUudG9rZW4gPSBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZW5kVGFnQSwgZmFsc2UpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbiA9IGh0bWw7XG4gICAgICAgICAgICBzdGF0ZS5sb2NhbFN0YXRlID0gc3RhdGUubG9jYWxNb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF5YmVCYWNrdXAoc3RyZWFtLCBlbmRUYWcsIHN0YXRlLmxvY2FsTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmxvY2FsU3RhdGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUubG9jYWxNb2RlID0gbW9kZTtcbiAgICAgICAgc3RhdGUubG9jYWxTdGF0ZSA9IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShtb2RlLCBodG1sTW9kZS5pbmRlbnQoc3RhdGUuaHRtbFN0YXRlLCBcIlwiKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmluVGFnKSB7XG4gICAgICAgIHN0YXRlLmluVGFnICs9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHN0YXRlLmluVGFnICs9IFwiIFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoaHRtbE1vZGUpO1xuICAgICAgICByZXR1cm4geyB0b2tlbjogaHRtbCwgaW5UYWc6IG51bGwsIGxvY2FsTW9kZTogbnVsbCwgbG9jYWxTdGF0ZTogbnVsbCwgaHRtbFN0YXRlOiBzdGF0ZSB9O1xuICAgICAgfSxcblxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGxvY2FsO1xuICAgICAgICBpZiAoc3RhdGUubG9jYWxTdGF0ZSkge1xuICAgICAgICAgIGxvY2FsID0gQ29kZU1pcnJvci5jb3B5U3RhdGUoc3RhdGUubG9jYWxNb2RlLCBzdGF0ZS5sb2NhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0b2tlbjogc3RhdGUudG9rZW4sIGluVGFnOiBzdGF0ZS5pblRhZyxcbiAgICAgICAgICBsb2NhbE1vZGU6IHN0YXRlLmxvY2FsTW9kZSwgbG9jYWxTdGF0ZTogbG9jYWwsXG4gICAgICAgICAgaHRtbFN0YXRlOiBDb2RlTWlycm9yLmNvcHlTdGF0ZShodG1sTW9kZSwgc3RhdGUuaHRtbFN0YXRlKSB9O1xuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24gKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5sb2NhbE1vZGUgfHwgL15cXHMqPFxcLy8udGVzdCh0ZXh0QWZ0ZXIpKSByZXR1cm4gaHRtbE1vZGUuaW5kZW50KHN0YXRlLmh0bWxTdGF0ZSwgdGV4dEFmdGVyKTtlbHNlIGlmIChzdGF0ZS5sb2NhbE1vZGUuaW5kZW50KSByZXR1cm4gc3RhdGUubG9jYWxNb2RlLmluZGVudChzdGF0ZS5sb2NhbFN0YXRlLCB0ZXh0QWZ0ZXIpO2Vsc2UgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIH0sXG5cbiAgICAgIGlubmVyTW9kZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBzdGF0ZS5sb2NhbFN0YXRlIHx8IHN0YXRlLmh0bWxTdGF0ZSwgbW9kZTogc3RhdGUubG9jYWxNb2RlIHx8IGh0bWxNb2RlIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSwgXCJ4bWxcIiwgXCJqYXZhc2NyaXB0XCIsIFwiY3NzXCIpO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvaHRtbFwiLCBcImh0bWxtaXhlZFwiKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb2RlbWlycm9yL21vZGUvaHRtbG1peGVkL2h0bWxtaXhlZC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==')},57:function(module,exports,__webpack_require__){eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function (mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(55));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var htmlConfig = {\n    autoSelfClosers: { 'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n      'track': true, 'wbr': true, 'menuitem': true },\n    implicitlyClosed: { 'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n      'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n      'th': true, 'tr': true },\n    contextGrabbers: {\n      'dd': { 'dd': true, 'dt': true },\n      'dt': { 'dd': true, 'dt': true },\n      'li': { 'li': true },\n      'option': { 'option': true, 'optgroup': true },\n      'optgroup': { 'optgroup': true },\n      'p': { 'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n        'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n        'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n        'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n        'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true },\n      'rp': { 'rp': true, 'rt': true },\n      'rt': { 'rp': true, 'rt': true },\n      'tbody': { 'tbody': true, 'tfoot': true },\n      'td': { 'td': true, 'th': true },\n      'tfoot': { 'tbody': true },\n      'th': { 'td': true, 'th': true },\n      'thead': { 'tbody': true, 'tfoot': true },\n      'tr': { 'tr': true }\n    },\n    doNotIndent: { \"pre\": true },\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  };\n\n  var xmlConfig = {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    caseFold: false\n  };\n\n  CodeMirror.defineMode(\"xml\", function (editorConf, config_) {\n    var indentUnit = editorConf.indentUnit;\n    var config = {};\n    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;\n    for (var prop in defaults) config[prop] = defaults[prop];\n    for (var prop in config_) config[prop] = config_[prop];\n\n    // Return variables for tokenizers\n    var type, setStyle;\n\n    function inText(stream, state) {\n      function chain(parser) {\n        state.tokenize = parser;\n        return parser(stream, state);\n      }\n\n      var ch = stream.next();\n      if (ch == \"<\") {\n        if (stream.eat(\"!\")) {\n          if (stream.eat(\"[\")) {\n            if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));else return null;\n          } else if (stream.match(\"--\")) {\n            return chain(inBlock(\"comment\", \"-->\"));\n          } else if (stream.match(\"DOCTYPE\", true, true)) {\n            stream.eatWhile(/[\\w\\._\\-]/);\n            return chain(doctype(1));\n          } else {\n            return null;\n          }\n        } else if (stream.eat(\"?\")) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          state.tokenize = inBlock(\"meta\", \"?>\");\n          return \"meta\";\n        } else {\n          type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n          state.tokenize = inTag;\n          return \"tag bracket\";\n        }\n      } else if (ch == \"&\") {\n        var ok;\n        if (stream.eat(\"#\")) {\n          if (stream.eat(\"x\")) {\n            ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n          } else {\n            ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n          }\n        } else {\n          ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n        }\n        return ok ? \"atom\" : \"error\";\n      } else {\n        stream.eatWhile(/[^&<]/);\n        return null;\n      }\n    }\n    inText.isInText = true;\n\n    function inTag(stream, state) {\n      var ch = stream.next();\n      if (ch == \">\" || ch == \"/\" && stream.eat(\">\")) {\n        state.tokenize = inText;\n        type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n        return \"tag bracket\";\n      } else if (ch == \"=\") {\n        type = \"equals\";\n        return null;\n      } else if (ch == \"<\") {\n        state.tokenize = inText;\n        state.state = baseState;\n        state.tagName = state.tagStart = null;\n        var next = state.tokenize(stream, state);\n        return next ? next + \" tag error\" : \"tag error\";\n      } else if (/[\\'\\\"]/.test(ch)) {\n        state.tokenize = inAttribute(ch);\n        state.stringStartCol = stream.column();\n        return state.tokenize(stream, state);\n      } else {\n        stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n        return \"word\";\n      }\n    }\n\n    function inAttribute(quote) {\n      var closure = function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.next() == quote) {\n            state.tokenize = inTag;\n            break;\n          }\n        }\n        return \"string\";\n      };\n      closure.isInAttribute = true;\n      return closure;\n    }\n\n    function inBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = inText;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      };\n    }\n    function doctype(depth) {\n      return function (stream, state) {\n        var ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == \"<\") {\n            state.tokenize = doctype(depth + 1);\n            return state.tokenize(stream, state);\n          } else if (ch == \">\") {\n            if (depth == 1) {\n              state.tokenize = inText;\n              break;\n            } else {\n              state.tokenize = doctype(depth - 1);\n              return state.tokenize(stream, state);\n            }\n          }\n        }\n        return \"meta\";\n      };\n    }\n\n    function Context(state, tagName, startOfLine) {\n      this.prev = state.context;\n      this.tagName = tagName;\n      this.indent = state.indented;\n      this.startOfLine = startOfLine;\n      if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;\n    }\n    function popContext(state) {\n      if (state.context) state.context = state.context.prev;\n    }\n    function maybePopContext(state, nextTagName) {\n      var parentTagName;\n      while (true) {\n        if (!state.context) {\n          return;\n        }\n        parentTagName = state.context.tagName;\n        if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n          return;\n        }\n        popContext(state);\n      }\n    }\n\n    function baseState(type, stream, state) {\n      if (type == \"openTag\") {\n        state.tagStart = stream.column();\n        return tagNameState;\n      } else if (type == \"closeTag\") {\n        return closeTagNameState;\n      } else {\n        return baseState;\n      }\n    }\n    function tagNameState(type, stream, state) {\n      if (type == \"word\") {\n        state.tagName = stream.current();\n        setStyle = \"tag\";\n        return attrState;\n      } else {\n        setStyle = \"error\";\n        return tagNameState;\n      }\n    }\n    function closeTagNameState(type, stream, state) {\n      if (type == \"word\") {\n        var tagName = stream.current();\n        if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);\n        if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n          setStyle = \"tag\";\n          return closeState;\n        } else {\n          setStyle = \"tag error\";\n          return closeStateErr;\n        }\n      } else {\n        setStyle = \"error\";\n        return closeStateErr;\n      }\n    }\n\n    function closeState(type, _stream, state) {\n      if (type != \"endTag\") {\n        setStyle = \"error\";\n        return closeState;\n      }\n      popContext(state);\n      return baseState;\n    }\n    function closeStateErr(type, stream, state) {\n      setStyle = \"error\";\n      return closeState(type, stream, state);\n    }\n\n    function attrState(type, _stream, state) {\n      if (type == \"word\") {\n        setStyle = \"attribute\";\n        return attrEqState;\n      } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n        var tagName = state.tagName,\n            tagStart = state.tagStart;\n        state.tagName = state.tagStart = null;\n        if (type == \"selfcloseTag\" || config.autoSelfClosers.hasOwnProperty(tagName)) {\n          maybePopContext(state, tagName);\n        } else {\n          maybePopContext(state, tagName);\n          state.context = new Context(state, tagName, tagStart == state.indented);\n        }\n        return baseState;\n      }\n      setStyle = \"error\";\n      return attrState;\n    }\n    function attrEqState(type, stream, state) {\n      if (type == \"equals\") return attrValueState;\n      if (!config.allowMissing) setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrValueState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      if (type == \"word\" && config.allowUnquoted) {\n        setStyle = \"string\";return attrState;\n      }\n      setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n    function attrContinuedState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      return attrState(type, stream, state);\n    }\n\n    return {\n      startState: function (baseIndent) {\n        var state = { tokenize: inText,\n          state: baseState,\n          indented: baseIndent || 0,\n          tagName: null, tagStart: null,\n          context: null };\n        if (baseIndent != null) state.baseIndent = baseIndent;\n        return state;\n      },\n\n      token: function (stream, state) {\n        if (!state.tagName && stream.sol()) state.indented = stream.indentation();\n\n        if (stream.eatSpace()) return null;\n        type = null;\n        var style = state.tokenize(stream, state);\n        if ((style || type) && style != \"comment\") {\n          setStyle = null;\n          state.state = state.state(type || style, stream, state);\n          if (setStyle) style = setStyle == \"error\" ? style + \" error\" : setStyle;\n        }\n        return style;\n      },\n\n      indent: function (state, textAfter, fullLine) {\n        var context = state.context;\n        // Indent multi-line strings (e.g. css).\n        if (state.tokenize.isInAttribute) {\n          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;\n        }\n        if (context && context.noIndent) return CodeMirror.Pass;\n        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n        // Indent the starts of attribute names.\n        if (state.tagName) {\n          if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n        }\n        if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n        var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n        if (tagAfter && tagAfter[1]) {\n          // Closing tag spotted\n          while (context) {\n            if (context.tagName == tagAfter[2]) {\n              context = context.prev;\n              break;\n            } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n              context = context.prev;\n            } else {\n              break;\n            }\n          }\n        } else if (tagAfter) {\n          // Opening tag spotted\n          while (context) {\n            var grabbers = config.contextGrabbers[context.tagName];\n            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;\n          }\n        }\n        while (context && context.prev && !context.startOfLine) context = context.prev;\n        if (context) return context.indent + indentUnit;else return state.baseIndent || 0;\n      },\n\n      electricInput: /<\\/[\\s\\w:]+>$/,\n      blockCommentStart: \"<!--\",\n      blockCommentEnd: \"-->\",\n\n      configuration: config.htmlMode ? \"html\" : \"xml\",\n      helperType: config.htmlMode ? \"html\" : \"xml\",\n\n      skipAttribute: function (state) {\n        if (state.state == attrValueState) state.state = attrState;\n      }\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/xml\", \"xml\");\n  CodeMirror.defineMIME(\"application/xml\", \"xml\");\n  if (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\")) CodeMirror.defineMIME(\"text/html\", { name: \"xml\", htmlMode: true });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24gKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO2Vsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbiAoQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaHRtbENvbmZpZyA9IHtcbiAgICBhdXRvU2VsZkNsb3NlcnM6IHsgJ2FyZWEnOiB0cnVlLCAnYmFzZSc6IHRydWUsICdicic6IHRydWUsICdjb2wnOiB0cnVlLCAnY29tbWFuZCc6IHRydWUsXG4gICAgICAnZW1iZWQnOiB0cnVlLCAnZnJhbWUnOiB0cnVlLCAnaHInOiB0cnVlLCAnaW1nJzogdHJ1ZSwgJ2lucHV0JzogdHJ1ZSxcbiAgICAgICdrZXlnZW4nOiB0cnVlLCAnbGluayc6IHRydWUsICdtZXRhJzogdHJ1ZSwgJ3BhcmFtJzogdHJ1ZSwgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndHJhY2snOiB0cnVlLCAnd2JyJzogdHJ1ZSwgJ21lbnVpdGVtJzogdHJ1ZSB9LFxuICAgIGltcGxpY2l0bHlDbG9zZWQ6IHsgJ2RkJzogdHJ1ZSwgJ2xpJzogdHJ1ZSwgJ29wdGdyb3VwJzogdHJ1ZSwgJ29wdGlvbic6IHRydWUsICdwJzogdHJ1ZSxcbiAgICAgICdycCc6IHRydWUsICdydCc6IHRydWUsICd0Ym9keSc6IHRydWUsICd0ZCc6IHRydWUsICd0Zm9vdCc6IHRydWUsXG4gICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlIH0sXG4gICAgY29udGV4dEdyYWJiZXJzOiB7XG4gICAgICAnZGQnOiB7ICdkZCc6IHRydWUsICdkdCc6IHRydWUgfSxcbiAgICAgICdkdCc6IHsgJ2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZSB9LFxuICAgICAgJ2xpJzogeyAnbGknOiB0cnVlIH0sXG4gICAgICAnb3B0aW9uJzogeyAnb3B0aW9uJzogdHJ1ZSwgJ29wdGdyb3VwJzogdHJ1ZSB9LFxuICAgICAgJ29wdGdyb3VwJzogeyAnb3B0Z3JvdXAnOiB0cnVlIH0sXG4gICAgICAncCc6IHsgJ2FkZHJlc3MnOiB0cnVlLCAnYXJ0aWNsZSc6IHRydWUsICdhc2lkZSc6IHRydWUsICdibG9ja3F1b3RlJzogdHJ1ZSwgJ2Rpcic6IHRydWUsXG4gICAgICAgICdkaXYnOiB0cnVlLCAnZGwnOiB0cnVlLCAnZmllbGRzZXQnOiB0cnVlLCAnZm9vdGVyJzogdHJ1ZSwgJ2Zvcm0nOiB0cnVlLFxuICAgICAgICAnaDEnOiB0cnVlLCAnaDInOiB0cnVlLCAnaDMnOiB0cnVlLCAnaDQnOiB0cnVlLCAnaDUnOiB0cnVlLCAnaDYnOiB0cnVlLFxuICAgICAgICAnaGVhZGVyJzogdHJ1ZSwgJ2hncm91cCc6IHRydWUsICdocic6IHRydWUsICdtZW51JzogdHJ1ZSwgJ25hdic6IHRydWUsICdvbCc6IHRydWUsXG4gICAgICAgICdwJzogdHJ1ZSwgJ3ByZSc6IHRydWUsICdzZWN0aW9uJzogdHJ1ZSwgJ3RhYmxlJzogdHJ1ZSwgJ3VsJzogdHJ1ZSB9LFxuICAgICAgJ3JwJzogeyAncnAnOiB0cnVlLCAncnQnOiB0cnVlIH0sXG4gICAgICAncnQnOiB7ICdycCc6IHRydWUsICdydCc6IHRydWUgfSxcbiAgICAgICd0Ym9keSc6IHsgJ3Rib2R5JzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZSB9LFxuICAgICAgJ3RkJzogeyAndGQnOiB0cnVlLCAndGgnOiB0cnVlIH0sXG4gICAgICAndGZvb3QnOiB7ICd0Ym9keSc6IHRydWUgfSxcbiAgICAgICd0aCc6IHsgJ3RkJzogdHJ1ZSwgJ3RoJzogdHJ1ZSB9LFxuICAgICAgJ3RoZWFkJzogeyAndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlIH0sXG4gICAgICAndHInOiB7ICd0cic6IHRydWUgfVxuICAgIH0sXG4gICAgZG9Ob3RJbmRlbnQ6IHsgXCJwcmVcIjogdHJ1ZSB9LFxuICAgIGFsbG93VW5xdW90ZWQ6IHRydWUsXG4gICAgYWxsb3dNaXNzaW5nOiB0cnVlLFxuICAgIGNhc2VGb2xkOiB0cnVlXG4gIH07XG5cbiAgdmFyIHhtbENvbmZpZyA9IHtcbiAgICBhdXRvU2VsZkNsb3NlcnM6IHt9LFxuICAgIGltcGxpY2l0bHlDbG9zZWQ6IHt9LFxuICAgIGNvbnRleHRHcmFiYmVyczoge30sXG4gICAgZG9Ob3RJbmRlbnQ6IHt9LFxuICAgIGFsbG93VW5xdW90ZWQ6IGZhbHNlLFxuICAgIGFsbG93TWlzc2luZzogZmFsc2UsXG4gICAgY2FzZUZvbGQ6IGZhbHNlXG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwieG1sXCIsIGZ1bmN0aW9uIChlZGl0b3JDb25mLCBjb25maWdfKSB7XG4gICAgdmFyIGluZGVudFVuaXQgPSBlZGl0b3JDb25mLmluZGVudFVuaXQ7XG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgIHZhciBkZWZhdWx0cyA9IGNvbmZpZ18uaHRtbE1vZGUgPyBodG1sQ29uZmlnIDogeG1sQ29uZmlnO1xuICAgIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdHMpIGNvbmZpZ1twcm9wXSA9IGRlZmF1bHRzW3Byb3BdO1xuICAgIGZvciAodmFyIHByb3AgaW4gY29uZmlnXykgY29uZmlnW3Byb3BdID0gY29uZmlnX1twcm9wXTtcblxuICAgIC8vIFJldHVybiB2YXJpYWJsZXMgZm9yIHRva2VuaXplcnNcbiAgICB2YXIgdHlwZSwgc2V0U3R5bGU7XG5cbiAgICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgZnVuY3Rpb24gY2hhaW4ocGFyc2VyKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gcGFyc2VyO1xuICAgICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiIVwiKSkge1xuICAgICAgICAgIGlmIChzdHJlYW0uZWF0KFwiW1wiKSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIkNEQVRBW1wiKSkgcmV0dXJuIGNoYWluKGluQmxvY2soXCJhdG9tXCIsIFwiXV0+XCIpKTtlbHNlIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiLS1cIikpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiY29tbWVudFwiLCBcIi0tPlwiKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCJET0NUWVBFXCIsIHRydWUsIHRydWUpKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluKGRvY3R5cGUoMSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5fXFwtXS8pO1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5CbG9jayhcIm1ldGFcIiwgXCI/PlwiKTtcbiAgICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IHN0cmVhbS5lYXQoXCIvXCIpID8gXCJjbG9zZVRhZ1wiIDogXCJvcGVuVGFnXCI7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcbiAgICAgICAgICByZXR1cm4gXCJ0YWcgYnJhY2tldFwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiJlwiKSB7XG4gICAgICAgIHZhciBvaztcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIjXCIpKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJ4XCIpKSB7XG4gICAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW2EtZkEtRlxcZF0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXGRdLykgJiYgc3RyZWFtLmVhdChcIjtcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9rID0gc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXFwtOl0vKSAmJiBzdHJlYW0uZWF0KFwiO1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2sgPyBcImF0b21cIiA6IFwiZXJyb3JcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14mPF0vKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGluVGV4dC5pc0luVGV4dCA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGNoID09IFwiPlwiIHx8IGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgICB0eXBlID0gY2ggPT0gXCI+XCIgPyBcImVuZFRhZ1wiIDogXCJzZWxmY2xvc2VUYWdcIjtcbiAgICAgICAgcmV0dXJuIFwidGFnIGJyYWNrZXRcIjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICAgICAgdHlwZSA9IFwiZXF1YWxzXCI7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIjxcIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgICAgc3RhdGUuc3RhdGUgPSBiYXNlU3RhdGU7XG4gICAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XG4gICAgICAgIHZhciBuZXh0ID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIHJldHVybiBuZXh0ID8gbmV4dCArIFwiIHRhZyBlcnJvclwiIDogXCJ0YWcgZXJyb3JcIjtcbiAgICAgIH0gZWxzZSBpZiAoL1tcXCdcXFwiXS8udGVzdChjaCkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkF0dHJpYnV0ZShjaCk7XG4gICAgICAgIHN0YXRlLnN0cmluZ1N0YXJ0Q29sID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL15bXlxcc1xcdTAwYTA9PD5cXFwiXFwnXSpbXlxcc1xcdTAwYTA9PD5cXFwiXFwnXFwvXS8pO1xuICAgICAgICByZXR1cm4gXCJ3b3JkXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5BdHRyaWJ1dGUocXVvdGUpIHtcbiAgICAgIHZhciBjbG9zdXJlID0gZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm5leHQoKSA9PSBxdW90ZSkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH07XG4gICAgICBjbG9zdXJlLmlzSW5BdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGNsb3N1cmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5CbG9jayhzdHlsZSwgdGVybWluYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCh0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb2N0eXBlKGRlcHRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChjaCA9PSBcIjxcIikge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBkb2N0eXBlKGRlcHRoICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIj5cIikge1xuICAgICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcbiAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBkb2N0eXBlKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCBzdGFydE9mTGluZSkge1xuICAgICAgdGhpcy5wcmV2ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICB0aGlzLmluZGVudCA9IHN0YXRlLmluZGVudGVkO1xuICAgICAgdGhpcy5zdGFydE9mTGluZSA9IHN0YXJ0T2ZMaW5lO1xuICAgICAgaWYgKGNvbmZpZy5kb05vdEluZGVudC5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSB8fCBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQubm9JbmRlbnQpIHRoaXMubm9JbmRlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuY29udGV4dCkgc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF5YmVQb3BDb250ZXh0KHN0YXRlLCBuZXh0VGFnTmFtZSkge1xuICAgICAgdmFyIHBhcmVudFRhZ05hbWU7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoIXN0YXRlLmNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50VGFnTmFtZSA9IHN0YXRlLmNvbnRleHQudGFnTmFtZTtcbiAgICAgICAgaWYgKCFjb25maWcuY29udGV4dEdyYWJiZXJzLmhhc093blByb3BlcnR5KHBhcmVudFRhZ05hbWUpIHx8ICFjb25maWcuY29udGV4dEdyYWJiZXJzW3BhcmVudFRhZ05hbWVdLmhhc093blByb3BlcnR5KG5leHRUYWdOYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYXNlU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJvcGVuVGFnXCIpIHtcbiAgICAgICAgc3RhdGUudGFnU3RhcnQgPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJjbG9zZVRhZ1wiKSB7XG4gICAgICAgIHJldHVybiBjbG9zZVRhZ05hbWVTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlU3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICBzdGF0ZS50YWdOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgc2V0U3R5bGUgPSBcInRhZ1wiO1xuICAgICAgICByZXR1cm4gYXR0clN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlVGFnTmFtZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50YWdOYW1lICE9IHRhZ05hbWUgJiYgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoc3RhdGUuY29udGV4dC50YWdOYW1lKSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudGFnTmFtZSA9PSB0YWdOYW1lIHx8IGNvbmZpZy5tYXRjaENsb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2V0U3R5bGUgPSBcInRhZ1wiO1xuICAgICAgICAgIHJldHVybiBjbG9zZVN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFN0eWxlID0gXCJ0YWcgZXJyb3JcIjtcbiAgICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZUVycjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlICE9IFwiZW5kVGFnXCIpIHtcbiAgICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlO1xuICAgICAgfVxuICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICByZXR1cm4gYmFzZVN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIGNsb3NlU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0clN0YXRlKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICBzZXRTdHlsZSA9IFwiYXR0cmlidXRlXCI7XG4gICAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImVuZFRhZ1wiIHx8IHR5cGUgPT0gXCJzZWxmY2xvc2VUYWdcIikge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsXG4gICAgICAgICAgICB0YWdTdGFydCA9IHN0YXRlLnRhZ1N0YXJ0O1xuICAgICAgICBzdGF0ZS50YWdOYW1lID0gc3RhdGUudGFnU3RhcnQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZSA9PSBcInNlbGZjbG9zZVRhZ1wiIHx8IGNvbmZpZy5hdXRvU2VsZkNsb3NlcnMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHtcbiAgICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heWJlUG9wQ29udGV4dChzdGF0ZSwgdGFnTmFtZSk7XG4gICAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCB0YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VTdGF0ZTtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIGF0dHJTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckVxU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJlcXVhbHNcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xuICAgICAgaWYgKCFjb25maWcuYWxsb3dNaXNzaW5nKSBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJWYWx1ZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIiAmJiBjb25maWcuYWxsb3dVbnF1b3RlZCkge1xuICAgICAgICBzZXRTdHlsZSA9IFwic3RyaW5nXCI7cmV0dXJuIGF0dHJTdGF0ZTtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ckNvbnRpbnVlZFN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XG4gICAgICByZXR1cm4gYXR0clN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoYmFzZUluZGVudCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB7IHRva2VuaXplOiBpblRleHQsXG4gICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcbiAgICAgICAgICBpbmRlbnRlZDogYmFzZUluZGVudCB8fCAwLFxuICAgICAgICAgIHRhZ05hbWU6IG51bGwsIHRhZ1N0YXJ0OiBudWxsLFxuICAgICAgICAgIGNvbnRleHQ6IG51bGwgfTtcbiAgICAgICAgaWYgKGJhc2VJbmRlbnQgIT0gbnVsbCkgc3RhdGUuYmFzZUluZGVudCA9IGJhc2VJbmRlbnQ7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0YXRlLnRhZ05hbWUgJiYgc3RyZWFtLnNvbCgpKSBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuXG4gICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKChzdHlsZSB8fCB0eXBlKSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuICAgICAgICAgIHNldFN0eWxlID0gbnVsbDtcbiAgICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLnN0YXRlKHR5cGUgfHwgc3R5bGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgIGlmIChzZXRTdHlsZSkgc3R5bGUgPSBzZXRTdHlsZSA9PSBcImVycm9yXCIgPyBzdHlsZSArIFwiIGVycm9yXCIgOiBzZXRTdHlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LFxuXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSwgdGV4dEFmdGVyLCBmdWxsTGluZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAgIC8vIEluZGVudCBtdWx0aS1saW5lIHN0cmluZ3MgKGUuZy4gY3NzKS5cbiAgICAgICAgaWYgKHN0YXRlLnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUudGFnU3RhcnQgPT0gc3RhdGUuaW5kZW50ZWQpIHJldHVybiBzdGF0ZS5zdHJpbmdTdGFydENvbCArIDE7ZWxzZSByZXR1cm4gc3RhdGUuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQubm9JbmRlbnQpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSBpblRhZyAmJiBzdGF0ZS50b2tlbml6ZSAhPSBpblRleHQpIHJldHVybiBmdWxsTGluZSA/IGZ1bGxMaW5lLm1hdGNoKC9eKFxccyopLylbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxuICAgICAgICBpZiAoc3RhdGUudGFnTmFtZSkge1xuICAgICAgICAgIGlmIChjb25maWcubXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZyAhPT0gZmFsc2UpIHJldHVybiBzdGF0ZS50YWdTdGFydCArIHN0YXRlLnRhZ05hbWUubGVuZ3RoICsgMjtlbHNlIHJldHVybiBzdGF0ZS50YWdTdGFydCArIGluZGVudFVuaXQgKiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudEZhY3RvciB8fCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmFsaWduQ0RBVEEgJiYgLzwhXFxbQ0RBVEFcXFsvLnRlc3QodGV4dEFmdGVyKSkgcmV0dXJuIDA7XG4gICAgICAgIHZhciB0YWdBZnRlciA9IHRleHRBZnRlciAmJiAvXjwoXFwvKT8oW1xcd186XFwuLV0qKS8uZXhlYyh0ZXh0QWZ0ZXIpO1xuICAgICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHtcbiAgICAgICAgICAvLyBDbG9zaW5nIHRhZyBzcG90dGVkXG4gICAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnRhZ05hbWUgPT0gdGFnQWZ0ZXJbMl0pIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pbXBsaWNpdGx5Q2xvc2VkLmhhc093blByb3BlcnR5KGNvbnRleHQudGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YWdBZnRlcikge1xuICAgICAgICAgIC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcbiAgICAgICAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGdyYWJiZXJzID0gY29uZmlnLmNvbnRleHRHcmFiYmVyc1tjb250ZXh0LnRhZ05hbWVdO1xuICAgICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSkgY29udGV4dCA9IGNvbnRleHQucHJldjtlbHNlIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29udGV4dCAmJiBjb250ZXh0LnByZXYgJiYgIWNvbnRleHQuc3RhcnRPZkxpbmUpIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgICAgIGlmIChjb250ZXh0KSByZXR1cm4gY29udGV4dC5pbmRlbnQgKyBpbmRlbnRVbml0O2Vsc2UgcmV0dXJuIHN0YXRlLmJhc2VJbmRlbnQgfHwgMDtcbiAgICAgIH0sXG5cbiAgICAgIGVsZWN0cmljSW5wdXQ6IC88XFwvW1xcc1xcdzpdKz4kLyxcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIjwhLS1cIixcbiAgICAgIGJsb2NrQ29tbWVudEVuZDogXCItLT5cIixcblxuICAgICAgY29uZmlndXJhdGlvbjogY29uZmlnLmh0bWxNb2RlID8gXCJodG1sXCIgOiBcInhtbFwiLFxuICAgICAgaGVscGVyVHlwZTogY29uZmlnLmh0bWxNb2RlID8gXCJodG1sXCIgOiBcInhtbFwiLFxuXG4gICAgICBza2lwQXR0cmlidXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXRlID09IGF0dHJWYWx1ZVN0YXRlKSBzdGF0ZS5zdGF0ZSA9IGF0dHJTdGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3htbFwiLCBcInhtbFwiKTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veG1sXCIsIFwieG1sXCIpO1xuICBpZiAoIUNvZGVNaXJyb3IubWltZU1vZGVzLmhhc093blByb3BlcnR5KFwidGV4dC9odG1sXCIpKSBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2h0bWxcIiwgeyBuYW1lOiBcInhtbFwiLCBodG1sTW9kZTogdHJ1ZSB9KTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");
},58:function(module,exports,__webpack_require__){eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function (mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(55));else if (typeof define == "function" && define.amd) // AMD\n    define(["../../lib/codemirror"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  "use strict";\n\n  CodeMirror.defineMode("css", function (config, parserConfig) {\n    var inline = parserConfig.inline;\n    if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");\n\n    var indentUnit = config.indentUnit,\n        tokenHooks = parserConfig.tokenHooks,\n        documentTypes = parserConfig.documentTypes || {},\n        mediaTypes = parserConfig.mediaTypes || {},\n        mediaFeatures = parserConfig.mediaFeatures || {},\n        mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n        propertyKeywords = parserConfig.propertyKeywords || {},\n        nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n        fontProperties = parserConfig.fontProperties || {},\n        counterDescriptors = parserConfig.counterDescriptors || {},\n        colorKeywords = parserConfig.colorKeywords || {},\n        valueKeywords = parserConfig.valueKeywords || {},\n        allowNested = parserConfig.allowNested,\n        supportsAtComponent = parserConfig.supportsAtComponent === true;\n\n    var type, override;\n    function ret(style, tp) {\n      type = tp;return style;\n    }\n\n    // Tokenizers\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n      if (tokenHooks[ch]) {\n        var result = tokenHooks[ch](stream, state);\n        if (result !== false) return result;\n      }\n      if (ch == "@") {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        return ret("def", stream.current());\n      } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {\n        return ret(null, "compare");\n      } else if (ch == "\\"" || ch == "\'") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } else if (ch == "#") {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        return ret("atom", "hash");\n      } else if (ch == "!") {\n        stream.match(/^\\s*\\w*/);\n        return ret("keyword", "important");\n      } else if (/\\d/.test(ch) || ch == "." && stream.eat(/\\d/)) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret("number", "unit");\n      } else if (ch === "-") {\n        if (/[\\d.]/.test(stream.peek())) {\n          stream.eatWhile(/[\\w.%]/);\n          return ret("number", "unit");\n        } else if (stream.match(/^-[\\w\\\\\\-]+/)) {\n          stream.eatWhile(/[\\w\\\\\\-]/);\n          if (stream.match(/^\\s*:/, false)) return ret("variable-2", "variable-definition");\n          return ret("variable-2", "variable");\n        } else if (stream.match(/^\\w+-/)) {\n          return ret("meta", "meta");\n        }\n      } else if (/[,+>*\\/]/.test(ch)) {\n        return ret(null, "select-op");\n      } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n        return ret("qualifier", "qualifier");\n      } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n        return ret(null, ch);\n      } else if (ch == "u" && stream.match(/rl(-prefix)?\\(/) || ch == "d" && stream.match("omain(") || ch == "r" && stream.match("egexp(")) {\n        stream.backUp(1);\n        state.tokenize = tokenParenthesized;\n        return ret("property", "word");\n      } else if (/[\\w\\\\\\-]/.test(ch)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        return ret("property", "word");\n      } else {\n        return ret(null, null);\n      }\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && !escaped) {\n            if (quote == ")") stream.backUp(1);\n            break;\n          }\n          escaped = !escaped && ch == "\\\\";\n        }\n        if (ch == quote || !escaped && quote != ")") state.tokenize = null;\n        return ret("string", "string");\n      };\n    }\n\n    function tokenParenthesized(stream, state) {\n      stream.next(); // Must be \'(\'\n      if (!stream.match(/\\s*[\\"\\\')]/, false)) state.tokenize = tokenString(")");else state.tokenize = null;\n      return ret(null, "(");\n    }\n\n    // Context management\n\n    function Context(type, indent, prev) {\n      this.type = type;\n      this.indent = indent;\n      this.prev = prev;\n    }\n\n    function pushContext(state, stream, type, indent) {\n      state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n      return type;\n    }\n\n    function popContext(state) {\n      if (state.context.prev) state.context = state.context.prev;\n      return state.context.type;\n    }\n\n    function pass(type, stream, state) {\n      return states[state.context.type](type, stream, state);\n    }\n    function popAndPass(type, stream, state, n) {\n      for (var i = n || 1; i > 0; i--) state.context = state.context.prev;\n      return pass(type, stream, state);\n    }\n\n    // Parser\n\n    function wordAsValue(stream) {\n      var word = stream.current().toLowerCase();\n      if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "variable";\n    }\n\n    var states = {};\n\n    states.top = function (type, stream, state) {\n      if (type == "{") {\n        return pushContext(state, stream, "block");\n      } else if (type == "}" && state.context.prev) {\n        return popContext(state);\n      } else if (supportsAtComponent && /@component/.test(type)) {\n        return pushContext(state, stream, "atComponentBlock");\n      } else if (/^@(-moz-)?document$/.test(type)) {\n        return pushContext(state, stream, "documentTypes");\n      } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {\n        return pushContext(state, stream, "atBlock");\n      } else if (/^@(font-face|counter-style)/.test(type)) {\n        state.stateArg = type;\n        return "restricted_atBlock_before";\n      } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {\n        return "keyframes";\n      } else if (type && type.charAt(0) == "@") {\n        return pushContext(state, stream, "at");\n      } else if (type == "hash") {\n        override = "builtin";\n      } else if (type == "word") {\n        override = "tag";\n      } else if (type == "variable-definition") {\n        return "maybeprop";\n      } else if (type == "interpolation") {\n        return pushContext(state, stream, "interpolation");\n      } else if (type == ":") {\n        return "pseudo";\n      } else if (allowNested && type == "(") {\n        return pushContext(state, stream, "parens");\n      }\n      return state.context.type;\n    };\n\n    states.block = function (type, stream, state) {\n      if (type == "word") {\n        var word = stream.current().toLowerCase();\n        if (propertyKeywords.hasOwnProperty(word)) {\n          override = "property";\n          return "maybeprop";\n        } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n          override = "string-2";\n          return "maybeprop";\n        } else if (allowNested) {\n          override = stream.match(/^\\s*:(?:\\s|$)/, false) ? "property" : "tag";\n          return "block";\n        } else {\n          override += " error";\n          return "maybeprop";\n        }\n      } else if (type == "meta") {\n        return "block";\n      } else if (!allowNested && (type == "hash" || type == "qualifier")) {\n        override = "error";\n        return "block";\n      } else {\n        return states.top(type, stream, state);\n      }\n    };\n\n    states.maybeprop = function (type, stream, state) {\n      if (type == ":") return pushContext(state, stream, "prop");\n      return pass(type, stream, state);\n    };\n\n    states.prop = function (type, stream, state) {\n      if (type == ";") return popContext(state);\n      if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");\n      if (type == "}" || type == "{") return popAndPass(type, stream, state);\n      if (type == "(") return pushContext(state, stream, "parens");\n\n      if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {\n        override += " error";\n      } else if (type == "word") {\n        wordAsValue(stream);\n      } else if (type == "interpolation") {\n        return pushContext(state, stream, "interpolation");\n      }\n      return "prop";\n    };\n\n    states.propBlock = function (type, _stream, state) {\n      if (type == "}") return popContext(state);\n      if (type == "word") {\n        override = "property";return "maybeprop";\n      }\n      return state.context.type;\n    };\n\n    states.parens = function (type, stream, state) {\n      if (type == "{" || type == "}") return popAndPass(type, stream, state);\n      if (type == ")") return popContext(state);\n      if (type == "(") return pushContext(state, stream, "parens");\n      if (type == "interpolation") return pushContext(state, stream, "interpolation");\n      if (type == "word") wordAsValue(stream);\n      return "parens";\n    };\n\n    states.pseudo = function (type, stream, state) {\n      if (type == "word") {\n        override = "variable-3";\n        return state.context.type;\n      }\n      return pass(type, stream, state);\n    };\n\n    states.documentTypes = function (type, stream, state) {\n      if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {\n        override = "tag";\n        return state.context.type;\n      } else {\n        return states.atBlock(type, stream, state);\n      }\n    };\n\n    states.atBlock = function (type, stream, state) {\n      if (type == "(") return pushContext(state, stream, "atBlock_parens");\n      if (type == "}" || type == ";") return popAndPass(type, stream, state);\n      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");\n\n      if (type == "interpolation") return pushContext(state, stream, "interpolation");\n\n      if (type == "word") {\n        var word = stream.current().toLowerCase();\n        if (word == "only" || word == "not" || word == "and" || word == "or") override = "keyword";else if (mediaTypes.hasOwnProperty(word)) override = "attribute";else if (mediaFeatures.hasOwnProperty(word)) override = "property";else if (mediaValueKeywords.hasOwnProperty(word)) override = "keyword";else if (propertyKeywords.hasOwnProperty(word)) override = "property";else if (nonStandardPropertyKeywords.hasOwnProperty(word)) override = "string-2";else if (valueKeywords.hasOwnProperty(word)) override = "atom";else if (colorKeywords.hasOwnProperty(word)) override = "keyword";else override = "error";\n      }\n      return state.context.type;\n    };\n\n    states.atComponentBlock = function (type, stream, state) {\n      if (type == "}") return popAndPass(type, stream, state);\n      if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);\n      if (type == "word") override = "error";\n      return state.context.type;\n    };\n\n    states.atBlock_parens = function (type, stream, state) {\n      if (type == ")") return popContext(state);\n      if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);\n      return states.atBlock(type, stream, state);\n    };\n\n    states.restricted_atBlock_before = function (type, stream, state) {\n      if (type == "{") return pushContext(state, stream, "restricted_atBlock");\n      if (type == "word" && state.stateArg == "@counter-style") {\n        override = "variable";\n        return "restricted_atBlock_before";\n      }\n      return pass(type, stream, state);\n    };\n\n    states.restricted_atBlock = function (type, stream, state) {\n      if (type == "}") {\n        state.stateArg = null;\n        return popContext(state);\n      }\n      if (type == "word") {\n        if (state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())) override = "error";else override = "property";\n        return "maybeprop";\n      }\n      return "restricted_atBlock";\n    };\n\n    states.keyframes = function (type, stream, state) {\n      if (type == "word") {\n        override = "variable";return "keyframes";\n      }\n      if (type == "{") return pushContext(state, stream, "top");\n      return pass(type, stream, state);\n    };\n\n    states.at = function (type, stream, state) {\n      if (type == ";") return popContext(state);\n      if (type == "{" || type == "}") return popAndPass(type, stream, state);\n      if (type == "word") override = "tag";else if (type == "hash") override = "builtin";\n      return "at";\n    };\n\n    states.interpolation = function (type, stream, state) {\n      if (type == "}") return popContext(state);\n      if (type == "{" || type == ";") return popAndPass(type, stream, state);\n      if (type == "word") override = "variable";else if (type != "variable" && type != "(" && type != ")") override = "error";\n      return "interpolation";\n    };\n\n    return {\n      startState: function (base) {\n        return { tokenize: null,\n          state: inline ? "block" : "top",\n          stateArg: null,\n          context: new Context(inline ? "block" : "top", base || 0, null) };\n      },\n\n      token: function (stream, state) {\n        if (!state.tokenize && stream.eatSpace()) return null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n        if (style && typeof style == "object") {\n          type = style[1];\n          style = style[0];\n        }\n        override = style;\n        state.state = states[state.state](type, stream, state);\n        return override;\n      },\n\n      indent: function (state, textAfter) {\n        var cx = state.context,\n            ch = textAfter && textAfter.charAt(0);\n        var indent = cx.indent;\n        if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;\n        if (cx.prev) {\n          if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {\n            // Resume indentation from parent context.\n            cx = cx.prev;\n            indent = cx.indent;\n          } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {\n            // Dedent relative to current context.\n            indent = Math.max(0, cx.indent - indentUnit);\n            cx = cx.prev;\n          }\n        }\n        return indent;\n      },\n\n      electricChars: "}",\n      blockCommentStart: "/*",\n      blockCommentEnd: "*/",\n      fold: "brace"\n    };\n  });\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i].toLowerCase()] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = ["domain", "regexp", "url", "url-prefix"],\n      documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"],\n      mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover"],\n      mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive"],\n      mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index",\n  // SVG-specific\n  "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"],\n      propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"],\n      nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"],\n      fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"],\n      counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"],\n      colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"],\n      valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);\n  CodeMirror.registerHelper("hintWords", "css", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false,\n        ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == "/") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = ch == "*";\n    }\n    return ["comment", "comment"];\n  }\n\n  CodeMirror.defineMIME("text/css", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      "/": function (stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css"\n  });\n\n  CodeMirror.defineMIME("text/x-scss", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function (stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      ":": function (stream) {\n        if (stream.match(/\\s*\\{/)) return [null, "{"];\n        return false;\n      },\n      "$": function (stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false)) return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "#": function (stream) {\n        if (!stream.eat("{")) return false;\n        return [null, "interpolation"];\n      }\n    },\n    name: "css",\n    helperType: "scss"\n  });\n\n  CodeMirror.defineMIME("text/x-less", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function (stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      "@": function (stream) {\n        if (stream.eat("{")) return [null, "interpolation"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false)) return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "&": function () {\n        return ["atom", "atom"];\n      }\n    },\n    name: "css",\n    helperType: "less"\n  });\n\n  CodeMirror.defineMIME("text/x-gss", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      "/": function (stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css",\n    helperType: "gss"\n  });\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NvZGVtaXJyb3IvbW9kZS9jc3MvY3NzLmpzPzljMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24gKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO2Vsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbiAoQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJjc3NcIiwgZnVuY3Rpb24gKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gICAgdmFyIGlubGluZSA9IHBhcnNlckNvbmZpZy5pbmxpbmU7XG4gICAgaWYgKCFwYXJzZXJDb25maWcucHJvcGVydHlLZXl3b3JkcykgcGFyc2VyQ29uZmlnID0gQ29kZU1pcnJvci5yZXNvbHZlTW9kZShcInRleHQvY3NzXCIpO1xuXG4gICAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdCxcbiAgICAgICAgdG9rZW5Ib29rcyA9IHBhcnNlckNvbmZpZy50b2tlbkhvb2tzLFxuICAgICAgICBkb2N1bWVudFR5cGVzID0gcGFyc2VyQ29uZmlnLmRvY3VtZW50VHlwZXMgfHwge30sXG4gICAgICAgIG1lZGlhVHlwZXMgPSBwYXJzZXJDb25maWcubWVkaWFUeXBlcyB8fCB7fSxcbiAgICAgICAgbWVkaWFGZWF0dXJlcyA9IHBhcnNlckNvbmZpZy5tZWRpYUZlYXR1cmVzIHx8IHt9LFxuICAgICAgICBtZWRpYVZhbHVlS2V5d29yZHMgPSBwYXJzZXJDb25maWcubWVkaWFWYWx1ZUtleXdvcmRzIHx8IHt9LFxuICAgICAgICBwcm9wZXJ0eUtleXdvcmRzID0gcGFyc2VyQ29uZmlnLnByb3BlcnR5S2V5d29yZHMgfHwge30sXG4gICAgICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5ub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgfHwge30sXG4gICAgICAgIGZvbnRQcm9wZXJ0aWVzID0gcGFyc2VyQ29uZmlnLmZvbnRQcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgICBjb3VudGVyRGVzY3JpcHRvcnMgPSBwYXJzZXJDb25maWcuY291bnRlckRlc2NyaXB0b3JzIHx8IHt9LFxuICAgICAgICBjb2xvcktleXdvcmRzID0gcGFyc2VyQ29uZmlnLmNvbG9yS2V5d29yZHMgfHwge30sXG4gICAgICAgIHZhbHVlS2V5d29yZHMgPSBwYXJzZXJDb25maWcudmFsdWVLZXl3b3JkcyB8fCB7fSxcbiAgICAgICAgYWxsb3dOZXN0ZWQgPSBwYXJzZXJDb25maWcuYWxsb3dOZXN0ZWQsXG4gICAgICAgIHN1cHBvcnRzQXRDb21wb25lbnQgPSBwYXJzZXJDb25maWcuc3VwcG9ydHNBdENvbXBvbmVudCA9PT0gdHJ1ZTtcblxuICAgIHZhciB0eXBlLCBvdmVycmlkZTtcbiAgICBmdW5jdGlvbiByZXQoc3R5bGUsIHRwKSB7XG4gICAgICB0eXBlID0gdHA7cmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIC8vIFRva2VuaXplcnNcblxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKHRva2VuSG9va3NbY2hdKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0b2tlbkhvb2tzW2NoXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT0gXCJAXCIpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgICAgcmV0dXJuIHJldChcImRlZlwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIgfHwgKGNoID09IFwiflwiIHx8IGNoID09IFwifFwiKSAmJiBzdHJlYW0uZWF0KFwiPVwiKSkge1xuICAgICAgICByZXR1cm4gcmV0KG51bGwsIFwiY29tcGFyZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJcXFwiXCIgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgICAgcmV0dXJuIHJldChcImF0b21cIiwgXCJoYXNoXCIpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIiFcIikge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL15cXHMqXFx3Ki8pO1xuICAgICAgICByZXR1cm4gcmV0KFwia2V5d29yZFwiLCBcImltcG9ydGFudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkgfHwgY2ggPT0gXCIuXCIgJiYgc3RyZWFtLmVhdCgvXFxkLykpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LiVdLyk7XG4gICAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJ1bml0XCIpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCItXCIpIHtcbiAgICAgICAgaWYgKC9bXFxkLl0vLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHcuJV0vKTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwidW5pdFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14tW1xcd1xcXFxcXC1dKy8pKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxzKjovLCBmYWxzZSkpIHJldHVybiByZXQoXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGUtZGVmaW5pdGlvblwiKTtcbiAgICAgICAgICByZXR1cm4gcmV0KFwidmFyaWFibGUtMlwiLCBcInZhcmlhYmxlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlxcdystLykpIHtcbiAgICAgICAgICByZXR1cm4gcmV0KFwibWV0YVwiLCBcIm1ldGFcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoL1ssKz4qXFwvXS8udGVzdChjaCkpIHtcbiAgICAgICAgcmV0dXJuIHJldChudWxsLCBcInNlbGVjdC1vcFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKC9eLT9bX2Etel1bX2EtejAtOS1dKi9pKSkge1xuICAgICAgICByZXR1cm4gcmV0KFwicXVhbGlmaWVyXCIsIFwicXVhbGlmaWVyXCIpO1xuICAgICAgfSBlbHNlIGlmICgvWzo7e31cXFtcXF1cXChcXCldLy50ZXN0KGNoKSkge1xuICAgICAgICByZXR1cm4gcmV0KG51bGwsIGNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJ1XCIgJiYgc3RyZWFtLm1hdGNoKC9ybCgtcHJlZml4KT9cXCgvKSB8fCBjaCA9PSBcImRcIiAmJiBzdHJlYW0ubWF0Y2goXCJvbWFpbihcIikgfHwgY2ggPT0gXCJyXCIgJiYgc3RyZWFtLm1hdGNoKFwiZWdleHAoXCIpKSB7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5QYXJlbnRoZXNpemVkO1xuICAgICAgICByZXR1cm4gcmV0KFwicHJvcGVydHlcIiwgXCJ3b3JkXCIpO1xuICAgICAgfSBlbHNlIGlmICgvW1xcd1xcXFxcXC1dLy50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXFxcXFwtXS8pO1xuICAgICAgICByZXR1cm4gcmV0KFwicHJvcGVydHlcIiwgXCJ3b3JkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldChudWxsLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgICBjaDtcbiAgICAgICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgIGlmIChxdW90ZSA9PSBcIilcIikgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09IHF1b3RlIHx8ICFlc2NhcGVkICYmIHF1b3RlICE9IFwiKVwiKSBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuUGFyZW50aGVzaXplZChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpOyAvLyBNdXN0IGJlICcoJ1xuICAgICAgaWYgKCFzdHJlYW0ubWF0Y2goL1xccypbXFxcIlxcJyldLywgZmFsc2UpKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKFwiKVwiKTtlbHNlIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIHJldHVybiByZXQobnVsbCwgXCIoXCIpO1xuICAgIH1cblxuICAgIC8vIENvbnRleHQgbWFuYWdlbWVudFxuXG4gICAgZnVuY3Rpb24gQ29udGV4dCh0eXBlLCBpbmRlbnQsIHByZXYpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgdHlwZSwgaW5kZW50KSB7XG4gICAgICBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQodHlwZSwgc3RyZWFtLmluZGVudGF0aW9uKCkgKyAoaW5kZW50ID09PSBmYWxzZSA/IDAgOiBpbmRlbnRVbml0KSwgc3RhdGUuY29udGV4dCk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuY29udGV4dC5wcmV2KSBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZXNbc3RhdGUuY29udGV4dC50eXBlXSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlLCBuKSB7XG4gICAgICBmb3IgKHZhciBpID0gbiB8fCAxOyBpID4gMDsgaS0tKSBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICAgICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2VyXG5cbiAgICBmdW5jdGlvbiB3b3JkQXNWYWx1ZShzdHJlYW0pIHtcbiAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHZhbHVlS2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIG92ZXJyaWRlID0gXCJhdG9tXCI7ZWxzZSBpZiAoY29sb3JLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkgb3ZlcnJpZGUgPSBcImtleXdvcmRcIjtlbHNlIG92ZXJyaWRlID0gXCJ2YXJpYWJsZVwiO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZXMgPSB7fTtcblxuICAgIHN0YXRlcy50b3AgPSBmdW5jdGlvbiAodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ9XCIgJiYgc3RhdGUuY29udGV4dC5wcmV2KSB7XG4gICAgICAgIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydHNBdENvbXBvbmVudCAmJiAvQGNvbXBvbmVudC8udGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJhdENvbXBvbmVudEJsb2NrXCIpO1xuICAgICAgfSBlbHNlIGlmICgvXkAoLW1vei0pP2RvY3VtZW50JC8udGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJkb2N1bWVudFR5cGVzXCIpO1xuICAgICAgfSBlbHNlIGlmICgvXkAobWVkaWF8c3VwcG9ydHN8KC1tb3otKT9kb2N1bWVudHxpbXBvcnQpJC8udGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJhdEJsb2NrXCIpO1xuICAgICAgfSBlbHNlIGlmICgvXkAoZm9udC1mYWNlfGNvdW50ZXItc3R5bGUpLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHN0YXRlLnN0YXRlQXJnID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIFwicmVzdHJpY3RlZF9hdEJsb2NrX2JlZm9yZVwiO1xuICAgICAgfSBlbHNlIGlmICgvXkAoLShtb3p8bXN8b3x3ZWJraXQpLSk/a2V5ZnJhbWVzJC8udGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm4gXCJrZXlmcmFtZXNcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAmJiB0eXBlLmNoYXJBdCgwKSA9PSBcIkBcIikge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJhdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImhhc2hcIikge1xuICAgICAgICBvdmVycmlkZSA9IFwiYnVpbHRpblwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICAgIG92ZXJyaWRlID0gXCJ0YWdcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInZhcmlhYmxlLWRlZmluaXRpb25cIikge1xuICAgICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImludGVycG9sYXRpb25cIikge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJpbnRlcnBvbGF0aW9uXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiBcInBzZXVkb1wiO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd05lc3RlZCAmJiB0eXBlID09IFwiKFwiKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInBhcmVuc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgfTtcblxuICAgIHN0YXRlcy5ibG9jayA9IGZ1bmN0aW9uICh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgICBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICAgICAgfSBlbHNlIGlmIChub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgICBvdmVycmlkZSA9IFwic3RyaW5nLTJcIjtcbiAgICAgICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxvd05lc3RlZCkge1xuICAgICAgICAgIG92ZXJyaWRlID0gc3RyZWFtLm1hdGNoKC9eXFxzKjooPzpcXHN8JCkvLCBmYWxzZSkgPyBcInByb3BlcnR5XCIgOiBcInRhZ1wiO1xuICAgICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3ZlcnJpZGUgKz0gXCIgZXJyb3JcIjtcbiAgICAgICAgICByZXR1cm4gXCJtYXliZXByb3BcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwibWV0YVwiKSB7XG4gICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgICB9IGVsc2UgaWYgKCFhbGxvd05lc3RlZCAmJiAodHlwZSA9PSBcImhhc2hcIiB8fCB0eXBlID09IFwicXVhbGlmaWVyXCIpKSB7XG4gICAgICAgIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlcy50b3AodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHN0YXRlcy5tYXliZXByb3AgPSBmdW5jdGlvbiAodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInByb3BcIik7XG4gICAgICByZXR1cm4gcGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgc3RhdGVzLnByb3AgPSBmdW5jdGlvbiAodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGlmICh0eXBlID09IFwie1wiICYmIGFsbG93TmVzdGVkKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwcm9wQmxvY2tcIik7XG4gICAgICBpZiAodHlwZSA9PSBcIn1cIiB8fCB0eXBlID09IFwie1wiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwYXJlbnNcIik7XG5cbiAgICAgIGlmICh0eXBlID09IFwiaGFzaFwiICYmICEvXiMoWzAtOWEtZkEtZl17Myw0fXxbMC05YS1mQS1mXXs2fXxbMC05YS1mQS1mXXs4fSkkLy50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgIG92ZXJyaWRlICs9IFwiIGVycm9yXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgICAgd29yZEFzVmFsdWUoc3RyZWFtKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImludGVycG9sYXRpb25cIikge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJpbnRlcnBvbGF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwicHJvcFwiO1xuICAgIH07XG5cbiAgICBzdGF0ZXMucHJvcEJsb2NrID0gZnVuY3Rpb24gKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgICAgb3ZlcnJpZGUgPSBcInByb3BlcnR5XCI7cmV0dXJuIFwibWF5YmVwcm9wXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIH07XG5cbiAgICBzdGF0ZXMucGFyZW5zID0gZnVuY3Rpb24gKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwie1wiIHx8IHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHR5cGUgPT0gXCIpXCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwYXJlbnNcIik7XG4gICAgICBpZiAodHlwZSA9PSBcImludGVycG9sYXRpb25cIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiaW50ZXJwb2xhdGlvblwiKTtcbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSB3b3JkQXNWYWx1ZShzdHJlYW0pO1xuICAgICAgcmV0dXJuIFwicGFyZW5zXCI7XG4gICAgfTtcblxuICAgIHN0YXRlcy5wc2V1ZG8gPSBmdW5jdGlvbiAodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgICAgb3ZlcnJpZGUgPSBcInZhcmlhYmxlLTNcIjtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH07XG5cbiAgICBzdGF0ZXMuZG9jdW1lbnRUeXBlcyA9IGZ1bmN0aW9uICh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIiAmJiBkb2N1bWVudFR5cGVzLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgIG92ZXJyaWRlID0gXCJ0YWdcIjtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZXMuYXRCbG9jayh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhdGVzLmF0QmxvY2sgPSBmdW5jdGlvbiAodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImF0QmxvY2tfcGFyZW5zXCIpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ9XCIgfHwgdHlwZSA9PSBcIjtcIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpICYmIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIGFsbG93TmVzdGVkID8gXCJibG9ja1wiIDogXCJ0b3BcIik7XG5cbiAgICAgIGlmICh0eXBlID09IFwiaW50ZXJwb2xhdGlvblwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJpbnRlcnBvbGF0aW9uXCIpO1xuXG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHdvcmQgPT0gXCJvbmx5XCIgfHwgd29yZCA9PSBcIm5vdFwiIHx8IHdvcmQgPT0gXCJhbmRcIiB8fCB3b3JkID09IFwib3JcIikgb3ZlcnJpZGUgPSBcImtleXdvcmRcIjtlbHNlIGlmIChtZWRpYVR5cGVzLmhhc093blByb3BlcnR5KHdvcmQpKSBvdmVycmlkZSA9IFwiYXR0cmlidXRlXCI7ZWxzZSBpZiAobWVkaWFGZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkgb3ZlcnJpZGUgPSBcInByb3BlcnR5XCI7ZWxzZSBpZiAobWVkaWFWYWx1ZUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKSBvdmVycmlkZSA9IFwia2V5d29yZFwiO2Vsc2UgaWYgKHByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIG92ZXJyaWRlID0gXCJwcm9wZXJ0eVwiO2Vsc2UgaWYgKG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkgb3ZlcnJpZGUgPSBcInN0cmluZy0yXCI7ZWxzZSBpZiAodmFsdWVLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkgb3ZlcnJpZGUgPSBcImF0b21cIjtlbHNlIGlmIChjb2xvcktleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKSBvdmVycmlkZSA9IFwia2V5d29yZFwiO2Vsc2Ugb3ZlcnJpZGUgPSBcImVycm9yXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIH07XG5cbiAgICBzdGF0ZXMuYXRDb21wb25lbnRCbG9jayA9IGZ1bmN0aW9uICh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpICYmIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIGFsbG93TmVzdGVkID8gXCJibG9ja1wiIDogXCJ0b3BcIiwgZmFsc2UpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9O1xuXG4gICAgc3RhdGVzLmF0QmxvY2tfcGFyZW5zID0gZnVuY3Rpb24gKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiKVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIntcIiB8fCB0eXBlID09IFwifVwiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlLCAyKTtcbiAgICAgIHJldHVybiBzdGF0ZXMuYXRCbG9jayh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgc3RhdGVzLnJlc3RyaWN0ZWRfYXRCbG9ja19iZWZvcmUgPSBmdW5jdGlvbiAodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInJlc3RyaWN0ZWRfYXRCbG9ja1wiKTtcbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiICYmIHN0YXRlLnN0YXRlQXJnID09IFwiQGNvdW50ZXItc3R5bGVcIikge1xuICAgICAgICBvdmVycmlkZSA9IFwidmFyaWFibGVcIjtcbiAgICAgICAgcmV0dXJuIFwicmVzdHJpY3RlZF9hdEJsb2NrX2JlZm9yZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIHN0YXRlcy5yZXN0cmljdGVkX2F0QmxvY2sgPSBmdW5jdGlvbiAodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHtcbiAgICAgICAgc3RhdGUuc3RhdGVBcmcgPSBudWxsO1xuICAgICAgICByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICBpZiAoc3RhdGUuc3RhdGVBcmcgPT0gXCJAZm9udC1mYWNlXCIgJiYgIWZvbnRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKSkgfHwgc3RhdGUuc3RhdGVBcmcgPT0gXCJAY291bnRlci1zdHlsZVwiICYmICFjb3VudGVyRGVzY3JpcHRvcnMuaGFzT3duUHJvcGVydHkoc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpKSkgb3ZlcnJpZGUgPSBcImVycm9yXCI7ZWxzZSBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgcmV0dXJuIFwibWF5YmVwcm9wXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJyZXN0cmljdGVkX2F0QmxvY2tcIjtcbiAgICB9O1xuXG4gICAgc3RhdGVzLmtleWZyYW1lcyA9IGZ1bmN0aW9uICh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICBvdmVycmlkZSA9IFwidmFyaWFibGVcIjtyZXR1cm4gXCJrZXlmcmFtZXNcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJ0b3BcIik7XG4gICAgICByZXR1cm4gcGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgc3RhdGVzLmF0ID0gZnVuY3Rpb24gKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIntcIiB8fCB0eXBlID09IFwifVwiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSBvdmVycmlkZSA9IFwidGFnXCI7ZWxzZSBpZiAodHlwZSA9PSBcImhhc2hcIikgb3ZlcnJpZGUgPSBcImJ1aWx0aW5cIjtcbiAgICAgIHJldHVybiBcImF0XCI7XG4gICAgfTtcblxuICAgIHN0YXRlcy5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwifVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIntcIiB8fCB0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSBvdmVycmlkZSA9IFwidmFyaWFibGVcIjtlbHNlIGlmICh0eXBlICE9IFwidmFyaWFibGVcIiAmJiB0eXBlICE9IFwiKFwiICYmIHR5cGUgIT0gXCIpXCIpIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIFwiaW50ZXJwb2xhdGlvblwiO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9rZW5pemU6IG51bGwsXG4gICAgICAgICAgc3RhdGU6IGlubGluZSA/IFwiYmxvY2tcIiA6IFwidG9wXCIsXG4gICAgICAgICAgc3RhdGVBcmc6IG51bGwsXG4gICAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoaW5saW5lID8gXCJibG9ja1wiIDogXCJ0b3BcIiwgYmFzZSB8fCAwLCBudWxsKSB9O1xuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RhdGUudG9rZW5pemUgJiYgc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdHlwZSA9IHN0eWxlWzFdO1xuICAgICAgICAgIHN0eWxlID0gc3R5bGVbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3ZlcnJpZGUgPSBzdHlsZTtcbiAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZXNbc3RhdGUuc3RhdGVdKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgICB9LFxuXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICAgIHZhciBjeCA9IHN0YXRlLmNvbnRleHQsXG4gICAgICAgICAgICBjaCA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgICB2YXIgaW5kZW50ID0gY3guaW5kZW50O1xuICAgICAgICBpZiAoY3gudHlwZSA9PSBcInByb3BcIiAmJiAoY2ggPT0gXCJ9XCIgfHwgY2ggPT0gXCIpXCIpKSBjeCA9IGN4LnByZXY7XG4gICAgICAgIGlmIChjeC5wcmV2KSB7XG4gICAgICAgICAgaWYgKGNoID09IFwifVwiICYmIChjeC50eXBlID09IFwiYmxvY2tcIiB8fCBjeC50eXBlID09IFwidG9wXCIgfHwgY3gudHlwZSA9PSBcImludGVycG9sYXRpb25cIiB8fCBjeC50eXBlID09IFwicmVzdHJpY3RlZF9hdEJsb2NrXCIpKSB7XG4gICAgICAgICAgICAvLyBSZXN1bWUgaW5kZW50YXRpb24gZnJvbSBwYXJlbnQgY29udGV4dC5cbiAgICAgICAgICAgIGN4ID0gY3gucHJldjtcbiAgICAgICAgICAgIGluZGVudCA9IGN4LmluZGVudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiKVwiICYmIChjeC50eXBlID09IFwicGFyZW5zXCIgfHwgY3gudHlwZSA9PSBcImF0QmxvY2tfcGFyZW5zXCIpIHx8IGNoID09IFwie1wiICYmIChjeC50eXBlID09IFwiYXRcIiB8fCBjeC50eXBlID09IFwiYXRCbG9ja1wiKSkge1xuICAgICAgICAgICAgLy8gRGVkZW50IHJlbGF0aXZlIHRvIGN1cnJlbnQgY29udGV4dC5cbiAgICAgICAgICAgIGluZGVudCA9IE1hdGgubWF4KDAsIGN4LmluZGVudCAtIGluZGVudFVuaXQpO1xuICAgICAgICAgICAgY3ggPSBjeC5wcmV2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZW50O1xuICAgICAgfSxcblxuICAgICAgZWxlY3RyaWNDaGFyczogXCJ9XCIsXG4gICAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgICBmb2xkOiBcImJyYWNlXCJcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiBrZXlTZXQoYXJyYXkpIHtcbiAgICB2YXIga2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGtleXNbYXJyYXlbaV0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIHZhciBkb2N1bWVudFR5cGVzXyA9IFtcImRvbWFpblwiLCBcInJlZ2V4cFwiLCBcInVybFwiLCBcInVybC1wcmVmaXhcIl0sXG4gICAgICBkb2N1bWVudFR5cGVzID0ga2V5U2V0KGRvY3VtZW50VHlwZXNfKTtcblxuICB2YXIgbWVkaWFUeXBlc18gPSBbXCJhbGxcIiwgXCJhdXJhbFwiLCBcImJyYWlsbGVcIiwgXCJoYW5kaGVsZFwiLCBcInByaW50XCIsIFwicHJvamVjdGlvblwiLCBcInNjcmVlblwiLCBcInR0eVwiLCBcInR2XCIsIFwiZW1ib3NzZWRcIl0sXG4gICAgICBtZWRpYVR5cGVzID0ga2V5U2V0KG1lZGlhVHlwZXNfKTtcblxuICB2YXIgbWVkaWFGZWF0dXJlc18gPSBbXCJ3aWR0aFwiLCBcIm1pbi13aWR0aFwiLCBcIm1heC13aWR0aFwiLCBcImhlaWdodFwiLCBcIm1pbi1oZWlnaHRcIiwgXCJtYXgtaGVpZ2h0XCIsIFwiZGV2aWNlLXdpZHRoXCIsIFwibWluLWRldmljZS13aWR0aFwiLCBcIm1heC1kZXZpY2Utd2lkdGhcIiwgXCJkZXZpY2UtaGVpZ2h0XCIsIFwibWluLWRldmljZS1oZWlnaHRcIiwgXCJtYXgtZGV2aWNlLWhlaWdodFwiLCBcImFzcGVjdC1yYXRpb1wiLCBcIm1pbi1hc3BlY3QtcmF0aW9cIiwgXCJtYXgtYXNwZWN0LXJhdGlvXCIsIFwiZGV2aWNlLWFzcGVjdC1yYXRpb1wiLCBcIm1pbi1kZXZpY2UtYXNwZWN0LXJhdGlvXCIsIFwibWF4LWRldmljZS1hc3BlY3QtcmF0aW9cIiwgXCJjb2xvclwiLCBcIm1pbi1jb2xvclwiLCBcIm1heC1jb2xvclwiLCBcImNvbG9yLWluZGV4XCIsIFwibWluLWNvbG9yLWluZGV4XCIsIFwibWF4LWNvbG9yLWluZGV4XCIsIFwibW9ub2Nocm9tZVwiLCBcIm1pbi1tb25vY2hyb21lXCIsIFwibWF4LW1vbm9jaHJvbWVcIiwgXCJyZXNvbHV0aW9uXCIsIFwibWluLXJlc29sdXRpb25cIiwgXCJtYXgtcmVzb2x1dGlvblwiLCBcInNjYW5cIiwgXCJncmlkXCIsIFwib3JpZW50YXRpb25cIiwgXCJkZXZpY2UtcGl4ZWwtcmF0aW9cIiwgXCJtaW4tZGV2aWNlLXBpeGVsLXJhdGlvXCIsIFwibWF4LWRldmljZS1waXhlbC1yYXRpb1wiLCBcInBvaW50ZXJcIiwgXCJhbnktcG9pbnRlclwiLCBcImhvdmVyXCIsIFwiYW55LWhvdmVyXCJdLFxuICAgICAgbWVkaWFGZWF0dXJlcyA9IGtleVNldChtZWRpYUZlYXR1cmVzXyk7XG5cbiAgdmFyIG1lZGlhVmFsdWVLZXl3b3Jkc18gPSBbXCJsYW5kc2NhcGVcIiwgXCJwb3J0cmFpdFwiLCBcIm5vbmVcIiwgXCJjb2Fyc2VcIiwgXCJmaW5lXCIsIFwib24tZGVtYW5kXCIsIFwiaG92ZXJcIiwgXCJpbnRlcmxhY2VcIiwgXCJwcm9ncmVzc2l2ZVwiXSxcbiAgICAgIG1lZGlhVmFsdWVLZXl3b3JkcyA9IGtleVNldChtZWRpYVZhbHVlS2V5d29yZHNfKTtcblxuICB2YXIgcHJvcGVydHlLZXl3b3Jkc18gPSBbXCJhbGlnbi1jb250ZW50XCIsIFwiYWxpZ24taXRlbXNcIiwgXCJhbGlnbi1zZWxmXCIsIFwiYWxpZ25tZW50LWFkanVzdFwiLCBcImFsaWdubWVudC1iYXNlbGluZVwiLCBcImFuY2hvci1wb2ludFwiLCBcImFuaW1hdGlvblwiLCBcImFuaW1hdGlvbi1kZWxheVwiLCBcImFuaW1hdGlvbi1kaXJlY3Rpb25cIiwgXCJhbmltYXRpb24tZHVyYXRpb25cIiwgXCJhbmltYXRpb24tZmlsbC1tb2RlXCIsIFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiLCBcImFuaW1hdGlvbi1uYW1lXCIsIFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIiwgXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsIFwiYXBwZWFyYW5jZVwiLCBcImF6aW11dGhcIiwgXCJiYWNrZmFjZS12aXNpYmlsaXR5XCIsIFwiYmFja2dyb3VuZFwiLCBcImJhY2tncm91bmQtYXR0YWNobWVudFwiLCBcImJhY2tncm91bmQtYmxlbmQtbW9kZVwiLCBcImJhY2tncm91bmQtY2xpcFwiLCBcImJhY2tncm91bmQtY29sb3JcIiwgXCJiYWNrZ3JvdW5kLWltYWdlXCIsIFwiYmFja2dyb3VuZC1vcmlnaW5cIiwgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsIFwiYmFja2dyb3VuZC1yZXBlYXRcIiwgXCJiYWNrZ3JvdW5kLXNpemVcIiwgXCJiYXNlbGluZS1zaGlmdFwiLCBcImJpbmRpbmdcIiwgXCJibGVlZFwiLCBcImJvb2ttYXJrLWxhYmVsXCIsIFwiYm9va21hcmstbGV2ZWxcIiwgXCJib29rbWFyay1zdGF0ZVwiLCBcImJvb2ttYXJrLXRhcmdldFwiLCBcImJvcmRlclwiLCBcImJvcmRlci1ib3R0b21cIiwgXCJib3JkZXItYm90dG9tLWNvbG9yXCIsIFwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLCBcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsIFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLCBcImJvcmRlci1ib3R0b20td2lkdGhcIiwgXCJib3JkZXItY29sbGFwc2VcIiwgXCJib3JkZXItY29sb3JcIiwgXCJib3JkZXItaW1hZ2VcIiwgXCJib3JkZXItaW1hZ2Utb3V0c2V0XCIsIFwiYm9yZGVyLWltYWdlLXJlcGVhdFwiLCBcImJvcmRlci1pbWFnZS1zbGljZVwiLCBcImJvcmRlci1pbWFnZS1zb3VyY2VcIiwgXCJib3JkZXItaW1hZ2Utd2lkdGhcIiwgXCJib3JkZXItbGVmdFwiLCBcImJvcmRlci1sZWZ0LWNvbG9yXCIsIFwiYm9yZGVyLWxlZnQtc3R5bGVcIiwgXCJib3JkZXItbGVmdC13aWR0aFwiLCBcImJvcmRlci1yYWRpdXNcIiwgXCJib3JkZXItcmlnaHRcIiwgXCJib3JkZXItcmlnaHQtY29sb3JcIiwgXCJib3JkZXItcmlnaHQtc3R5bGVcIiwgXCJib3JkZXItcmlnaHQtd2lkdGhcIiwgXCJib3JkZXItc3BhY2luZ1wiLCBcImJvcmRlci1zdHlsZVwiLCBcImJvcmRlci10b3BcIiwgXCJib3JkZXItdG9wLWNvbG9yXCIsIFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiLCBcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsIFwiYm9yZGVyLXRvcC1zdHlsZVwiLCBcImJvcmRlci10b3Atd2lkdGhcIiwgXCJib3JkZXItd2lkdGhcIiwgXCJib3R0b21cIiwgXCJib3gtZGVjb3JhdGlvbi1icmVha1wiLCBcImJveC1zaGFkb3dcIiwgXCJib3gtc2l6aW5nXCIsIFwiYnJlYWstYWZ0ZXJcIiwgXCJicmVhay1iZWZvcmVcIiwgXCJicmVhay1pbnNpZGVcIiwgXCJjYXB0aW9uLXNpZGVcIiwgXCJjbGVhclwiLCBcImNsaXBcIiwgXCJjb2xvclwiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJjb2x1bW4tY291bnRcIiwgXCJjb2x1bW4tZmlsbFwiLCBcImNvbHVtbi1nYXBcIiwgXCJjb2x1bW4tcnVsZVwiLCBcImNvbHVtbi1ydWxlLWNvbG9yXCIsIFwiY29sdW1uLXJ1bGUtc3R5bGVcIiwgXCJjb2x1bW4tcnVsZS13aWR0aFwiLCBcImNvbHVtbi1zcGFuXCIsIFwiY29sdW1uLXdpZHRoXCIsIFwiY29sdW1uc1wiLCBcImNvbnRlbnRcIiwgXCJjb3VudGVyLWluY3JlbWVudFwiLCBcImNvdW50ZXItcmVzZXRcIiwgXCJjcm9wXCIsIFwiY3VlXCIsIFwiY3VlLWFmdGVyXCIsIFwiY3VlLWJlZm9yZVwiLCBcImN1cnNvclwiLCBcImRpcmVjdGlvblwiLCBcImRpc3BsYXlcIiwgXCJkb21pbmFudC1iYXNlbGluZVwiLCBcImRyb3AtaW5pdGlhbC1hZnRlci1hZGp1c3RcIiwgXCJkcm9wLWluaXRpYWwtYWZ0ZXItYWxpZ25cIiwgXCJkcm9wLWluaXRpYWwtYmVmb3JlLWFkanVzdFwiLCBcImRyb3AtaW5pdGlhbC1iZWZvcmUtYWxpZ25cIiwgXCJkcm9wLWluaXRpYWwtc2l6ZVwiLCBcImRyb3AtaW5pdGlhbC12YWx1ZVwiLCBcImVsZXZhdGlvblwiLCBcImVtcHR5LWNlbGxzXCIsIFwiZml0XCIsIFwiZml0LXBvc2l0aW9uXCIsIFwiZmxleFwiLCBcImZsZXgtYmFzaXNcIiwgXCJmbGV4LWRpcmVjdGlvblwiLCBcImZsZXgtZmxvd1wiLCBcImZsZXgtZ3Jvd1wiLCBcImZsZXgtc2hyaW5rXCIsIFwiZmxleC13cmFwXCIsIFwiZmxvYXRcIiwgXCJmbG9hdC1vZmZzZXRcIiwgXCJmbG93LWZyb21cIiwgXCJmbG93LWludG9cIiwgXCJmb250XCIsIFwiZm9udC1mZWF0dXJlLXNldHRpbmdzXCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LWtlcm5pbmdcIiwgXCJmb250LWxhbmd1YWdlLW92ZXJyaWRlXCIsIFwiZm9udC1zaXplXCIsIFwiZm9udC1zaXplLWFkanVzdFwiLCBcImZvbnQtc3RyZXRjaFwiLCBcImZvbnQtc3R5bGVcIiwgXCJmb250LXN5bnRoZXNpc1wiLCBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtdmFyaWFudC1hbHRlcm5hdGVzXCIsIFwiZm9udC12YXJpYW50LWNhcHNcIiwgXCJmb250LXZhcmlhbnQtZWFzdC1hc2lhblwiLCBcImZvbnQtdmFyaWFudC1saWdhdHVyZXNcIiwgXCJmb250LXZhcmlhbnQtbnVtZXJpY1wiLCBcImZvbnQtdmFyaWFudC1wb3NpdGlvblwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZ3JpZFwiLCBcImdyaWQtYXJlYVwiLCBcImdyaWQtYXV0by1jb2x1bW5zXCIsIFwiZ3JpZC1hdXRvLWZsb3dcIiwgXCJncmlkLWF1dG8tcm93c1wiLCBcImdyaWQtY29sdW1uXCIsIFwiZ3JpZC1jb2x1bW4tZW5kXCIsIFwiZ3JpZC1jb2x1bW4tZ2FwXCIsIFwiZ3JpZC1jb2x1bW4tc3RhcnRcIiwgXCJncmlkLWdhcFwiLCBcImdyaWQtcm93XCIsIFwiZ3JpZC1yb3ctZW5kXCIsIFwiZ3JpZC1yb3ctZ2FwXCIsIFwiZ3JpZC1yb3ctc3RhcnRcIiwgXCJncmlkLXRlbXBsYXRlXCIsIFwiZ3JpZC10ZW1wbGF0ZS1hcmVhc1wiLCBcImdyaWQtdGVtcGxhdGUtY29sdW1uc1wiLCBcImdyaWQtdGVtcGxhdGUtcm93c1wiLCBcImhhbmdpbmctcHVuY3R1YXRpb25cIiwgXCJoZWlnaHRcIiwgXCJoeXBoZW5zXCIsIFwiaWNvblwiLCBcImltYWdlLW9yaWVudGF0aW9uXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCIsIFwiaW1hZ2UtcmVzb2x1dGlvblwiLCBcImlubGluZS1ib3gtYWxpZ25cIiwgXCJqdXN0aWZ5LWNvbnRlbnRcIiwgXCJsZWZ0XCIsIFwibGV0dGVyLXNwYWNpbmdcIiwgXCJsaW5lLWJyZWFrXCIsIFwibGluZS1oZWlnaHRcIiwgXCJsaW5lLXN0YWNraW5nXCIsIFwibGluZS1zdGFja2luZy1ydWJ5XCIsIFwibGluZS1zdGFja2luZy1zaGlmdFwiLCBcImxpbmUtc3RhY2tpbmctc3RyYXRlZ3lcIiwgXCJsaXN0LXN0eWxlXCIsIFwibGlzdC1zdHlsZS1pbWFnZVwiLCBcImxpc3Qtc3R5bGUtcG9zaXRpb25cIiwgXCJsaXN0LXN0eWxlLXR5cGVcIiwgXCJtYXJnaW5cIiwgXCJtYXJnaW4tYm90dG9tXCIsIFwibWFyZ2luLWxlZnRcIiwgXCJtYXJnaW4tcmlnaHRcIiwgXCJtYXJnaW4tdG9wXCIsIFwibWFya2VyLW9mZnNldFwiLCBcIm1hcmtzXCIsIFwibWFycXVlZS1kaXJlY3Rpb25cIiwgXCJtYXJxdWVlLWxvb3BcIiwgXCJtYXJxdWVlLXBsYXktY291bnRcIiwgXCJtYXJxdWVlLXNwZWVkXCIsIFwibWFycXVlZS1zdHlsZVwiLCBcIm1heC1oZWlnaHRcIiwgXCJtYXgtd2lkdGhcIiwgXCJtaW4taGVpZ2h0XCIsIFwibWluLXdpZHRoXCIsIFwibW92ZS10b1wiLCBcIm5hdi1kb3duXCIsIFwibmF2LWluZGV4XCIsIFwibmF2LWxlZnRcIiwgXCJuYXYtcmlnaHRcIiwgXCJuYXYtdXBcIiwgXCJvYmplY3QtZml0XCIsIFwib2JqZWN0LXBvc2l0aW9uXCIsIFwib3BhY2l0eVwiLCBcIm9yZGVyXCIsIFwib3JwaGFuc1wiLCBcIm91dGxpbmVcIiwgXCJvdXRsaW5lLWNvbG9yXCIsIFwib3V0bGluZS1vZmZzZXRcIiwgXCJvdXRsaW5lLXN0eWxlXCIsIFwib3V0bGluZS13aWR0aFwiLCBcIm92ZXJmbG93XCIsIFwib3ZlcmZsb3ctc3R5bGVcIiwgXCJvdmVyZmxvdy13cmFwXCIsIFwib3ZlcmZsb3cteFwiLCBcIm92ZXJmbG93LXlcIiwgXCJwYWRkaW5nXCIsIFwicGFkZGluZy1ib3R0b21cIiwgXCJwYWRkaW5nLWxlZnRcIiwgXCJwYWRkaW5nLXJpZ2h0XCIsIFwicGFkZGluZy10b3BcIiwgXCJwYWdlXCIsIFwicGFnZS1icmVhay1hZnRlclwiLCBcInBhZ2UtYnJlYWstYmVmb3JlXCIsIFwicGFnZS1icmVhay1pbnNpZGVcIiwgXCJwYWdlLXBvbGljeVwiLCBcInBhdXNlXCIsIFwicGF1c2UtYWZ0ZXJcIiwgXCJwYXVzZS1iZWZvcmVcIiwgXCJwZXJzcGVjdGl2ZVwiLCBcInBlcnNwZWN0aXZlLW9yaWdpblwiLCBcInBpdGNoXCIsIFwicGl0Y2gtcmFuZ2VcIiwgXCJwbGF5LWR1cmluZ1wiLCBcInBvc2l0aW9uXCIsIFwicHJlc2VudGF0aW9uLWxldmVsXCIsIFwicHVuY3R1YXRpb24tdHJpbVwiLCBcInF1b3Rlc1wiLCBcInJlZ2lvbi1icmVhay1hZnRlclwiLCBcInJlZ2lvbi1icmVhay1iZWZvcmVcIiwgXCJyZWdpb24tYnJlYWstaW5zaWRlXCIsIFwicmVnaW9uLWZyYWdtZW50XCIsIFwicmVuZGVyaW5nLWludGVudFwiLCBcInJlc2l6ZVwiLCBcInJlc3RcIiwgXCJyZXN0LWFmdGVyXCIsIFwicmVzdC1iZWZvcmVcIiwgXCJyaWNobmVzc1wiLCBcInJpZ2h0XCIsIFwicm90YXRpb25cIiwgXCJyb3RhdGlvbi1wb2ludFwiLCBcInJ1YnktYWxpZ25cIiwgXCJydWJ5LW92ZXJoYW5nXCIsIFwicnVieS1wb3NpdGlvblwiLCBcInJ1Ynktc3BhblwiLCBcInNoYXBlLWltYWdlLXRocmVzaG9sZFwiLCBcInNoYXBlLWluc2lkZVwiLCBcInNoYXBlLW1hcmdpblwiLCBcInNoYXBlLW91dHNpZGVcIiwgXCJzaXplXCIsIFwic3BlYWtcIiwgXCJzcGVhay1hc1wiLCBcInNwZWFrLWhlYWRlclwiLCBcInNwZWFrLW51bWVyYWxcIiwgXCJzcGVhay1wdW5jdHVhdGlvblwiLCBcInNwZWVjaC1yYXRlXCIsIFwic3RyZXNzXCIsIFwic3RyaW5nLXNldFwiLCBcInRhYi1zaXplXCIsIFwidGFibGUtbGF5b3V0XCIsIFwidGFyZ2V0XCIsIFwidGFyZ2V0LW5hbWVcIiwgXCJ0YXJnZXQtbmV3XCIsIFwidGFyZ2V0LXBvc2l0aW9uXCIsIFwidGV4dC1hbGlnblwiLCBcInRleHQtYWxpZ24tbGFzdFwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiLCBcInRleHQtZGVjb3JhdGlvbi1saW5lXCIsIFwidGV4dC1kZWNvcmF0aW9uLXNraXBcIiwgXCJ0ZXh0LWRlY29yYXRpb24tc3R5bGVcIiwgXCJ0ZXh0LWVtcGhhc2lzXCIsIFwidGV4dC1lbXBoYXNpcy1jb2xvclwiLCBcInRleHQtZW1waGFzaXMtcG9zaXRpb25cIiwgXCJ0ZXh0LWVtcGhhc2lzLXN0eWxlXCIsIFwidGV4dC1oZWlnaHRcIiwgXCJ0ZXh0LWluZGVudFwiLCBcInRleHQtanVzdGlmeVwiLCBcInRleHQtb3V0bGluZVwiLCBcInRleHQtb3ZlcmZsb3dcIiwgXCJ0ZXh0LXNoYWRvd1wiLCBcInRleHQtc2l6ZS1hZGp1c3RcIiwgXCJ0ZXh0LXNwYWNlLWNvbGxhcHNlXCIsIFwidGV4dC10cmFuc2Zvcm1cIiwgXCJ0ZXh0LXVuZGVybGluZS1wb3NpdGlvblwiLCBcInRleHQtd3JhcFwiLCBcInRvcFwiLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybS1vcmlnaW5cIiwgXCJ0cmFuc2Zvcm0tc3R5bGVcIiwgXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbi1kZWxheVwiLCBcInRyYW5zaXRpb24tZHVyYXRpb25cIiwgXCJ0cmFuc2l0aW9uLXByb3BlcnR5XCIsIFwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIiwgXCJ1bmljb2RlLWJpZGlcIiwgXCJ2ZXJ0aWNhbC1hbGlnblwiLCBcInZpc2liaWxpdHlcIiwgXCJ2b2ljZS1iYWxhbmNlXCIsIFwidm9pY2UtZHVyYXRpb25cIiwgXCJ2b2ljZS1mYW1pbHlcIiwgXCJ2b2ljZS1waXRjaFwiLCBcInZvaWNlLXJhbmdlXCIsIFwidm9pY2UtcmF0ZVwiLCBcInZvaWNlLXN0cmVzc1wiLCBcInZvaWNlLXZvbHVtZVwiLCBcInZvbHVtZVwiLCBcIndoaXRlLXNwYWNlXCIsIFwid2lkb3dzXCIsIFwid2lkdGhcIiwgXCJ3b3JkLWJyZWFrXCIsIFwid29yZC1zcGFjaW5nXCIsIFwid29yZC13cmFwXCIsIFwiei1pbmRleFwiLFxuICAvLyBTVkctc3BlY2lmaWNcbiAgXCJjbGlwLXBhdGhcIiwgXCJjbGlwLXJ1bGVcIiwgXCJtYXNrXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIiwgXCJmaWx0ZXJcIiwgXCJmbG9vZC1jb2xvclwiLCBcImZsb29kLW9wYWNpdHlcIiwgXCJsaWdodGluZy1jb2xvclwiLCBcInN0b3AtY29sb3JcIiwgXCJzdG9wLW9wYWNpdHlcIiwgXCJwb2ludGVyLWV2ZW50c1wiLCBcImNvbG9yLWludGVycG9sYXRpb25cIiwgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJjb2xvci1yZW5kZXJpbmdcIiwgXCJmaWxsXCIsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCIsIFwibWFya2VyXCIsIFwibWFya2VyLWVuZFwiLCBcIm1hcmtlci1taWRcIiwgXCJtYXJrZXItc3RhcnRcIiwgXCJzaGFwZS1yZW5kZXJpbmdcIiwgXCJzdHJva2VcIiwgXCJzdHJva2UtZGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgXCJzdHJva2UtbGluZWNhcFwiLCBcInN0cm9rZS1saW5lam9pblwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsIFwic3Ryb2tlLW9wYWNpdHlcIiwgXCJzdHJva2Utd2lkdGhcIiwgXCJ0ZXh0LXJlbmRlcmluZ1wiLCBcImJhc2VsaW5lLXNoaWZ0XCIsIFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIiwgXCJ0ZXh0LWFuY2hvclwiLCBcIndyaXRpbmctbW9kZVwiXSxcbiAgICAgIHByb3BlcnR5S2V5d29yZHMgPSBrZXlTZXQocHJvcGVydHlLZXl3b3Jkc18pO1xuXG4gIHZhciBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHNfID0gW1wic2Nyb2xsYmFyLWFycm93LWNvbG9yXCIsIFwic2Nyb2xsYmFyLWJhc2UtY29sb3JcIiwgXCJzY3JvbGxiYXItZGFyay1zaGFkb3ctY29sb3JcIiwgXCJzY3JvbGxiYXItZmFjZS1jb2xvclwiLCBcInNjcm9sbGJhci1oaWdobGlnaHQtY29sb3JcIiwgXCJzY3JvbGxiYXItc2hhZG93LWNvbG9yXCIsIFwic2Nyb2xsYmFyLTNkLWxpZ2h0LWNvbG9yXCIsIFwic2Nyb2xsYmFyLXRyYWNrLWNvbG9yXCIsIFwic2hhcGUtaW5zaWRlXCIsIFwic2VhcmNoZmllbGQtY2FuY2VsLWJ1dHRvblwiLCBcInNlYXJjaGZpZWxkLWRlY29yYXRpb25cIiwgXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWJ1dHRvblwiLCBcInNlYXJjaGZpZWxkLXJlc3VsdHMtZGVjb3JhdGlvblwiLCBcInpvb21cIl0sXG4gICAgICBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgPSBrZXlTZXQobm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzXyk7XG5cbiAgdmFyIGZvbnRQcm9wZXJ0aWVzXyA9IFtcImZvbnQtZmFtaWx5XCIsIFwic3JjXCIsIFwidW5pY29kZS1yYW5nZVwiLCBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtZmVhdHVyZS1zZXR0aW5nc1wiLCBcImZvbnQtc3RyZXRjaFwiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZm9udC1zdHlsZVwiXSxcbiAgICAgIGZvbnRQcm9wZXJ0aWVzID0ga2V5U2V0KGZvbnRQcm9wZXJ0aWVzXyk7XG5cbiAgdmFyIGNvdW50ZXJEZXNjcmlwdG9yc18gPSBbXCJhZGRpdGl2ZS1zeW1ib2xzXCIsIFwiZmFsbGJhY2tcIiwgXCJuZWdhdGl2ZVwiLCBcInBhZFwiLCBcInByZWZpeFwiLCBcInJhbmdlXCIsIFwic3BlYWstYXNcIiwgXCJzdWZmaXhcIiwgXCJzeW1ib2xzXCIsIFwic3lzdGVtXCJdLFxuICAgICAgY291bnRlckRlc2NyaXB0b3JzID0ga2V5U2V0KGNvdW50ZXJEZXNjcmlwdG9yc18pO1xuXG4gIHZhciBjb2xvcktleXdvcmRzXyA9IFtcImFsaWNlYmx1ZVwiLCBcImFudGlxdWV3aGl0ZVwiLCBcImFxdWFcIiwgXCJhcXVhbWFyaW5lXCIsIFwiYXp1cmVcIiwgXCJiZWlnZVwiLCBcImJpc3F1ZVwiLCBcImJsYWNrXCIsIFwiYmxhbmNoZWRhbG1vbmRcIiwgXCJibHVlXCIsIFwiYmx1ZXZpb2xldFwiLCBcImJyb3duXCIsIFwiYnVybHl3b29kXCIsIFwiY2FkZXRibHVlXCIsIFwiY2hhcnRyZXVzZVwiLCBcImNob2NvbGF0ZVwiLCBcImNvcmFsXCIsIFwiY29ybmZsb3dlcmJsdWVcIiwgXCJjb3Juc2lsa1wiLCBcImNyaW1zb25cIiwgXCJjeWFuXCIsIFwiZGFya2JsdWVcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtnb2xkZW5yb2RcIiwgXCJkYXJrZ3JheVwiLCBcImRhcmtncmVlblwiLCBcImRhcmtraGFraVwiLCBcImRhcmttYWdlbnRhXCIsIFwiZGFya29saXZlZ3JlZW5cIiwgXCJkYXJrb3JhbmdlXCIsIFwiZGFya29yY2hpZFwiLCBcImRhcmtyZWRcIiwgXCJkYXJrc2FsbW9uXCIsIFwiZGFya3NlYWdyZWVuXCIsIFwiZGFya3NsYXRlYmx1ZVwiLCBcImRhcmtzbGF0ZWdyYXlcIiwgXCJkYXJrdHVycXVvaXNlXCIsIFwiZGFya3Zpb2xldFwiLCBcImRlZXBwaW5rXCIsIFwiZGVlcHNreWJsdWVcIiwgXCJkaW1ncmF5XCIsIFwiZG9kZ2VyYmx1ZVwiLCBcImZpcmVicmlja1wiLCBcImZsb3JhbHdoaXRlXCIsIFwiZm9yZXN0Z3JlZW5cIiwgXCJmdWNoc2lhXCIsIFwiZ2FpbnNib3JvXCIsIFwiZ2hvc3R3aGl0ZVwiLCBcImdvbGRcIiwgXCJnb2xkZW5yb2RcIiwgXCJncmF5XCIsIFwiZ3JleVwiLCBcImdyZWVuXCIsIFwiZ3JlZW55ZWxsb3dcIiwgXCJob25leWRld1wiLCBcImhvdHBpbmtcIiwgXCJpbmRpYW5yZWRcIiwgXCJpbmRpZ29cIiwgXCJpdm9yeVwiLCBcImtoYWtpXCIsIFwibGF2ZW5kZXJcIiwgXCJsYXZlbmRlcmJsdXNoXCIsIFwibGF3bmdyZWVuXCIsIFwibGVtb25jaGlmZm9uXCIsIFwibGlnaHRibHVlXCIsIFwibGlnaHRjb3JhbFwiLCBcImxpZ2h0Y3lhblwiLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsIFwibGlnaHRncmF5XCIsIFwibGlnaHRncmVlblwiLCBcImxpZ2h0cGlua1wiLCBcImxpZ2h0c2FsbW9uXCIsIFwibGlnaHRzZWFncmVlblwiLCBcImxpZ2h0c2t5Ymx1ZVwiLCBcImxpZ2h0c2xhdGVncmF5XCIsIFwibGlnaHRzdGVlbGJsdWVcIiwgXCJsaWdodHllbGxvd1wiLCBcImxpbWVcIiwgXCJsaW1lZ3JlZW5cIiwgXCJsaW5lblwiLCBcIm1hZ2VudGFcIiwgXCJtYXJvb25cIiwgXCJtZWRpdW1hcXVhbWFyaW5lXCIsIFwibWVkaXVtYmx1ZVwiLCBcIm1lZGl1bW9yY2hpZFwiLCBcIm1lZGl1bXB1cnBsZVwiLCBcIm1lZGl1bXNlYWdyZWVuXCIsIFwibWVkaXVtc2xhdGVibHVlXCIsIFwibWVkaXVtc3ByaW5nZ3JlZW5cIiwgXCJtZWRpdW10dXJxdW9pc2VcIiwgXCJtZWRpdW12aW9sZXRyZWRcIiwgXCJtaWRuaWdodGJsdWVcIiwgXCJtaW50Y3JlYW1cIiwgXCJtaXN0eXJvc2VcIiwgXCJtb2NjYXNpblwiLCBcIm5hdmFqb3doaXRlXCIsIFwibmF2eVwiLCBcIm9sZGxhY2VcIiwgXCJvbGl2ZVwiLCBcIm9saXZlZHJhYlwiLCBcIm9yYW5nZVwiLCBcIm9yYW5nZXJlZFwiLCBcIm9yY2hpZFwiLCBcInBhbGVnb2xkZW5yb2RcIiwgXCJwYWxlZ3JlZW5cIiwgXCJwYWxldHVycXVvaXNlXCIsIFwicGFsZXZpb2xldHJlZFwiLCBcInBhcGF5YXdoaXBcIiwgXCJwZWFjaHB1ZmZcIiwgXCJwZXJ1XCIsIFwicGlua1wiLCBcInBsdW1cIiwgXCJwb3dkZXJibHVlXCIsIFwicHVycGxlXCIsIFwicmViZWNjYXB1cnBsZVwiLCBcInJlZFwiLCBcInJvc3licm93blwiLCBcInJveWFsYmx1ZVwiLCBcInNhZGRsZWJyb3duXCIsIFwic2FsbW9uXCIsIFwic2FuZHlicm93blwiLCBcInNlYWdyZWVuXCIsIFwic2Vhc2hlbGxcIiwgXCJzaWVubmFcIiwgXCJzaWx2ZXJcIiwgXCJza3libHVlXCIsIFwic2xhdGVibHVlXCIsIFwic2xhdGVncmF5XCIsIFwic25vd1wiLCBcInNwcmluZ2dyZWVuXCIsIFwic3RlZWxibHVlXCIsIFwidGFuXCIsIFwidGVhbFwiLCBcInRoaXN0bGVcIiwgXCJ0b21hdG9cIiwgXCJ0dXJxdW9pc2VcIiwgXCJ2aW9sZXRcIiwgXCJ3aGVhdFwiLCBcIndoaXRlXCIsIFwid2hpdGVzbW9rZVwiLCBcInllbGxvd1wiLCBcInllbGxvd2dyZWVuXCJdLFxuICAgICAgY29sb3JLZXl3b3JkcyA9IGtleVNldChjb2xvcktleXdvcmRzXyk7XG5cbiAgdmFyIHZhbHVlS2V5d29yZHNfID0gW1wiYWJvdmVcIiwgXCJhYnNvbHV0ZVwiLCBcImFjdGl2ZWJvcmRlclwiLCBcImFkZGl0aXZlXCIsIFwiYWN0aXZlY2FwdGlvblwiLCBcImFmYXJcIiwgXCJhZnRlci13aGl0ZS1zcGFjZVwiLCBcImFoZWFkXCIsIFwiYWxpYXNcIiwgXCJhbGxcIiwgXCJhbGwtc2Nyb2xsXCIsIFwiYWxwaGFiZXRpY1wiLCBcImFsdGVybmF0ZVwiLCBcImFsd2F5c1wiLCBcImFtaGFyaWNcIiwgXCJhbWhhcmljLWFiZWdlZGVcIiwgXCJhbnRpYWxpYXNlZFwiLCBcImFwcHdvcmtzcGFjZVwiLCBcImFyYWJpYy1pbmRpY1wiLCBcImFybWVuaWFuXCIsIFwiYXN0ZXJpc2tzXCIsIFwiYXR0clwiLCBcImF1dG9cIiwgXCJhdm9pZFwiLCBcImF2b2lkLWNvbHVtblwiLCBcImF2b2lkLXBhZ2VcIiwgXCJhdm9pZC1yZWdpb25cIiwgXCJiYWNrZ3JvdW5kXCIsIFwiYmFja3dhcmRzXCIsIFwiYmFzZWxpbmVcIiwgXCJiZWxvd1wiLCBcImJpZGktb3ZlcnJpZGVcIiwgXCJiaW5hcnlcIiwgXCJiZW5nYWxpXCIsIFwiYmxpbmtcIiwgXCJibG9ja1wiLCBcImJsb2NrLWF4aXNcIiwgXCJib2xkXCIsIFwiYm9sZGVyXCIsIFwiYm9yZGVyXCIsIFwiYm9yZGVyLWJveFwiLCBcImJvdGhcIiwgXCJib3R0b21cIiwgXCJicmVha1wiLCBcImJyZWFrLWFsbFwiLCBcImJyZWFrLXdvcmRcIiwgXCJidWxsZXRzXCIsIFwiYnV0dG9uXCIsIFwiYnV0dG9uLWJldmVsXCIsIFwiYnV0dG9uZmFjZVwiLCBcImJ1dHRvbmhpZ2hsaWdodFwiLCBcImJ1dHRvbnNoYWRvd1wiLCBcImJ1dHRvbnRleHRcIiwgXCJjYWxjXCIsIFwiY2FtYm9kaWFuXCIsIFwiY2FwaXRhbGl6ZVwiLCBcImNhcHMtbG9jay1pbmRpY2F0b3JcIiwgXCJjYXB0aW9uXCIsIFwiY2FwdGlvbnRleHRcIiwgXCJjYXJldFwiLCBcImNlbGxcIiwgXCJjZW50ZXJcIiwgXCJjaGVja2JveFwiLCBcImNpcmNsZVwiLCBcImNqay1kZWNpbWFsXCIsIFwiY2prLWVhcnRobHktYnJhbmNoXCIsIFwiY2prLWhlYXZlbmx5LXN0ZW1cIiwgXCJjamstaWRlb2dyYXBoaWNcIiwgXCJjbGVhclwiLCBcImNsaXBcIiwgXCJjbG9zZS1xdW90ZVwiLCBcImNvbC1yZXNpemVcIiwgXCJjb2xsYXBzZVwiLCBcImNvbG9yXCIsIFwiY29sb3ItYnVyblwiLCBcImNvbG9yLWRvZGdlXCIsIFwiY29sdW1uXCIsIFwiY29sdW1uLXJldmVyc2VcIiwgXCJjb21wYWN0XCIsIFwiY29uZGVuc2VkXCIsIFwiY29udGFpblwiLCBcImNvbnRlbnRcIiwgXCJjb250ZW50LWJveFwiLCBcImNvbnRleHQtbWVudVwiLCBcImNvbnRpbnVvdXNcIiwgXCJjb3B5XCIsIFwiY291bnRlclwiLCBcImNvdW50ZXJzXCIsIFwiY292ZXJcIiwgXCJjcm9wXCIsIFwiY3Jvc3NcIiwgXCJjcm9zc2hhaXJcIiwgXCJjdXJyZW50Y29sb3JcIiwgXCJjdXJzaXZlXCIsIFwiY3ljbGljXCIsIFwiZGFya2VuXCIsIFwiZGFzaGVkXCIsIFwiZGVjaW1hbFwiLCBcImRlY2ltYWwtbGVhZGluZy16ZXJvXCIsIFwiZGVmYXVsdFwiLCBcImRlZmF1bHQtYnV0dG9uXCIsIFwiZGVuc2VcIiwgXCJkZXN0aW5hdGlvbi1hdG9wXCIsIFwiZGVzdGluYXRpb24taW5cIiwgXCJkZXN0aW5hdGlvbi1vdXRcIiwgXCJkZXN0aW5hdGlvbi1vdmVyXCIsIFwiZGV2YW5hZ2FyaVwiLCBcImRpZmZlcmVuY2VcIiwgXCJkaXNjXCIsIFwiZGlzY2FyZFwiLCBcImRpc2Nsb3N1cmUtY2xvc2VkXCIsIFwiZGlzY2xvc3VyZS1vcGVuXCIsIFwiZG9jdW1lbnRcIiwgXCJkb3QtZGFzaFwiLCBcImRvdC1kb3QtZGFzaFwiLCBcImRvdHRlZFwiLCBcImRvdWJsZVwiLCBcImRvd25cIiwgXCJlLXJlc2l6ZVwiLCBcImVhc2VcIiwgXCJlYXNlLWluXCIsIFwiZWFzZS1pbi1vdXRcIiwgXCJlYXNlLW91dFwiLCBcImVsZW1lbnRcIiwgXCJlbGxpcHNlXCIsIFwiZWxsaXBzaXNcIiwgXCJlbWJlZFwiLCBcImVuZFwiLCBcImV0aGlvcGljXCIsIFwiZXRoaW9waWMtYWJlZ2VkZVwiLCBcImV0aGlvcGljLWFiZWdlZGUtYW0tZXRcIiwgXCJldGhpb3BpYy1hYmVnZWRlLWdlelwiLCBcImV0aGlvcGljLWFiZWdlZGUtdGktZXJcIiwgXCJldGhpb3BpYy1hYmVnZWRlLXRpLWV0XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtYWEtZXJcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1hYS1ldFwiLCBcImV0aGlvcGljLWhhbGVoYW1lLWFtLWV0XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtZ2V6XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtb20tZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1zaWQtZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1zby1ldFwiLCBcImV0aGlvcGljLWhhbGVoYW1lLXRpLWVyXCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtdGktZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS10aWdcIiwgXCJldGhpb3BpYy1udW1lcmljXCIsIFwiZXctcmVzaXplXCIsIFwiZXhjbHVzaW9uXCIsIFwiZXhwYW5kZWRcIiwgXCJleHRlbmRzXCIsIFwiZXh0cmEtY29uZGVuc2VkXCIsIFwiZXh0cmEtZXhwYW5kZWRcIiwgXCJmYW50YXN5XCIsIFwiZmFzdFwiLCBcImZpbGxcIiwgXCJmaXhlZFwiLCBcImZsYXRcIiwgXCJmbGV4XCIsIFwiZmxleC1lbmRcIiwgXCJmbGV4LXN0YXJ0XCIsIFwiZm9vdG5vdGVzXCIsIFwiZm9yd2FyZHNcIiwgXCJmcm9tXCIsIFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsIFwiZ2VvcmdpYW5cIiwgXCJncmF5dGV4dFwiLCBcImdyaWRcIiwgXCJncm9vdmVcIiwgXCJndWphcmF0aVwiLCBcImd1cm11a2hpXCIsIFwiaGFuZFwiLCBcImhhbmd1bFwiLCBcImhhbmd1bC1jb25zb25hbnRcIiwgXCJoYXJkLWxpZ2h0XCIsIFwiaGVicmV3XCIsIFwiaGVscFwiLCBcImhpZGRlblwiLCBcImhpZGVcIiwgXCJoaWdoZXJcIiwgXCJoaWdobGlnaHRcIiwgXCJoaWdobGlnaHR0ZXh0XCIsIFwiaGlyYWdhbmFcIiwgXCJoaXJhZ2FuYS1pcm9oYVwiLCBcImhvcml6b250YWxcIiwgXCJoc2xcIiwgXCJoc2xhXCIsIFwiaHVlXCIsIFwiaWNvblwiLCBcImlnbm9yZVwiLCBcImluYWN0aXZlYm9yZGVyXCIsIFwiaW5hY3RpdmVjYXB0aW9uXCIsIFwiaW5hY3RpdmVjYXB0aW9udGV4dFwiLCBcImluZmluaXRlXCIsIFwiaW5mb2JhY2tncm91bmRcIiwgXCJpbmZvdGV4dFwiLCBcImluaGVyaXRcIiwgXCJpbml0aWFsXCIsIFwiaW5saW5lXCIsIFwiaW5saW5lLWF4aXNcIiwgXCJpbmxpbmUtYmxvY2tcIiwgXCJpbmxpbmUtZmxleFwiLCBcImlubGluZS1ncmlkXCIsIFwiaW5saW5lLXRhYmxlXCIsIFwiaW5zZXRcIiwgXCJpbnNpZGVcIiwgXCJpbnRyaW5zaWNcIiwgXCJpbnZlcnRcIiwgXCJpdGFsaWNcIiwgXCJqYXBhbmVzZS1mb3JtYWxcIiwgXCJqYXBhbmVzZS1pbmZvcm1hbFwiLCBcImp1c3RpZnlcIiwgXCJrYW5uYWRhXCIsIFwia2F0YWthbmFcIiwgXCJrYXRha2FuYS1pcm9oYVwiLCBcImtlZXAtYWxsXCIsIFwia2htZXJcIiwgXCJrb3JlYW4taGFuZ3VsLWZvcm1hbFwiLCBcImtvcmVhbi1oYW5qYS1mb3JtYWxcIiwgXCJrb3JlYW4taGFuamEtaW5mb3JtYWxcIiwgXCJsYW5kc2NhcGVcIiwgXCJsYW9cIiwgXCJsYXJnZVwiLCBcImxhcmdlclwiLCBcImxlZnRcIiwgXCJsZXZlbFwiLCBcImxpZ2h0ZXJcIiwgXCJsaWdodGVuXCIsIFwibGluZS10aHJvdWdoXCIsIFwibGluZWFyXCIsIFwibGluZWFyLWdyYWRpZW50XCIsIFwibGluZXNcIiwgXCJsaXN0LWl0ZW1cIiwgXCJsaXN0Ym94XCIsIFwibGlzdGl0ZW1cIiwgXCJsb2NhbFwiLCBcImxvZ2ljYWxcIiwgXCJsb3VkXCIsIFwibG93ZXJcIiwgXCJsb3dlci1hbHBoYVwiLCBcImxvd2VyLWFybWVuaWFuXCIsIFwibG93ZXItZ3JlZWtcIiwgXCJsb3dlci1oZXhhZGVjaW1hbFwiLCBcImxvd2VyLWxhdGluXCIsIFwibG93ZXItbm9yd2VnaWFuXCIsIFwibG93ZXItcm9tYW5cIiwgXCJsb3dlcmNhc2VcIiwgXCJsdHJcIiwgXCJsdW1pbm9zaXR5XCIsIFwibWFsYXlhbGFtXCIsIFwibWF0Y2hcIiwgXCJtYXRyaXhcIiwgXCJtYXRyaXgzZFwiLCBcIm1lZGlhLWNvbnRyb2xzLWJhY2tncm91bmRcIiwgXCJtZWRpYS1jdXJyZW50LXRpbWUtZGlzcGxheVwiLCBcIm1lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uXCIsIFwibWVkaWEtbXV0ZS1idXR0b25cIiwgXCJtZWRpYS1wbGF5LWJ1dHRvblwiLCBcIm1lZGlhLXJldHVybi10by1yZWFsdGltZS1idXR0b25cIiwgXCJtZWRpYS1yZXdpbmQtYnV0dG9uXCIsIFwibWVkaWEtc2Vlay1iYWNrLWJ1dHRvblwiLCBcIm1lZGlhLXNlZWstZm9yd2FyZC1idXR0b25cIiwgXCJtZWRpYS1zbGlkZXJcIiwgXCJtZWRpYS1zbGlkZXJ0aHVtYlwiLCBcIm1lZGlhLXRpbWUtcmVtYWluaW5nLWRpc3BsYXlcIiwgXCJtZWRpYS12b2x1bWUtc2xpZGVyXCIsIFwibWVkaWEtdm9sdW1lLXNsaWRlci1jb250YWluZXJcIiwgXCJtZWRpYS12b2x1bWUtc2xpZGVydGh1bWJcIiwgXCJtZWRpdW1cIiwgXCJtZW51XCIsIFwibWVudWxpc3RcIiwgXCJtZW51bGlzdC1idXR0b25cIiwgXCJtZW51bGlzdC10ZXh0XCIsIFwibWVudWxpc3QtdGV4dGZpZWxkXCIsIFwibWVudXRleHRcIiwgXCJtZXNzYWdlLWJveFwiLCBcIm1pZGRsZVwiLCBcIm1pbi1pbnRyaW5zaWNcIiwgXCJtaXhcIiwgXCJtb25nb2xpYW5cIiwgXCJtb25vc3BhY2VcIiwgXCJtb3ZlXCIsIFwibXVsdGlwbGVcIiwgXCJtdWx0aXBseVwiLCBcIm15YW5tYXJcIiwgXCJuLXJlc2l6ZVwiLCBcIm5hcnJvd2VyXCIsIFwibmUtcmVzaXplXCIsIFwibmVzdy1yZXNpemVcIiwgXCJuby1jbG9zZS1xdW90ZVwiLCBcIm5vLWRyb3BcIiwgXCJuby1vcGVuLXF1b3RlXCIsIFwibm8tcmVwZWF0XCIsIFwibm9uZVwiLCBcIm5vcm1hbFwiLCBcIm5vdC1hbGxvd2VkXCIsIFwibm93cmFwXCIsIFwibnMtcmVzaXplXCIsIFwibnVtYmVyc1wiLCBcIm51bWVyaWNcIiwgXCJudy1yZXNpemVcIiwgXCJud3NlLXJlc2l6ZVwiLCBcIm9ibGlxdWVcIiwgXCJvY3RhbFwiLCBcIm9wZW4tcXVvdGVcIiwgXCJvcHRpbWl6ZUxlZ2liaWxpdHlcIiwgXCJvcHRpbWl6ZVNwZWVkXCIsIFwib3JpeWFcIiwgXCJvcm9tb1wiLCBcIm91dHNldFwiLCBcIm91dHNpZGVcIiwgXCJvdXRzaWRlLXNoYXBlXCIsIFwib3ZlcmxheVwiLCBcIm92ZXJsaW5lXCIsIFwicGFkZGluZ1wiLCBcInBhZGRpbmctYm94XCIsIFwicGFpbnRlZFwiLCBcInBhZ2VcIiwgXCJwYXVzZWRcIiwgXCJwZXJzaWFuXCIsIFwicGVyc3BlY3RpdmVcIiwgXCJwbHVzLWRhcmtlclwiLCBcInBsdXMtbGlnaHRlclwiLCBcInBvaW50ZXJcIiwgXCJwb2x5Z29uXCIsIFwicG9ydHJhaXRcIiwgXCJwcmVcIiwgXCJwcmUtbGluZVwiLCBcInByZS13cmFwXCIsIFwicHJlc2VydmUtM2RcIiwgXCJwcm9ncmVzc1wiLCBcInB1c2gtYnV0dG9uXCIsIFwicmFkaWFsLWdyYWRpZW50XCIsIFwicmFkaW9cIiwgXCJyZWFkLW9ubHlcIiwgXCJyZWFkLXdyaXRlXCIsIFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLCBcInJlY3RhbmdsZVwiLCBcInJlZ2lvblwiLCBcInJlbGF0aXZlXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudFwiLCBcInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIFwicmVzZXRcIiwgXCJyZXZlcnNlXCIsIFwicmdiXCIsIFwicmdiYVwiLCBcInJpZGdlXCIsIFwicmlnaHRcIiwgXCJyb3RhdGVcIiwgXCJyb3RhdGUzZFwiLCBcInJvdGF0ZVhcIiwgXCJyb3RhdGVZXCIsIFwicm90YXRlWlwiLCBcInJvdW5kXCIsIFwicm93XCIsIFwicm93LXJlc2l6ZVwiLCBcInJvdy1yZXZlcnNlXCIsIFwicnRsXCIsIFwicnVuLWluXCIsIFwicnVubmluZ1wiLCBcInMtcmVzaXplXCIsIFwic2Fucy1zZXJpZlwiLCBcInNhdHVyYXRpb25cIiwgXCJzY2FsZVwiLCBcInNjYWxlM2RcIiwgXCJzY2FsZVhcIiwgXCJzY2FsZVlcIiwgXCJzY2FsZVpcIiwgXCJzY3JlZW5cIiwgXCJzY3JvbGxcIiwgXCJzY3JvbGxiYXJcIiwgXCJzZS1yZXNpemVcIiwgXCJzZWFyY2hmaWVsZFwiLCBcInNlYXJjaGZpZWxkLWNhbmNlbC1idXR0b25cIiwgXCJzZWFyY2hmaWVsZC1kZWNvcmF0aW9uXCIsIFwic2VhcmNoZmllbGQtcmVzdWx0cy1idXR0b25cIiwgXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWRlY29yYXRpb25cIiwgXCJzZW1pLWNvbmRlbnNlZFwiLCBcInNlbWktZXhwYW5kZWRcIiwgXCJzZXBhcmF0ZVwiLCBcInNlcmlmXCIsIFwic2hvd1wiLCBcInNpZGFtYVwiLCBcInNpbXAtY2hpbmVzZS1mb3JtYWxcIiwgXCJzaW1wLWNoaW5lc2UtaW5mb3JtYWxcIiwgXCJzaW5nbGVcIiwgXCJza2V3XCIsIFwic2tld1hcIiwgXCJza2V3WVwiLCBcInNraXAtd2hpdGUtc3BhY2VcIiwgXCJzbGlkZVwiLCBcInNsaWRlci1ob3Jpem9udGFsXCIsIFwic2xpZGVyLXZlcnRpY2FsXCIsIFwic2xpZGVydGh1bWItaG9yaXpvbnRhbFwiLCBcInNsaWRlcnRodW1iLXZlcnRpY2FsXCIsIFwic2xvd1wiLCBcInNtYWxsXCIsIFwic21hbGwtY2Fwc1wiLCBcInNtYWxsLWNhcHRpb25cIiwgXCJzbWFsbGVyXCIsIFwic29mdC1saWdodFwiLCBcInNvbGlkXCIsIFwic29tYWxpXCIsIFwic291cmNlLWF0b3BcIiwgXCJzb3VyY2UtaW5cIiwgXCJzb3VyY2Utb3V0XCIsIFwic291cmNlLW92ZXJcIiwgXCJzcGFjZVwiLCBcInNwYWNlLWFyb3VuZFwiLCBcInNwYWNlLWJldHdlZW5cIiwgXCJzcGVsbC1vdXRcIiwgXCJzcXVhcmVcIiwgXCJzcXVhcmUtYnV0dG9uXCIsIFwic3RhcnRcIiwgXCJzdGF0aWNcIiwgXCJzdGF0dXMtYmFyXCIsIFwic3RyZXRjaFwiLCBcInN0cm9rZVwiLCBcInN1YlwiLCBcInN1YnBpeGVsLWFudGlhbGlhc2VkXCIsIFwic3VwZXJcIiwgXCJzdy1yZXNpemVcIiwgXCJzeW1ib2xpY1wiLCBcInN5bWJvbHNcIiwgXCJ0YWJsZVwiLCBcInRhYmxlLWNhcHRpb25cIiwgXCJ0YWJsZS1jZWxsXCIsIFwidGFibGUtY29sdW1uXCIsIFwidGFibGUtY29sdW1uLWdyb3VwXCIsIFwidGFibGUtZm9vdGVyLWdyb3VwXCIsIFwidGFibGUtaGVhZGVyLWdyb3VwXCIsIFwidGFibGUtcm93XCIsIFwidGFibGUtcm93LWdyb3VwXCIsIFwidGFtaWxcIiwgXCJ0ZWx1Z3VcIiwgXCJ0ZXh0XCIsIFwidGV4dC1ib3R0b21cIiwgXCJ0ZXh0LXRvcFwiLCBcInRleHRhcmVhXCIsIFwidGV4dGZpZWxkXCIsIFwidGhhaVwiLCBcInRoaWNrXCIsIFwidGhpblwiLCBcInRocmVlZGRhcmtzaGFkb3dcIiwgXCJ0aHJlZWRmYWNlXCIsIFwidGhyZWVkaGlnaGxpZ2h0XCIsIFwidGhyZWVkbGlnaHRzaGFkb3dcIiwgXCJ0aHJlZWRzaGFkb3dcIiwgXCJ0aWJldGFuXCIsIFwidGlncmVcIiwgXCJ0aWdyaW55YS1lclwiLCBcInRpZ3JpbnlhLWVyLWFiZWdlZGVcIiwgXCJ0aWdyaW55YS1ldFwiLCBcInRpZ3JpbnlhLWV0LWFiZWdlZGVcIiwgXCJ0b1wiLCBcInRvcFwiLCBcInRyYWQtY2hpbmVzZS1mb3JtYWxcIiwgXCJ0cmFkLWNoaW5lc2UtaW5mb3JtYWxcIiwgXCJ0cmFuc2xhdGVcIiwgXCJ0cmFuc2xhdGUzZFwiLCBcInRyYW5zbGF0ZVhcIiwgXCJ0cmFuc2xhdGVZXCIsIFwidHJhbnNsYXRlWlwiLCBcInRyYW5zcGFyZW50XCIsIFwidWx0cmEtY29uZGVuc2VkXCIsIFwidWx0cmEtZXhwYW5kZWRcIiwgXCJ1bmRlcmxpbmVcIiwgXCJ1cFwiLCBcInVwcGVyLWFscGhhXCIsIFwidXBwZXItYXJtZW5pYW5cIiwgXCJ1cHBlci1ncmVla1wiLCBcInVwcGVyLWhleGFkZWNpbWFsXCIsIFwidXBwZXItbGF0aW5cIiwgXCJ1cHBlci1ub3J3ZWdpYW5cIiwgXCJ1cHBlci1yb21hblwiLCBcInVwcGVyY2FzZVwiLCBcInVyZHVcIiwgXCJ1cmxcIiwgXCJ2YXJcIiwgXCJ2ZXJ0aWNhbFwiLCBcInZlcnRpY2FsLXRleHRcIiwgXCJ2aXNpYmxlXCIsIFwidmlzaWJsZUZpbGxcIiwgXCJ2aXNpYmxlUGFpbnRlZFwiLCBcInZpc2libGVTdHJva2VcIiwgXCJ2aXN1YWxcIiwgXCJ3LXJlc2l6ZVwiLCBcIndhaXRcIiwgXCJ3YXZlXCIsIFwid2lkZXJcIiwgXCJ3aW5kb3dcIiwgXCJ3aW5kb3dmcmFtZVwiLCBcIndpbmRvd3RleHRcIiwgXCJ3b3Jkc1wiLCBcIndyYXBcIiwgXCJ3cmFwLXJldmVyc2VcIiwgXCJ4LWxhcmdlXCIsIFwieC1zbWFsbFwiLCBcInhvclwiLCBcInh4LWxhcmdlXCIsIFwieHgtc21hbGxcIl0sXG4gICAgICB2YWx1ZUtleXdvcmRzID0ga2V5U2V0KHZhbHVlS2V5d29yZHNfKTtcblxuICB2YXIgYWxsV29yZHMgPSBkb2N1bWVudFR5cGVzXy5jb25jYXQobWVkaWFUeXBlc18pLmNvbmNhdChtZWRpYUZlYXR1cmVzXykuY29uY2F0KG1lZGlhVmFsdWVLZXl3b3Jkc18pLmNvbmNhdChwcm9wZXJ0eUtleXdvcmRzXykuY29uY2F0KG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkc18pLmNvbmNhdChjb2xvcktleXdvcmRzXykuY29uY2F0KHZhbHVlS2V5d29yZHNfKTtcbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBcImNzc1wiLCBhbGxXb3Jkcyk7XG5cbiAgZnVuY3Rpb24gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsXG4gICAgICAgIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gY2ggPT0gXCIqXCI7XG4gICAgfVxuICAgIHJldHVybiBbXCJjb21tZW50XCIsIFwiY29tbWVudFwiXTtcbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvY3NzXCIsIHtcbiAgICBkb2N1bWVudFR5cGVzOiBkb2N1bWVudFR5cGVzLFxuICAgIG1lZGlhVHlwZXM6IG1lZGlhVHlwZXMsXG4gICAgbWVkaWFGZWF0dXJlczogbWVkaWFGZWF0dXJlcyxcbiAgICBtZWRpYVZhbHVlS2V5d29yZHM6IG1lZGlhVmFsdWVLZXl3b3JkcyxcbiAgICBwcm9wZXJ0eUtleXdvcmRzOiBwcm9wZXJ0eUtleXdvcmRzLFxuICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkczogbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzLFxuICAgIGZvbnRQcm9wZXJ0aWVzOiBmb250UHJvcGVydGllcyxcbiAgICBjb3VudGVyRGVzY3JpcHRvcnM6IGNvdW50ZXJEZXNjcmlwdG9ycyxcbiAgICBjb2xvcktleXdvcmRzOiBjb2xvcktleXdvcmRzLFxuICAgIHZhbHVlS2V5d29yZHM6IHZhbHVlS2V5d29yZHMsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCJcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXNjc3NcIiwge1xuICAgIG1lZGlhVHlwZXM6IG1lZGlhVHlwZXMsXG4gICAgbWVkaWFGZWF0dXJlczogbWVkaWFGZWF0dXJlcyxcbiAgICBtZWRpYVZhbHVlS2V5d29yZHM6IG1lZGlhVmFsdWVLZXl3b3JkcyxcbiAgICBwcm9wZXJ0eUtleXdvcmRzOiBwcm9wZXJ0eUtleXdvcmRzLFxuICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkczogbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzLFxuICAgIGNvbG9yS2V5d29yZHM6IGNvbG9yS2V5d29yZHMsXG4gICAgdmFsdWVLZXl3b3JkczogdmFsdWVLZXl3b3JkcyxcbiAgICBmb250UHJvcGVydGllczogZm9udFByb3BlcnRpZXMsXG4gICAgYWxsb3dOZXN0ZWQ6IHRydWUsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gW1wiY29tbWVudFwiLCBcImNvbW1lbnRcIl07XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ0NvbW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtcIm9wZXJhdG9yXCIsIFwib3BlcmF0b3JcIl07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIjpcIjogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFx7LykpIHJldHVybiBbbnVsbCwgXCJ7XCJdO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgXCIkXCI6IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eW1xcdy1dKy8pO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxzKjovLCBmYWxzZSkpIHJldHVybiBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGUtZGVmaW5pdGlvblwiXTtcbiAgICAgICAgcmV0dXJuIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZVwiXTtcbiAgICAgIH0sXG4gICAgICBcIiNcIjogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCJ7XCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBbbnVsbCwgXCJpbnRlcnBvbGF0aW9uXCJdO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogXCJjc3NcIixcbiAgICBoZWxwZXJUeXBlOiBcInNjc3NcIlxuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtbGVzc1wiLCB7XG4gICAgbWVkaWFUeXBlczogbWVkaWFUeXBlcyxcbiAgICBtZWRpYUZlYXR1cmVzOiBtZWRpYUZlYXR1cmVzLFxuICAgIG1lZGlhVmFsdWVLZXl3b3JkczogbWVkaWFWYWx1ZUtleXdvcmRzLFxuICAgIHByb3BlcnR5S2V5d29yZHM6IHByb3BlcnR5S2V5d29yZHMsXG4gICAgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzOiBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMsXG4gICAgY29sb3JLZXl3b3JkczogY29sb3JLZXl3b3JkcyxcbiAgICB2YWx1ZUtleXdvcmRzOiB2YWx1ZUtleXdvcmRzLFxuICAgIGZvbnRQcm9wZXJ0aWVzOiBmb250UHJvcGVydGllcyxcbiAgICBhbGxvd05lc3RlZDogdHJ1ZSxcbiAgICB0b2tlbkhvb2tzOiB7XG4gICAgICBcIi9cIjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBbXCJjb21tZW50XCIsIFwiY29tbWVudFwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW1wib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiQFwiOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwie1wiKSkgcmV0dXJuIFtudWxsLCBcImludGVycG9sYXRpb25cIl07XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14oY2hhcnNldHxkb2N1bWVudHxmb250LWZhY2V8aW1wb3J0fCgtKG1venxtc3xvfHdlYmtpdCktKT9rZXlmcmFtZXN8bWVkaWF8bmFtZXNwYWNlfHBhZ2V8c3VwcG9ydHMpXFxiLywgZmFsc2UpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqOi8sIGZhbHNlKSkgcmV0dXJuIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZS1kZWZpbml0aW9uXCJdO1xuICAgICAgICByZXR1cm4gW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlXCJdO1xuICAgICAgfSxcbiAgICAgIFwiJlwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXCJhdG9tXCIsIFwiYXRvbVwiXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgaGVscGVyVHlwZTogXCJsZXNzXCJcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWdzc1wiLCB7XG4gICAgZG9jdW1lbnRUeXBlczogZG9jdW1lbnRUeXBlcyxcbiAgICBtZWRpYVR5cGVzOiBtZWRpYVR5cGVzLFxuICAgIG1lZGlhRmVhdHVyZXM6IG1lZGlhRmVhdHVyZXMsXG4gICAgcHJvcGVydHlLZXl3b3JkczogcHJvcGVydHlLZXl3b3JkcyxcbiAgICBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHM6IG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyxcbiAgICBmb250UHJvcGVydGllczogZm9udFByb3BlcnRpZXMsXG4gICAgY291bnRlckRlc2NyaXB0b3JzOiBjb3VudGVyRGVzY3JpcHRvcnMsXG4gICAgY29sb3JLZXl3b3JkczogY29sb3JLZXl3b3JkcyxcbiAgICB2YWx1ZUtleXdvcmRzOiB2YWx1ZUtleXdvcmRzLFxuICAgIHN1cHBvcnRzQXRDb21wb25lbnQ6IHRydWUsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgaGVscGVyVHlwZTogXCJnc3NcIlxuICB9KTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb2RlbWlycm9yL21vZGUvY3NzL2Nzcy5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==');
},59:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\nThe following batches are equivalent:\n\nvar beautify_js = require('js-beautify');\nvar beautify_js = require('js-beautify').js;\nvar beautify_js = require('js-beautify').js_beautify;\n\nvar beautify_css = require('js-beautify').css;\nvar beautify_css = require('js-beautify').css_beautify;\n\nvar beautify_html = require('js-beautify').html;\nvar beautify_html = require('js-beautify').html_beautify;\n\nAll methods returned accept two arguments, the source string and an options object.\n**/\n\nfunction get_beautify(js_beautify, css_beautify, html_beautify) {\n    // the default is js\n    var beautify = function (src, config) {\n        return js_beautify.js_beautify(src, config);\n    };\n\n    // short aliases\n    beautify.js = js_beautify.js_beautify;\n    beautify.css = css_beautify.css_beautify;\n    beautify.html = html_beautify.html_beautify;\n\n    // legacy aliases\n    beautify.js_beautify = js_beautify.js_beautify;\n    beautify.css_beautify = css_beautify.css_beautify;\n    beautify.html_beautify = html_beautify.html_beautify;\n\n    return beautify;\n}\n\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(60), __webpack_require__(61), __webpack_require__(62)], __WEBPACK_AMD_DEFINE_RESULT__ = function (js_beautify, css_beautify, html_beautify) {\n        return get_beautify(js_beautify, css_beautify, html_beautify);\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n    (function (mod) {\n        var js_beautify = require('./lib/beautify');\n        var css_beautify = require('./lib/beautify-css');\n        var html_beautify = require('./lib/beautify-html');\n\n        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);\n    })(module);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzLWJlYXV0aWZ5L2pzL2luZGV4LmpzP2U2OWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5UaGUgZm9sbG93aW5nIGJhdGNoZXMgYXJlIGVxdWl2YWxlbnQ6XG5cbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5Jyk7XG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmpzO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzO1xudmFyIGJlYXV0aWZ5X2NzcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuY3NzX2JlYXV0aWZ5O1xuXG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbDtcbnZhciBiZWF1dGlmeV9odG1sID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5odG1sX2JlYXV0aWZ5O1xuXG5BbGwgbWV0aG9kcyByZXR1cm5lZCBhY2NlcHQgdHdvIGFyZ3VtZW50cywgdGhlIHNvdXJjZSBzdHJpbmcgYW5kIGFuIG9wdGlvbnMgb2JqZWN0LlxuKiovXG5cbmZ1bmN0aW9uIGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KSB7XG4gICAgLy8gdGhlIGRlZmF1bHQgaXMganNcbiAgICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbiAoc3JjLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5KHNyYywgY29uZmlnKTtcbiAgICB9O1xuXG4gICAgLy8gc2hvcnQgYWxpYXNlc1xuICAgIGJlYXV0aWZ5LmpzID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gICAgYmVhdXRpZnkuY3NzID0gY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeTtcbiAgICBiZWF1dGlmeS5odG1sID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gICAgLy8gbGVnYWN5IGFsaWFzZXNcbiAgICBiZWF1dGlmeS5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICAgIGJlYXV0aWZ5LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gICAgYmVhdXRpZnkuaHRtbF9iZWF1dGlmeSA9IGh0bWxfYmVhdXRpZnkuaHRtbF9iZWF1dGlmeTtcblxuICAgIHJldHVybiBiZWF1dGlmeTtcbn1cblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtcIi4vbGliL2JlYXV0aWZ5XCIsIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsIFwiLi9saWIvYmVhdXRpZnktaHRtbFwiXSwgZnVuY3Rpb24gKGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnksIGh0bWxfYmVhdXRpZnkpIHtcbiAgICAgICAgcmV0dXJuIGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KTtcbiAgICB9KTtcbn0gZWxzZSB7XG4gICAgKGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgdmFyIGpzX2JlYXV0aWZ5ID0gcmVxdWlyZSgnLi9saWIvYmVhdXRpZnknKTtcbiAgICAgICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vbGliL2JlYXV0aWZ5LWNzcycpO1xuICAgICAgICB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoJy4vbGliL2JlYXV0aWZ5LWh0bWwnKTtcblxuICAgICAgICBtb2QuZXhwb3J0cyA9IGdldF9iZWF1dGlmeShqc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LCBodG1sX2JlYXV0aWZ5KTtcbiAgICB9KShtb2R1bGUpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcy1iZWF1dGlmeS9qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==")},60:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false *//*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@jsbeautifier.org>\n      http://jsbeautifier.org/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse-preserve-inline\" | \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/// Object.values polyfill found here:\n// http://tokenposts.blogspot.com.au/2012/04/javascript-objectkeys-browser.html\nif(!Object.values){Object.values=function(o){if(o!==Object(o)){throw new TypeError('Object.values called on a non-object');}var k=[],p;for(p in o){if(Object.prototype.hasOwnProperty.call(o,p)){k.push(o[p]);}}return k;};}(function(){function js_beautify(js_source_text,options){var acorn={};(function(exports){/* jshint curly: false */// This section of code is taken from acorn.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n// ## Character categories\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\nvar nonASCIIwhitespace=/[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;// jshint ignore:line\nvar nonASCIIidentifierStartChars=\"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";var nonASCIIidentifierChars=\"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";var nonASCIIidentifierStart=new RegExp(\"[\"+nonASCIIidentifierStartChars+\"]\");var nonASCIIidentifier=new RegExp(\"[\"+nonASCIIidentifierStartChars+nonASCIIidentifierChars+\"]\");// Whether a single character denotes a newline.\nexports.newline=/[\\n\\r\\u2028\\u2029]/;// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n// in javascript, these two differ\n// in python they are the same, different methods are called on them\nexports.lineBreak=new RegExp('\\r\\n|'+exports.newline.source);exports.allLineBreaks=new RegExp(exports.lineBreak.source,'g');// Test whether a given character code starts an identifier.\nexports.isIdentifierStart=function(code){// permit $ (36) and @ (64). @ is used in ES7 decorators.\nif(code<65)return code===36||code===64;// 65 through 91 are uppercase letters.\nif(code<91)return true;// permit _ (95).\nif(code<97)return code===95;// 97 through 123 are lowercase letters.\nif(code<123)return true;return code>=0xaa&&nonASCIIidentifierStart.test(String.fromCharCode(code));};// Test whether a given character is part of an identifier.\nexports.isIdentifierChar=function(code){if(code<48)return code===36;if(code<58)return true;if(code<65)return false;if(code<91)return true;if(code<97)return code===95;if(code<123)return true;return code>=0xaa&&nonASCIIidentifier.test(String.fromCharCode(code));};})(acorn);/* jshint curly: true */function in_array(what,arr){for(var i=0;i<arr.length;i+=1){if(arr[i]===what){return true;}}return false;}function trim(s){return s.replace(/^\\s+|\\s+$/g,'');}function ltrim(s){return s.replace(/^\\s+/g,'');}// function rtrim(s) {\n//     return s.replace(/\\s+$/g, '');\n// }\nfunction sanitizeOperatorPosition(opPosition){opPosition=opPosition||OPERATOR_POSITION.before_newline;var validPositionValues=Object.values(OPERATOR_POSITION);if(!in_array(opPosition,validPositionValues)){throw new Error(\"Invalid Option Value: The option 'operator_position' must be one of the following values\\n\"+validPositionValues+\"\\nYou passed in: '\"+opPosition+\"'\");}return opPosition;}var OPERATOR_POSITION={before_newline:'before-newline',after_newline:'after-newline',preserve_newline:'preserve-newline'};var OPERATOR_POSITION_BEFORE_OR_PRESERVE=[OPERATOR_POSITION.before_newline,OPERATOR_POSITION.preserve_newline];var MODE={BlockStatement:'BlockStatement',// 'BLOCK'\nStatement:'Statement',// 'STATEMENT'\nObjectLiteral:'ObjectLiteral',// 'OBJECT',\nArrayLiteral:'ArrayLiteral',//'[EXPRESSION]',\nForInitializer:'ForInitializer',//'(FOR-EXPRESSION)',\nConditional:'Conditional',//'(COND-EXPRESSION)',\nExpression:'Expression'//'(EXPRESSION)'\n};function Beautifier(js_source_text,options){\"use strict\";var output;var tokens=[],token_pos;var Tokenizer;var current_token;var last_type,last_last_text,indent_string;var flags,previous_flags,flag_store;var prefix;var handlers,opt;var baseIndentString='';handlers={'TK_START_EXPR':handle_start_expr,'TK_END_EXPR':handle_end_expr,'TK_START_BLOCK':handle_start_block,'TK_END_BLOCK':handle_end_block,'TK_WORD':handle_word,'TK_RESERVED':handle_word,'TK_SEMICOLON':handle_semicolon,'TK_STRING':handle_string,'TK_EQUALS':handle_equals,'TK_OPERATOR':handle_operator,'TK_COMMA':handle_comma,'TK_BLOCK_COMMENT':handle_block_comment,'TK_COMMENT':handle_comment,'TK_DOT':handle_dot,'TK_UNKNOWN':handle_unknown,'TK_EOF':handle_eof};function create_flags(flags_base,mode){var next_indent_level=0;if(flags_base){next_indent_level=flags_base.indentation_level;if(!output.just_added_newline()&&flags_base.line_indent_level>next_indent_level){next_indent_level=flags_base.line_indent_level;}}var next_flags={mode:mode,parent:flags_base,last_text:flags_base?flags_base.last_text:'',// last token text\nlast_word:flags_base?flags_base.last_word:'',// last 'TK_WORD' passed\ndeclaration_statement:false,declaration_assignment:false,multiline_frame:false,inline_frame:false,if_block:false,else_block:false,do_block:false,do_while:false,import_block:false,in_case_statement:false,// switch(..){ INSIDE HERE }\nin_case:false,// we're on the exact line with \"case 0:\"\ncase_body:false,// the indented case-action block\nindentation_level:next_indent_level,line_indent_level:flags_base?flags_base.line_indent_level:next_indent_level,start_line_index:output.get_line_number(),ternary_depth:0};return next_flags;}// Some interpreters have unexpected results with foo = baz || bar;\noptions=options?options:{};opt={};// compatibility\nif(options.braces_on_own_line!==undefined){//graceful handling of deprecated option\nopt.brace_style=options.braces_on_own_line?\"expand\":\"collapse\";}opt.brace_style=options.brace_style?options.brace_style:opt.brace_style?opt.brace_style:\"collapse\";// graceful handling of deprecated option\nif(opt.brace_style===\"expand-strict\"){opt.brace_style=\"expand\";}opt.indent_size=options.indent_size?parseInt(options.indent_size,10):4;opt.indent_char=options.indent_char?options.indent_char:' ';opt.eol=options.eol?options.eol:'auto';opt.preserve_newlines=options.preserve_newlines===undefined?true:options.preserve_newlines;opt.break_chained_methods=options.break_chained_methods===undefined?false:options.break_chained_methods;opt.max_preserve_newlines=options.max_preserve_newlines===undefined?0:parseInt(options.max_preserve_newlines,10);opt.space_in_paren=options.space_in_paren===undefined?false:options.space_in_paren;opt.space_in_empty_paren=options.space_in_empty_paren===undefined?false:options.space_in_empty_paren;opt.jslint_happy=options.jslint_happy===undefined?false:options.jslint_happy;opt.space_after_anon_function=options.space_after_anon_function===undefined?false:options.space_after_anon_function;opt.keep_array_indentation=options.keep_array_indentation===undefined?false:options.keep_array_indentation;opt.space_before_conditional=options.space_before_conditional===undefined?true:options.space_before_conditional;opt.unescape_strings=options.unescape_strings===undefined?false:options.unescape_strings;opt.wrap_line_length=options.wrap_line_length===undefined?0:parseInt(options.wrap_line_length,10);opt.e4x=options.e4x===undefined?false:options.e4x;opt.end_with_newline=options.end_with_newline===undefined?false:options.end_with_newline;opt.comma_first=options.comma_first===undefined?false:options.comma_first;opt.operator_position=sanitizeOperatorPosition(options.operator_position);// For testing of beautify ignore:start directive\nopt.test_output_raw=options.test_output_raw===undefined?false:options.test_output_raw;// force opt.space_after_anon_function to true if opt.jslint_happy\nif(opt.jslint_happy){opt.space_after_anon_function=true;}if(options.indent_with_tabs){opt.indent_char='\\t';opt.indent_size=1;}if(opt.eol==='auto'){opt.eol='\\n';if(js_source_text&&acorn.lineBreak.test(js_source_text||'')){opt.eol=js_source_text.match(acorn.lineBreak)[0];}}opt.eol=opt.eol.replace(/\\\\r/,'\\r').replace(/\\\\n/,'\\n');//----------------------------------\nindent_string='';while(opt.indent_size>0){indent_string+=opt.indent_char;opt.indent_size-=1;}var preindent_index=0;if(js_source_text&&js_source_text.length){while(js_source_text.charAt(preindent_index)===' '||js_source_text.charAt(preindent_index)==='\\t'){baseIndentString+=js_source_text.charAt(preindent_index);preindent_index+=1;}js_source_text=js_source_text.substring(preindent_index);}last_type='TK_START_BLOCK';// last token type\nlast_last_text='';// pre-last token text\noutput=new Output(indent_string,baseIndentString);// If testing the ignore directive, start with output disable set to true\noutput.raw=opt.test_output_raw;// Stack of parsing/formatting states, including MODE.\n// We tokenize, parse, and output in an almost purely a forward-only stream of token input\n// and formatted output.  This makes the beautifier less accurate than full parsers\n// but also far more tolerant of syntax errors.\n//\n// For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n// MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n// encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n// most full parsers would die, but the beautifier gracefully falls back to\n// MODE.BlockStatement and continues on.\nflag_store=[];set_mode(MODE.BlockStatement);this.beautify=function(){/*jshint onevar:true */var local_token,sweet_code;Tokenizer=new tokenizer(js_source_text,opt,indent_string);tokens=Tokenizer.tokenize();token_pos=0;function get_local_token(){local_token=get_token();return local_token;}while(get_local_token()){for(var i=0;i<local_token.comments_before.length;i++){// The cleanest handling of inline comments is to treat them as though they aren't there.\n// Just continue formatting and the behavior should be logical.\n// Also ignore unknown tokens.  Again, this should result in better behavior.\nhandle_token(local_token.comments_before[i]);}handle_token(local_token);last_last_text=flags.last_text;last_type=local_token.type;flags.last_text=local_token.text;token_pos+=1;}sweet_code=output.get_code();if(opt.end_with_newline){sweet_code+='\\n';}if(opt.eol!=='\\n'){sweet_code=sweet_code.replace(/[\\n]/g,opt.eol);}return sweet_code;};function handle_token(local_token){var newlines=local_token.newlines;var keep_whitespace=opt.keep_array_indentation&&is_array(flags.mode);if(keep_whitespace){for(var i=0;i<newlines;i+=1){print_newline(i>0);}}else{if(opt.max_preserve_newlines&&newlines>opt.max_preserve_newlines){newlines=opt.max_preserve_newlines;}if(opt.preserve_newlines){if(local_token.newlines>1){print_newline();for(var j=1;j<newlines;j+=1){print_newline(true);}}}}current_token=local_token;handlers[current_token.type]();}// we could use just string.split, but\n// IE doesn't like returning empty strings\nfunction split_linebreaks(s){//return s.split(/\\x0d\\x0a|\\x0a/);\ns=s.replace(acorn.allLineBreaks,'\\n');var out=[],idx=s.indexOf(\"\\n\");while(idx!==-1){out.push(s.substring(0,idx));s=s.substring(idx+1);idx=s.indexOf(\"\\n\");}if(s.length){out.push(s);}return out;}var newline_restricted_tokens=['break','continue','return','throw'];function allow_wrap_or_preserved_newline(force_linewrap){force_linewrap=force_linewrap===undefined?false:force_linewrap;// Never wrap the first token on a line\nif(output.just_added_newline()){return;}var shouldPreserveOrForce=opt.preserve_newlines&&current_token.wanted_newline||force_linewrap;var operatorLogicApplies=in_array(flags.last_text,Tokenizer.positionable_operators)||in_array(current_token.text,Tokenizer.positionable_operators);if(operatorLogicApplies){var shouldPrintOperatorNewline=in_array(flags.last_text,Tokenizer.positionable_operators)&&in_array(opt.operator_position,OPERATOR_POSITION_BEFORE_OR_PRESERVE)||in_array(current_token.text,Tokenizer.positionable_operators);shouldPreserveOrForce=shouldPreserveOrForce&&shouldPrintOperatorNewline;}if(shouldPreserveOrForce){print_newline(false,true);}else if(opt.wrap_line_length){if(last_type==='TK_RESERVED'&&in_array(flags.last_text,newline_restricted_tokens)){// These tokens should never have a newline inserted\n// between them and the following expression.\nreturn;}var proposed_line_length=output.current_line.get_character_count()+current_token.text.length+(output.space_before_token?1:0);if(proposed_line_length>=opt.wrap_line_length){print_newline(false,true);}}}function print_newline(force_newline,preserve_statement_flags){if(!preserve_statement_flags){if(flags.last_text!==';'&&flags.last_text!==','&&flags.last_text!=='='&&last_type!=='TK_OPERATOR'){while(flags.mode===MODE.Statement&&!flags.if_block&&!flags.do_block){restore_mode();}}}if(output.add_new_line(force_newline)){flags.multiline_frame=true;}}function print_token_line_indentation(){if(output.just_added_newline()){if(opt.keep_array_indentation&&is_array(flags.mode)&&current_token.wanted_newline){output.current_line.push(current_token.whitespace_before);output.space_before_token=false;}else if(output.set_indent(flags.indentation_level)){flags.line_indent_level=flags.indentation_level;}}}function print_token(printable_token){if(output.raw){output.add_raw_token(current_token);return;}if(opt.comma_first&&last_type==='TK_COMMA'&&output.just_added_newline()){if(output.previous_line.last()===','){var popped=output.previous_line.pop();// if the comma was already at the start of the line,\n// pull back onto that line and reprint the indentation\nif(output.previous_line.is_empty()){output.previous_line.push(popped);output.trim(true);output.current_line.pop();output.trim();}// add the comma in front of the next token\nprint_token_line_indentation();output.add_token(',');output.space_before_token=true;}}printable_token=printable_token||current_token.text;print_token_line_indentation();output.add_token(printable_token);}function indent(){flags.indentation_level+=1;}function deindent(){if(flags.indentation_level>0&&(!flags.parent||flags.indentation_level>flags.parent.indentation_level)){flags.indentation_level-=1;}}function set_mode(mode){if(flags){flag_store.push(flags);previous_flags=flags;}else{previous_flags=create_flags(null,mode);}flags=create_flags(previous_flags,mode);}function is_array(mode){return mode===MODE.ArrayLiteral;}function is_expression(mode){return in_array(mode,[MODE.Expression,MODE.ForInitializer,MODE.Conditional]);}function restore_mode(){if(flag_store.length>0){previous_flags=flags;flags=flag_store.pop();if(previous_flags.mode===MODE.Statement){output.remove_redundant_indentation(previous_flags);}}}function start_of_object_property(){return flags.parent.mode===MODE.ObjectLiteral&&flags.mode===MODE.Statement&&(flags.last_text===':'&&flags.ternary_depth===0||last_type==='TK_RESERVED'&&in_array(flags.last_text,['get','set']));}function start_of_statement(){if(last_type==='TK_RESERVED'&&in_array(flags.last_text,['var','let','const'])&&current_token.type==='TK_WORD'||last_type==='TK_RESERVED'&&flags.last_text==='do'||last_type==='TK_RESERVED'&&in_array(flags.last_text,['return','throw'])&&!current_token.wanted_newline||last_type==='TK_RESERVED'&&flags.last_text==='else'&&!(current_token.type==='TK_RESERVED'&&current_token.text==='if')||last_type==='TK_END_EXPR'&&(previous_flags.mode===MODE.ForInitializer||previous_flags.mode===MODE.Conditional)||last_type==='TK_WORD'&&flags.mode===MODE.BlockStatement&&!flags.in_case&&!(current_token.text==='--'||current_token.text==='++')&&last_last_text!=='function'&&current_token.type!=='TK_WORD'&&current_token.type!=='TK_RESERVED'||flags.mode===MODE.ObjectLiteral&&(flags.last_text===':'&&flags.ternary_depth===0||last_type==='TK_RESERVED'&&in_array(flags.last_text,['get','set']))){set_mode(MODE.Statement);indent();if(last_type==='TK_RESERVED'&&in_array(flags.last_text,['var','let','const'])&&current_token.type==='TK_WORD'){flags.declaration_statement=true;}// Issue #276:\n// If starting a new statement with [if, for, while, do], push to a new line.\n// if (a) if (b) if(c) d(); else e(); else f();\nif(!start_of_object_property()){allow_wrap_or_preserved_newline(current_token.type==='TK_RESERVED'&&in_array(current_token.text,['do','for','if','while']));}return true;}return false;}function all_lines_start_with(lines,c){for(var i=0;i<lines.length;i++){var line=trim(lines[i]);if(line.charAt(0)!==c){return false;}}return true;}function each_line_matches_indent(lines,indent){var i=0,len=lines.length,line;for(;i<len;i++){line=lines[i];// allow empty lines to pass through\nif(line&&line.indexOf(indent)!==0){return false;}}return true;}function is_special_word(word){return in_array(word,['case','return','do','if','throw','else']);}function get_token(offset){var index=token_pos+(offset||0);return index<0||index>=tokens.length?null:tokens[index];}function handle_start_expr(){if(start_of_statement()){// The conditional starts the statement if appropriate.\n}var next_mode=MODE.Expression;if(current_token.text==='['){if(last_type==='TK_WORD'||flags.last_text===')'){// this is array index specifier, break immediately\n// a[x], fn()[x]\nif(last_type==='TK_RESERVED'&&in_array(flags.last_text,Tokenizer.line_starters)){output.space_before_token=true;}set_mode(next_mode);print_token();indent();if(opt.space_in_paren){output.space_before_token=true;}return;}next_mode=MODE.ArrayLiteral;if(is_array(flags.mode)){if(flags.last_text==='['||flags.last_text===','&&(last_last_text===']'||last_last_text==='}')){// ], [ goes to new line\n// }, [ goes to new line\nif(!opt.keep_array_indentation){print_newline();}}}}else{if(last_type==='TK_RESERVED'&&flags.last_text==='for'){next_mode=MODE.ForInitializer;}else if(last_type==='TK_RESERVED'&&in_array(flags.last_text,['if','while'])){next_mode=MODE.Conditional;}else{// next_mode = MODE.Expression;\n}}if(flags.last_text===';'||last_type==='TK_START_BLOCK'){print_newline();}else if(last_type==='TK_END_EXPR'||last_type==='TK_START_EXPR'||last_type==='TK_END_BLOCK'||flags.last_text==='.'){// TODO: Consider whether forcing this is required.  Review failing tests when removed.\nallow_wrap_or_preserved_newline(current_token.wanted_newline);// do nothing on (( and )( and ][ and ]( and .(\n}else if(!(last_type==='TK_RESERVED'&&current_token.text==='(')&&last_type!=='TK_WORD'&&last_type!=='TK_OPERATOR'){output.space_before_token=true;}else if(last_type==='TK_RESERVED'&&(flags.last_word==='function'||flags.last_word==='typeof')||flags.last_text==='*'&&(in_array(last_last_text,['function','yield'])||flags.mode===MODE.ObjectLiteral&&in_array(last_last_text,['{',',']))){// function() vs function ()\n// yield*() vs yield* ()\n// function*() vs function* ()\nif(opt.space_after_anon_function){output.space_before_token=true;}}else if(last_type==='TK_RESERVED'&&(in_array(flags.last_text,Tokenizer.line_starters)||flags.last_text==='catch')){if(opt.space_before_conditional){output.space_before_token=true;}}// Should be a space between await and an IIFE\nif(current_token.text==='('&&last_type==='TK_RESERVED'&&flags.last_word==='await'){output.space_before_token=true;}// Support of this kind of newline preservation.\n// a = (b &&\n//     (c || d));\nif(current_token.text==='('){if(last_type==='TK_EQUALS'||last_type==='TK_OPERATOR'){if(!start_of_object_property()){allow_wrap_or_preserved_newline();}}}// Support preserving wrapped arrow function expressions\n// a.b('c',\n//     () => d.e\n// )\nif(current_token.text==='('&&last_type!=='TK_WORD'&&last_type!=='TK_RESERVED'){allow_wrap_or_preserved_newline();}set_mode(next_mode);print_token();if(opt.space_in_paren){output.space_before_token=true;}// In all cases, if we newline while inside an expression it should be indented.\nindent();}function handle_end_expr(){// statements inside expressions are not valid syntax, but...\n// statements must all be closed when their container closes\nwhile(flags.mode===MODE.Statement){restore_mode();}if(flags.multiline_frame){allow_wrap_or_preserved_newline(current_token.text===']'&&is_array(flags.mode)&&!opt.keep_array_indentation);}if(opt.space_in_paren){if(last_type==='TK_START_EXPR'&&!opt.space_in_empty_paren){// () [] no inner space in empty parens like these, ever, ref #320\noutput.trim();output.space_before_token=false;}else{output.space_before_token=true;}}if(current_token.text===']'&&opt.keep_array_indentation){print_token();restore_mode();}else{restore_mode();print_token();}output.remove_redundant_indentation(previous_flags);// do {} while () // no statement required after\nif(flags.do_while&&previous_flags.mode===MODE.Conditional){previous_flags.mode=MODE.Expression;flags.do_block=false;flags.do_while=false;}}function handle_start_block(){// Check if this is should be treated as a ObjectLiteral\nvar next_token=get_token(1);var second_token=get_token(2);if(second_token&&(in_array(second_token.text,[':',','])&&in_array(next_token.type,['TK_STRING','TK_WORD','TK_RESERVED'])||in_array(next_token.text,['get','set'])&&in_array(second_token.type,['TK_WORD','TK_RESERVED']))){// We don't support TypeScript,but we didn't break it for a very long time.\n// We'll try to keep not breaking it.\nif(!in_array(last_last_text,['class','interface'])){set_mode(MODE.ObjectLiteral);}else{set_mode(MODE.BlockStatement);}}else if(last_type==='TK_OPERATOR'&&flags.last_text==='=>'){// arrow function: (param1, paramN) => { statements }\nset_mode(MODE.BlockStatement);}else if(in_array(last_type,['TK_EQUALS','TK_START_EXPR','TK_COMMA','TK_OPERATOR'])||last_type==='TK_RESERVED'&&in_array(flags.last_text,['return','throw','import','default'])){// Detecting shorthand function syntax is difficult by scanning forward,\n//     so check the surrounding context.\n// If the block is being returned, imported, export default, passed as arg,\n//     assigned with = or assigned in a nested object, treat as an ObjectLiteral.\nset_mode(MODE.ObjectLiteral);}else{set_mode(MODE.BlockStatement);}var empty_braces=!next_token.comments_before.length&&next_token.text==='}';var empty_anonymous_function=empty_braces&&flags.last_word==='function'&&last_type==='TK_END_EXPR';if(opt.brace_style===\"expand\"||opt.brace_style===\"none\"&&current_token.wanted_newline){if(last_type!=='TK_OPERATOR'&&(empty_anonymous_function||last_type==='TK_EQUALS'||last_type==='TK_RESERVED'&&is_special_word(flags.last_text)&&flags.last_text!=='else')){output.space_before_token=true;}else{print_newline(false,true);}}else{// collapse\nif(opt.brace_style==='collapse-preserve-inline'){// search forward for a newline wanted inside this block\nvar index=0;var check_token=null;flags.inline_frame=true;do{index+=1;check_token=get_token(index);if(check_token.wanted_newline){flags.inline_frame=false;break;}}while(check_token.type!=='TK_EOF'&&!(check_token.type==='TK_END_BLOCK'&&check_token.opened===current_token));}if(is_array(previous_flags.mode)&&(last_type==='TK_START_EXPR'||last_type==='TK_COMMA')){// if we're preserving inline,\n// allow newline between comma and next brace.\nif(last_type==='TK_COMMA'||opt.space_in_paren){output.space_before_token=true;}if(opt.brace_style==='collapse-preserve-inline'&&(last_type==='TK_COMMA'||last_type==='TK_START_EXPR'&&flags.inline_frame)){allow_wrap_or_preserved_newline();previous_flags.multiline_frame=previous_flags.multiline_frame||flags.multiline_frame;flags.multiline_frame=false;}}else if(last_type!=='TK_OPERATOR'&&last_type!=='TK_START_EXPR'){if(last_type==='TK_START_BLOCK'){print_newline();}else{output.space_before_token=true;}}}print_token();indent();}function handle_end_block(){// statements must all be closed when their container closes\nwhile(flags.mode===MODE.Statement){restore_mode();}var empty_braces=last_type==='TK_START_BLOCK';if(opt.brace_style===\"expand\"){if(!empty_braces){print_newline();}}else{// skip {}\nif(!empty_braces){if(flags.inline_frame){output.space_before_token=true;}else if(is_array(flags.mode)&&opt.keep_array_indentation){// we REALLY need a newline here, but newliner would skip that\nopt.keep_array_indentation=false;print_newline();opt.keep_array_indentation=true;}else{print_newline();}}}restore_mode();print_token();}function handle_word(){if(current_token.type==='TK_RESERVED'){if(in_array(current_token.text,['set','get'])&&flags.mode!==MODE.ObjectLiteral){current_token.type='TK_WORD';}else if(in_array(current_token.text,['as','from'])&&!flags.import_block){current_token.type='TK_WORD';}else if(flags.mode===MODE.ObjectLiteral){var next_token=get_token(1);if(next_token.text===':'){current_token.type='TK_WORD';}}}if(start_of_statement()){// The conditional starts the statement if appropriate.\n}else if(current_token.wanted_newline&&!is_expression(flags.mode)&&(last_type!=='TK_OPERATOR'||flags.last_text==='--'||flags.last_text==='++')&&last_type!=='TK_EQUALS'&&(opt.preserve_newlines||!(last_type==='TK_RESERVED'&&in_array(flags.last_text,['var','let','const','set','get'])))){print_newline();}if(flags.do_block&&!flags.do_while){if(current_token.type==='TK_RESERVED'&&current_token.text==='while'){// do {} ## while ()\noutput.space_before_token=true;print_token();output.space_before_token=true;flags.do_while=true;return;}else{// do {} should always have while as the next word.\n// if we don't see the expected while, recover\nprint_newline();flags.do_block=false;}}// if may be followed by else, or not\n// Bare/inline ifs are tricky\n// Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\nif(flags.if_block){if(!flags.else_block&&current_token.type==='TK_RESERVED'&&current_token.text==='else'){flags.else_block=true;}else{while(flags.mode===MODE.Statement){restore_mode();}flags.if_block=false;flags.else_block=false;}}if(current_token.type==='TK_RESERVED'&&(current_token.text==='case'||current_token.text==='default'&&flags.in_case_statement)){print_newline();if(flags.case_body||opt.jslint_happy){// switch cases following one another\ndeindent();flags.case_body=false;}print_token();flags.in_case=true;flags.in_case_statement=true;return;}if(current_token.type==='TK_RESERVED'&&current_token.text==='function'){if(in_array(flags.last_text,['}',';'])||output.just_added_newline()&&!in_array(flags.last_text,['[','{',':','=',','])){// make sure there is a nice clean space of at least one blank line\n// before a new function definition\nif(!output.just_added_blankline()&&!current_token.comments_before.length){print_newline();print_newline(true);}}if(last_type==='TK_RESERVED'||last_type==='TK_WORD'){if(last_type==='TK_RESERVED'&&in_array(flags.last_text,['get','set','new','return','export','async'])){output.space_before_token=true;}else if(last_type==='TK_RESERVED'&&flags.last_text==='default'&&last_last_text==='export'){output.space_before_token=true;}else{print_newline();}}else if(last_type==='TK_OPERATOR'||flags.last_text==='='){// foo = function\noutput.space_before_token=true;}else if(!flags.multiline_frame&&(is_expression(flags.mode)||is_array(flags.mode))){// (function\n}else{print_newline();}}if(last_type==='TK_COMMA'||last_type==='TK_START_EXPR'||last_type==='TK_EQUALS'||last_type==='TK_OPERATOR'){if(!start_of_object_property()){allow_wrap_or_preserved_newline();}}if(current_token.type==='TK_RESERVED'&&in_array(current_token.text,['function','get','set'])){print_token();flags.last_word=current_token.text;return;}prefix='NONE';if(last_type==='TK_END_BLOCK'){if(!(current_token.type==='TK_RESERVED'&&in_array(current_token.text,['else','catch','finally','from']))){prefix='NEWLINE';}else{if(opt.brace_style===\"expand\"||opt.brace_style===\"end-expand\"||opt.brace_style===\"none\"&&current_token.wanted_newline){prefix='NEWLINE';}else{prefix='SPACE';output.space_before_token=true;}}}else if(last_type==='TK_SEMICOLON'&&flags.mode===MODE.BlockStatement){// TODO: Should this be for STATEMENT as well?\nprefix='NEWLINE';}else if(last_type==='TK_SEMICOLON'&&is_expression(flags.mode)){prefix='SPACE';}else if(last_type==='TK_STRING'){prefix='NEWLINE';}else if(last_type==='TK_RESERVED'||last_type==='TK_WORD'||flags.last_text==='*'&&(in_array(last_last_text,['function','yield'])||flags.mode===MODE.ObjectLiteral&&in_array(last_last_text,['{',',']))){prefix='SPACE';}else if(last_type==='TK_START_BLOCK'){if(flags.inline_frame){prefix='SPACE';}else{prefix='NEWLINE';}}else if(last_type==='TK_END_EXPR'){output.space_before_token=true;prefix='NEWLINE';}if(current_token.type==='TK_RESERVED'&&in_array(current_token.text,Tokenizer.line_starters)&&flags.last_text!==')'){if(flags.inline_frame||flags.last_text==='else'||flags.last_text==='export'){prefix='SPACE';}else{prefix='NEWLINE';}}if(current_token.type==='TK_RESERVED'&&in_array(current_token.text,['else','catch','finally'])){if(!(last_type==='TK_END_BLOCK'&&previous_flags.mode===MODE.BlockStatement)||opt.brace_style===\"expand\"||opt.brace_style===\"end-expand\"||opt.brace_style===\"none\"&&current_token.wanted_newline){print_newline();}else{output.trim(true);var line=output.current_line;// If we trimmed and there's something other than a close block before us\n// put a newline back in.  Handles '} // comment' scenario.\nif(line.last()!=='}'){print_newline();}output.space_before_token=true;}}else if(prefix==='NEWLINE'){if(last_type==='TK_RESERVED'&&is_special_word(flags.last_text)){// no newline between 'return nnn'\noutput.space_before_token=true;}else if(last_type!=='TK_END_EXPR'){if((last_type!=='TK_START_EXPR'||!(current_token.type==='TK_RESERVED'&&in_array(current_token.text,['var','let','const'])))&&flags.last_text!==':'){// no need to force newline on 'var': for (var x = 0...)\nif(current_token.type==='TK_RESERVED'&&current_token.text==='if'&&flags.last_text==='else'){// no newline for } else if {\noutput.space_before_token=true;}else{print_newline();}}}else if(current_token.type==='TK_RESERVED'&&in_array(current_token.text,Tokenizer.line_starters)&&flags.last_text!==')'){print_newline();}}else if(flags.multiline_frame&&is_array(flags.mode)&&flags.last_text===','&&last_last_text==='}'){print_newline();// }, in lists get a newline treatment\n}else if(prefix==='SPACE'){output.space_before_token=true;}print_token();flags.last_word=current_token.text;if(current_token.type==='TK_RESERVED'){if(current_token.text==='do'){flags.do_block=true;}else if(current_token.text==='if'){flags.if_block=true;}else if(current_token.text==='import'){flags.import_block=true;}else if(flags.import_block&&current_token.type==='TK_RESERVED'&&current_token.text==='from'){flags.import_block=false;}}}function handle_semicolon(){if(start_of_statement()){// The conditional starts the statement if appropriate.\n// Semicolon can be the start (and end) of a statement\noutput.space_before_token=false;}while(flags.mode===MODE.Statement&&!flags.if_block&&!flags.do_block){restore_mode();}// hacky but effective for the moment\nif(flags.import_block){flags.import_block=false;}print_token();}function handle_string(){if(start_of_statement()){// The conditional starts the statement if appropriate.\n// One difference - strings want at least a space before\noutput.space_before_token=true;}else if(last_type==='TK_RESERVED'||last_type==='TK_WORD'||flags.inline_frame){output.space_before_token=true;}else if(last_type==='TK_COMMA'||last_type==='TK_START_EXPR'||last_type==='TK_EQUALS'||last_type==='TK_OPERATOR'){if(!start_of_object_property()){allow_wrap_or_preserved_newline();}}else{print_newline();}print_token();}function handle_equals(){if(start_of_statement()){// The conditional starts the statement if appropriate.\n}if(flags.declaration_statement){// just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\nflags.declaration_assignment=true;}output.space_before_token=true;print_token();output.space_before_token=true;}function handle_comma(){print_token();output.space_before_token=true;if(flags.declaration_statement){if(is_expression(flags.parent.mode)){// do not break on comma, for(var a = 1, b = 2)\nflags.declaration_assignment=false;}if(flags.declaration_assignment){flags.declaration_assignment=false;print_newline(false,true);}else if(opt.comma_first){// for comma-first, we want to allow a newline before the comma\n// to turn into a newline after the comma, which we will fixup later\nallow_wrap_or_preserved_newline();}}else if(flags.mode===MODE.ObjectLiteral||flags.mode===MODE.Statement&&flags.parent.mode===MODE.ObjectLiteral){if(flags.mode===MODE.Statement){restore_mode();}if(!flags.inline_frame){print_newline();}}else if(opt.comma_first){// EXPR or DO_BLOCK\n// for comma-first, we want to allow a newline before the comma\n// to turn into a newline after the comma, which we will fixup later\nallow_wrap_or_preserved_newline();}}function handle_operator(){if(start_of_statement()){// The conditional starts the statement if appropriate.\n}if(last_type==='TK_RESERVED'&&is_special_word(flags.last_text)){// \"return\" had a special handling in TK_WORD. Now we need to return the favor\noutput.space_before_token=true;print_token();return;}// hack for actionscript's import .*;\nif(current_token.text==='*'&&last_type==='TK_DOT'){print_token();return;}if(current_token.text==='::'){// no spaces around exotic namespacing syntax operator\nprint_token();return;}// Allow line wrapping between operators when operator_position is\n//   set to before or preserve\nif(last_type==='TK_OPERATOR'&&in_array(opt.operator_position,OPERATOR_POSITION_BEFORE_OR_PRESERVE)){allow_wrap_or_preserved_newline();}if(current_token.text===':'&&flags.in_case){flags.case_body=true;indent();print_token();print_newline();flags.in_case=false;return;}var space_before=true;var space_after=true;var in_ternary=false;var isGeneratorAsterisk=current_token.text==='*'&&(last_type==='TK_RESERVED'&&in_array(flags.last_text,['function','yield'])||flags.mode===MODE.ObjectLiteral&&in_array(last_type,['TK_START_BLOCK','TK_COMMA']));var isUnary=in_array(current_token.text,['-','+'])&&(in_array(last_type,['TK_START_BLOCK','TK_START_EXPR','TK_EQUALS','TK_OPERATOR'])||in_array(flags.last_text,Tokenizer.line_starters)||flags.last_text===',');if(current_token.text===':'){if(flags.ternary_depth===0){// Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\nspace_before=false;}else{flags.ternary_depth-=1;in_ternary=true;}}else if(current_token.text==='?'){flags.ternary_depth+=1;}// let's handle the operator_position option prior to any conflicting logic\nif(!isUnary&&!isGeneratorAsterisk&&opt.preserve_newlines&&in_array(current_token.text,Tokenizer.positionable_operators)){var isColon=current_token.text===':';var isTernaryColon=isColon&&in_ternary;var isOtherColon=isColon&&!in_ternary;switch(opt.operator_position){case OPERATOR_POSITION.before_newline:// if the current token is : and it's not a ternary statement then we set space_before to false\noutput.space_before_token=!isOtherColon;print_token();if(!isColon||isTernaryColon){allow_wrap_or_preserved_newline();}output.space_before_token=true;return;case OPERATOR_POSITION.after_newline:// if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,\n//   then print a newline.\noutput.space_before_token=true;if(!isColon||isTernaryColon){if(get_token(1).wanted_newline){print_newline(false,true);}else{allow_wrap_or_preserved_newline();}}else{output.space_before_token=false;}print_token();output.space_before_token=true;return;case OPERATOR_POSITION.preserve_newline:if(!isOtherColon){allow_wrap_or_preserved_newline();}// if we just added a newline, or the current token is : and it's not a ternary statement,\n//   then we set space_before to false\nspace_before=!(output.just_added_newline()||isOtherColon);output.space_before_token=space_before;print_token();output.space_before_token=true;return;}}if(in_array(current_token.text,['--','++','!','~'])||isUnary){// unary operators (and binary +/- pretending to be unary) special cases\nspace_before=false;space_after=false;// http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n// if there is a newline between -- or ++ and anything else we should preserve it.\nif(current_token.wanted_newline&&(current_token.text==='--'||current_token.text==='++')){print_newline(false,true);}if(flags.last_text===';'&&is_expression(flags.mode)){// for (;; ++i)\n//        ^^^\nspace_before=true;}if(last_type==='TK_RESERVED'){space_before=true;}else if(last_type==='TK_END_EXPR'){space_before=!(flags.last_text===']'&&(current_token.text==='--'||current_token.text==='++'));}else if(last_type==='TK_OPERATOR'){// a++ + ++b;\n// a - -b\nspace_before=in_array(current_token.text,['--','-','++','+'])&&in_array(flags.last_text,['--','-','++','+']);// + and - are not unary when preceeded by -- or ++ operator\n// a-- + b\n// a * +b\n// a - -b\nif(in_array(current_token.text,['+','-'])&&in_array(flags.last_text,['--','++'])){space_after=true;}}if((flags.mode===MODE.BlockStatement&&!flags.inline_frame||flags.mode===MODE.Statement)&&(flags.last_text==='{'||flags.last_text===';')){// { foo; --i }\n// foo(); --bar;\nprint_newline();}}else if(isGeneratorAsterisk){allow_wrap_or_preserved_newline();space_before=false;space_after=false;}output.space_before_token=output.space_before_token||space_before;print_token();output.space_before_token=space_after;}function handle_block_comment(){if(output.raw){output.add_raw_token(current_token);if(current_token.directives&&current_token.directives.preserve==='end'){// If we're testing the raw output behavior, do not allow a directive to turn it off.\noutput.raw=opt.test_output_raw;}return;}if(current_token.directives){print_newline(false,true);print_token();if(current_token.directives.preserve==='start'){output.raw=true;}print_newline(false,true);return;}// inline block\nif(!acorn.newline.test(current_token.text)&&!current_token.wanted_newline){output.space_before_token=true;print_token();output.space_before_token=true;return;}var lines=split_linebreaks(current_token.text);var j;// iterator for this case\nvar javadoc=false;var starless=false;var lastIndent=current_token.whitespace_before;var lastIndentLength=lastIndent.length;// block comment starts with a new line\nprint_newline(false,true);if(lines.length>1){javadoc=all_lines_start_with(lines.slice(1),'*');starless=each_line_matches_indent(lines.slice(1),lastIndent);}// first line always indented\nprint_token(lines[0]);for(j=1;j<lines.length;j++){print_newline(false,true);if(javadoc){// javadoc: reformat and re-indent\nprint_token(' '+ltrim(lines[j]));}else if(starless&&lines[j].length>lastIndentLength){// starless: re-indent non-empty content, avoiding trim\nprint_token(lines[j].substring(lastIndentLength));}else{// normal comments output raw\noutput.add_token(lines[j]);}}// for comments of more than one line, make sure there's a new line after\nprint_newline(false,true);}function handle_comment(){if(current_token.wanted_newline){print_newline(false,true);}else{output.trim(true);}output.space_before_token=true;print_token();print_newline(false,true);}function handle_dot(){if(start_of_statement()){// The conditional starts the statement if appropriate.\n}if(last_type==='TK_RESERVED'&&is_special_word(flags.last_text)){output.space_before_token=true;}else{// allow preserved newlines before dots in general\n// force newlines on dots after close paren when break_chained - for bar().baz()\nallow_wrap_or_preserved_newline(flags.last_text===')'&&opt.break_chained_methods);}print_token();}function handle_unknown(){print_token();if(current_token.text[current_token.text.length-1]==='\\n'){print_newline();}}function handle_eof(){// Unwind any open statements\nwhile(flags.mode===MODE.Statement){restore_mode();}}}function OutputLine(parent){var _character_count=0;// use indent_count as a marker for lines that have preserved indentation\nvar _indent_count=-1;var _items=[];var _empty=true;this.set_indent=function(level){_character_count=parent.baseIndentLength+level*parent.indent_length;_indent_count=level;};this.get_character_count=function(){return _character_count;};this.is_empty=function(){return _empty;};this.last=function(){if(!this._empty){return _items[_items.length-1];}else{return null;}};this.push=function(input){_items.push(input);_character_count+=input.length;_empty=false;};this.pop=function(){var item=null;if(!_empty){item=_items.pop();_character_count-=item.length;_empty=_items.length===0;}return item;};this.remove_indent=function(){if(_indent_count>0){_indent_count-=1;_character_count-=parent.indent_length;}};this.trim=function(){while(this.last()===' '){_items.pop();_character_count-=1;}_empty=_items.length===0;};this.toString=function(){var result='';if(!this._empty){if(_indent_count>=0){result=parent.indent_cache[_indent_count];}result+=_items.join('');}return result;};}function Output(indent_string,baseIndentString){baseIndentString=baseIndentString||'';this.indent_cache=[baseIndentString];this.baseIndentLength=baseIndentString.length;this.indent_length=indent_string.length;this.raw=false;var lines=[];this.baseIndentString=baseIndentString;this.indent_string=indent_string;this.previous_line=null;this.current_line=null;this.space_before_token=false;this.add_outputline=function(){this.previous_line=this.current_line;this.current_line=new OutputLine(this);lines.push(this.current_line);};// initialize\nthis.add_outputline();this.get_line_number=function(){return lines.length;};// Using object instead of string to allow for later expansion of info about each line\nthis.add_new_line=function(force_newline){if(this.get_line_number()===1&&this.just_added_newline()){return false;// no newline on start of file\n}if(force_newline||!this.just_added_newline()){if(!this.raw){this.add_outputline();}return true;}return false;};this.get_code=function(){var sweet_code=lines.join('\\n').replace(/[\\r\\n\\t ]+$/,'');return sweet_code;};this.set_indent=function(level){// Never indent your first output indent at the start of the file\nif(lines.length>1){while(level>=this.indent_cache.length){this.indent_cache.push(this.indent_cache[this.indent_cache.length-1]+this.indent_string);}this.current_line.set_indent(level);return true;}this.current_line.set_indent(0);return false;};this.add_raw_token=function(token){for(var x=0;x<token.newlines;x++){this.add_outputline();}this.current_line.push(token.whitespace_before);this.current_line.push(token.text);this.space_before_token=false;};this.add_token=function(printable_token){this.add_space_before_token();this.current_line.push(printable_token);};this.add_space_before_token=function(){if(this.space_before_token&&!this.just_added_newline()){this.current_line.push(' ');}this.space_before_token=false;};this.remove_redundant_indentation=function(frame){// This implementation is effective but has some issues:\n//     - can cause line wrap to happen too soon due to indent removal\n//           after wrap points are calculated\n// These issues are minor compared to ugly indentation.\nif(frame.multiline_frame||frame.mode===MODE.ForInitializer||frame.mode===MODE.Conditional){return;}// remove one indent from each line inside this section\nvar index=frame.start_line_index;var output_length=lines.length;while(index<output_length){lines[index].remove_indent();index++;}};this.trim=function(eat_newlines){eat_newlines=eat_newlines===undefined?false:eat_newlines;this.current_line.trim(indent_string,baseIndentString);while(eat_newlines&&lines.length>1&&this.current_line.is_empty()){lines.pop();this.current_line=lines[lines.length-1];this.current_line.trim();}this.previous_line=lines.length>1?lines[lines.length-2]:null;};this.just_added_newline=function(){return this.current_line.is_empty();};this.just_added_blankline=function(){if(this.just_added_newline()){if(lines.length===1){return true;// start of the file and newline = blank\n}var line=lines[lines.length-2];return line.is_empty();}return false;};}var InputScanner=function(input){var _input=input;var _input_length=_input.length;var _position=0;this.back=function(){_position-=1;};this.hasNext=function(){return _position<_input_length;};this.next=function(){var val=null;if(this.hasNext()){val=_input.charAt(_position);_position+=1;}return val;};this.peek=function(index){var val=null;index=index||0;index+=_position;if(index>=0&&index<_input_length){val=_input.charAt(index);}return val;};this.peekCharCode=function(index){var val=0;index=index||0;index+=_position;if(index>=0&&index<_input_length){val=_input.charCodeAt(index);}return val;};this.test=function(pattern,index){index=index||0;pattern.lastIndex=_position+index;return pattern.test(_input);};this.testChar=function(pattern,index){var val=this.peek(index);return val!==null&&pattern.test(val);};this.match=function(pattern){pattern.lastIndex=_position;var pattern_match=pattern.exec(_input);if(pattern_match&&pattern_match.index===_position){_position+=pattern_match[0].length;}else{pattern_match=null;}return pattern_match;};};var Token=function(type,text,newlines,whitespace_before,parent){this.type=type;this.text=text;this.comments_before=[];this.newlines=newlines||0;this.wanted_newline=newlines>0;this.whitespace_before=whitespace_before||'';this.parent=parent||null;this.opened=null;this.directives=null;};function tokenizer(input_string,opts){var whitespace=\"\\n\\r\\t \".split('');var digit=/[0-9]/;var digit_bin=/[01]/;var digit_oct=/[01234567]/;var digit_hex=/[0123456789abcdefABCDEF]/;this.positionable_operators='!= !== % & && * ** + - / : < << <= == === > >= >> >>> ? ^ | ||'.split(' ');var punct=this.positionable_operators.concat(// non-positionable operators - these do not follow operator position settings\n'! %= &= *= **= ++ += , -- -= /= :: <<= = => >>= >>>= ^= |= ~'.split(' '));// words which should always start on new line.\nthis.line_starters='continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');var reserved_words=this.line_starters.concat(['do','in','else','get','set','new','catch','finally','typeof','yield','async','await','from','as']);//  /* ... */ comment ends with nearest */ or end of file\nvar block_comment_pattern=/([\\s\\S]*?)((?:\\*\\/)|$)/g;// comment ends just before nearest linefeed or end of file\nvar comment_pattern=/([^\\n\\r\\u2028\\u2029]*)/g;var directives_block_pattern=/\\/\\* beautify( \\w+[:]\\w+)+ \\*\\//g;var directive_pattern=/ (\\w+)[:](\\w+)/g;var directives_end_ignore_pattern=/([\\s\\S]*?)((?:\\/\\*\\sbeautify\\signore:end\\s\\*\\/)|$)/g;var template_pattern=/((<\\?php|<\\?=)[\\s\\S]*?\\?>)|(<%[\\s\\S]*?%>)/g;var n_newlines,whitespace_before_token,in_html_comment,tokens;var input;this.tokenize=function(){input=new InputScanner(input_string);in_html_comment=false;tokens=[];var next,last;var token_values;var open=null;var open_stack=[];var comments=[];while(!(last&&last.type==='TK_EOF')){token_values=tokenize_next();next=new Token(token_values[1],token_values[0],n_newlines,whitespace_before_token);while(next.type==='TK_COMMENT'||next.type==='TK_BLOCK_COMMENT'||next.type==='TK_UNKNOWN'){if(next.type==='TK_BLOCK_COMMENT'){next.directives=token_values[2];}comments.push(next);token_values=tokenize_next();next=new Token(token_values[1],token_values[0],n_newlines,whitespace_before_token);}if(comments.length){next.comments_before=comments;comments=[];}if(next.type==='TK_START_BLOCK'||next.type==='TK_START_EXPR'){next.parent=last;open_stack.push(open);open=next;}else if((next.type==='TK_END_BLOCK'||next.type==='TK_END_EXPR')&&open&&(next.text===']'&&open.text==='['||next.text===')'&&open.text==='('||next.text==='}'&&open.text==='{')){next.parent=open.parent;next.opened=open;open=open_stack.pop();}tokens.push(next);last=next;}return tokens;};function get_directives(text){if(!text.match(directives_block_pattern)){return null;}var directives={};directive_pattern.lastIndex=0;var directive_match=directive_pattern.exec(text);while(directive_match){directives[directive_match[1]]=directive_match[2];directive_match=directive_pattern.exec(text);}return directives;}function tokenize_next(){var resulting_string;var whitespace_on_this_line=[];n_newlines=0;whitespace_before_token='';var c=input.next();if(c===null){return['','TK_EOF'];}var last_token;if(tokens.length){last_token=tokens[tokens.length-1];}else{// For the sake of tokenizing we can pretend that there was on open brace to start\nlast_token=new Token('TK_START_BLOCK','{');}while(in_array(c,whitespace)){if(acorn.newline.test(c)){if(!(c==='\\n'&&input.peek(-2)==='\\r')){n_newlines+=1;whitespace_on_this_line=[];}}else{whitespace_on_this_line.push(c);}c=input.next();if(c===null){return['','TK_EOF'];}}if(whitespace_on_this_line.length){whitespace_before_token=whitespace_on_this_line.join('');}if(digit.test(c)||c==='.'&&input.testChar(digit)){var allow_decimal=true;var allow_e=true;var local_digit=digit;if(c==='0'&&input.testChar(/[XxOoBb]/)){// switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits\nallow_decimal=false;allow_e=false;if(input.testChar(/[Bb]/)){local_digit=digit_bin;}else if(input.testChar(/[Oo]/)){local_digit=digit_oct;}else{local_digit=digit_hex;}c+=input.next();}else if(c==='.'){// Already have a decimal for this literal, don't allow another\nallow_decimal=false;}else{// we know this first loop will run.  It keeps the logic simpler.\nc='';input.back();}// Add the digits\nwhile(input.testChar(local_digit)){c+=input.next();if(allow_decimal&&input.peek()==='.'){c+=input.next();allow_decimal=false;}else if(allow_e&&input.testChar(/[Ee]/)){c+=input.next();if(input.testChar(/[+-]/)){c+=input.next();}allow_e=false;allow_decimal=false;}}return[c,'TK_WORD'];}if(acorn.isIdentifierStart(input.peekCharCode(-1))){if(input.hasNext()){while(acorn.isIdentifierChar(input.peekCharCode())){c+=input.next();if(!input.hasNext()){break;}}}if(!(last_token.type==='TK_DOT'||last_token.type==='TK_RESERVED'&&in_array(last_token.text,['set','get']))&&in_array(c,reserved_words)){if(c==='in'){// hack for 'in' operator\nreturn[c,'TK_OPERATOR'];}return[c,'TK_RESERVED'];}return[c,'TK_WORD'];}if(c==='('||c==='['){return[c,'TK_START_EXPR'];}if(c===')'||c===']'){return[c,'TK_END_EXPR'];}if(c==='{'){return[c,'TK_START_BLOCK'];}if(c==='}'){return[c,'TK_END_BLOCK'];}if(c===';'){return[c,'TK_SEMICOLON'];}if(c==='/'){var comment='';var comment_match;// peek for comment /* ... */\nif(input.peek()==='*'){input.next();comment_match=input.match(block_comment_pattern);comment='/*'+comment_match[0];var directives=get_directives(comment);if(directives&&directives.ignore==='start'){comment_match=input.match(directives_end_ignore_pattern);comment+=comment_match[0];}comment=comment.replace(acorn.allLineBreaks,'\\n');return[comment,'TK_BLOCK_COMMENT',directives];}// peek for comment // ...\nif(input.peek()==='/'){input.next();comment_match=input.match(comment_pattern);comment='//'+comment_match[0];return[comment,'TK_COMMENT'];}}var startXmlRegExp=/<()([-a-zA-Z:0-9_.]+|{[\\s\\S]+?}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+{[\\s\\S]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{[\\s\\S]+?}))*\\s*(\\/?)\\s*>/g;if(c==='`'||c===\"'\"||c==='\"'||// string\n(c==='/'||// regexp\nopts.e4x&&c===\"<\"&&input.test(startXmlRegExp,-1)// xml\n)&&(// regex and xml can only appear in specific locations during parsing\nlast_token.type==='TK_RESERVED'&&in_array(last_token.text,['return','case','throw','else','do','typeof','yield'])||last_token.type==='TK_END_EXPR'&&last_token.text===')'&&last_token.parent&&last_token.parent.type==='TK_RESERVED'&&in_array(last_token.parent.text,['if','while','for'])||in_array(last_token.type,['TK_COMMENT','TK_START_EXPR','TK_START_BLOCK','TK_END_BLOCK','TK_OPERATOR','TK_EQUALS','TK_EOF','TK_SEMICOLON','TK_COMMA']))){var sep=c,esc=false,has_char_escapes=false;resulting_string=c;if(sep==='/'){//\n// handle regexp\n//\nvar in_char_class=false;while(input.hasNext()&&(esc||in_char_class||input.peek()!==sep)&&!input.testChar(acorn.newline)){resulting_string+=input.peek();if(!esc){esc=input.peek()==='\\\\';if(input.peek()==='['){in_char_class=true;}else if(input.peek()===']'){in_char_class=false;}}else{esc=false;}input.next();}}else if(opts.e4x&&sep==='<'){//\n// handle e4x xml literals\n//\nvar xmlRegExp=/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[\\s\\S]+?}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+{[\\s\\S]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{[\\s\\S]+?}))*\\s*(\\/?)\\s*>/g;input.back();var xmlStr='';var match=input.match(startXmlRegExp);if(match){// Trim root tag to attempt to\nvar rootTag=match[2].replace(/^{\\s+/,'{').replace(/\\s+}$/,'}');var isCurlyRoot=rootTag.indexOf('{')===0;var depth=0;while(match){var isEndTag=!!match[1];var tagName=match[2];var isSingletonTag=!!match[match.length-1]||tagName.slice(0,8)===\"![CDATA[\";if(!isSingletonTag&&(tagName===rootTag||isCurlyRoot&&tagName.replace(/^{\\s+/,'{').replace(/\\s+}$/,'}'))){if(isEndTag){--depth;}else{++depth;}}xmlStr+=match[0];if(depth<=0){break;}match=input.match(xmlRegExp);}// if we didn't close correctly, keep unformatted.\nif(!match){xmlStr+=input.match(/[\\s\\S]*/g)[0];}xmlStr=xmlStr.replace(acorn.allLineBreaks,'\\n');return[xmlStr,\"TK_STRING\"];}}else{//\n// handle string\n//\nvar parse_string=function(delimiter,allow_unescaped_newlines,start_sub){// Template strings can travers lines without escape characters.\n// Other strings cannot\nvar current_char;while(input.hasNext()){current_char=input.peek();if(!(esc||current_char!==delimiter&&(allow_unescaped_newlines||!acorn.newline.test(current_char)))){break;}// Handle \\r\\n linebreaks after escapes or in template strings\nif((esc||allow_unescaped_newlines)&&acorn.newline.test(current_char)){if(current_char==='\\r'&&input.peek(1)==='\\n'){input.next();current_char=input.peek();}resulting_string+='\\n';}else{resulting_string+=current_char;}if(esc){if(current_char==='x'||current_char==='u'){has_char_escapes=true;}esc=false;}else{esc=current_char==='\\\\';}input.next();if(start_sub&&resulting_string.indexOf(start_sub,resulting_string.length-start_sub.length)!==-1){if(delimiter==='`'){parse_string('}',allow_unescaped_newlines,'`');}else{parse_string('`',allow_unescaped_newlines,'${');}}}};if(sep==='`'){parse_string('`',true,'${');}else{parse_string(sep);}}if(has_char_escapes&&opts.unescape_strings){resulting_string=unescape_string(resulting_string);}if(input.peek()===sep){resulting_string+=sep;input.next();if(sep==='/'){// regexps may have modifiers /regexp/MOD , so fetch those, too\n// Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\nwhile(input.hasNext()&&acorn.isIdentifierStart(input.peekCharCode())){resulting_string+=input.next();}}}return[resulting_string,'TK_STRING'];}if(c==='#'){if(tokens.length===0&&input.peek()==='!'){// shebang\nresulting_string=c;while(input.hasNext()&&c!=='\\n'){c=input.next();resulting_string+=c;}return[trim(resulting_string)+'\\n','TK_UNKNOWN'];}// Spidermonkey-specific sharp variables for circular references\n// https://developer.mozilla.org/En/Sharp_variables_in_JavaScript\n// http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935\nvar sharp='#';if(input.hasNext()&&input.testChar(digit)){do{c=input.next();sharp+=c;}while(input.hasNext()&&c!=='#'&&c!=='=');if(c==='#'){//\n}else if(input.peek()==='['&&input.peek(1)===']'){sharp+='[]';input.next();input.next();}else if(input.peek()==='{'&&input.peek(1)==='}'){sharp+='{}';input.next();input.next();}return[sharp,'TK_WORD'];}}if(c==='<'&&(input.peek()==='?'||input.peek()==='%')){input.back();var template_match=input.match(template_pattern);if(template_match){c=template_match[0];c=c.replace(acorn.allLineBreaks,'\\n');return[c,'TK_STRING'];}}if(c==='<'&&input.match(/\\!--/g)){c='<!--';while(input.hasNext()&&!input.testChar(acorn.newline)){c+=input.next();}in_html_comment=true;return[c,'TK_COMMENT'];}if(c==='-'&&in_html_comment&&input.match(/->/g)){in_html_comment=false;return['-->','TK_COMMENT'];}if(c==='.'){return[c,'TK_DOT'];}if(in_array(c,punct)){while(input.hasNext()&&in_array(c+input.peek(),punct)){c+=input.next();if(!input.hasNext()){break;}}if(c===','){return[c,'TK_COMMA'];}else if(c==='='){return[c,'TK_EQUALS'];}else{return[c,'TK_OPERATOR'];}}return[c,'TK_UNKNOWN'];}function unescape_string(s){// You think that a regex would work for this\n// return s.replace(/\\\\x([0-9a-f]{2})/gi, function(match, val) {\n//         return String.fromCharCode(parseInt(val, 16));\n//     })\n// However, dealing with '\\xff', '\\\\xff', '\\\\\\xff' makes this more fun.\nvar out='',escaped=0;var input_scan=new InputScanner(s);var matched=null;while(input_scan.hasNext()){// Keep any whitespace, non-slash characters\n// also keep slash pairs.\nmatched=input_scan.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g);if(matched){out+=matched[0];}if(input_scan.peek()==='\\\\'){input_scan.next();if(input_scan.peek()==='x'){matched=input_scan.match(/x([0-9A-Fa-f]{2})/g);}else if(input_scan.peek()==='u'){matched=input_scan.match(/u([0-9A-Fa-f]{4})/g);}else{out+='\\\\';if(input_scan.hasNext()){out+=input_scan.next();}continue;}// If there's some error decoding, return the original string\nif(!matched){return s;}escaped=parseInt(matched[1],16);if(escaped>0x7e&&escaped<=0xff&&matched[0].indexOf('x')===0){// we bail out on \\x7f..\\xff,\n// leaving whole string escaped,\n// as it's probably completely binary\nreturn s;}else if(escaped>=0x00&&escaped<0x20){// leave 0x00...0x1f escaped\nout+='\\\\'+matched[0];continue;}else if(escaped===0x22||escaped===0x27||escaped===0x5c){// single-quote, apostrophe, backslash - escape these\nout+='\\\\'+String.fromCharCode(escaped);}else{out+=String.fromCharCode(escaped);}}}return out;}}var beautifier=new Beautifier(js_source_text,options);return beautifier.beautify();}if(true){// Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){return{js_beautify:js_beautify};}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else if(typeof exports!==\"undefined\"){// Add support for CommonJS. Just put this file somewhere on your require.paths\n// and you will be able to `var js_beautify = require(\"beautify\").js_beautify`.\nexports.js_beautify=js_beautify;}else if(typeof window!==\"undefined\"){// If we're running a web page and don't have either of the above, add our one global\nwindow.js_beautify=js_beautify;}else if(typeof global!==\"undefined\"){// If we don't even have window, try global.\nglobal.js_beautify=js_beautify;}})();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS5qcz8zNTdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IGN1cmx5OnRydWUsIGVxZXFlcTp0cnVlLCBsYXhicmVhazp0cnVlLCBub2VtcHR5OmZhbHNlICovLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxMyBFaW5hciBMaWVsbWFuaXMgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4gSlMgQmVhdXRpZmllclxuLS0tLS0tLS0tLS0tLS0tXG5cblxuICBXcml0dGVuIGJ5IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGpzYmVhdXRpZmllci5vcmc+XG4gICAgICBodHRwOi8vanNiZWF1dGlmaWVyLm9yZy9cblxuICBPcmlnaW5hbGx5IGNvbnZlcnRlZCB0byBqYXZhc2NyaXB0IGJ5IFZpdGFsLCA8dml0YWw3NkBnbWFpbC5jb20+XG4gIFwiRW5kIGJyYWNlcyBvbiBvd24gbGluZVwiIGFkZGVkIGJ5IENocmlzIEouIFNodWxsLCA8Y2hyaXNqc2h1bGxAZ21haWwuY29tPlxuICBQYXJzaW5nIGltcHJvdmVtZW50cyBmb3IgYnJhY2UtbGVzcyBzdGF0ZW1lbnRzIGJ5IExpYW0gTmV3bWFuIDxiaXR3aXNlbWFuQGdtYWlsLmNvbT5cblxuXG4gIFVzYWdlOlxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0KTtcbiAgICBqc19iZWF1dGlmeShqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9zaXplIChkZWZhdWx0IDQpICAgICAgICAgIC0gaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICAtIGNoYXJhY3RlciB0byBpbmRlbnQgd2l0aCxcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB0cnVlKSAtIHdoZXRoZXIgZXhpc3RpbmcgbGluZSBicmVha3Mgc2hvdWxkIGJlIHByZXNlcnZlZCxcbiAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdW5saW1pdGVkKSAtIG1heGltdW0gbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIGJlIHByZXNlcnZlZCBpbiBvbmUgY2h1bmssXG5cbiAgICBqc2xpbnRfaGFwcHkgKGRlZmF1bHQgZmFsc2UpIC0gaWYgdHJ1ZSwgdGhlbiBqc2xpbnQtc3RyaWN0ZXIgbW9kZSBpcyBlbmZvcmNlZC5cblxuICAgICAgICAgICAganNsaW50X2hhcHB5ICAgICAgICAhanNsaW50X2hhcHB5XG4gICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpICAgICAgICAgZnVuY3Rpb24oKVxuXG4gICAgICAgICAgICBzd2l0Y2ggKCkgeyAgICAgICAgIHN3aXRjaCgpIHtcbiAgICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiAoZGVmYXVsdCBmYWxzZSkgLSBzaG91bGQgdGhlIHNwYWNlIGJlZm9yZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24ncyBwYXJlbnMgYmUgYWRkZWQsIFwiZnVuY3Rpb24oKVwiIHZzIFwiZnVuY3Rpb24gKClcIixcbiAgICAgICAgICBOT1RFOiBUaGlzIG9wdGlvbiBpcyBvdmVycmlkZW4gYnkganNsaW50X2hhcHB5IChpLmUuIGlmIGpzbGludF9oYXBweSBpcyB0cnVlLCBzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIGlzIHRydWUgYnkgZGVzaWduKVxuXG4gICAgYnJhY2Vfc3R5bGUgKGRlZmF1bHQgXCJjb2xsYXBzZVwiKSAtIFwiY29sbGFwc2UtcHJlc2VydmUtaW5saW5lXCIgfCBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cblxuICAgIHNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCAoZGVmYXVsdCB0cnVlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBiZSBhZGRlZCwgXCJpZih0cnVlKVwiIHZzIFwiaWYgKHRydWUpXCIsXG5cbiAgICB1bmVzY2FwZV9zdHJpbmdzIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCBwcmludGFibGUgY2hhcmFjdGVycyBpbiBzdHJpbmdzIGVuY29kZWQgaW4gXFx4Tk4gbm90YXRpb24gYmUgdW5lc2NhcGVkLCBcImV4YW1wbGVcIiB2cyBcIlxceDY1XFx4NzhcXHg2MVxceDZkXFx4NzBcXHg2Y1xceDY1XCJcblxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgdW5saW1pdGVkKSAtIGxpbmVzIHNob3VsZCB3cmFwIGF0IG5leHQgb3Bwb3J0dW5pdHkgYWZ0ZXIgdGhpcyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICBOT1RFOiBUaGlzIGlzIG5vdCBhIGhhcmQgbGltaXQuIExpbmVzIHdpbGwgY29udGludWUgdW50aWwgYSBwb2ludCB3aGVyZSBhIG5ld2xpbmUgd291bGRcbiAgICAgICAgICAgICAgICBiZSBwcmVzZXJ2ZWQgaWYgaXQgd2VyZSBwcmVzZW50LlxuXG4gICAgZW5kX3dpdGhfbmV3bGluZSAoZGVmYXVsdCBmYWxzZSkgIC0gZW5kIG91dHB1dCB3aXRoIGEgbmV3bGluZVxuXG5cbiAgICBlLmdcblxuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCB7XG4gICAgICAnaW5kZW50X3NpemUnOiAxLFxuICAgICAgJ2luZGVudF9jaGFyJzogJ1xcdCdcbiAgICB9KTtcblxuKi8vLyBPYmplY3QudmFsdWVzIHBvbHlmaWxsIGZvdW5kIGhlcmU6XG4vLyBodHRwOi8vdG9rZW5wb3N0cy5ibG9nc3BvdC5jb20uYXUvMjAxMi8wNC9qYXZhc2NyaXB0LW9iamVjdGtleXMtYnJvd3Nlci5odG1sXG5pZighT2JqZWN0LnZhbHVlcyl7T2JqZWN0LnZhbHVlcz1mdW5jdGlvbihvKXtpZihvIT09T2JqZWN0KG8pKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QudmFsdWVzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTt9dmFyIGs9W10scDtmb3IocCBpbiBvKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxwKSl7ay5wdXNoKG9bcF0pO319cmV0dXJuIGs7fTt9KGZ1bmN0aW9uKCl7ZnVuY3Rpb24ganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsb3B0aW9ucyl7dmFyIGFjb3JuPXt9OyhmdW5jdGlvbihleHBvcnRzKXsvKiBqc2hpbnQgY3VybHk6IGZhbHNlICovLy8gVGhpcyBzZWN0aW9uIG9mIGNvZGUgaXMgdGFrZW4gZnJvbSBhY29ybi5cbi8vXG4vLyBBY29ybiB3YXMgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVRcbi8vIGxpY2Vuc2UuIFRoZSBVbmljb2RlIHJlZ2V4cHMgKGZvciBpZGVudGlmaWVycyBhbmQgd2hpdGVzcGFjZSkgd2VyZVxuLy8gdGFrZW4gZnJvbSBbRXNwcmltYV0oaHR0cDovL2VzcHJpbWEub3JnKSBieSBBcml5YSBIaWRheWF0LlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9hY29ybi5naXRcbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG4vLyBCaWcgdWdseSByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggY2hhcmFjdGVycyBpbiB0aGVcbi8vIHdoaXRlc3BhY2UsIGlkZW50aWZpZXIsIGFuZCBpZGVudGlmaWVyLXN0YXJ0IGNhdGVnb3JpZXMuIFRoZXNlXG4vLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4vLyBjb2RlIHBvaW50IGFib3ZlIDEyOC5cbnZhciBub25BU0NJSXdoaXRlc3BhY2U9L1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLzsvLyBqc2hpbnQgaWdub3JlOmxpbmVcbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzPVwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjt2YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnM9XCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO3ZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydD1uZXcgUmVnRXhwKFwiW1wiK25vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMrXCJdXCIpO3ZhciBub25BU0NJSWlkZW50aWZpZXI9bmV3IFJlZ0V4cChcIltcIitub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzK25vbkFTQ0lJaWRlbnRpZmllckNoYXJzK1wiXVwiKTsvLyBXaGV0aGVyIGEgc2luZ2xlIGNoYXJhY3RlciBkZW5vdGVzIGEgbmV3bGluZS5cbmV4cG9ydHMubmV3bGluZT0vW1xcblxcclxcdTIwMjhcXHUyMDI5XS87Ly8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG4vLyBpbiBqYXZhc2NyaXB0LCB0aGVzZSB0d28gZGlmZmVyXG4vLyBpbiBweXRob24gdGhleSBhcmUgdGhlIHNhbWUsIGRpZmZlcmVudCBtZXRob2RzIGFyZSBjYWxsZWQgb24gdGhlbVxuZXhwb3J0cy5saW5lQnJlYWs9bmV3IFJlZ0V4cCgnXFxyXFxufCcrZXhwb3J0cy5uZXdsaW5lLnNvdXJjZSk7ZXhwb3J0cy5hbGxMaW5lQnJlYWtzPW5ldyBSZWdFeHAoZXhwb3J0cy5saW5lQnJlYWsuc291cmNlLCdnJyk7Ly8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0PWZ1bmN0aW9uKGNvZGUpey8vIHBlcm1pdCAkICgzNikgYW5kIEAgKDY0KS4gQCBpcyB1c2VkIGluIEVTNyBkZWNvcmF0b3JzLlxuaWYoY29kZTw2NSlyZXR1cm4gY29kZT09PTM2fHxjb2RlPT09NjQ7Ly8gNjUgdGhyb3VnaCA5MSBhcmUgdXBwZXJjYXNlIGxldHRlcnMuXG5pZihjb2RlPDkxKXJldHVybiB0cnVlOy8vIHBlcm1pdCBfICg5NSkuXG5pZihjb2RlPDk3KXJldHVybiBjb2RlPT09OTU7Ly8gOTcgdGhyb3VnaCAxMjMgYXJlIGxvd2VyY2FzZSBsZXR0ZXJzLlxuaWYoY29kZTwxMjMpcmV0dXJuIHRydWU7cmV0dXJuIGNvZGU+PTB4YWEmJm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7fTsvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyPWZ1bmN0aW9uKGNvZGUpe2lmKGNvZGU8NDgpcmV0dXJuIGNvZGU9PT0zNjtpZihjb2RlPDU4KXJldHVybiB0cnVlO2lmKGNvZGU8NjUpcmV0dXJuIGZhbHNlO2lmKGNvZGU8OTEpcmV0dXJuIHRydWU7aWYoY29kZTw5NylyZXR1cm4gY29kZT09PTk1O2lmKGNvZGU8MTIzKXJldHVybiB0cnVlO3JldHVybiBjb2RlPj0weGFhJiZub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTt9O30pKGFjb3JuKTsvKiBqc2hpbnQgY3VybHk6IHRydWUgKi9mdW5jdGlvbiBpbl9hcnJheSh3aGF0LGFycil7Zm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoO2krPTEpe2lmKGFycltpXT09PXdoYXQpe3JldHVybiB0cnVlO319cmV0dXJuIGZhbHNlO31mdW5jdGlvbiB0cmltKHMpe3JldHVybiBzLnJlcGxhY2UoL15cXHMrfFxccyskL2csJycpO31mdW5jdGlvbiBsdHJpbShzKXtyZXR1cm4gcy5yZXBsYWNlKC9eXFxzKy9nLCcnKTt9Ly8gZnVuY3Rpb24gcnRyaW0ocykge1xuLy8gICAgIHJldHVybiBzLnJlcGxhY2UoL1xccyskL2csICcnKTtcbi8vIH1cbmZ1bmN0aW9uIHNhbml0aXplT3BlcmF0b3JQb3NpdGlvbihvcFBvc2l0aW9uKXtvcFBvc2l0aW9uPW9wUG9zaXRpb258fE9QRVJBVE9SX1BPU0lUSU9OLmJlZm9yZV9uZXdsaW5lO3ZhciB2YWxpZFBvc2l0aW9uVmFsdWVzPU9iamVjdC52YWx1ZXMoT1BFUkFUT1JfUE9TSVRJT04pO2lmKCFpbl9hcnJheShvcFBvc2l0aW9uLHZhbGlkUG9zaXRpb25WYWx1ZXMpKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnb3BlcmF0b3JfcG9zaXRpb24nIG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzXFxuXCIrdmFsaWRQb3NpdGlvblZhbHVlcytcIlxcbllvdSBwYXNzZWQgaW46ICdcIitvcFBvc2l0aW9uK1wiJ1wiKTt9cmV0dXJuIG9wUG9zaXRpb247fXZhciBPUEVSQVRPUl9QT1NJVElPTj17YmVmb3JlX25ld2xpbmU6J2JlZm9yZS1uZXdsaW5lJyxhZnRlcl9uZXdsaW5lOidhZnRlci1uZXdsaW5lJyxwcmVzZXJ2ZV9uZXdsaW5lOidwcmVzZXJ2ZS1uZXdsaW5lJ307dmFyIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRT1bT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmUsT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZV07dmFyIE1PREU9e0Jsb2NrU3RhdGVtZW50OidCbG9ja1N0YXRlbWVudCcsLy8gJ0JMT0NLJ1xuU3RhdGVtZW50OidTdGF0ZW1lbnQnLC8vICdTVEFURU1FTlQnXG5PYmplY3RMaXRlcmFsOidPYmplY3RMaXRlcmFsJywvLyAnT0JKRUNUJyxcbkFycmF5TGl0ZXJhbDonQXJyYXlMaXRlcmFsJywvLydbRVhQUkVTU0lPTl0nLFxuRm9ySW5pdGlhbGl6ZXI6J0ZvckluaXRpYWxpemVyJywvLycoRk9SLUVYUFJFU1NJT04pJyxcbkNvbmRpdGlvbmFsOidDb25kaXRpb25hbCcsLy8nKENPTkQtRVhQUkVTU0lPTiknLFxuRXhwcmVzc2lvbjonRXhwcmVzc2lvbicvLycoRVhQUkVTU0lPTiknXG59O2Z1bmN0aW9uIEJlYXV0aWZpZXIoanNfc291cmNlX3RleHQsb3B0aW9ucyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG91dHB1dDt2YXIgdG9rZW5zPVtdLHRva2VuX3Bvczt2YXIgVG9rZW5pemVyO3ZhciBjdXJyZW50X3Rva2VuO3ZhciBsYXN0X3R5cGUsbGFzdF9sYXN0X3RleHQsaW5kZW50X3N0cmluZzt2YXIgZmxhZ3MscHJldmlvdXNfZmxhZ3MsZmxhZ19zdG9yZTt2YXIgcHJlZml4O3ZhciBoYW5kbGVycyxvcHQ7dmFyIGJhc2VJbmRlbnRTdHJpbmc9Jyc7aGFuZGxlcnM9eydUS19TVEFSVF9FWFBSJzpoYW5kbGVfc3RhcnRfZXhwciwnVEtfRU5EX0VYUFInOmhhbmRsZV9lbmRfZXhwciwnVEtfU1RBUlRfQkxPQ0snOmhhbmRsZV9zdGFydF9ibG9jaywnVEtfRU5EX0JMT0NLJzpoYW5kbGVfZW5kX2Jsb2NrLCdUS19XT1JEJzpoYW5kbGVfd29yZCwnVEtfUkVTRVJWRUQnOmhhbmRsZV93b3JkLCdUS19TRU1JQ09MT04nOmhhbmRsZV9zZW1pY29sb24sJ1RLX1NUUklORyc6aGFuZGxlX3N0cmluZywnVEtfRVFVQUxTJzpoYW5kbGVfZXF1YWxzLCdUS19PUEVSQVRPUic6aGFuZGxlX29wZXJhdG9yLCdUS19DT01NQSc6aGFuZGxlX2NvbW1hLCdUS19CTE9DS19DT01NRU5UJzpoYW5kbGVfYmxvY2tfY29tbWVudCwnVEtfQ09NTUVOVCc6aGFuZGxlX2NvbW1lbnQsJ1RLX0RPVCc6aGFuZGxlX2RvdCwnVEtfVU5LTk9XTic6aGFuZGxlX3Vua25vd24sJ1RLX0VPRic6aGFuZGxlX2VvZn07ZnVuY3Rpb24gY3JlYXRlX2ZsYWdzKGZsYWdzX2Jhc2UsbW9kZSl7dmFyIG5leHRfaW5kZW50X2xldmVsPTA7aWYoZmxhZ3NfYmFzZSl7bmV4dF9pbmRlbnRfbGV2ZWw9ZmxhZ3NfYmFzZS5pbmRlbnRhdGlvbl9sZXZlbDtpZighb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpJiZmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsPm5leHRfaW5kZW50X2xldmVsKXtuZXh0X2luZGVudF9sZXZlbD1mbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsO319dmFyIG5leHRfZmxhZ3M9e21vZGU6bW9kZSxwYXJlbnQ6ZmxhZ3NfYmFzZSxsYXN0X3RleHQ6ZmxhZ3NfYmFzZT9mbGFnc19iYXNlLmxhc3RfdGV4dDonJywvLyBsYXN0IHRva2VuIHRleHRcbmxhc3Rfd29yZDpmbGFnc19iYXNlP2ZsYWdzX2Jhc2UubGFzdF93b3JkOicnLC8vIGxhc3QgJ1RLX1dPUkQnIHBhc3NlZFxuZGVjbGFyYXRpb25fc3RhdGVtZW50OmZhbHNlLGRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQ6ZmFsc2UsbXVsdGlsaW5lX2ZyYW1lOmZhbHNlLGlubGluZV9mcmFtZTpmYWxzZSxpZl9ibG9jazpmYWxzZSxlbHNlX2Jsb2NrOmZhbHNlLGRvX2Jsb2NrOmZhbHNlLGRvX3doaWxlOmZhbHNlLGltcG9ydF9ibG9jazpmYWxzZSxpbl9jYXNlX3N0YXRlbWVudDpmYWxzZSwvLyBzd2l0Y2goLi4peyBJTlNJREUgSEVSRSB9XG5pbl9jYXNlOmZhbHNlLC8vIHdlJ3JlIG9uIHRoZSBleGFjdCBsaW5lIHdpdGggXCJjYXNlIDA6XCJcbmNhc2VfYm9keTpmYWxzZSwvLyB0aGUgaW5kZW50ZWQgY2FzZS1hY3Rpb24gYmxvY2tcbmluZGVudGF0aW9uX2xldmVsOm5leHRfaW5kZW50X2xldmVsLGxpbmVfaW5kZW50X2xldmVsOmZsYWdzX2Jhc2U/ZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbDpuZXh0X2luZGVudF9sZXZlbCxzdGFydF9saW5lX2luZGV4Om91dHB1dC5nZXRfbGluZV9udW1iZXIoKSx0ZXJuYXJ5X2RlcHRoOjB9O3JldHVybiBuZXh0X2ZsYWdzO30vLyBTb21lIGludGVycHJldGVycyBoYXZlIHVuZXhwZWN0ZWQgcmVzdWx0cyB3aXRoIGZvbyA9IGJheiB8fCBiYXI7XG5vcHRpb25zPW9wdGlvbnM/b3B0aW9uczp7fTtvcHQ9e307Ly8gY29tcGF0aWJpbGl0eVxuaWYob3B0aW9ucy5icmFjZXNfb25fb3duX2xpbmUhPT11bmRlZmluZWQpey8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbm9wdC5icmFjZV9zdHlsZT1vcHRpb25zLmJyYWNlc19vbl9vd25fbGluZT9cImV4cGFuZFwiOlwiY29sbGFwc2VcIjt9b3B0LmJyYWNlX3N0eWxlPW9wdGlvbnMuYnJhY2Vfc3R5bGU/b3B0aW9ucy5icmFjZV9zdHlsZTpvcHQuYnJhY2Vfc3R5bGU/b3B0LmJyYWNlX3N0eWxlOlwiY29sbGFwc2VcIjsvLyBncmFjZWZ1bCBoYW5kbGluZyBvZiBkZXByZWNhdGVkIG9wdGlvblxuaWYob3B0LmJyYWNlX3N0eWxlPT09XCJleHBhbmQtc3RyaWN0XCIpe29wdC5icmFjZV9zdHlsZT1cImV4cGFuZFwiO31vcHQuaW5kZW50X3NpemU9b3B0aW9ucy5pbmRlbnRfc2l6ZT9wYXJzZUludChvcHRpb25zLmluZGVudF9zaXplLDEwKTo0O29wdC5pbmRlbnRfY2hhcj1vcHRpb25zLmluZGVudF9jaGFyP29wdGlvbnMuaW5kZW50X2NoYXI6JyAnO29wdC5lb2w9b3B0aW9ucy5lb2w/b3B0aW9ucy5lb2w6J2F1dG8nO29wdC5wcmVzZXJ2ZV9uZXdsaW5lcz1vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzPT09dW5kZWZpbmVkP3RydWU6b3B0aW9ucy5wcmVzZXJ2ZV9uZXdsaW5lcztvcHQuYnJlYWtfY2hhaW5lZF9tZXRob2RzPW9wdGlvbnMuYnJlYWtfY2hhaW5lZF9tZXRob2RzPT09dW5kZWZpbmVkP2ZhbHNlOm9wdGlvbnMuYnJlYWtfY2hhaW5lZF9tZXRob2RzO29wdC5tYXhfcHJlc2VydmVfbmV3bGluZXM9b3B0aW9ucy5tYXhfcHJlc2VydmVfbmV3bGluZXM9PT11bmRlZmluZWQ/MDpwYXJzZUludChvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcywxMCk7b3B0LnNwYWNlX2luX3BhcmVuPW9wdGlvbnMuc3BhY2VfaW5fcGFyZW49PT11bmRlZmluZWQ/ZmFsc2U6b3B0aW9ucy5zcGFjZV9pbl9wYXJlbjtvcHQuc3BhY2VfaW5fZW1wdHlfcGFyZW49b3B0aW9ucy5zcGFjZV9pbl9lbXB0eV9wYXJlbj09PXVuZGVmaW5lZD9mYWxzZTpvcHRpb25zLnNwYWNlX2luX2VtcHR5X3BhcmVuO29wdC5qc2xpbnRfaGFwcHk9b3B0aW9ucy5qc2xpbnRfaGFwcHk9PT11bmRlZmluZWQ/ZmFsc2U6b3B0aW9ucy5qc2xpbnRfaGFwcHk7b3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb249b3B0aW9ucy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uPT09dW5kZWZpbmVkP2ZhbHNlOm9wdGlvbnMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbjtvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbj1vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb249PT11bmRlZmluZWQ/ZmFsc2U6b3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uO29wdC5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWw9b3B0aW9ucy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWw9PT11bmRlZmluZWQ/dHJ1ZTpvcHRpb25zLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbDtvcHQudW5lc2NhcGVfc3RyaW5ncz1vcHRpb25zLnVuZXNjYXBlX3N0cmluZ3M9PT11bmRlZmluZWQ/ZmFsc2U6b3B0aW9ucy51bmVzY2FwZV9zdHJpbmdzO29wdC53cmFwX2xpbmVfbGVuZ3RoPW9wdGlvbnMud3JhcF9saW5lX2xlbmd0aD09PXVuZGVmaW5lZD8wOnBhcnNlSW50KG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCwxMCk7b3B0LmU0eD1vcHRpb25zLmU0eD09PXVuZGVmaW5lZD9mYWxzZTpvcHRpb25zLmU0eDtvcHQuZW5kX3dpdGhfbmV3bGluZT1vcHRpb25zLmVuZF93aXRoX25ld2xpbmU9PT11bmRlZmluZWQ/ZmFsc2U6b3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO29wdC5jb21tYV9maXJzdD1vcHRpb25zLmNvbW1hX2ZpcnN0PT09dW5kZWZpbmVkP2ZhbHNlOm9wdGlvbnMuY29tbWFfZmlyc3Q7b3B0Lm9wZXJhdG9yX3Bvc2l0aW9uPXNhbml0aXplT3BlcmF0b3JQb3NpdGlvbihvcHRpb25zLm9wZXJhdG9yX3Bvc2l0aW9uKTsvLyBGb3IgdGVzdGluZyBvZiBiZWF1dGlmeSBpZ25vcmU6c3RhcnQgZGlyZWN0aXZlXG5vcHQudGVzdF9vdXRwdXRfcmF3PW9wdGlvbnMudGVzdF9vdXRwdXRfcmF3PT09dW5kZWZpbmVkP2ZhbHNlOm9wdGlvbnMudGVzdF9vdXRwdXRfcmF3Oy8vIGZvcmNlIG9wdC5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIHRvIHRydWUgaWYgb3B0LmpzbGludF9oYXBweVxuaWYob3B0LmpzbGludF9oYXBweSl7b3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb249dHJ1ZTt9aWYob3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKXtvcHQuaW5kZW50X2NoYXI9J1xcdCc7b3B0LmluZGVudF9zaXplPTE7fWlmKG9wdC5lb2w9PT0nYXV0bycpe29wdC5lb2w9J1xcbic7aWYoanNfc291cmNlX3RleHQmJmFjb3JuLmxpbmVCcmVhay50ZXN0KGpzX3NvdXJjZV90ZXh0fHwnJykpe29wdC5lb2w9anNfc291cmNlX3RleHQubWF0Y2goYWNvcm4ubGluZUJyZWFrKVswXTt9fW9wdC5lb2w9b3B0LmVvbC5yZXBsYWNlKC9cXFxcci8sJ1xccicpLnJlcGxhY2UoL1xcXFxuLywnXFxuJyk7Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pbmRlbnRfc3RyaW5nPScnO3doaWxlKG9wdC5pbmRlbnRfc2l6ZT4wKXtpbmRlbnRfc3RyaW5nKz1vcHQuaW5kZW50X2NoYXI7b3B0LmluZGVudF9zaXplLT0xO312YXIgcHJlaW5kZW50X2luZGV4PTA7aWYoanNfc291cmNlX3RleHQmJmpzX3NvdXJjZV90ZXh0Lmxlbmd0aCl7d2hpbGUoanNfc291cmNlX3RleHQuY2hhckF0KHByZWluZGVudF9pbmRleCk9PT0nICd8fGpzX3NvdXJjZV90ZXh0LmNoYXJBdChwcmVpbmRlbnRfaW5kZXgpPT09J1xcdCcpe2Jhc2VJbmRlbnRTdHJpbmcrPWpzX3NvdXJjZV90ZXh0LmNoYXJBdChwcmVpbmRlbnRfaW5kZXgpO3ByZWluZGVudF9pbmRleCs9MTt9anNfc291cmNlX3RleHQ9anNfc291cmNlX3RleHQuc3Vic3RyaW5nKHByZWluZGVudF9pbmRleCk7fWxhc3RfdHlwZT0nVEtfU1RBUlRfQkxPQ0snOy8vIGxhc3QgdG9rZW4gdHlwZVxubGFzdF9sYXN0X3RleHQ9Jyc7Ly8gcHJlLWxhc3QgdG9rZW4gdGV4dFxub3V0cHV0PW5ldyBPdXRwdXQoaW5kZW50X3N0cmluZyxiYXNlSW5kZW50U3RyaW5nKTsvLyBJZiB0ZXN0aW5nIHRoZSBpZ25vcmUgZGlyZWN0aXZlLCBzdGFydCB3aXRoIG91dHB1dCBkaXNhYmxlIHNldCB0byB0cnVlXG5vdXRwdXQucmF3PW9wdC50ZXN0X291dHB1dF9yYXc7Ly8gU3RhY2sgb2YgcGFyc2luZy9mb3JtYXR0aW5nIHN0YXRlcywgaW5jbHVkaW5nIE1PREUuXG4vLyBXZSB0b2tlbml6ZSwgcGFyc2UsIGFuZCBvdXRwdXQgaW4gYW4gYWxtb3N0IHB1cmVseSBhIGZvcndhcmQtb25seSBzdHJlYW0gb2YgdG9rZW4gaW5wdXRcbi8vIGFuZCBmb3JtYXR0ZWQgb3V0cHV0LiAgVGhpcyBtYWtlcyB0aGUgYmVhdXRpZmllciBsZXNzIGFjY3VyYXRlIHRoYW4gZnVsbCBwYXJzZXJzXG4vLyBidXQgYWxzbyBmYXIgbW9yZSB0b2xlcmFudCBvZiBzeW50YXggZXJyb3JzLlxuLy9cbi8vIEZvciBleGFtcGxlLCB0aGUgZGVmYXVsdCBtb2RlIGlzIE1PREUuQmxvY2tTdGF0ZW1lbnQuIElmIHdlIHNlZSBhICd7JyB3ZSBwdXNoIGEgbmV3IGZyYW1lIG9mIHR5cGVcbi8vIE1PREUuQmxvY2tTdGF0ZW1lbnQgb24gdGhlIHRoZSBzdGFjaywgZXZlbiB0aG91Z2ggaXQgY291bGQgYmUgb2JqZWN0IGxpdGVyYWwuICBJZiB3ZSBsYXRlclxuLy8gZW5jb3VudGVyIGEgXCI6XCIsIHdlJ2xsIHN3aXRjaCB0byB0byBNT0RFLk9iamVjdExpdGVyYWwuICBJZiB3ZSB0aGVuIHNlZSBhIFwiO1wiLFxuLy8gbW9zdCBmdWxsIHBhcnNlcnMgd291bGQgZGllLCBidXQgdGhlIGJlYXV0aWZpZXIgZ3JhY2VmdWxseSBmYWxscyBiYWNrIHRvXG4vLyBNT0RFLkJsb2NrU3RhdGVtZW50IGFuZCBjb250aW51ZXMgb24uXG5mbGFnX3N0b3JlPVtdO3NldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO3RoaXMuYmVhdXRpZnk9ZnVuY3Rpb24oKXsvKmpzaGludCBvbmV2YXI6dHJ1ZSAqL3ZhciBsb2NhbF90b2tlbixzd2VldF9jb2RlO1Rva2VuaXplcj1uZXcgdG9rZW5pemVyKGpzX3NvdXJjZV90ZXh0LG9wdCxpbmRlbnRfc3RyaW5nKTt0b2tlbnM9VG9rZW5pemVyLnRva2VuaXplKCk7dG9rZW5fcG9zPTA7ZnVuY3Rpb24gZ2V0X2xvY2FsX3Rva2VuKCl7bG9jYWxfdG9rZW49Z2V0X3Rva2VuKCk7cmV0dXJuIGxvY2FsX3Rva2VuO313aGlsZShnZXRfbG9jYWxfdG9rZW4oKSl7Zm9yKHZhciBpPTA7aTxsb2NhbF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoO2krKyl7Ly8gVGhlIGNsZWFuZXN0IGhhbmRsaW5nIG9mIGlubGluZSBjb21tZW50cyBpcyB0byB0cmVhdCB0aGVtIGFzIHRob3VnaCB0aGV5IGFyZW4ndCB0aGVyZS5cbi8vIEp1c3QgY29udGludWUgZm9ybWF0dGluZyBhbmQgdGhlIGJlaGF2aW9yIHNob3VsZCBiZSBsb2dpY2FsLlxuLy8gQWxzbyBpZ25vcmUgdW5rbm93biB0b2tlbnMuICBBZ2FpbiwgdGhpcyBzaG91bGQgcmVzdWx0IGluIGJldHRlciBiZWhhdmlvci5cbmhhbmRsZV90b2tlbihsb2NhbF90b2tlbi5jb21tZW50c19iZWZvcmVbaV0pO31oYW5kbGVfdG9rZW4obG9jYWxfdG9rZW4pO2xhc3RfbGFzdF90ZXh0PWZsYWdzLmxhc3RfdGV4dDtsYXN0X3R5cGU9bG9jYWxfdG9rZW4udHlwZTtmbGFncy5sYXN0X3RleHQ9bG9jYWxfdG9rZW4udGV4dDt0b2tlbl9wb3MrPTE7fXN3ZWV0X2NvZGU9b3V0cHV0LmdldF9jb2RlKCk7aWYob3B0LmVuZF93aXRoX25ld2xpbmUpe3N3ZWV0X2NvZGUrPSdcXG4nO31pZihvcHQuZW9sIT09J1xcbicpe3N3ZWV0X2NvZGU9c3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLG9wdC5lb2wpO31yZXR1cm4gc3dlZXRfY29kZTt9O2Z1bmN0aW9uIGhhbmRsZV90b2tlbihsb2NhbF90b2tlbil7dmFyIG5ld2xpbmVzPWxvY2FsX3Rva2VuLm5ld2xpbmVzO3ZhciBrZWVwX3doaXRlc3BhY2U9b3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24mJmlzX2FycmF5KGZsYWdzLm1vZGUpO2lmKGtlZXBfd2hpdGVzcGFjZSl7Zm9yKHZhciBpPTA7aTxuZXdsaW5lcztpKz0xKXtwcmludF9uZXdsaW5lKGk+MCk7fX1lbHNle2lmKG9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXMmJm5ld2xpbmVzPm9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXMpe25ld2xpbmVzPW9wdC5tYXhfcHJlc2VydmVfbmV3bGluZXM7fWlmKG9wdC5wcmVzZXJ2ZV9uZXdsaW5lcyl7aWYobG9jYWxfdG9rZW4ubmV3bGluZXM+MSl7cHJpbnRfbmV3bGluZSgpO2Zvcih2YXIgaj0xO2o8bmV3bGluZXM7ais9MSl7cHJpbnRfbmV3bGluZSh0cnVlKTt9fX19Y3VycmVudF90b2tlbj1sb2NhbF90b2tlbjtoYW5kbGVyc1tjdXJyZW50X3Rva2VuLnR5cGVdKCk7fS8vIHdlIGNvdWxkIHVzZSBqdXN0IHN0cmluZy5zcGxpdCwgYnV0XG4vLyBJRSBkb2Vzbid0IGxpa2UgcmV0dXJuaW5nIGVtcHR5IHN0cmluZ3NcbmZ1bmN0aW9uIHNwbGl0X2xpbmVicmVha3Mocyl7Ly9yZXR1cm4gcy5zcGxpdCgvXFx4MGRcXHgwYXxcXHgwYS8pO1xucz1zLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywnXFxuJyk7dmFyIG91dD1bXSxpZHg9cy5pbmRleE9mKFwiXFxuXCIpO3doaWxlKGlkeCE9PS0xKXtvdXQucHVzaChzLnN1YnN0cmluZygwLGlkeCkpO3M9cy5zdWJzdHJpbmcoaWR4KzEpO2lkeD1zLmluZGV4T2YoXCJcXG5cIik7fWlmKHMubGVuZ3RoKXtvdXQucHVzaChzKTt9cmV0dXJuIG91dDt9dmFyIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnM9WydicmVhaycsJ2NvbnRpbnVlJywncmV0dXJuJywndGhyb3cnXTtmdW5jdGlvbiBhbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGZvcmNlX2xpbmV3cmFwKXtmb3JjZV9saW5ld3JhcD1mb3JjZV9saW5ld3JhcD09PXVuZGVmaW5lZD9mYWxzZTpmb3JjZV9saW5ld3JhcDsvLyBOZXZlciB3cmFwIHRoZSBmaXJzdCB0b2tlbiBvbiBhIGxpbmVcbmlmKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSl7cmV0dXJuO312YXIgc2hvdWxkUHJlc2VydmVPckZvcmNlPW9wdC5wcmVzZXJ2ZV9uZXdsaW5lcyYmY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZXx8Zm9yY2VfbGluZXdyYXA7dmFyIG9wZXJhdG9yTG9naWNBcHBsaWVzPWluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCxUb2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycyl8fGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCxUb2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycyk7aWYob3BlcmF0b3JMb2dpY0FwcGxpZXMpe3ZhciBzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZT1pbl9hcnJheShmbGFncy5sYXN0X3RleHQsVG9rZW5pemVyLnBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpJiZpbl9hcnJheShvcHQub3BlcmF0b3JfcG9zaXRpb24sT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKXx8aW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LFRva2VuaXplci5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtzaG91bGRQcmVzZXJ2ZU9yRm9yY2U9c2hvdWxkUHJlc2VydmVPckZvcmNlJiZzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZTt9aWYoc2hvdWxkUHJlc2VydmVPckZvcmNlKXtwcmludF9uZXdsaW5lKGZhbHNlLHRydWUpO31lbHNlIGlmKG9wdC53cmFwX2xpbmVfbGVuZ3RoKXtpZihsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZpbl9hcnJheShmbGFncy5sYXN0X3RleHQsbmV3bGluZV9yZXN0cmljdGVkX3Rva2Vucykpey8vIFRoZXNlIHRva2VucyBzaG91bGQgbmV2ZXIgaGF2ZSBhIG5ld2xpbmUgaW5zZXJ0ZWRcbi8vIGJldHdlZW4gdGhlbSBhbmQgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uLlxucmV0dXJuO312YXIgcHJvcG9zZWRfbGluZV9sZW5ndGg9b3V0cHV0LmN1cnJlbnRfbGluZS5nZXRfY2hhcmFjdGVyX2NvdW50KCkrY3VycmVudF90b2tlbi50ZXh0Lmxlbmd0aCsob3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj8xOjApO2lmKHByb3Bvc2VkX2xpbmVfbGVuZ3RoPj1vcHQud3JhcF9saW5lX2xlbmd0aCl7cHJpbnRfbmV3bGluZShmYWxzZSx0cnVlKTt9fX1mdW5jdGlvbiBwcmludF9uZXdsaW5lKGZvcmNlX25ld2xpbmUscHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKXtpZighcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKXtpZihmbGFncy5sYXN0X3RleHQhPT0nOycmJmZsYWdzLmxhc3RfdGV4dCE9PScsJyYmZmxhZ3MubGFzdF90ZXh0IT09Jz0nJiZsYXN0X3R5cGUhPT0nVEtfT1BFUkFUT1InKXt3aGlsZShmbGFncy5tb2RlPT09TU9ERS5TdGF0ZW1lbnQmJiFmbGFncy5pZl9ibG9jayYmIWZsYWdzLmRvX2Jsb2NrKXtyZXN0b3JlX21vZGUoKTt9fX1pZihvdXRwdXQuYWRkX25ld19saW5lKGZvcmNlX25ld2xpbmUpKXtmbGFncy5tdWx0aWxpbmVfZnJhbWU9dHJ1ZTt9fWZ1bmN0aW9uIHByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oKXtpZihvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpe2lmKG9wdC5rZWVwX2FycmF5X2luZGVudGF0aW9uJiZpc19hcnJheShmbGFncy5tb2RlKSYmY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSl7b3V0cHV0LmN1cnJlbnRfbGluZS5wdXNoKGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49ZmFsc2U7fWVsc2UgaWYob3V0cHV0LnNldF9pbmRlbnQoZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwpKXtmbGFncy5saW5lX2luZGVudF9sZXZlbD1mbGFncy5pbmRlbnRhdGlvbl9sZXZlbDt9fX1mdW5jdGlvbiBwcmludF90b2tlbihwcmludGFibGVfdG9rZW4pe2lmKG91dHB1dC5yYXcpe291dHB1dC5hZGRfcmF3X3Rva2VuKGN1cnJlbnRfdG9rZW4pO3JldHVybjt9aWYob3B0LmNvbW1hX2ZpcnN0JiZsYXN0X3R5cGU9PT0nVEtfQ09NTUEnJiZvdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpe2lmKG91dHB1dC5wcmV2aW91c19saW5lLmxhc3QoKT09PScsJyl7dmFyIHBvcHBlZD1vdXRwdXQucHJldmlvdXNfbGluZS5wb3AoKTsvLyBpZiB0aGUgY29tbWEgd2FzIGFscmVhZHkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLFxuLy8gcHVsbCBiYWNrIG9udG8gdGhhdCBsaW5lIGFuZCByZXByaW50IHRoZSBpbmRlbnRhdGlvblxuaWYob3V0cHV0LnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSl7b3V0cHV0LnByZXZpb3VzX2xpbmUucHVzaChwb3BwZWQpO291dHB1dC50cmltKHRydWUpO291dHB1dC5jdXJyZW50X2xpbmUucG9wKCk7b3V0cHV0LnRyaW0oKTt9Ly8gYWRkIHRoZSBjb21tYSBpbiBmcm9udCBvZiB0aGUgbmV4dCB0b2tlblxucHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbigpO291dHB1dC5hZGRfdG9rZW4oJywnKTtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7fX1wcmludGFibGVfdG9rZW49cHJpbnRhYmxlX3Rva2VufHxjdXJyZW50X3Rva2VuLnRleHQ7cHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbigpO291dHB1dC5hZGRfdG9rZW4ocHJpbnRhYmxlX3Rva2VuKTt9ZnVuY3Rpb24gaW5kZW50KCl7ZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwrPTE7fWZ1bmN0aW9uIGRlaW5kZW50KCl7aWYoZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWw+MCYmKCFmbGFncy5wYXJlbnR8fGZsYWdzLmluZGVudGF0aW9uX2xldmVsPmZsYWdzLnBhcmVudC5pbmRlbnRhdGlvbl9sZXZlbCkpe2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLT0xO319ZnVuY3Rpb24gc2V0X21vZGUobW9kZSl7aWYoZmxhZ3Mpe2ZsYWdfc3RvcmUucHVzaChmbGFncyk7cHJldmlvdXNfZmxhZ3M9ZmxhZ3M7fWVsc2V7cHJldmlvdXNfZmxhZ3M9Y3JlYXRlX2ZsYWdzKG51bGwsbW9kZSk7fWZsYWdzPWNyZWF0ZV9mbGFncyhwcmV2aW91c19mbGFncyxtb2RlKTt9ZnVuY3Rpb24gaXNfYXJyYXkobW9kZSl7cmV0dXJuIG1vZGU9PT1NT0RFLkFycmF5TGl0ZXJhbDt9ZnVuY3Rpb24gaXNfZXhwcmVzc2lvbihtb2RlKXtyZXR1cm4gaW5fYXJyYXkobW9kZSxbTU9ERS5FeHByZXNzaW9uLE1PREUuRm9ySW5pdGlhbGl6ZXIsTU9ERS5Db25kaXRpb25hbF0pO31mdW5jdGlvbiByZXN0b3JlX21vZGUoKXtpZihmbGFnX3N0b3JlLmxlbmd0aD4wKXtwcmV2aW91c19mbGFncz1mbGFncztmbGFncz1mbGFnX3N0b3JlLnBvcCgpO2lmKHByZXZpb3VzX2ZsYWdzLm1vZGU9PT1NT0RFLlN0YXRlbWVudCl7b3V0cHV0LnJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24ocHJldmlvdXNfZmxhZ3MpO319fWZ1bmN0aW9uIHN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpe3JldHVybiBmbGFncy5wYXJlbnQubW9kZT09PU1PREUuT2JqZWN0TGl0ZXJhbCYmZmxhZ3MubW9kZT09PU1PREUuU3RhdGVtZW50JiYoZmxhZ3MubGFzdF90ZXh0PT09JzonJiZmbGFncy50ZXJuYXJ5X2RlcHRoPT09MHx8bGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsnZ2V0Jywnc2V0J10pKTt9ZnVuY3Rpb24gc3RhcnRfb2Zfc3RhdGVtZW50KCl7aWYobGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsndmFyJywnbGV0JywnY29uc3QnXSkmJmN1cnJlbnRfdG9rZW4udHlwZT09PSdUS19XT1JEJ3x8bGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmZmxhZ3MubGFzdF90ZXh0PT09J2RvJ3x8bGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsncmV0dXJuJywndGhyb3cnXSkmJiFjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lfHxsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZmbGFncy5sYXN0X3RleHQ9PT0nZWxzZScmJiEoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmY3VycmVudF90b2tlbi50ZXh0PT09J2lmJyl8fGxhc3RfdHlwZT09PSdUS19FTkRfRVhQUicmJihwcmV2aW91c19mbGFncy5tb2RlPT09TU9ERS5Gb3JJbml0aWFsaXplcnx8cHJldmlvdXNfZmxhZ3MubW9kZT09PU1PREUuQ29uZGl0aW9uYWwpfHxsYXN0X3R5cGU9PT0nVEtfV09SRCcmJmZsYWdzLm1vZGU9PT1NT0RFLkJsb2NrU3RhdGVtZW50JiYhZmxhZ3MuaW5fY2FzZSYmIShjdXJyZW50X3Rva2VuLnRleHQ9PT0nLS0nfHxjdXJyZW50X3Rva2VuLnRleHQ9PT0nKysnKSYmbGFzdF9sYXN0X3RleHQhPT0nZnVuY3Rpb24nJiZjdXJyZW50X3Rva2VuLnR5cGUhPT0nVEtfV09SRCcmJmN1cnJlbnRfdG9rZW4udHlwZSE9PSdUS19SRVNFUlZFRCd8fGZsYWdzLm1vZGU9PT1NT0RFLk9iamVjdExpdGVyYWwmJihmbGFncy5sYXN0X3RleHQ9PT0nOicmJmZsYWdzLnRlcm5hcnlfZGVwdGg9PT0wfHxsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZpbl9hcnJheShmbGFncy5sYXN0X3RleHQsWydnZXQnLCdzZXQnXSkpKXtzZXRfbW9kZShNT0RFLlN0YXRlbWVudCk7aW5kZW50KCk7aWYobGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsndmFyJywnbGV0JywnY29uc3QnXSkmJmN1cnJlbnRfdG9rZW4udHlwZT09PSdUS19XT1JEJyl7ZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50PXRydWU7fS8vIElzc3VlICMyNzY6XG4vLyBJZiBzdGFydGluZyBhIG5ldyBzdGF0ZW1lbnQgd2l0aCBbaWYsIGZvciwgd2hpbGUsIGRvXSwgcHVzaCB0byBhIG5ldyBsaW5lLlxuLy8gaWYgKGEpIGlmIChiKSBpZihjKSBkKCk7IGVsc2UgZSgpOyBlbHNlIGYoKTtcbmlmKCFzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSl7YWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLnR5cGU9PT0nVEtfUkVTRVJWRUQnJiZpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsWydkbycsJ2ZvcicsJ2lmJywnd2hpbGUnXSkpO31yZXR1cm4gdHJ1ZTt9cmV0dXJuIGZhbHNlO31mdW5jdGlvbiBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcyxjKXtmb3IodmFyIGk9MDtpPGxpbmVzLmxlbmd0aDtpKyspe3ZhciBsaW5lPXRyaW0obGluZXNbaV0pO2lmKGxpbmUuY2hhckF0KDApIT09Yyl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fWZ1bmN0aW9uIGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcyxpbmRlbnQpe3ZhciBpPTAsbGVuPWxpbmVzLmxlbmd0aCxsaW5lO2Zvcig7aTxsZW47aSsrKXtsaW5lPWxpbmVzW2ldOy8vIGFsbG93IGVtcHR5IGxpbmVzIHRvIHBhc3MgdGhyb3VnaFxuaWYobGluZSYmbGluZS5pbmRleE9mKGluZGVudCkhPT0wKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9ZnVuY3Rpb24gaXNfc3BlY2lhbF93b3JkKHdvcmQpe3JldHVybiBpbl9hcnJheSh3b3JkLFsnY2FzZScsJ3JldHVybicsJ2RvJywnaWYnLCd0aHJvdycsJ2Vsc2UnXSk7fWZ1bmN0aW9uIGdldF90b2tlbihvZmZzZXQpe3ZhciBpbmRleD10b2tlbl9wb3MrKG9mZnNldHx8MCk7cmV0dXJuIGluZGV4PDB8fGluZGV4Pj10b2tlbnMubGVuZ3RoP251bGw6dG9rZW5zW2luZGV4XTt9ZnVuY3Rpb24gaGFuZGxlX3N0YXJ0X2V4cHIoKXtpZihzdGFydF9vZl9zdGF0ZW1lbnQoKSl7Ly8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxufXZhciBuZXh0X21vZGU9TU9ERS5FeHByZXNzaW9uO2lmKGN1cnJlbnRfdG9rZW4udGV4dD09PSdbJyl7aWYobGFzdF90eXBlPT09J1RLX1dPUkQnfHxmbGFncy5sYXN0X3RleHQ9PT0nKScpey8vIHRoaXMgaXMgYXJyYXkgaW5kZXggc3BlY2lmaWVyLCBicmVhayBpbW1lZGlhdGVseVxuLy8gYVt4XSwgZm4oKVt4XVxuaWYobGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSl7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO31zZXRfbW9kZShuZXh0X21vZGUpO3ByaW50X3Rva2VuKCk7aW5kZW50KCk7aWYob3B0LnNwYWNlX2luX3BhcmVuKXtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7fXJldHVybjt9bmV4dF9tb2RlPU1PREUuQXJyYXlMaXRlcmFsO2lmKGlzX2FycmF5KGZsYWdzLm1vZGUpKXtpZihmbGFncy5sYXN0X3RleHQ9PT0nWyd8fGZsYWdzLmxhc3RfdGV4dD09PScsJyYmKGxhc3RfbGFzdF90ZXh0PT09J10nfHxsYXN0X2xhc3RfdGV4dD09PSd9Jykpey8vIF0sIFsgZ29lcyB0byBuZXcgbGluZVxuLy8gfSwgWyBnb2VzIHRvIG5ldyBsaW5lXG5pZighb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24pe3ByaW50X25ld2xpbmUoKTt9fX19ZWxzZXtpZihsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZmbGFncy5sYXN0X3RleHQ9PT0nZm9yJyl7bmV4dF9tb2RlPU1PREUuRm9ySW5pdGlhbGl6ZXI7fWVsc2UgaWYobGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsnaWYnLCd3aGlsZSddKSl7bmV4dF9tb2RlPU1PREUuQ29uZGl0aW9uYWw7fWVsc2V7Ly8gbmV4dF9tb2RlID0gTU9ERS5FeHByZXNzaW9uO1xufX1pZihmbGFncy5sYXN0X3RleHQ9PT0nOyd8fGxhc3RfdHlwZT09PSdUS19TVEFSVF9CTE9DSycpe3ByaW50X25ld2xpbmUoKTt9ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfRU5EX0VYUFInfHxsYXN0X3R5cGU9PT0nVEtfU1RBUlRfRVhQUid8fGxhc3RfdHlwZT09PSdUS19FTkRfQkxPQ0snfHxmbGFncy5sYXN0X3RleHQ9PT0nLicpey8vIFRPRE86IENvbnNpZGVyIHdoZXRoZXIgZm9yY2luZyB0aGlzIGlzIHJlcXVpcmVkLiAgUmV2aWV3IGZhaWxpbmcgdGVzdHMgd2hlbiByZW1vdmVkLlxuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKTsvLyBkbyBub3RoaW5nIG9uICgoIGFuZCApKCBhbmQgXVsgYW5kIF0oIGFuZCAuKFxufWVsc2UgaWYoIShsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZjdXJyZW50X3Rva2VuLnRleHQ9PT0nKCcpJiZsYXN0X3R5cGUhPT0nVEtfV09SRCcmJmxhc3RfdHlwZSE9PSdUS19PUEVSQVRPUicpe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiYoZmxhZ3MubGFzdF93b3JkPT09J2Z1bmN0aW9uJ3x8ZmxhZ3MubGFzdF93b3JkPT09J3R5cGVvZicpfHxmbGFncy5sYXN0X3RleHQ9PT0nKicmJihpbl9hcnJheShsYXN0X2xhc3RfdGV4dCxbJ2Z1bmN0aW9uJywneWllbGQnXSl8fGZsYWdzLm1vZGU9PT1NT0RFLk9iamVjdExpdGVyYWwmJmluX2FycmF5KGxhc3RfbGFzdF90ZXh0LFsneycsJywnXSkpKXsvLyBmdW5jdGlvbigpIHZzIGZ1bmN0aW9uICgpXG4vLyB5aWVsZCooKSB2cyB5aWVsZCogKClcbi8vIGZ1bmN0aW9uKigpIHZzIGZ1bmN0aW9uKiAoKVxuaWYob3B0LnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24pe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9fWVsc2UgaWYobGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmKGluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCxUb2tlbml6ZXIubGluZV9zdGFydGVycyl8fGZsYWdzLmxhc3RfdGV4dD09PSdjYXRjaCcpKXtpZihvcHQuc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsKXtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7fX0vLyBTaG91bGQgYmUgYSBzcGFjZSBiZXR3ZWVuIGF3YWl0IGFuZCBhbiBJSUZFXG5pZihjdXJyZW50X3Rva2VuLnRleHQ9PT0nKCcmJmxhc3RfdHlwZT09PSdUS19SRVNFUlZFRCcmJmZsYWdzLmxhc3Rfd29yZD09PSdhd2FpdCcpe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9Ly8gU3VwcG9ydCBvZiB0aGlzIGtpbmQgb2YgbmV3bGluZSBwcmVzZXJ2YXRpb24uXG4vLyBhID0gKGIgJiZcbi8vICAgICAoYyB8fCBkKSk7XG5pZihjdXJyZW50X3Rva2VuLnRleHQ9PT0nKCcpe2lmKGxhc3RfdHlwZT09PSdUS19FUVVBTFMnfHxsYXN0X3R5cGU9PT0nVEtfT1BFUkFUT1InKXtpZighc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpe2FsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTt9fX0vLyBTdXBwb3J0IHByZXNlcnZpbmcgd3JhcHBlZCBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uc1xuLy8gYS5iKCdjJyxcbi8vICAgICAoKSA9PiBkLmVcbi8vIClcbmlmKGN1cnJlbnRfdG9rZW4udGV4dD09PScoJyYmbGFzdF90eXBlIT09J1RLX1dPUkQnJiZsYXN0X3R5cGUhPT0nVEtfUkVTRVJWRUQnKXthbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7fXNldF9tb2RlKG5leHRfbW9kZSk7cHJpbnRfdG9rZW4oKTtpZihvcHQuc3BhY2VfaW5fcGFyZW4pe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9Ly8gSW4gYWxsIGNhc2VzLCBpZiB3ZSBuZXdsaW5lIHdoaWxlIGluc2lkZSBhbiBleHByZXNzaW9uIGl0IHNob3VsZCBiZSBpbmRlbnRlZC5cbmluZGVudCgpO31mdW5jdGlvbiBoYW5kbGVfZW5kX2V4cHIoKXsvLyBzdGF0ZW1lbnRzIGluc2lkZSBleHByZXNzaW9ucyBhcmUgbm90IHZhbGlkIHN5bnRheCwgYnV0Li4uXG4vLyBzdGF0ZW1lbnRzIG11c3QgYWxsIGJlIGNsb3NlZCB3aGVuIHRoZWlyIGNvbnRhaW5lciBjbG9zZXNcbndoaWxlKGZsYWdzLm1vZGU9PT1NT0RFLlN0YXRlbWVudCl7cmVzdG9yZV9tb2RlKCk7fWlmKGZsYWdzLm11bHRpbGluZV9mcmFtZSl7YWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLnRleHQ9PT0nXScmJmlzX2FycmF5KGZsYWdzLm1vZGUpJiYhb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24pO31pZihvcHQuc3BhY2VfaW5fcGFyZW4pe2lmKGxhc3RfdHlwZT09PSdUS19TVEFSVF9FWFBSJyYmIW9wdC5zcGFjZV9pbl9lbXB0eV9wYXJlbil7Ly8gKCkgW10gbm8gaW5uZXIgc3BhY2UgaW4gZW1wdHkgcGFyZW5zIGxpa2UgdGhlc2UsIGV2ZXIsIHJlZiAjMzIwXG5vdXRwdXQudHJpbSgpO291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49ZmFsc2U7fWVsc2V7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO319aWYoY3VycmVudF90b2tlbi50ZXh0PT09J10nJiZvcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbil7cHJpbnRfdG9rZW4oKTtyZXN0b3JlX21vZGUoKTt9ZWxzZXtyZXN0b3JlX21vZGUoKTtwcmludF90b2tlbigpO31vdXRwdXQucmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbihwcmV2aW91c19mbGFncyk7Ly8gZG8ge30gd2hpbGUgKCkgLy8gbm8gc3RhdGVtZW50IHJlcXVpcmVkIGFmdGVyXG5pZihmbGFncy5kb193aGlsZSYmcHJldmlvdXNfZmxhZ3MubW9kZT09PU1PREUuQ29uZGl0aW9uYWwpe3ByZXZpb3VzX2ZsYWdzLm1vZGU9TU9ERS5FeHByZXNzaW9uO2ZsYWdzLmRvX2Jsb2NrPWZhbHNlO2ZsYWdzLmRvX3doaWxlPWZhbHNlO319ZnVuY3Rpb24gaGFuZGxlX3N0YXJ0X2Jsb2NrKCl7Ly8gQ2hlY2sgaWYgdGhpcyBpcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIE9iamVjdExpdGVyYWxcbnZhciBuZXh0X3Rva2VuPWdldF90b2tlbigxKTt2YXIgc2Vjb25kX3Rva2VuPWdldF90b2tlbigyKTtpZihzZWNvbmRfdG9rZW4mJihpbl9hcnJheShzZWNvbmRfdG9rZW4udGV4dCxbJzonLCcsJ10pJiZpbl9hcnJheShuZXh0X3Rva2VuLnR5cGUsWydUS19TVFJJTkcnLCdUS19XT1JEJywnVEtfUkVTRVJWRUQnXSl8fGluX2FycmF5KG5leHRfdG9rZW4udGV4dCxbJ2dldCcsJ3NldCddKSYmaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnR5cGUsWydUS19XT1JEJywnVEtfUkVTRVJWRUQnXSkpKXsvLyBXZSBkb24ndCBzdXBwb3J0IFR5cGVTY3JpcHQsYnV0IHdlIGRpZG4ndCBicmVhayBpdCBmb3IgYSB2ZXJ5IGxvbmcgdGltZS5cbi8vIFdlJ2xsIHRyeSB0byBrZWVwIG5vdCBicmVha2luZyBpdC5cbmlmKCFpbl9hcnJheShsYXN0X2xhc3RfdGV4dCxbJ2NsYXNzJywnaW50ZXJmYWNlJ10pKXtzZXRfbW9kZShNT0RFLk9iamVjdExpdGVyYWwpO31lbHNle3NldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO319ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfT1BFUkFUT1InJiZmbGFncy5sYXN0X3RleHQ9PT0nPT4nKXsvLyBhcnJvdyBmdW5jdGlvbjogKHBhcmFtMSwgcGFyYW1OKSA9PiB7IHN0YXRlbWVudHMgfVxuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7fWVsc2UgaWYoaW5fYXJyYXkobGFzdF90eXBlLFsnVEtfRVFVQUxTJywnVEtfU1RBUlRfRVhQUicsJ1RLX0NPTU1BJywnVEtfT1BFUkFUT1InXSl8fGxhc3RfdHlwZT09PSdUS19SRVNFUlZFRCcmJmluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCxbJ3JldHVybicsJ3Rocm93JywnaW1wb3J0JywnZGVmYXVsdCddKSl7Ly8gRGV0ZWN0aW5nIHNob3J0aGFuZCBmdW5jdGlvbiBzeW50YXggaXMgZGlmZmljdWx0IGJ5IHNjYW5uaW5nIGZvcndhcmQsXG4vLyAgICAgc28gY2hlY2sgdGhlIHN1cnJvdW5kaW5nIGNvbnRleHQuXG4vLyBJZiB0aGUgYmxvY2sgaXMgYmVpbmcgcmV0dXJuZWQsIGltcG9ydGVkLCBleHBvcnQgZGVmYXVsdCwgcGFzc2VkIGFzIGFyZyxcbi8vICAgICBhc3NpZ25lZCB3aXRoID0gb3IgYXNzaWduZWQgaW4gYSBuZXN0ZWQgb2JqZWN0LCB0cmVhdCBhcyBhbiBPYmplY3RMaXRlcmFsLlxuc2V0X21vZGUoTU9ERS5PYmplY3RMaXRlcmFsKTt9ZWxzZXtzZXRfbW9kZShNT0RFLkJsb2NrU3RhdGVtZW50KTt9dmFyIGVtcHR5X2JyYWNlcz0hbmV4dF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoJiZuZXh0X3Rva2VuLnRleHQ9PT0nfSc7dmFyIGVtcHR5X2Fub255bW91c19mdW5jdGlvbj1lbXB0eV9icmFjZXMmJmZsYWdzLmxhc3Rfd29yZD09PSdmdW5jdGlvbicmJmxhc3RfdHlwZT09PSdUS19FTkRfRVhQUic7aWYob3B0LmJyYWNlX3N0eWxlPT09XCJleHBhbmRcInx8b3B0LmJyYWNlX3N0eWxlPT09XCJub25lXCImJmN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUpe2lmKGxhc3RfdHlwZSE9PSdUS19PUEVSQVRPUicmJihlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb258fGxhc3RfdHlwZT09PSdUS19FUVVBTFMnfHxsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSYmZmxhZ3MubGFzdF90ZXh0IT09J2Vsc2UnKSl7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO31lbHNle3ByaW50X25ld2xpbmUoZmFsc2UsdHJ1ZSk7fX1lbHNley8vIGNvbGxhcHNlXG5pZihvcHQuYnJhY2Vfc3R5bGU9PT0nY29sbGFwc2UtcHJlc2VydmUtaW5saW5lJyl7Ly8gc2VhcmNoIGZvcndhcmQgZm9yIGEgbmV3bGluZSB3YW50ZWQgaW5zaWRlIHRoaXMgYmxvY2tcbnZhciBpbmRleD0wO3ZhciBjaGVja190b2tlbj1udWxsO2ZsYWdzLmlubGluZV9mcmFtZT10cnVlO2Rve2luZGV4Kz0xO2NoZWNrX3Rva2VuPWdldF90b2tlbihpbmRleCk7aWYoY2hlY2tfdG9rZW4ud2FudGVkX25ld2xpbmUpe2ZsYWdzLmlubGluZV9mcmFtZT1mYWxzZTticmVhazt9fXdoaWxlKGNoZWNrX3Rva2VuLnR5cGUhPT0nVEtfRU9GJyYmIShjaGVja190b2tlbi50eXBlPT09J1RLX0VORF9CTE9DSycmJmNoZWNrX3Rva2VuLm9wZW5lZD09PWN1cnJlbnRfdG9rZW4pKTt9aWYoaXNfYXJyYXkocHJldmlvdXNfZmxhZ3MubW9kZSkmJihsYXN0X3R5cGU9PT0nVEtfU1RBUlRfRVhQUid8fGxhc3RfdHlwZT09PSdUS19DT01NQScpKXsvLyBpZiB3ZSdyZSBwcmVzZXJ2aW5nIGlubGluZSxcbi8vIGFsbG93IG5ld2xpbmUgYmV0d2VlbiBjb21tYSBhbmQgbmV4dCBicmFjZS5cbmlmKGxhc3RfdHlwZT09PSdUS19DT01NQSd8fG9wdC5zcGFjZV9pbl9wYXJlbil7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO31pZihvcHQuYnJhY2Vfc3R5bGU9PT0nY29sbGFwc2UtcHJlc2VydmUtaW5saW5lJyYmKGxhc3RfdHlwZT09PSdUS19DT01NQSd8fGxhc3RfdHlwZT09PSdUS19TVEFSVF9FWFBSJyYmZmxhZ3MuaW5saW5lX2ZyYW1lKSl7YWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO3ByZXZpb3VzX2ZsYWdzLm11bHRpbGluZV9mcmFtZT1wcmV2aW91c19mbGFncy5tdWx0aWxpbmVfZnJhbWV8fGZsYWdzLm11bHRpbGluZV9mcmFtZTtmbGFncy5tdWx0aWxpbmVfZnJhbWU9ZmFsc2U7fX1lbHNlIGlmKGxhc3RfdHlwZSE9PSdUS19PUEVSQVRPUicmJmxhc3RfdHlwZSE9PSdUS19TVEFSVF9FWFBSJyl7aWYobGFzdF90eXBlPT09J1RLX1NUQVJUX0JMT0NLJyl7cHJpbnRfbmV3bGluZSgpO31lbHNle291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9fX1wcmludF90b2tlbigpO2luZGVudCgpO31mdW5jdGlvbiBoYW5kbGVfZW5kX2Jsb2NrKCl7Ly8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG53aGlsZShmbGFncy5tb2RlPT09TU9ERS5TdGF0ZW1lbnQpe3Jlc3RvcmVfbW9kZSgpO312YXIgZW1wdHlfYnJhY2VzPWxhc3RfdHlwZT09PSdUS19TVEFSVF9CTE9DSyc7aWYob3B0LmJyYWNlX3N0eWxlPT09XCJleHBhbmRcIil7aWYoIWVtcHR5X2JyYWNlcyl7cHJpbnRfbmV3bGluZSgpO319ZWxzZXsvLyBza2lwIHt9XG5pZighZW1wdHlfYnJhY2VzKXtpZihmbGFncy5pbmxpbmVfZnJhbWUpe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9ZWxzZSBpZihpc19hcnJheShmbGFncy5tb2RlKSYmb3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb24pey8vIHdlIFJFQUxMWSBuZWVkIGEgbmV3bGluZSBoZXJlLCBidXQgbmV3bGluZXIgd291bGQgc2tpcCB0aGF0XG5vcHQua2VlcF9hcnJheV9pbmRlbnRhdGlvbj1mYWxzZTtwcmludF9uZXdsaW5lKCk7b3B0LmtlZXBfYXJyYXlfaW5kZW50YXRpb249dHJ1ZTt9ZWxzZXtwcmludF9uZXdsaW5lKCk7fX19cmVzdG9yZV9tb2RlKCk7cHJpbnRfdG9rZW4oKTt9ZnVuY3Rpb24gaGFuZGxlX3dvcmQoKXtpZihjdXJyZW50X3Rva2VuLnR5cGU9PT0nVEtfUkVTRVJWRUQnKXtpZihpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsWydzZXQnLCdnZXQnXSkmJmZsYWdzLm1vZGUhPT1NT0RFLk9iamVjdExpdGVyYWwpe2N1cnJlbnRfdG9rZW4udHlwZT0nVEtfV09SRCc7fWVsc2UgaWYoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LFsnYXMnLCdmcm9tJ10pJiYhZmxhZ3MuaW1wb3J0X2Jsb2NrKXtjdXJyZW50X3Rva2VuLnR5cGU9J1RLX1dPUkQnO31lbHNlIGlmKGZsYWdzLm1vZGU9PT1NT0RFLk9iamVjdExpdGVyYWwpe3ZhciBuZXh0X3Rva2VuPWdldF90b2tlbigxKTtpZihuZXh0X3Rva2VuLnRleHQ9PT0nOicpe2N1cnJlbnRfdG9rZW4udHlwZT0nVEtfV09SRCc7fX19aWYoc3RhcnRfb2Zfc3RhdGVtZW50KCkpey8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbn1lbHNlIGlmKGN1cnJlbnRfdG9rZW4ud2FudGVkX25ld2xpbmUmJiFpc19leHByZXNzaW9uKGZsYWdzLm1vZGUpJiYobGFzdF90eXBlIT09J1RLX09QRVJBVE9SJ3x8ZmxhZ3MubGFzdF90ZXh0PT09Jy0tJ3x8ZmxhZ3MubGFzdF90ZXh0PT09JysrJykmJmxhc3RfdHlwZSE9PSdUS19FUVVBTFMnJiYob3B0LnByZXNlcnZlX25ld2xpbmVzfHwhKGxhc3RfdHlwZT09PSdUS19SRVNFUlZFRCcmJmluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCxbJ3ZhcicsJ2xldCcsJ2NvbnN0Jywnc2V0JywnZ2V0J10pKSkpe3ByaW50X25ld2xpbmUoKTt9aWYoZmxhZ3MuZG9fYmxvY2smJiFmbGFncy5kb193aGlsZSl7aWYoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmY3VycmVudF90b2tlbi50ZXh0PT09J3doaWxlJyl7Ly8gZG8ge30gIyMgd2hpbGUgKClcbm91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTtwcmludF90b2tlbigpO291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTtmbGFncy5kb193aGlsZT10cnVlO3JldHVybjt9ZWxzZXsvLyBkbyB7fSBzaG91bGQgYWx3YXlzIGhhdmUgd2hpbGUgYXMgdGhlIG5leHQgd29yZC5cbi8vIGlmIHdlIGRvbid0IHNlZSB0aGUgZXhwZWN0ZWQgd2hpbGUsIHJlY292ZXJcbnByaW50X25ld2xpbmUoKTtmbGFncy5kb19ibG9jaz1mYWxzZTt9fS8vIGlmIG1heSBiZSBmb2xsb3dlZCBieSBlbHNlLCBvciBub3Rcbi8vIEJhcmUvaW5saW5lIGlmcyBhcmUgdHJpY2t5XG4vLyBOZWVkIHRvIHVud2luZCB0aGUgbW9kZXMgY29ycmVjdGx5OiBpZiAoYSkgaWYgKGIpIGMoKTsgZWxzZSBkKCk7IGVsc2UgZSgpO1xuaWYoZmxhZ3MuaWZfYmxvY2spe2lmKCFmbGFncy5lbHNlX2Jsb2NrJiZjdXJyZW50X3Rva2VuLnR5cGU9PT0nVEtfUkVTRVJWRUQnJiZjdXJyZW50X3Rva2VuLnRleHQ9PT0nZWxzZScpe2ZsYWdzLmVsc2VfYmxvY2s9dHJ1ZTt9ZWxzZXt3aGlsZShmbGFncy5tb2RlPT09TU9ERS5TdGF0ZW1lbnQpe3Jlc3RvcmVfbW9kZSgpO31mbGFncy5pZl9ibG9jaz1mYWxzZTtmbGFncy5lbHNlX2Jsb2NrPWZhbHNlO319aWYoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmKGN1cnJlbnRfdG9rZW4udGV4dD09PSdjYXNlJ3x8Y3VycmVudF90b2tlbi50ZXh0PT09J2RlZmF1bHQnJiZmbGFncy5pbl9jYXNlX3N0YXRlbWVudCkpe3ByaW50X25ld2xpbmUoKTtpZihmbGFncy5jYXNlX2JvZHl8fG9wdC5qc2xpbnRfaGFwcHkpey8vIHN3aXRjaCBjYXNlcyBmb2xsb3dpbmcgb25lIGFub3RoZXJcbmRlaW5kZW50KCk7ZmxhZ3MuY2FzZV9ib2R5PWZhbHNlO31wcmludF90b2tlbigpO2ZsYWdzLmluX2Nhc2U9dHJ1ZTtmbGFncy5pbl9jYXNlX3N0YXRlbWVudD10cnVlO3JldHVybjt9aWYoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmY3VycmVudF90b2tlbi50ZXh0PT09J2Z1bmN0aW9uJyl7aWYoaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsnfScsJzsnXSl8fG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSYmIWluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCxbJ1snLCd7JywnOicsJz0nLCcsJ10pKXsvLyBtYWtlIHN1cmUgdGhlcmUgaXMgYSBuaWNlIGNsZWFuIHNwYWNlIG9mIGF0IGxlYXN0IG9uZSBibGFuayBsaW5lXG4vLyBiZWZvcmUgYSBuZXcgZnVuY3Rpb24gZGVmaW5pdGlvblxuaWYoIW91dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpJiYhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUubGVuZ3RoKXtwcmludF9uZXdsaW5lKCk7cHJpbnRfbmV3bGluZSh0cnVlKTt9fWlmKGxhc3RfdHlwZT09PSdUS19SRVNFUlZFRCd8fGxhc3RfdHlwZT09PSdUS19XT1JEJyl7aWYobGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsnZ2V0Jywnc2V0JywnbmV3JywncmV0dXJuJywnZXhwb3J0JywnYXN5bmMnXSkpe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZmbGFncy5sYXN0X3RleHQ9PT0nZGVmYXVsdCcmJmxhc3RfbGFzdF90ZXh0PT09J2V4cG9ydCcpe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9ZWxzZXtwcmludF9uZXdsaW5lKCk7fX1lbHNlIGlmKGxhc3RfdHlwZT09PSdUS19PUEVSQVRPUid8fGZsYWdzLmxhc3RfdGV4dD09PSc9Jyl7Ly8gZm9vID0gZnVuY3Rpb25cbm91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9ZWxzZSBpZighZmxhZ3MubXVsdGlsaW5lX2ZyYW1lJiYoaXNfZXhwcmVzc2lvbihmbGFncy5tb2RlKXx8aXNfYXJyYXkoZmxhZ3MubW9kZSkpKXsvLyAoZnVuY3Rpb25cbn1lbHNle3ByaW50X25ld2xpbmUoKTt9fWlmKGxhc3RfdHlwZT09PSdUS19DT01NQSd8fGxhc3RfdHlwZT09PSdUS19TVEFSVF9FWFBSJ3x8bGFzdF90eXBlPT09J1RLX0VRVUFMUyd8fGxhc3RfdHlwZT09PSdUS19PUEVSQVRPUicpe2lmKCFzdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSl7YWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO319aWYoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LFsnZnVuY3Rpb24nLCdnZXQnLCdzZXQnXSkpe3ByaW50X3Rva2VuKCk7ZmxhZ3MubGFzdF93b3JkPWN1cnJlbnRfdG9rZW4udGV4dDtyZXR1cm47fXByZWZpeD0nTk9ORSc7aWYobGFzdF90eXBlPT09J1RLX0VORF9CTE9DSycpe2lmKCEoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LFsnZWxzZScsJ2NhdGNoJywnZmluYWxseScsJ2Zyb20nXSkpKXtwcmVmaXg9J05FV0xJTkUnO31lbHNle2lmKG9wdC5icmFjZV9zdHlsZT09PVwiZXhwYW5kXCJ8fG9wdC5icmFjZV9zdHlsZT09PVwiZW5kLWV4cGFuZFwifHxvcHQuYnJhY2Vfc3R5bGU9PT1cIm5vbmVcIiYmY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSl7cHJlZml4PSdORVdMSU5FJzt9ZWxzZXtwcmVmaXg9J1NQQUNFJztvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7fX19ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfU0VNSUNPTE9OJyYmZmxhZ3MubW9kZT09PU1PREUuQmxvY2tTdGF0ZW1lbnQpey8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGZvciBTVEFURU1FTlQgYXMgd2VsbD9cbnByZWZpeD0nTkVXTElORSc7fWVsc2UgaWYobGFzdF90eXBlPT09J1RLX1NFTUlDT0xPTicmJmlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkpe3ByZWZpeD0nU1BBQ0UnO31lbHNlIGlmKGxhc3RfdHlwZT09PSdUS19TVFJJTkcnKXtwcmVmaXg9J05FV0xJTkUnO31lbHNlIGlmKGxhc3RfdHlwZT09PSdUS19SRVNFUlZFRCd8fGxhc3RfdHlwZT09PSdUS19XT1JEJ3x8ZmxhZ3MubGFzdF90ZXh0PT09JyonJiYoaW5fYXJyYXkobGFzdF9sYXN0X3RleHQsWydmdW5jdGlvbicsJ3lpZWxkJ10pfHxmbGFncy5tb2RlPT09TU9ERS5PYmplY3RMaXRlcmFsJiZpbl9hcnJheShsYXN0X2xhc3RfdGV4dCxbJ3snLCcsJ10pKSl7cHJlZml4PSdTUEFDRSc7fWVsc2UgaWYobGFzdF90eXBlPT09J1RLX1NUQVJUX0JMT0NLJyl7aWYoZmxhZ3MuaW5saW5lX2ZyYW1lKXtwcmVmaXg9J1NQQUNFJzt9ZWxzZXtwcmVmaXg9J05FV0xJTkUnO319ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfRU5EX0VYUFInKXtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7cHJlZml4PSdORVdMSU5FJzt9aWYoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LFRva2VuaXplci5saW5lX3N0YXJ0ZXJzKSYmZmxhZ3MubGFzdF90ZXh0IT09JyknKXtpZihmbGFncy5pbmxpbmVfZnJhbWV8fGZsYWdzLmxhc3RfdGV4dD09PSdlbHNlJ3x8ZmxhZ3MubGFzdF90ZXh0PT09J2V4cG9ydCcpe3ByZWZpeD0nU1BBQ0UnO31lbHNle3ByZWZpeD0nTkVXTElORSc7fX1pZihjdXJyZW50X3Rva2VuLnR5cGU9PT0nVEtfUkVTRVJWRUQnJiZpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsWydlbHNlJywnY2F0Y2gnLCdmaW5hbGx5J10pKXtpZighKGxhc3RfdHlwZT09PSdUS19FTkRfQkxPQ0snJiZwcmV2aW91c19mbGFncy5tb2RlPT09TU9ERS5CbG9ja1N0YXRlbWVudCl8fG9wdC5icmFjZV9zdHlsZT09PVwiZXhwYW5kXCJ8fG9wdC5icmFjZV9zdHlsZT09PVwiZW5kLWV4cGFuZFwifHxvcHQuYnJhY2Vfc3R5bGU9PT1cIm5vbmVcIiYmY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSl7cHJpbnRfbmV3bGluZSgpO31lbHNle291dHB1dC50cmltKHRydWUpO3ZhciBsaW5lPW91dHB1dC5jdXJyZW50X2xpbmU7Ly8gSWYgd2UgdHJpbW1lZCBhbmQgdGhlcmUncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsb3NlIGJsb2NrIGJlZm9yZSB1c1xuLy8gcHV0IGEgbmV3bGluZSBiYWNrIGluLiAgSGFuZGxlcyAnfSAvLyBjb21tZW50JyBzY2VuYXJpby5cbmlmKGxpbmUubGFzdCgpIT09J30nKXtwcmludF9uZXdsaW5lKCk7fW91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9fWVsc2UgaWYocHJlZml4PT09J05FV0xJTkUnKXtpZihsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSl7Ly8gbm8gbmV3bGluZSBiZXR3ZWVuICdyZXR1cm4gbm5uJ1xub3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO31lbHNlIGlmKGxhc3RfdHlwZSE9PSdUS19FTkRfRVhQUicpe2lmKChsYXN0X3R5cGUhPT0nVEtfU1RBUlRfRVhQUid8fCEoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LFsndmFyJywnbGV0JywnY29uc3QnXSkpKSYmZmxhZ3MubGFzdF90ZXh0IT09JzonKXsvLyBubyBuZWVkIHRvIGZvcmNlIG5ld2xpbmUgb24gJ3Zhcic6IGZvciAodmFyIHggPSAwLi4uKVxuaWYoY3VycmVudF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmY3VycmVudF90b2tlbi50ZXh0PT09J2lmJyYmZmxhZ3MubGFzdF90ZXh0PT09J2Vsc2UnKXsvLyBubyBuZXdsaW5lIGZvciB9IGVsc2UgaWYge1xub3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO31lbHNle3ByaW50X25ld2xpbmUoKTt9fX1lbHNlIGlmKGN1cnJlbnRfdG9rZW4udHlwZT09PSdUS19SRVNFUlZFRCcmJmluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCxUb2tlbml6ZXIubGluZV9zdGFydGVycykmJmZsYWdzLmxhc3RfdGV4dCE9PScpJyl7cHJpbnRfbmV3bGluZSgpO319ZWxzZSBpZihmbGFncy5tdWx0aWxpbmVfZnJhbWUmJmlzX2FycmF5KGZsYWdzLm1vZGUpJiZmbGFncy5sYXN0X3RleHQ9PT0nLCcmJmxhc3RfbGFzdF90ZXh0PT09J30nKXtwcmludF9uZXdsaW5lKCk7Ly8gfSwgaW4gbGlzdHMgZ2V0IGEgbmV3bGluZSB0cmVhdG1lbnRcbn1lbHNlIGlmKHByZWZpeD09PSdTUEFDRScpe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9cHJpbnRfdG9rZW4oKTtmbGFncy5sYXN0X3dvcmQ9Y3VycmVudF90b2tlbi50ZXh0O2lmKGN1cnJlbnRfdG9rZW4udHlwZT09PSdUS19SRVNFUlZFRCcpe2lmKGN1cnJlbnRfdG9rZW4udGV4dD09PSdkbycpe2ZsYWdzLmRvX2Jsb2NrPXRydWU7fWVsc2UgaWYoY3VycmVudF90b2tlbi50ZXh0PT09J2lmJyl7ZmxhZ3MuaWZfYmxvY2s9dHJ1ZTt9ZWxzZSBpZihjdXJyZW50X3Rva2VuLnRleHQ9PT0naW1wb3J0Jyl7ZmxhZ3MuaW1wb3J0X2Jsb2NrPXRydWU7fWVsc2UgaWYoZmxhZ3MuaW1wb3J0X2Jsb2NrJiZjdXJyZW50X3Rva2VuLnR5cGU9PT0nVEtfUkVTRVJWRUQnJiZjdXJyZW50X3Rva2VuLnRleHQ9PT0nZnJvbScpe2ZsYWdzLmltcG9ydF9ibG9jaz1mYWxzZTt9fX1mdW5jdGlvbiBoYW5kbGVfc2VtaWNvbG9uKCl7aWYoc3RhcnRfb2Zfc3RhdGVtZW50KCkpey8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbi8vIFNlbWljb2xvbiBjYW4gYmUgdGhlIHN0YXJ0IChhbmQgZW5kKSBvZiBhIHN0YXRlbWVudFxub3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj1mYWxzZTt9d2hpbGUoZmxhZ3MubW9kZT09PU1PREUuU3RhdGVtZW50JiYhZmxhZ3MuaWZfYmxvY2smJiFmbGFncy5kb19ibG9jayl7cmVzdG9yZV9tb2RlKCk7fS8vIGhhY2t5IGJ1dCBlZmZlY3RpdmUgZm9yIHRoZSBtb21lbnRcbmlmKGZsYWdzLmltcG9ydF9ibG9jayl7ZmxhZ3MuaW1wb3J0X2Jsb2NrPWZhbHNlO31wcmludF90b2tlbigpO31mdW5jdGlvbiBoYW5kbGVfc3RyaW5nKCl7aWYoc3RhcnRfb2Zfc3RhdGVtZW50KCkpey8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbi8vIE9uZSBkaWZmZXJlbmNlIC0gc3RyaW5ncyB3YW50IGF0IGxlYXN0IGEgc3BhY2UgYmVmb3JlXG5vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7fWVsc2UgaWYobGFzdF90eXBlPT09J1RLX1JFU0VSVkVEJ3x8bGFzdF90eXBlPT09J1RLX1dPUkQnfHxmbGFncy5pbmxpbmVfZnJhbWUpe291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTt9ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfQ09NTUEnfHxsYXN0X3R5cGU9PT0nVEtfU1RBUlRfRVhQUid8fGxhc3RfdHlwZT09PSdUS19FUVVBTFMnfHxsYXN0X3R5cGU9PT0nVEtfT1BFUkFUT1InKXtpZighc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpe2FsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTt9fWVsc2V7cHJpbnRfbmV3bGluZSgpO31wcmludF90b2tlbigpO31mdW5jdGlvbiBoYW5kbGVfZXF1YWxzKCl7aWYoc3RhcnRfb2Zfc3RhdGVtZW50KCkpey8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbn1pZihmbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpey8vIGp1c3QgZ290IGFuICc9JyBpbiBhIHZhci1saW5lLCBkaWZmZXJlbnQgZm9ybWF0dGluZy9saW5lLWJyZWFraW5nLCBldGMgd2lsbCBub3cgYmUgZG9uZVxuZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudD10cnVlO31vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7cHJpbnRfdG9rZW4oKTtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7fWZ1bmN0aW9uIGhhbmRsZV9jb21tYSgpe3ByaW50X3Rva2VuKCk7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO2lmKGZsYWdzLmRlY2xhcmF0aW9uX3N0YXRlbWVudCl7aWYoaXNfZXhwcmVzc2lvbihmbGFncy5wYXJlbnQubW9kZSkpey8vIGRvIG5vdCBicmVhayBvbiBjb21tYSwgZm9yKHZhciBhID0gMSwgYiA9IDIpXG5mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50PWZhbHNlO31pZihmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50KXtmbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50PWZhbHNlO3ByaW50X25ld2xpbmUoZmFsc2UsdHJ1ZSk7fWVsc2UgaWYob3B0LmNvbW1hX2ZpcnN0KXsvLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbi8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7fX1lbHNlIGlmKGZsYWdzLm1vZGU9PT1NT0RFLk9iamVjdExpdGVyYWx8fGZsYWdzLm1vZGU9PT1NT0RFLlN0YXRlbWVudCYmZmxhZ3MucGFyZW50Lm1vZGU9PT1NT0RFLk9iamVjdExpdGVyYWwpe2lmKGZsYWdzLm1vZGU9PT1NT0RFLlN0YXRlbWVudCl7cmVzdG9yZV9tb2RlKCk7fWlmKCFmbGFncy5pbmxpbmVfZnJhbWUpe3ByaW50X25ld2xpbmUoKTt9fWVsc2UgaWYob3B0LmNvbW1hX2ZpcnN0KXsvLyBFWFBSIG9yIERPX0JMT0NLXG4vLyBmb3IgY29tbWEtZmlyc3QsIHdlIHdhbnQgdG8gYWxsb3cgYSBuZXdsaW5lIGJlZm9yZSB0aGUgY29tbWFcbi8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7fX1mdW5jdGlvbiBoYW5kbGVfb3BlcmF0b3IoKXtpZihzdGFydF9vZl9zdGF0ZW1lbnQoKSl7Ly8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxufWlmKGxhc3RfdHlwZT09PSdUS19SRVNFUlZFRCcmJmlzX3NwZWNpYWxfd29yZChmbGFncy5sYXN0X3RleHQpKXsvLyBcInJldHVyblwiIGhhZCBhIHNwZWNpYWwgaGFuZGxpbmcgaW4gVEtfV09SRC4gTm93IHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBmYXZvclxub3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO3ByaW50X3Rva2VuKCk7cmV0dXJuO30vLyBoYWNrIGZvciBhY3Rpb25zY3JpcHQncyBpbXBvcnQgLio7XG5pZihjdXJyZW50X3Rva2VuLnRleHQ9PT0nKicmJmxhc3RfdHlwZT09PSdUS19ET1QnKXtwcmludF90b2tlbigpO3JldHVybjt9aWYoY3VycmVudF90b2tlbi50ZXh0PT09Jzo6Jyl7Ly8gbm8gc3BhY2VzIGFyb3VuZCBleG90aWMgbmFtZXNwYWNpbmcgc3ludGF4IG9wZXJhdG9yXG5wcmludF90b2tlbigpO3JldHVybjt9Ly8gQWxsb3cgbGluZSB3cmFwcGluZyBiZXR3ZWVuIG9wZXJhdG9ycyB3aGVuIG9wZXJhdG9yX3Bvc2l0aW9uIGlzXG4vLyAgIHNldCB0byBiZWZvcmUgb3IgcHJlc2VydmVcbmlmKGxhc3RfdHlwZT09PSdUS19PUEVSQVRPUicmJmluX2FycmF5KG9wdC5vcGVyYXRvcl9wb3NpdGlvbixPUEVSQVRPUl9QT1NJVElPTl9CRUZPUkVfT1JfUFJFU0VSVkUpKXthbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7fWlmKGN1cnJlbnRfdG9rZW4udGV4dD09PSc6JyYmZmxhZ3MuaW5fY2FzZSl7ZmxhZ3MuY2FzZV9ib2R5PXRydWU7aW5kZW50KCk7cHJpbnRfdG9rZW4oKTtwcmludF9uZXdsaW5lKCk7ZmxhZ3MuaW5fY2FzZT1mYWxzZTtyZXR1cm47fXZhciBzcGFjZV9iZWZvcmU9dHJ1ZTt2YXIgc3BhY2VfYWZ0ZXI9dHJ1ZTt2YXIgaW5fdGVybmFyeT1mYWxzZTt2YXIgaXNHZW5lcmF0b3JBc3Rlcmlzaz1jdXJyZW50X3Rva2VuLnRleHQ9PT0nKicmJihsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZpbl9hcnJheShmbGFncy5sYXN0X3RleHQsWydmdW5jdGlvbicsJ3lpZWxkJ10pfHxmbGFncy5tb2RlPT09TU9ERS5PYmplY3RMaXRlcmFsJiZpbl9hcnJheShsYXN0X3R5cGUsWydUS19TVEFSVF9CTE9DSycsJ1RLX0NPTU1BJ10pKTt2YXIgaXNVbmFyeT1pbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsWyctJywnKyddKSYmKGluX2FycmF5KGxhc3RfdHlwZSxbJ1RLX1NUQVJUX0JMT0NLJywnVEtfU1RBUlRfRVhQUicsJ1RLX0VRVUFMUycsJ1RLX09QRVJBVE9SJ10pfHxpbl9hcnJheShmbGFncy5sYXN0X3RleHQsVG9rZW5pemVyLmxpbmVfc3RhcnRlcnMpfHxmbGFncy5sYXN0X3RleHQ9PT0nLCcpO2lmKGN1cnJlbnRfdG9rZW4udGV4dD09PSc6Jyl7aWYoZmxhZ3MudGVybmFyeV9kZXB0aD09PTApey8vIENvbG9uIGlzIGludmFsaWQgamF2YXNjcmlwdCBvdXRzaWRlIG9mIHRlcm5hcnkgYW5kIG9iamVjdCwgYnV0IGRvIG91ciBiZXN0IHRvIGd1ZXNzIHdoYXQgd2FzIG1lYW50Llxuc3BhY2VfYmVmb3JlPWZhbHNlO31lbHNle2ZsYWdzLnRlcm5hcnlfZGVwdGgtPTE7aW5fdGVybmFyeT10cnVlO319ZWxzZSBpZihjdXJyZW50X3Rva2VuLnRleHQ9PT0nPycpe2ZsYWdzLnRlcm5hcnlfZGVwdGgrPTE7fS8vIGxldCdzIGhhbmRsZSB0aGUgb3BlcmF0b3JfcG9zaXRpb24gb3B0aW9uIHByaW9yIHRvIGFueSBjb25mbGljdGluZyBsb2dpY1xuaWYoIWlzVW5hcnkmJiFpc0dlbmVyYXRvckFzdGVyaXNrJiZvcHQucHJlc2VydmVfbmV3bGluZXMmJmluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCxUb2tlbml6ZXIucG9zaXRpb25hYmxlX29wZXJhdG9ycykpe3ZhciBpc0NvbG9uPWN1cnJlbnRfdG9rZW4udGV4dD09PSc6Jzt2YXIgaXNUZXJuYXJ5Q29sb249aXNDb2xvbiYmaW5fdGVybmFyeTt2YXIgaXNPdGhlckNvbG9uPWlzQ29sb24mJiFpbl90ZXJuYXJ5O3N3aXRjaChvcHQub3BlcmF0b3JfcG9zaXRpb24pe2Nhc2UgT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmU6Ly8gaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgOiBhbmQgaXQncyBub3QgYSB0ZXJuYXJ5IHN0YXRlbWVudCB0aGVuIHdlIHNldCBzcGFjZV9iZWZvcmUgdG8gZmFsc2Vcbm91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49IWlzT3RoZXJDb2xvbjtwcmludF90b2tlbigpO2lmKCFpc0NvbG9ufHxpc1Rlcm5hcnlDb2xvbil7YWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSgpO31vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7cmV0dXJuO2Nhc2UgT1BFUkFUT1JfUE9TSVRJT04uYWZ0ZXJfbmV3bGluZTovLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyBhbnl0aGluZyBidXQgY29sb24sIG9yICh2aWEgZGVkdWN0aW9uKSBpdCdzIGEgY29sb24gYW5kIGluIGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4vLyAgIHRoZW4gcHJpbnQgYSBuZXdsaW5lLlxub3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO2lmKCFpc0NvbG9ufHxpc1Rlcm5hcnlDb2xvbil7aWYoZ2V0X3Rva2VuKDEpLndhbnRlZF9uZXdsaW5lKXtwcmludF9uZXdsaW5lKGZhbHNlLHRydWUpO31lbHNle2FsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTt9fWVsc2V7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj1mYWxzZTt9cHJpbnRfdG9rZW4oKTtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7cmV0dXJuO2Nhc2UgT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZTppZighaXNPdGhlckNvbG9uKXthbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKCk7fS8vIGlmIHdlIGp1c3QgYWRkZWQgYSBuZXdsaW5lLCBvciB0aGUgY3VycmVudCB0b2tlbiBpcyA6IGFuZCBpdCdzIG5vdCBhIHRlcm5hcnkgc3RhdGVtZW50LFxuLy8gICB0aGVuIHdlIHNldCBzcGFjZV9iZWZvcmUgdG8gZmFsc2VcbnNwYWNlX2JlZm9yZT0hKG91dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKXx8aXNPdGhlckNvbG9uKTtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXNwYWNlX2JlZm9yZTtwcmludF90b2tlbigpO291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49dHJ1ZTtyZXR1cm47fX1pZihpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsWyctLScsJysrJywnIScsJ34nXSl8fGlzVW5hcnkpey8vIHVuYXJ5IG9wZXJhdG9ycyAoYW5kIGJpbmFyeSArLy0gcHJldGVuZGluZyB0byBiZSB1bmFyeSkgc3BlY2lhbCBjYXNlc1xuc3BhY2VfYmVmb3JlPWZhbHNlO3NwYWNlX2FmdGVyPWZhbHNlOy8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjkuMVxuLy8gaWYgdGhlcmUgaXMgYSBuZXdsaW5lIGJldHdlZW4gLS0gb3IgKysgYW5kIGFueXRoaW5nIGVsc2Ugd2Ugc2hvdWxkIHByZXNlcnZlIGl0LlxuaWYoY3VycmVudF90b2tlbi53YW50ZWRfbmV3bGluZSYmKGN1cnJlbnRfdG9rZW4udGV4dD09PSctLSd8fGN1cnJlbnRfdG9rZW4udGV4dD09PScrKycpKXtwcmludF9uZXdsaW5lKGZhbHNlLHRydWUpO31pZihmbGFncy5sYXN0X3RleHQ9PT0nOycmJmlzX2V4cHJlc3Npb24oZmxhZ3MubW9kZSkpey8vIGZvciAoOzsgKytpKVxuLy8gICAgICAgIF5eXlxuc3BhY2VfYmVmb3JlPXRydWU7fWlmKGxhc3RfdHlwZT09PSdUS19SRVNFUlZFRCcpe3NwYWNlX2JlZm9yZT10cnVlO31lbHNlIGlmKGxhc3RfdHlwZT09PSdUS19FTkRfRVhQUicpe3NwYWNlX2JlZm9yZT0hKGZsYWdzLmxhc3RfdGV4dD09PSddJyYmKGN1cnJlbnRfdG9rZW4udGV4dD09PSctLSd8fGN1cnJlbnRfdG9rZW4udGV4dD09PScrKycpKTt9ZWxzZSBpZihsYXN0X3R5cGU9PT0nVEtfT1BFUkFUT1InKXsvLyBhKysgKyArK2I7XG4vLyBhIC0gLWJcbnNwYWNlX2JlZm9yZT1pbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsWyctLScsJy0nLCcrKycsJysnXSkmJmluX2FycmF5KGZsYWdzLmxhc3RfdGV4dCxbJy0tJywnLScsJysrJywnKyddKTsvLyArIGFuZCAtIGFyZSBub3QgdW5hcnkgd2hlbiBwcmVjZWVkZWQgYnkgLS0gb3IgKysgb3BlcmF0b3Jcbi8vIGEtLSArIGJcbi8vIGEgKiArYlxuLy8gYSAtIC1iXG5pZihpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsWycrJywnLSddKSYmaW5fYXJyYXkoZmxhZ3MubGFzdF90ZXh0LFsnLS0nLCcrKyddKSl7c3BhY2VfYWZ0ZXI9dHJ1ZTt9fWlmKChmbGFncy5tb2RlPT09TU9ERS5CbG9ja1N0YXRlbWVudCYmIWZsYWdzLmlubGluZV9mcmFtZXx8ZmxhZ3MubW9kZT09PU1PREUuU3RhdGVtZW50KSYmKGZsYWdzLmxhc3RfdGV4dD09PSd7J3x8ZmxhZ3MubGFzdF90ZXh0PT09JzsnKSl7Ly8geyBmb287IC0taSB9XG4vLyBmb28oKTsgLS1iYXI7XG5wcmludF9uZXdsaW5lKCk7fX1lbHNlIGlmKGlzR2VuZXJhdG9yQXN0ZXJpc2spe2FsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoKTtzcGFjZV9iZWZvcmU9ZmFsc2U7c3BhY2VfYWZ0ZXI9ZmFsc2U7fW91dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW49b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbnx8c3BhY2VfYmVmb3JlO3ByaW50X3Rva2VuKCk7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj1zcGFjZV9hZnRlcjt9ZnVuY3Rpb24gaGFuZGxlX2Jsb2NrX2NvbW1lbnQoKXtpZihvdXRwdXQucmF3KXtvdXRwdXQuYWRkX3Jhd190b2tlbihjdXJyZW50X3Rva2VuKTtpZihjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMmJmN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcy5wcmVzZXJ2ZT09PSdlbmQnKXsvLyBJZiB3ZSdyZSB0ZXN0aW5nIHRoZSByYXcgb3V0cHV0IGJlaGF2aW9yLCBkbyBub3QgYWxsb3cgYSBkaXJlY3RpdmUgdG8gdHVybiBpdCBvZmYuXG5vdXRwdXQucmF3PW9wdC50ZXN0X291dHB1dF9yYXc7fXJldHVybjt9aWYoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzKXtwcmludF9uZXdsaW5lKGZhbHNlLHRydWUpO3ByaW50X3Rva2VuKCk7aWYoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzLnByZXNlcnZlPT09J3N0YXJ0Jyl7b3V0cHV0LnJhdz10cnVlO31wcmludF9uZXdsaW5lKGZhbHNlLHRydWUpO3JldHVybjt9Ly8gaW5saW5lIGJsb2NrXG5pZighYWNvcm4ubmV3bGluZS50ZXN0KGN1cnJlbnRfdG9rZW4udGV4dCkmJiFjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKXtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7cHJpbnRfdG9rZW4oKTtvdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7cmV0dXJuO312YXIgbGluZXM9c3BsaXRfbGluZWJyZWFrcyhjdXJyZW50X3Rva2VuLnRleHQpO3ZhciBqOy8vIGl0ZXJhdG9yIGZvciB0aGlzIGNhc2VcbnZhciBqYXZhZG9jPWZhbHNlO3ZhciBzdGFybGVzcz1mYWxzZTt2YXIgbGFzdEluZGVudD1jdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlO3ZhciBsYXN0SW5kZW50TGVuZ3RoPWxhc3RJbmRlbnQubGVuZ3RoOy8vIGJsb2NrIGNvbW1lbnQgc3RhcnRzIHdpdGggYSBuZXcgbGluZVxucHJpbnRfbmV3bGluZShmYWxzZSx0cnVlKTtpZihsaW5lcy5sZW5ndGg+MSl7amF2YWRvYz1hbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcy5zbGljZSgxKSwnKicpO3N0YXJsZXNzPWVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcy5zbGljZSgxKSxsYXN0SW5kZW50KTt9Ly8gZmlyc3QgbGluZSBhbHdheXMgaW5kZW50ZWRcbnByaW50X3Rva2VuKGxpbmVzWzBdKTtmb3Ioaj0xO2o8bGluZXMubGVuZ3RoO2orKyl7cHJpbnRfbmV3bGluZShmYWxzZSx0cnVlKTtpZihqYXZhZG9jKXsvLyBqYXZhZG9jOiByZWZvcm1hdCBhbmQgcmUtaW5kZW50XG5wcmludF90b2tlbignICcrbHRyaW0obGluZXNbal0pKTt9ZWxzZSBpZihzdGFybGVzcyYmbGluZXNbal0ubGVuZ3RoPmxhc3RJbmRlbnRMZW5ndGgpey8vIHN0YXJsZXNzOiByZS1pbmRlbnQgbm9uLWVtcHR5IGNvbnRlbnQsIGF2b2lkaW5nIHRyaW1cbnByaW50X3Rva2VuKGxpbmVzW2pdLnN1YnN0cmluZyhsYXN0SW5kZW50TGVuZ3RoKSk7fWVsc2V7Ly8gbm9ybWFsIGNvbW1lbnRzIG91dHB1dCByYXdcbm91dHB1dC5hZGRfdG9rZW4obGluZXNbal0pO319Ly8gZm9yIGNvbW1lbnRzIG9mIG1vcmUgdGhhbiBvbmUgbGluZSwgbWFrZSBzdXJlIHRoZXJlJ3MgYSBuZXcgbGluZSBhZnRlclxucHJpbnRfbmV3bGluZShmYWxzZSx0cnVlKTt9ZnVuY3Rpb24gaGFuZGxlX2NvbW1lbnQoKXtpZihjdXJyZW50X3Rva2VuLndhbnRlZF9uZXdsaW5lKXtwcmludF9uZXdsaW5lKGZhbHNlLHRydWUpO31lbHNle291dHB1dC50cmltKHRydWUpO31vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuPXRydWU7cHJpbnRfdG9rZW4oKTtwcmludF9uZXdsaW5lKGZhbHNlLHRydWUpO31mdW5jdGlvbiBoYW5kbGVfZG90KCl7aWYoc3RhcnRfb2Zfc3RhdGVtZW50KCkpey8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbn1pZihsYXN0X3R5cGU9PT0nVEtfUkVTRVJWRUQnJiZpc19zcGVjaWFsX3dvcmQoZmxhZ3MubGFzdF90ZXh0KSl7b3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbj10cnVlO31lbHNley8vIGFsbG93IHByZXNlcnZlZCBuZXdsaW5lcyBiZWZvcmUgZG90cyBpbiBnZW5lcmFsXG4vLyBmb3JjZSBuZXdsaW5lcyBvbiBkb3RzIGFmdGVyIGNsb3NlIHBhcmVuIHdoZW4gYnJlYWtfY2hhaW5lZCAtIGZvciBiYXIoKS5iYXooKVxuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShmbGFncy5sYXN0X3RleHQ9PT0nKScmJm9wdC5icmVha19jaGFpbmVkX21ldGhvZHMpO31wcmludF90b2tlbigpO31mdW5jdGlvbiBoYW5kbGVfdW5rbm93bigpe3ByaW50X3Rva2VuKCk7aWYoY3VycmVudF90b2tlbi50ZXh0W2N1cnJlbnRfdG9rZW4udGV4dC5sZW5ndGgtMV09PT0nXFxuJyl7cHJpbnRfbmV3bGluZSgpO319ZnVuY3Rpb24gaGFuZGxlX2VvZigpey8vIFVud2luZCBhbnkgb3BlbiBzdGF0ZW1lbnRzXG53aGlsZShmbGFncy5tb2RlPT09TU9ERS5TdGF0ZW1lbnQpe3Jlc3RvcmVfbW9kZSgpO319fWZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KXt2YXIgX2NoYXJhY3Rlcl9jb3VudD0wOy8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIGxpbmVzIHRoYXQgaGF2ZSBwcmVzZXJ2ZWQgaW5kZW50YXRpb25cbnZhciBfaW5kZW50X2NvdW50PS0xO3ZhciBfaXRlbXM9W107dmFyIF9lbXB0eT10cnVlO3RoaXMuc2V0X2luZGVudD1mdW5jdGlvbihsZXZlbCl7X2NoYXJhY3Rlcl9jb3VudD1wYXJlbnQuYmFzZUluZGVudExlbmd0aCtsZXZlbCpwYXJlbnQuaW5kZW50X2xlbmd0aDtfaW5kZW50X2NvdW50PWxldmVsO307dGhpcy5nZXRfY2hhcmFjdGVyX2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIF9jaGFyYWN0ZXJfY291bnQ7fTt0aGlzLmlzX2VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIF9lbXB0eTt9O3RoaXMubGFzdD1mdW5jdGlvbigpe2lmKCF0aGlzLl9lbXB0eSl7cmV0dXJuIF9pdGVtc1tfaXRlbXMubGVuZ3RoLTFdO31lbHNle3JldHVybiBudWxsO319O3RoaXMucHVzaD1mdW5jdGlvbihpbnB1dCl7X2l0ZW1zLnB1c2goaW5wdXQpO19jaGFyYWN0ZXJfY291bnQrPWlucHV0Lmxlbmd0aDtfZW1wdHk9ZmFsc2U7fTt0aGlzLnBvcD1mdW5jdGlvbigpe3ZhciBpdGVtPW51bGw7aWYoIV9lbXB0eSl7aXRlbT1faXRlbXMucG9wKCk7X2NoYXJhY3Rlcl9jb3VudC09aXRlbS5sZW5ndGg7X2VtcHR5PV9pdGVtcy5sZW5ndGg9PT0wO31yZXR1cm4gaXRlbTt9O3RoaXMucmVtb3ZlX2luZGVudD1mdW5jdGlvbigpe2lmKF9pbmRlbnRfY291bnQ+MCl7X2luZGVudF9jb3VudC09MTtfY2hhcmFjdGVyX2NvdW50LT1wYXJlbnQuaW5kZW50X2xlbmd0aDt9fTt0aGlzLnRyaW09ZnVuY3Rpb24oKXt3aGlsZSh0aGlzLmxhc3QoKT09PScgJyl7X2l0ZW1zLnBvcCgpO19jaGFyYWN0ZXJfY291bnQtPTE7fV9lbXB0eT1faXRlbXMubGVuZ3RoPT09MDt9O3RoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgcmVzdWx0PScnO2lmKCF0aGlzLl9lbXB0eSl7aWYoX2luZGVudF9jb3VudD49MCl7cmVzdWx0PXBhcmVudC5pbmRlbnRfY2FjaGVbX2luZGVudF9jb3VudF07fXJlc3VsdCs9X2l0ZW1zLmpvaW4oJycpO31yZXR1cm4gcmVzdWx0O307fWZ1bmN0aW9uIE91dHB1dChpbmRlbnRfc3RyaW5nLGJhc2VJbmRlbnRTdHJpbmcpe2Jhc2VJbmRlbnRTdHJpbmc9YmFzZUluZGVudFN0cmluZ3x8Jyc7dGhpcy5pbmRlbnRfY2FjaGU9W2Jhc2VJbmRlbnRTdHJpbmddO3RoaXMuYmFzZUluZGVudExlbmd0aD1iYXNlSW5kZW50U3RyaW5nLmxlbmd0aDt0aGlzLmluZGVudF9sZW5ndGg9aW5kZW50X3N0cmluZy5sZW5ndGg7dGhpcy5yYXc9ZmFsc2U7dmFyIGxpbmVzPVtdO3RoaXMuYmFzZUluZGVudFN0cmluZz1iYXNlSW5kZW50U3RyaW5nO3RoaXMuaW5kZW50X3N0cmluZz1pbmRlbnRfc3RyaW5nO3RoaXMucHJldmlvdXNfbGluZT1udWxsO3RoaXMuY3VycmVudF9saW5lPW51bGw7dGhpcy5zcGFjZV9iZWZvcmVfdG9rZW49ZmFsc2U7dGhpcy5hZGRfb3V0cHV0bGluZT1mdW5jdGlvbigpe3RoaXMucHJldmlvdXNfbGluZT10aGlzLmN1cnJlbnRfbGluZTt0aGlzLmN1cnJlbnRfbGluZT1uZXcgT3V0cHV0TGluZSh0aGlzKTtsaW5lcy5wdXNoKHRoaXMuY3VycmVudF9saW5lKTt9Oy8vIGluaXRpYWxpemVcbnRoaXMuYWRkX291dHB1dGxpbmUoKTt0aGlzLmdldF9saW5lX251bWJlcj1mdW5jdGlvbigpe3JldHVybiBsaW5lcy5sZW5ndGg7fTsvLyBVc2luZyBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmcgdG8gYWxsb3cgZm9yIGxhdGVyIGV4cGFuc2lvbiBvZiBpbmZvIGFib3V0IGVhY2ggbGluZVxudGhpcy5hZGRfbmV3X2xpbmU9ZnVuY3Rpb24oZm9yY2VfbmV3bGluZSl7aWYodGhpcy5nZXRfbGluZV9udW1iZXIoKT09PTEmJnRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpe3JldHVybiBmYWxzZTsvLyBubyBuZXdsaW5lIG9uIHN0YXJ0IG9mIGZpbGVcbn1pZihmb3JjZV9uZXdsaW5lfHwhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSl7aWYoIXRoaXMucmF3KXt0aGlzLmFkZF9vdXRwdXRsaW5lKCk7fXJldHVybiB0cnVlO31yZXR1cm4gZmFsc2U7fTt0aGlzLmdldF9jb2RlPWZ1bmN0aW9uKCl7dmFyIHN3ZWV0X2NvZGU9bGluZXMuam9pbignXFxuJykucmVwbGFjZSgvW1xcclxcblxcdCBdKyQvLCcnKTtyZXR1cm4gc3dlZXRfY29kZTt9O3RoaXMuc2V0X2luZGVudD1mdW5jdGlvbihsZXZlbCl7Ly8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbmlmKGxpbmVzLmxlbmd0aD4xKXt3aGlsZShsZXZlbD49dGhpcy5pbmRlbnRfY2FjaGUubGVuZ3RoKXt0aGlzLmluZGVudF9jYWNoZS5wdXNoKHRoaXMuaW5kZW50X2NhY2hlW3RoaXMuaW5kZW50X2NhY2hlLmxlbmd0aC0xXSt0aGlzLmluZGVudF9zdHJpbmcpO310aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGxldmVsKTtyZXR1cm4gdHJ1ZTt9dGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgwKTtyZXR1cm4gZmFsc2U7fTt0aGlzLmFkZF9yYXdfdG9rZW49ZnVuY3Rpb24odG9rZW4pe2Zvcih2YXIgeD0wO3g8dG9rZW4ubmV3bGluZXM7eCsrKXt0aGlzLmFkZF9vdXRwdXRsaW5lKCk7fXRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO3RoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7dGhpcy5zcGFjZV9iZWZvcmVfdG9rZW49ZmFsc2U7fTt0aGlzLmFkZF90b2tlbj1mdW5jdGlvbihwcmludGFibGVfdG9rZW4pe3RoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO3RoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTt9O3RoaXMuYWRkX3NwYWNlX2JlZm9yZV90b2tlbj1mdW5jdGlvbigpe2lmKHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuJiYhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSl7dGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO310aGlzLnNwYWNlX2JlZm9yZV90b2tlbj1mYWxzZTt9O3RoaXMucmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbj1mdW5jdGlvbihmcmFtZSl7Ly8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBlZmZlY3RpdmUgYnV0IGhhcyBzb21lIGlzc3Vlczpcbi8vICAgICAtIGNhbiBjYXVzZSBsaW5lIHdyYXAgdG8gaGFwcGVuIHRvbyBzb29uIGR1ZSB0byBpbmRlbnQgcmVtb3ZhbFxuLy8gICAgICAgICAgIGFmdGVyIHdyYXAgcG9pbnRzIGFyZSBjYWxjdWxhdGVkXG4vLyBUaGVzZSBpc3N1ZXMgYXJlIG1pbm9yIGNvbXBhcmVkIHRvIHVnbHkgaW5kZW50YXRpb24uXG5pZihmcmFtZS5tdWx0aWxpbmVfZnJhbWV8fGZyYW1lLm1vZGU9PT1NT0RFLkZvckluaXRpYWxpemVyfHxmcmFtZS5tb2RlPT09TU9ERS5Db25kaXRpb25hbCl7cmV0dXJuO30vLyByZW1vdmUgb25lIGluZGVudCBmcm9tIGVhY2ggbGluZSBpbnNpZGUgdGhpcyBzZWN0aW9uXG52YXIgaW5kZXg9ZnJhbWUuc3RhcnRfbGluZV9pbmRleDt2YXIgb3V0cHV0X2xlbmd0aD1saW5lcy5sZW5ndGg7d2hpbGUoaW5kZXg8b3V0cHV0X2xlbmd0aCl7bGluZXNbaW5kZXhdLnJlbW92ZV9pbmRlbnQoKTtpbmRleCsrO319O3RoaXMudHJpbT1mdW5jdGlvbihlYXRfbmV3bGluZXMpe2VhdF9uZXdsaW5lcz1lYXRfbmV3bGluZXM9PT11bmRlZmluZWQ/ZmFsc2U6ZWF0X25ld2xpbmVzO3RoaXMuY3VycmVudF9saW5lLnRyaW0oaW5kZW50X3N0cmluZyxiYXNlSW5kZW50U3RyaW5nKTt3aGlsZShlYXRfbmV3bGluZXMmJmxpbmVzLmxlbmd0aD4xJiZ0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpKXtsaW5lcy5wb3AoKTt0aGlzLmN1cnJlbnRfbGluZT1saW5lc1tsaW5lcy5sZW5ndGgtMV07dGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO310aGlzLnByZXZpb3VzX2xpbmU9bGluZXMubGVuZ3RoPjE/bGluZXNbbGluZXMubGVuZ3RoLTJdOm51bGw7fTt0aGlzLmp1c3RfYWRkZWRfbmV3bGluZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO307dGhpcy5qdXN0X2FkZGVkX2JsYW5rbGluZT1mdW5jdGlvbigpe2lmKHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpe2lmKGxpbmVzLmxlbmd0aD09PTEpe3JldHVybiB0cnVlOy8vIHN0YXJ0IG9mIHRoZSBmaWxlIGFuZCBuZXdsaW5lID0gYmxhbmtcbn12YXIgbGluZT1saW5lc1tsaW5lcy5sZW5ndGgtMl07cmV0dXJuIGxpbmUuaXNfZW1wdHkoKTt9cmV0dXJuIGZhbHNlO307fXZhciBJbnB1dFNjYW5uZXI9ZnVuY3Rpb24oaW5wdXQpe3ZhciBfaW5wdXQ9aW5wdXQ7dmFyIF9pbnB1dF9sZW5ndGg9X2lucHV0Lmxlbmd0aDt2YXIgX3Bvc2l0aW9uPTA7dGhpcy5iYWNrPWZ1bmN0aW9uKCl7X3Bvc2l0aW9uLT0xO307dGhpcy5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9wb3NpdGlvbjxfaW5wdXRfbGVuZ3RoO307dGhpcy5uZXh0PWZ1bmN0aW9uKCl7dmFyIHZhbD1udWxsO2lmKHRoaXMuaGFzTmV4dCgpKXt2YWw9X2lucHV0LmNoYXJBdChfcG9zaXRpb24pO19wb3NpdGlvbis9MTt9cmV0dXJuIHZhbDt9O3RoaXMucGVlaz1mdW5jdGlvbihpbmRleCl7dmFyIHZhbD1udWxsO2luZGV4PWluZGV4fHwwO2luZGV4Kz1fcG9zaXRpb247aWYoaW5kZXg+PTAmJmluZGV4PF9pbnB1dF9sZW5ndGgpe3ZhbD1faW5wdXQuY2hhckF0KGluZGV4KTt9cmV0dXJuIHZhbDt9O3RoaXMucGVla0NoYXJDb2RlPWZ1bmN0aW9uKGluZGV4KXt2YXIgdmFsPTA7aW5kZXg9aW5kZXh8fDA7aW5kZXgrPV9wb3NpdGlvbjtpZihpbmRleD49MCYmaW5kZXg8X2lucHV0X2xlbmd0aCl7dmFsPV9pbnB1dC5jaGFyQ29kZUF0KGluZGV4KTt9cmV0dXJuIHZhbDt9O3RoaXMudGVzdD1mdW5jdGlvbihwYXR0ZXJuLGluZGV4KXtpbmRleD1pbmRleHx8MDtwYXR0ZXJuLmxhc3RJbmRleD1fcG9zaXRpb24raW5kZXg7cmV0dXJuIHBhdHRlcm4udGVzdChfaW5wdXQpO307dGhpcy50ZXN0Q2hhcj1mdW5jdGlvbihwYXR0ZXJuLGluZGV4KXt2YXIgdmFsPXRoaXMucGVlayhpbmRleCk7cmV0dXJuIHZhbCE9PW51bGwmJnBhdHRlcm4udGVzdCh2YWwpO307dGhpcy5tYXRjaD1mdW5jdGlvbihwYXR0ZXJuKXtwYXR0ZXJuLmxhc3RJbmRleD1fcG9zaXRpb247dmFyIHBhdHRlcm5fbWF0Y2g9cGF0dGVybi5leGVjKF9pbnB1dCk7aWYocGF0dGVybl9tYXRjaCYmcGF0dGVybl9tYXRjaC5pbmRleD09PV9wb3NpdGlvbil7X3Bvc2l0aW9uKz1wYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDt9ZWxzZXtwYXR0ZXJuX21hdGNoPW51bGw7fXJldHVybiBwYXR0ZXJuX21hdGNoO307fTt2YXIgVG9rZW49ZnVuY3Rpb24odHlwZSx0ZXh0LG5ld2xpbmVzLHdoaXRlc3BhY2VfYmVmb3JlLHBhcmVudCl7dGhpcy50eXBlPXR5cGU7dGhpcy50ZXh0PXRleHQ7dGhpcy5jb21tZW50c19iZWZvcmU9W107dGhpcy5uZXdsaW5lcz1uZXdsaW5lc3x8MDt0aGlzLndhbnRlZF9uZXdsaW5lPW5ld2xpbmVzPjA7dGhpcy53aGl0ZXNwYWNlX2JlZm9yZT13aGl0ZXNwYWNlX2JlZm9yZXx8Jyc7dGhpcy5wYXJlbnQ9cGFyZW50fHxudWxsO3RoaXMub3BlbmVkPW51bGw7dGhpcy5kaXJlY3RpdmVzPW51bGw7fTtmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXRfc3RyaW5nLG9wdHMpe3ZhciB3aGl0ZXNwYWNlPVwiXFxuXFxyXFx0IFwiLnNwbGl0KCcnKTt2YXIgZGlnaXQ9L1swLTldLzt2YXIgZGlnaXRfYmluPS9bMDFdLzt2YXIgZGlnaXRfb2N0PS9bMDEyMzQ1NjddLzt2YXIgZGlnaXRfaGV4PS9bMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRl0vO3RoaXMucG9zaXRpb25hYmxlX29wZXJhdG9ycz0nIT0gIT09ICUgJiAmJiAqICoqICsgLSAvIDogPCA8PCA8PSA9PSA9PT0gPiA+PSA+PiA+Pj4gPyBeIHwgfHwnLnNwbGl0KCcgJyk7dmFyIHB1bmN0PXRoaXMucG9zaXRpb25hYmxlX29wZXJhdG9ycy5jb25jYXQoLy8gbm9uLXBvc2l0aW9uYWJsZSBvcGVyYXRvcnMgLSB0aGVzZSBkbyBub3QgZm9sbG93IG9wZXJhdG9yIHBvc2l0aW9uIHNldHRpbmdzXG4nISAlPSAmPSAqPSAqKj0gKysgKz0gLCAtLSAtPSAvPSA6OiA8PD0gPSA9PiA+Pj0gPj4+PSBePSB8PSB+Jy5zcGxpdCgnICcpKTsvLyB3b3JkcyB3aGljaCBzaG91bGQgYWx3YXlzIHN0YXJ0IG9uIG5ldyBsaW5lLlxudGhpcy5saW5lX3N0YXJ0ZXJzPSdjb250aW51ZSx0cnksdGhyb3cscmV0dXJuLHZhcixsZXQsY29uc3QsaWYsc3dpdGNoLGNhc2UsZGVmYXVsdCxmb3Isd2hpbGUsYnJlYWssZnVuY3Rpb24saW1wb3J0LGV4cG9ydCcuc3BsaXQoJywnKTt2YXIgcmVzZXJ2ZWRfd29yZHM9dGhpcy5saW5lX3N0YXJ0ZXJzLmNvbmNhdChbJ2RvJywnaW4nLCdlbHNlJywnZ2V0Jywnc2V0JywnbmV3JywnY2F0Y2gnLCdmaW5hbGx5JywndHlwZW9mJywneWllbGQnLCdhc3luYycsJ2F3YWl0JywnZnJvbScsJ2FzJ10pOy8vICAvKiAuLi4gKi8gY29tbWVudCBlbmRzIHdpdGggbmVhcmVzdCAqLyBvciBlbmQgb2YgZmlsZVxudmFyIGJsb2NrX2NvbW1lbnRfcGF0dGVybj0vKFtcXHNcXFNdKj8pKCg/OlxcKlxcLyl8JCkvZzsvLyBjb21tZW50IGVuZHMganVzdCBiZWZvcmUgbmVhcmVzdCBsaW5lZmVlZCBvciBlbmQgb2YgZmlsZVxudmFyIGNvbW1lbnRfcGF0dGVybj0vKFteXFxuXFxyXFx1MjAyOFxcdTIwMjldKikvZzt2YXIgZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuPS9cXC9cXCogYmVhdXRpZnkoIFxcdytbOl1cXHcrKSsgXFwqXFwvL2c7dmFyIGRpcmVjdGl2ZV9wYXR0ZXJuPS8gKFxcdyspWzpdKFxcdyspL2c7dmFyIGRpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuPS8oW1xcc1xcU10qPykoKD86XFwvXFwqXFxzYmVhdXRpZnlcXHNpZ25vcmU6ZW5kXFxzXFwqXFwvKXwkKS9nO3ZhciB0ZW1wbGF0ZV9wYXR0ZXJuPS8oKDxcXD9waHB8PFxcPz0pW1xcc1xcU10qP1xcPz4pfCg8JVtcXHNcXFNdKj8lPikvZzt2YXIgbl9uZXdsaW5lcyx3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbixpbl9odG1sX2NvbW1lbnQsdG9rZW5zO3ZhciBpbnB1dDt0aGlzLnRva2VuaXplPWZ1bmN0aW9uKCl7aW5wdXQ9bmV3IElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpO2luX2h0bWxfY29tbWVudD1mYWxzZTt0b2tlbnM9W107dmFyIG5leHQsbGFzdDt2YXIgdG9rZW5fdmFsdWVzO3ZhciBvcGVuPW51bGw7dmFyIG9wZW5fc3RhY2s9W107dmFyIGNvbW1lbnRzPVtdO3doaWxlKCEobGFzdCYmbGFzdC50eXBlPT09J1RLX0VPRicpKXt0b2tlbl92YWx1ZXM9dG9rZW5pemVfbmV4dCgpO25leHQ9bmV3IFRva2VuKHRva2VuX3ZhbHVlc1sxXSx0b2tlbl92YWx1ZXNbMF0sbl9uZXdsaW5lcyx3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbik7d2hpbGUobmV4dC50eXBlPT09J1RLX0NPTU1FTlQnfHxuZXh0LnR5cGU9PT0nVEtfQkxPQ0tfQ09NTUVOVCd8fG5leHQudHlwZT09PSdUS19VTktOT1dOJyl7aWYobmV4dC50eXBlPT09J1RLX0JMT0NLX0NPTU1FTlQnKXtuZXh0LmRpcmVjdGl2ZXM9dG9rZW5fdmFsdWVzWzJdO31jb21tZW50cy5wdXNoKG5leHQpO3Rva2VuX3ZhbHVlcz10b2tlbml6ZV9uZXh0KCk7bmV4dD1uZXcgVG9rZW4odG9rZW5fdmFsdWVzWzFdLHRva2VuX3ZhbHVlc1swXSxuX25ld2xpbmVzLHdoaXRlc3BhY2VfYmVmb3JlX3Rva2VuKTt9aWYoY29tbWVudHMubGVuZ3RoKXtuZXh0LmNvbW1lbnRzX2JlZm9yZT1jb21tZW50cztjb21tZW50cz1bXTt9aWYobmV4dC50eXBlPT09J1RLX1NUQVJUX0JMT0NLJ3x8bmV4dC50eXBlPT09J1RLX1NUQVJUX0VYUFInKXtuZXh0LnBhcmVudD1sYXN0O29wZW5fc3RhY2sucHVzaChvcGVuKTtvcGVuPW5leHQ7fWVsc2UgaWYoKG5leHQudHlwZT09PSdUS19FTkRfQkxPQ0snfHxuZXh0LnR5cGU9PT0nVEtfRU5EX0VYUFInKSYmb3BlbiYmKG5leHQudGV4dD09PSddJyYmb3Blbi50ZXh0PT09J1snfHxuZXh0LnRleHQ9PT0nKScmJm9wZW4udGV4dD09PScoJ3x8bmV4dC50ZXh0PT09J30nJiZvcGVuLnRleHQ9PT0neycpKXtuZXh0LnBhcmVudD1vcGVuLnBhcmVudDtuZXh0Lm9wZW5lZD1vcGVuO29wZW49b3Blbl9zdGFjay5wb3AoKTt9dG9rZW5zLnB1c2gobmV4dCk7bGFzdD1uZXh0O31yZXR1cm4gdG9rZW5zO307ZnVuY3Rpb24gZ2V0X2RpcmVjdGl2ZXModGV4dCl7aWYoIXRleHQubWF0Y2goZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuKSl7cmV0dXJuIG51bGw7fXZhciBkaXJlY3RpdmVzPXt9O2RpcmVjdGl2ZV9wYXR0ZXJuLmxhc3RJbmRleD0wO3ZhciBkaXJlY3RpdmVfbWF0Y2g9ZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTt3aGlsZShkaXJlY3RpdmVfbWF0Y2gpe2RpcmVjdGl2ZXNbZGlyZWN0aXZlX21hdGNoWzFdXT1kaXJlY3RpdmVfbWF0Y2hbMl07ZGlyZWN0aXZlX21hdGNoPWRpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7fXJldHVybiBkaXJlY3RpdmVzO31mdW5jdGlvbiB0b2tlbml6ZV9uZXh0KCl7dmFyIHJlc3VsdGluZ19zdHJpbmc7dmFyIHdoaXRlc3BhY2Vfb25fdGhpc19saW5lPVtdO25fbmV3bGluZXM9MDt3aGl0ZXNwYWNlX2JlZm9yZV90b2tlbj0nJzt2YXIgYz1pbnB1dC5uZXh0KCk7aWYoYz09PW51bGwpe3JldHVyblsnJywnVEtfRU9GJ107fXZhciBsYXN0X3Rva2VuO2lmKHRva2Vucy5sZW5ndGgpe2xhc3RfdG9rZW49dG9rZW5zW3Rva2Vucy5sZW5ndGgtMV07fWVsc2V7Ly8gRm9yIHRoZSBzYWtlIG9mIHRva2VuaXppbmcgd2UgY2FuIHByZXRlbmQgdGhhdCB0aGVyZSB3YXMgb24gb3BlbiBicmFjZSB0byBzdGFydFxubGFzdF90b2tlbj1uZXcgVG9rZW4oJ1RLX1NUQVJUX0JMT0NLJywneycpO313aGlsZShpbl9hcnJheShjLHdoaXRlc3BhY2UpKXtpZihhY29ybi5uZXdsaW5lLnRlc3QoYykpe2lmKCEoYz09PSdcXG4nJiZpbnB1dC5wZWVrKC0yKT09PSdcXHInKSl7bl9uZXdsaW5lcys9MTt3aGl0ZXNwYWNlX29uX3RoaXNfbGluZT1bXTt9fWVsc2V7d2hpdGVzcGFjZV9vbl90aGlzX2xpbmUucHVzaChjKTt9Yz1pbnB1dC5uZXh0KCk7aWYoYz09PW51bGwpe3JldHVyblsnJywnVEtfRU9GJ107fX1pZih3aGl0ZXNwYWNlX29uX3RoaXNfbGluZS5sZW5ndGgpe3doaXRlc3BhY2VfYmVmb3JlX3Rva2VuPXdoaXRlc3BhY2Vfb25fdGhpc19saW5lLmpvaW4oJycpO31pZihkaWdpdC50ZXN0KGMpfHxjPT09Jy4nJiZpbnB1dC50ZXN0Q2hhcihkaWdpdCkpe3ZhciBhbGxvd19kZWNpbWFsPXRydWU7dmFyIGFsbG93X2U9dHJ1ZTt2YXIgbG9jYWxfZGlnaXQ9ZGlnaXQ7aWYoYz09PScwJyYmaW5wdXQudGVzdENoYXIoL1tYeE9vQmJdLykpey8vIHN3aXRjaCB0byBoZXgvb2N0L2JpbiBudW1iZXIsIG5vIGRlY2ltYWwgb3IgZSwganVzdCBoZXgvb2N0L2JpbiBkaWdpdHNcbmFsbG93X2RlY2ltYWw9ZmFsc2U7YWxsb3dfZT1mYWxzZTtpZihpbnB1dC50ZXN0Q2hhcigvW0JiXS8pKXtsb2NhbF9kaWdpdD1kaWdpdF9iaW47fWVsc2UgaWYoaW5wdXQudGVzdENoYXIoL1tPb10vKSl7bG9jYWxfZGlnaXQ9ZGlnaXRfb2N0O31lbHNle2xvY2FsX2RpZ2l0PWRpZ2l0X2hleDt9Yys9aW5wdXQubmV4dCgpO31lbHNlIGlmKGM9PT0nLicpey8vIEFscmVhZHkgaGF2ZSBhIGRlY2ltYWwgZm9yIHRoaXMgbGl0ZXJhbCwgZG9uJ3QgYWxsb3cgYW5vdGhlclxuYWxsb3dfZGVjaW1hbD1mYWxzZTt9ZWxzZXsvLyB3ZSBrbm93IHRoaXMgZmlyc3QgbG9vcCB3aWxsIHJ1bi4gIEl0IGtlZXBzIHRoZSBsb2dpYyBzaW1wbGVyLlxuYz0nJztpbnB1dC5iYWNrKCk7fS8vIEFkZCB0aGUgZGlnaXRzXG53aGlsZShpbnB1dC50ZXN0Q2hhcihsb2NhbF9kaWdpdCkpe2MrPWlucHV0Lm5leHQoKTtpZihhbGxvd19kZWNpbWFsJiZpbnB1dC5wZWVrKCk9PT0nLicpe2MrPWlucHV0Lm5leHQoKTthbGxvd19kZWNpbWFsPWZhbHNlO31lbHNlIGlmKGFsbG93X2UmJmlucHV0LnRlc3RDaGFyKC9bRWVdLykpe2MrPWlucHV0Lm5leHQoKTtpZihpbnB1dC50ZXN0Q2hhcigvWystXS8pKXtjKz1pbnB1dC5uZXh0KCk7fWFsbG93X2U9ZmFsc2U7YWxsb3dfZGVjaW1hbD1mYWxzZTt9fXJldHVybltjLCdUS19XT1JEJ107fWlmKGFjb3JuLmlzSWRlbnRpZmllclN0YXJ0KGlucHV0LnBlZWtDaGFyQ29kZSgtMSkpKXtpZihpbnB1dC5oYXNOZXh0KCkpe3doaWxlKGFjb3JuLmlzSWRlbnRpZmllckNoYXIoaW5wdXQucGVla0NoYXJDb2RlKCkpKXtjKz1pbnB1dC5uZXh0KCk7aWYoIWlucHV0Lmhhc05leHQoKSl7YnJlYWs7fX19aWYoIShsYXN0X3Rva2VuLnR5cGU9PT0nVEtfRE9UJ3x8bGFzdF90b2tlbi50eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkobGFzdF90b2tlbi50ZXh0LFsnc2V0JywnZ2V0J10pKSYmaW5fYXJyYXkoYyxyZXNlcnZlZF93b3Jkcykpe2lmKGM9PT0naW4nKXsvLyBoYWNrIGZvciAnaW4nIG9wZXJhdG9yXG5yZXR1cm5bYywnVEtfT1BFUkFUT1InXTt9cmV0dXJuW2MsJ1RLX1JFU0VSVkVEJ107fXJldHVybltjLCdUS19XT1JEJ107fWlmKGM9PT0nKCd8fGM9PT0nWycpe3JldHVybltjLCdUS19TVEFSVF9FWFBSJ107fWlmKGM9PT0nKSd8fGM9PT0nXScpe3JldHVybltjLCdUS19FTkRfRVhQUiddO31pZihjPT09J3snKXtyZXR1cm5bYywnVEtfU1RBUlRfQkxPQ0snXTt9aWYoYz09PSd9Jyl7cmV0dXJuW2MsJ1RLX0VORF9CTE9DSyddO31pZihjPT09JzsnKXtyZXR1cm5bYywnVEtfU0VNSUNPTE9OJ107fWlmKGM9PT0nLycpe3ZhciBjb21tZW50PScnO3ZhciBjb21tZW50X21hdGNoOy8vIHBlZWsgZm9yIGNvbW1lbnQgLyogLi4uICovXG5pZihpbnB1dC5wZWVrKCk9PT0nKicpe2lucHV0Lm5leHQoKTtjb21tZW50X21hdGNoPWlucHV0Lm1hdGNoKGJsb2NrX2NvbW1lbnRfcGF0dGVybik7Y29tbWVudD0nLyonK2NvbW1lbnRfbWF0Y2hbMF07dmFyIGRpcmVjdGl2ZXM9Z2V0X2RpcmVjdGl2ZXMoY29tbWVudCk7aWYoZGlyZWN0aXZlcyYmZGlyZWN0aXZlcy5pZ25vcmU9PT0nc3RhcnQnKXtjb21tZW50X21hdGNoPWlucHV0Lm1hdGNoKGRpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuKTtjb21tZW50Kz1jb21tZW50X21hdGNoWzBdO31jb21tZW50PWNvbW1lbnQucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCdcXG4nKTtyZXR1cm5bY29tbWVudCwnVEtfQkxPQ0tfQ09NTUVOVCcsZGlyZWN0aXZlc107fS8vIHBlZWsgZm9yIGNvbW1lbnQgLy8gLi4uXG5pZihpbnB1dC5wZWVrKCk9PT0nLycpe2lucHV0Lm5leHQoKTtjb21tZW50X21hdGNoPWlucHV0Lm1hdGNoKGNvbW1lbnRfcGF0dGVybik7Y29tbWVudD0nLy8nK2NvbW1lbnRfbWF0Y2hbMF07cmV0dXJuW2NvbW1lbnQsJ1RLX0NPTU1FTlQnXTt9fXZhciBzdGFydFhtbFJlZ0V4cD0vPCgpKFstYS16QS1aOjAtOV8uXSt8e1tcXHNcXFNdKz99fCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0pKFxccyt7W1xcc1xcU10rP318XFxzK1stYS16QS1aOjAtOV8uXSt8XFxzK1stYS16QS1aOjAtOV8uXStcXHMqPVxccyooJ1teJ10qJ3xcIlteXCJdKlwifHtbXFxzXFxTXSs/fSkpKlxccyooXFwvPylcXHMqPi9nO2lmKGM9PT0nYCd8fGM9PT1cIidcInx8Yz09PSdcIid8fC8vIHN0cmluZ1xuKGM9PT0nLyd8fC8vIHJlZ2V4cFxub3B0cy5lNHgmJmM9PT1cIjxcIiYmaW5wdXQudGVzdChzdGFydFhtbFJlZ0V4cCwtMSkvLyB4bWxcbikmJigvLyByZWdleCBhbmQgeG1sIGNhbiBvbmx5IGFwcGVhciBpbiBzcGVjaWZpYyBsb2NhdGlvbnMgZHVyaW5nIHBhcnNpbmdcbmxhc3RfdG9rZW4udHlwZT09PSdUS19SRVNFUlZFRCcmJmluX2FycmF5KGxhc3RfdG9rZW4udGV4dCxbJ3JldHVybicsJ2Nhc2UnLCd0aHJvdycsJ2Vsc2UnLCdkbycsJ3R5cGVvZicsJ3lpZWxkJ10pfHxsYXN0X3Rva2VuLnR5cGU9PT0nVEtfRU5EX0VYUFInJiZsYXN0X3Rva2VuLnRleHQ9PT0nKScmJmxhc3RfdG9rZW4ucGFyZW50JiZsYXN0X3Rva2VuLnBhcmVudC50eXBlPT09J1RLX1JFU0VSVkVEJyYmaW5fYXJyYXkobGFzdF90b2tlbi5wYXJlbnQudGV4dCxbJ2lmJywnd2hpbGUnLCdmb3InXSl8fGluX2FycmF5KGxhc3RfdG9rZW4udHlwZSxbJ1RLX0NPTU1FTlQnLCdUS19TVEFSVF9FWFBSJywnVEtfU1RBUlRfQkxPQ0snLCdUS19FTkRfQkxPQ0snLCdUS19PUEVSQVRPUicsJ1RLX0VRVUFMUycsJ1RLX0VPRicsJ1RLX1NFTUlDT0xPTicsJ1RLX0NPTU1BJ10pKSl7dmFyIHNlcD1jLGVzYz1mYWxzZSxoYXNfY2hhcl9lc2NhcGVzPWZhbHNlO3Jlc3VsdGluZ19zdHJpbmc9YztpZihzZXA9PT0nLycpey8vXG4vLyBoYW5kbGUgcmVnZXhwXG4vL1xudmFyIGluX2NoYXJfY2xhc3M9ZmFsc2U7d2hpbGUoaW5wdXQuaGFzTmV4dCgpJiYoZXNjfHxpbl9jaGFyX2NsYXNzfHxpbnB1dC5wZWVrKCkhPT1zZXApJiYhaW5wdXQudGVzdENoYXIoYWNvcm4ubmV3bGluZSkpe3Jlc3VsdGluZ19zdHJpbmcrPWlucHV0LnBlZWsoKTtpZighZXNjKXtlc2M9aW5wdXQucGVlaygpPT09J1xcXFwnO2lmKGlucHV0LnBlZWsoKT09PSdbJyl7aW5fY2hhcl9jbGFzcz10cnVlO31lbHNlIGlmKGlucHV0LnBlZWsoKT09PSddJyl7aW5fY2hhcl9jbGFzcz1mYWxzZTt9fWVsc2V7ZXNjPWZhbHNlO31pbnB1dC5uZXh0KCk7fX1lbHNlIGlmKG9wdHMuZTR4JiZzZXA9PT0nPCcpey8vXG4vLyBoYW5kbGUgZTR4IHhtbCBsaXRlcmFsc1xuLy9cbnZhciB4bWxSZWdFeHA9L1tcXHNcXFNdKj88KFxcLz8pKFstYS16QS1aOjAtOV8uXSt8e1tcXHNcXFNdKz99fCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0pKFxccyt7W1xcc1xcU10rP318XFxzK1stYS16QS1aOjAtOV8uXSt8XFxzK1stYS16QS1aOjAtOV8uXStcXHMqPVxccyooJ1teJ10qJ3xcIlteXCJdKlwifHtbXFxzXFxTXSs/fSkpKlxccyooXFwvPylcXHMqPi9nO2lucHV0LmJhY2soKTt2YXIgeG1sU3RyPScnO3ZhciBtYXRjaD1pbnB1dC5tYXRjaChzdGFydFhtbFJlZ0V4cCk7aWYobWF0Y2gpey8vIFRyaW0gcm9vdCB0YWcgdG8gYXR0ZW1wdCB0b1xudmFyIHJvb3RUYWc9bWF0Y2hbMl0ucmVwbGFjZSgvXntcXHMrLywneycpLnJlcGxhY2UoL1xccyt9JC8sJ30nKTt2YXIgaXNDdXJseVJvb3Q9cm9vdFRhZy5pbmRleE9mKCd7Jyk9PT0wO3ZhciBkZXB0aD0wO3doaWxlKG1hdGNoKXt2YXIgaXNFbmRUYWc9ISFtYXRjaFsxXTt2YXIgdGFnTmFtZT1tYXRjaFsyXTt2YXIgaXNTaW5nbGV0b25UYWc9ISFtYXRjaFttYXRjaC5sZW5ndGgtMV18fHRhZ05hbWUuc2xpY2UoMCw4KT09PVwiIVtDREFUQVtcIjtpZighaXNTaW5nbGV0b25UYWcmJih0YWdOYW1lPT09cm9vdFRhZ3x8aXNDdXJseVJvb3QmJnRhZ05hbWUucmVwbGFjZSgvXntcXHMrLywneycpLnJlcGxhY2UoL1xccyt9JC8sJ30nKSkpe2lmKGlzRW5kVGFnKXstLWRlcHRoO31lbHNleysrZGVwdGg7fX14bWxTdHIrPW1hdGNoWzBdO2lmKGRlcHRoPD0wKXticmVhazt9bWF0Y2g9aW5wdXQubWF0Y2goeG1sUmVnRXhwKTt9Ly8gaWYgd2UgZGlkbid0IGNsb3NlIGNvcnJlY3RseSwga2VlcCB1bmZvcm1hdHRlZC5cbmlmKCFtYXRjaCl7eG1sU3RyKz1pbnB1dC5tYXRjaCgvW1xcc1xcU10qL2cpWzBdO314bWxTdHI9eG1sU3RyLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywnXFxuJyk7cmV0dXJuW3htbFN0cixcIlRLX1NUUklOR1wiXTt9fWVsc2V7Ly9cbi8vIGhhbmRsZSBzdHJpbmdcbi8vXG52YXIgcGFyc2Vfc3RyaW5nPWZ1bmN0aW9uKGRlbGltaXRlcixhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsc3RhcnRfc3ViKXsvLyBUZW1wbGF0ZSBzdHJpbmdzIGNhbiB0cmF2ZXJzIGxpbmVzIHdpdGhvdXQgZXNjYXBlIGNoYXJhY3RlcnMuXG4vLyBPdGhlciBzdHJpbmdzIGNhbm5vdFxudmFyIGN1cnJlbnRfY2hhcjt3aGlsZShpbnB1dC5oYXNOZXh0KCkpe2N1cnJlbnRfY2hhcj1pbnB1dC5wZWVrKCk7aWYoIShlc2N8fGN1cnJlbnRfY2hhciE9PWRlbGltaXRlciYmKGFsbG93X3VuZXNjYXBlZF9uZXdsaW5lc3x8IWFjb3JuLm5ld2xpbmUudGVzdChjdXJyZW50X2NoYXIpKSkpe2JyZWFrO30vLyBIYW5kbGUgXFxyXFxuIGxpbmVicmVha3MgYWZ0ZXIgZXNjYXBlcyBvciBpbiB0ZW1wbGF0ZSBzdHJpbmdzXG5pZigoZXNjfHxhbGxvd191bmVzY2FwZWRfbmV3bGluZXMpJiZhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF9jaGFyKSl7aWYoY3VycmVudF9jaGFyPT09J1xccicmJmlucHV0LnBlZWsoMSk9PT0nXFxuJyl7aW5wdXQubmV4dCgpO2N1cnJlbnRfY2hhcj1pbnB1dC5wZWVrKCk7fXJlc3VsdGluZ19zdHJpbmcrPSdcXG4nO31lbHNle3Jlc3VsdGluZ19zdHJpbmcrPWN1cnJlbnRfY2hhcjt9aWYoZXNjKXtpZihjdXJyZW50X2NoYXI9PT0neCd8fGN1cnJlbnRfY2hhcj09PSd1Jyl7aGFzX2NoYXJfZXNjYXBlcz10cnVlO31lc2M9ZmFsc2U7fWVsc2V7ZXNjPWN1cnJlbnRfY2hhcj09PSdcXFxcJzt9aW5wdXQubmV4dCgpO2lmKHN0YXJ0X3N1YiYmcmVzdWx0aW5nX3N0cmluZy5pbmRleE9mKHN0YXJ0X3N1YixyZXN1bHRpbmdfc3RyaW5nLmxlbmd0aC1zdGFydF9zdWIubGVuZ3RoKSE9PS0xKXtpZihkZWxpbWl0ZXI9PT0nYCcpe3BhcnNlX3N0cmluZygnfScsYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCdgJyk7fWVsc2V7cGFyc2Vfc3RyaW5nKCdgJyxhbGxvd191bmVzY2FwZWRfbmV3bGluZXMsJyR7Jyk7fX19fTtpZihzZXA9PT0nYCcpe3BhcnNlX3N0cmluZygnYCcsdHJ1ZSwnJHsnKTt9ZWxzZXtwYXJzZV9zdHJpbmcoc2VwKTt9fWlmKGhhc19jaGFyX2VzY2FwZXMmJm9wdHMudW5lc2NhcGVfc3RyaW5ncyl7cmVzdWx0aW5nX3N0cmluZz11bmVzY2FwZV9zdHJpbmcocmVzdWx0aW5nX3N0cmluZyk7fWlmKGlucHV0LnBlZWsoKT09PXNlcCl7cmVzdWx0aW5nX3N0cmluZys9c2VwO2lucHV0Lm5leHQoKTtpZihzZXA9PT0nLycpey8vIHJlZ2V4cHMgbWF5IGhhdmUgbW9kaWZpZXJzIC9yZWdleHAvTU9EICwgc28gZmV0Y2ggdGhvc2UsIHRvb1xuLy8gT25seSBbZ2ltXSBhcmUgdmFsaWQsIGJ1dCBpZiB0aGUgdXNlciBwdXRzIGluIGdhcmJhZ2UsIGRvIHdoYXQgd2UgY2FuIHRvIHRha2UgaXQuXG53aGlsZShpbnB1dC5oYXNOZXh0KCkmJmFjb3JuLmlzSWRlbnRpZmllclN0YXJ0KGlucHV0LnBlZWtDaGFyQ29kZSgpKSl7cmVzdWx0aW5nX3N0cmluZys9aW5wdXQubmV4dCgpO319fXJldHVybltyZXN1bHRpbmdfc3RyaW5nLCdUS19TVFJJTkcnXTt9aWYoYz09PScjJyl7aWYodG9rZW5zLmxlbmd0aD09PTAmJmlucHV0LnBlZWsoKT09PSchJyl7Ly8gc2hlYmFuZ1xucmVzdWx0aW5nX3N0cmluZz1jO3doaWxlKGlucHV0Lmhhc05leHQoKSYmYyE9PSdcXG4nKXtjPWlucHV0Lm5leHQoKTtyZXN1bHRpbmdfc3RyaW5nKz1jO31yZXR1cm5bdHJpbShyZXN1bHRpbmdfc3RyaW5nKSsnXFxuJywnVEtfVU5LTk9XTiddO30vLyBTcGlkZXJtb25rZXktc3BlY2lmaWMgc2hhcnAgdmFyaWFibGVzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9Fbi9TaGFycF92YXJpYWJsZXNfaW5fSmF2YVNjcmlwdFxuLy8gaHR0cDovL214ci5tb3ppbGxhLm9yZy9tb3ppbGxhLWNlbnRyYWwvc291cmNlL2pzL3NyYy9qc3NjYW4uY3BwIGFyb3VuZCBsaW5lIDE5MzVcbnZhciBzaGFycD0nIyc7aWYoaW5wdXQuaGFzTmV4dCgpJiZpbnB1dC50ZXN0Q2hhcihkaWdpdCkpe2Rve2M9aW5wdXQubmV4dCgpO3NoYXJwKz1jO313aGlsZShpbnB1dC5oYXNOZXh0KCkmJmMhPT0nIycmJmMhPT0nPScpO2lmKGM9PT0nIycpey8vXG59ZWxzZSBpZihpbnB1dC5wZWVrKCk9PT0nWycmJmlucHV0LnBlZWsoMSk9PT0nXScpe3NoYXJwKz0nW10nO2lucHV0Lm5leHQoKTtpbnB1dC5uZXh0KCk7fWVsc2UgaWYoaW5wdXQucGVlaygpPT09J3snJiZpbnB1dC5wZWVrKDEpPT09J30nKXtzaGFycCs9J3t9JztpbnB1dC5uZXh0KCk7aW5wdXQubmV4dCgpO31yZXR1cm5bc2hhcnAsJ1RLX1dPUkQnXTt9fWlmKGM9PT0nPCcmJihpbnB1dC5wZWVrKCk9PT0nPyd8fGlucHV0LnBlZWsoKT09PSclJykpe2lucHV0LmJhY2soKTt2YXIgdGVtcGxhdGVfbWF0Y2g9aW5wdXQubWF0Y2godGVtcGxhdGVfcGF0dGVybik7aWYodGVtcGxhdGVfbWF0Y2gpe2M9dGVtcGxhdGVfbWF0Y2hbMF07Yz1jLnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywnXFxuJyk7cmV0dXJuW2MsJ1RLX1NUUklORyddO319aWYoYz09PSc8JyYmaW5wdXQubWF0Y2goL1xcIS0tL2cpKXtjPSc8IS0tJzt3aGlsZShpbnB1dC5oYXNOZXh0KCkmJiFpbnB1dC50ZXN0Q2hhcihhY29ybi5uZXdsaW5lKSl7Yys9aW5wdXQubmV4dCgpO31pbl9odG1sX2NvbW1lbnQ9dHJ1ZTtyZXR1cm5bYywnVEtfQ09NTUVOVCddO31pZihjPT09Jy0nJiZpbl9odG1sX2NvbW1lbnQmJmlucHV0Lm1hdGNoKC8tPi9nKSl7aW5faHRtbF9jb21tZW50PWZhbHNlO3JldHVyblsnLS0+JywnVEtfQ09NTUVOVCddO31pZihjPT09Jy4nKXtyZXR1cm5bYywnVEtfRE9UJ107fWlmKGluX2FycmF5KGMscHVuY3QpKXt3aGlsZShpbnB1dC5oYXNOZXh0KCkmJmluX2FycmF5KGMraW5wdXQucGVlaygpLHB1bmN0KSl7Yys9aW5wdXQubmV4dCgpO2lmKCFpbnB1dC5oYXNOZXh0KCkpe2JyZWFrO319aWYoYz09PScsJyl7cmV0dXJuW2MsJ1RLX0NPTU1BJ107fWVsc2UgaWYoYz09PSc9Jyl7cmV0dXJuW2MsJ1RLX0VRVUFMUyddO31lbHNle3JldHVybltjLCdUS19PUEVSQVRPUiddO319cmV0dXJuW2MsJ1RLX1VOS05PV04nXTt9ZnVuY3Rpb24gdW5lc2NhcGVfc3RyaW5nKHMpey8vIFlvdSB0aGluayB0aGF0IGEgcmVnZXggd291bGQgd29yayBmb3IgdGhpc1xuLy8gcmV0dXJuIHMucmVwbGFjZSgvXFxcXHgoWzAtOWEtZl17Mn0pL2dpLCBmdW5jdGlvbihtYXRjaCwgdmFsKSB7XG4vLyAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHZhbCwgMTYpKTtcbi8vICAgICB9KVxuLy8gSG93ZXZlciwgZGVhbGluZyB3aXRoICdcXHhmZicsICdcXFxceGZmJywgJ1xcXFxcXHhmZicgbWFrZXMgdGhpcyBtb3JlIGZ1bi5cbnZhciBvdXQ9JycsZXNjYXBlZD0wO3ZhciBpbnB1dF9zY2FuPW5ldyBJbnB1dFNjYW5uZXIocyk7dmFyIG1hdGNoZWQ9bnVsbDt3aGlsZShpbnB1dF9zY2FuLmhhc05leHQoKSl7Ly8gS2VlcCBhbnkgd2hpdGVzcGFjZSwgbm9uLXNsYXNoIGNoYXJhY3RlcnNcbi8vIGFsc28ga2VlcCBzbGFzaCBwYWlycy5cbm1hdGNoZWQ9aW5wdXRfc2Nhbi5tYXRjaCgvKFtcXHNdfFteXFxcXF18XFxcXFxcXFwpKy9nKTtpZihtYXRjaGVkKXtvdXQrPW1hdGNoZWRbMF07fWlmKGlucHV0X3NjYW4ucGVlaygpPT09J1xcXFwnKXtpbnB1dF9zY2FuLm5leHQoKTtpZihpbnB1dF9zY2FuLnBlZWsoKT09PSd4Jyl7bWF0Y2hlZD1pbnB1dF9zY2FuLm1hdGNoKC94KFswLTlBLUZhLWZdezJ9KS9nKTt9ZWxzZSBpZihpbnB1dF9zY2FuLnBlZWsoKT09PSd1Jyl7bWF0Y2hlZD1pbnB1dF9zY2FuLm1hdGNoKC91KFswLTlBLUZhLWZdezR9KS9nKTt9ZWxzZXtvdXQrPSdcXFxcJztpZihpbnB1dF9zY2FuLmhhc05leHQoKSl7b3V0Kz1pbnB1dF9zY2FuLm5leHQoKTt9Y29udGludWU7fS8vIElmIHRoZXJlJ3Mgc29tZSBlcnJvciBkZWNvZGluZywgcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJpbmdcbmlmKCFtYXRjaGVkKXtyZXR1cm4gczt9ZXNjYXBlZD1wYXJzZUludChtYXRjaGVkWzFdLDE2KTtpZihlc2NhcGVkPjB4N2UmJmVzY2FwZWQ8PTB4ZmYmJm1hdGNoZWRbMF0uaW5kZXhPZigneCcpPT09MCl7Ly8gd2UgYmFpbCBvdXQgb24gXFx4N2YuLlxceGZmLFxuLy8gbGVhdmluZyB3aG9sZSBzdHJpbmcgZXNjYXBlZCxcbi8vIGFzIGl0J3MgcHJvYmFibHkgY29tcGxldGVseSBiaW5hcnlcbnJldHVybiBzO31lbHNlIGlmKGVzY2FwZWQ+PTB4MDAmJmVzY2FwZWQ8MHgyMCl7Ly8gbGVhdmUgMHgwMC4uLjB4MWYgZXNjYXBlZFxub3V0Kz0nXFxcXCcrbWF0Y2hlZFswXTtjb250aW51ZTt9ZWxzZSBpZihlc2NhcGVkPT09MHgyMnx8ZXNjYXBlZD09PTB4Mjd8fGVzY2FwZWQ9PT0weDVjKXsvLyBzaW5nbGUtcXVvdGUsIGFwb3N0cm9waGUsIGJhY2tzbGFzaCAtIGVzY2FwZSB0aGVzZVxub3V0Kz0nXFxcXCcrU3RyaW5nLmZyb21DaGFyQ29kZShlc2NhcGVkKTt9ZWxzZXtvdXQrPVN0cmluZy5mcm9tQ2hhckNvZGUoZXNjYXBlZCk7fX19cmV0dXJuIG91dDt9fXZhciBiZWF1dGlmaWVyPW5ldyBCZWF1dGlmaWVyKGpzX3NvdXJjZV90ZXh0LG9wdGlvbnMpO3JldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7fWlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpey8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuZGVmaW5lKFtdLGZ1bmN0aW9uKCl7cmV0dXJue2pzX2JlYXV0aWZ5OmpzX2JlYXV0aWZ5fTt9KTt9ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyE9PVwidW5kZWZpbmVkXCIpey8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbi8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKFwiYmVhdXRpZnlcIikuanNfYmVhdXRpZnlgLlxuZXhwb3J0cy5qc19iZWF1dGlmeT1qc19iZWF1dGlmeTt9ZWxzZSBpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Ly8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxud2luZG93LmpzX2JlYXV0aWZ5PWpzX2JlYXV0aWZ5O31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXsvLyBJZiB3ZSBkb24ndCBldmVuIGhhdmUgd2luZG93LCB0cnkgZ2xvYmFsLlxuZ2xvYmFsLmpzX2JlYXV0aWZ5PWpzX2JlYXV0aWZ5O319KSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");
},61:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\n        http://jsbeautifier.org/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                          indentation size,\n        indent_char (space)                      character to indent with,\n        selector_separator_newline (true)       - separate selectors with newline or\n                                                  not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)                - end with a newline\n        newline_between_rules (true)            - add a new line after every css rule\n        space_around_selector_separator (false) - ensure space around selector separators:\n                                                  '>', '+', '~' (e.g. \"a>b\" -> \"a > b\")\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n      'newline_between_rules': true,\n      'space_around_selector_separator': true\n    });\n*/\n\n// http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n\n(function () {\n    function css_beautify(source_text, options) {\n        options = options || {};\n        source_text = source_text || '';\n        // HACK: newline parsing inconsistent. This brute force normalizes the input.\n        source_text = source_text.replace(/\\r\\n|[\\r\\u2028\\u2029]/g, '\\n');\n\n        var indentSize = options.indent_size || 4;\n        var indentCharacter = options.indent_char || ' ';\n        var selectorSeparatorNewline = options.selector_separator_newline === undefined ? true : options.selector_separator_newline;\n        var end_with_newline = options.end_with_newline === undefined ? false : options.end_with_newline;\n        var newline_between_rules = options.newline_between_rules === undefined ? true : options.newline_between_rules;\n        var space_around_combinator = options.space_around_combinator === undefined ? false : options.space_around_combinator;\n        space_around_combinator = space_around_combinator || (options.space_around_selector_separator === undefined ? false : options.space_around_selector_separator);\n        var eol = options.eol ? options.eol : '\\n';\n\n        // compatibility\n        if (typeof indentSize === \"string\") {\n            indentSize = parseInt(indentSize, 10);\n        }\n\n        if (options.indent_with_tabs) {\n            indentCharacter = '\\t';\n            indentSize = 1;\n        }\n\n        eol = eol.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n');\n\n        // tokenizer\n        var whiteRe = /^\\s+$/;\n\n        var pos = -1,\n            ch;\n        var parenLevel = 0;\n\n        function next() {\n            ch = source_text.charAt(++pos);\n            return ch || '';\n        }\n\n        function peek(skipWhitespace) {\n            var result = '';\n            var prev_pos = pos;\n            if (skipWhitespace) {\n                eatWhitespace();\n            }\n            result = source_text.charAt(pos + 1) || '';\n            pos = prev_pos - 1;\n            next();\n            return result;\n        }\n\n        function eatString(endChars) {\n            var start = pos;\n            while (next()) {\n                if (ch === \"\\\\\") {\n                    next();\n                } else if (endChars.indexOf(ch) !== -1) {\n                    break;\n                } else if (ch === \"\\n\") {\n                    break;\n                }\n            }\n            return source_text.substring(start, pos + 1);\n        }\n\n        function peekString(endChar) {\n            var prev_pos = pos;\n            var str = eatString(endChar);\n            pos = prev_pos - 1;\n            next();\n            return str;\n        }\n\n        function eatWhitespace() {\n            var result = '';\n            while (whiteRe.test(peek())) {\n                next();\n                result += ch;\n            }\n            return result;\n        }\n\n        function skipWhitespace() {\n            var result = '';\n            if (ch && whiteRe.test(ch)) {\n                result = ch;\n            }\n            while (whiteRe.test(next())) {\n                result += ch;\n            }\n            return result;\n        }\n\n        function eatComment(singleLine) {\n            var start = pos;\n            singleLine = peek() === \"/\";\n            next();\n            while (next()) {\n                if (!singleLine && ch === \"*\" && peek() === \"/\") {\n                    next();\n                    break;\n                } else if (singleLine && ch === \"\\n\") {\n                    return source_text.substring(start, pos);\n                }\n            }\n\n            return source_text.substring(start, pos) + ch;\n        }\n\n        function lookBack(str) {\n            return source_text.substring(pos - str.length, pos).toLowerCase() === str;\n        }\n\n        // Nested pseudo-class if we are insideRule\n        // and the next special character found opens\n        // a new block\n        function foundNestedPseudoClass() {\n            var openParen = 0;\n            for (var i = pos + 1; i < source_text.length; i++) {\n                var ch = source_text.charAt(i);\n                if (ch === \"{\") {\n                    return true;\n                } else if (ch === '(') {\n                    // pseudoclasses can contain ()\n                    openParen += 1;\n                } else if (ch === ')') {\n                    if (openParen === 0) {\n                        return false;\n                    }\n                    openParen -= 1;\n                } else if (ch === \";\" || ch === \"}\") {\n                    return false;\n                }\n            }\n            return false;\n        }\n\n        // printer\n        var basebaseIndentString = source_text.match(/^[\\t ]*/)[0];\n        var singleIndent = new Array(indentSize + 1).join(indentCharacter);\n        var indentLevel = 0;\n        var nestedLevel = 0;\n\n        function indent() {\n            indentLevel++;\n            basebaseIndentString += singleIndent;\n        }\n\n        function outdent() {\n            indentLevel--;\n            basebaseIndentString = basebaseIndentString.slice(0, -indentSize);\n        }\n\n        var print = {};\n        print[\"{\"] = function (ch) {\n            print.singleSpace();\n            output.push(ch);\n            print.newLine();\n        };\n        print[\"}\"] = function (ch) {\n            print.newLine();\n            output.push(ch);\n            print.newLine();\n        };\n\n        print._lastCharWhitespace = function () {\n            return whiteRe.test(output[output.length - 1]);\n        };\n\n        print.newLine = function (keepWhitespace) {\n            if (output.length) {\n                if (!keepWhitespace && output[output.length - 1] !== '\\n') {\n                    print.trim();\n                }\n\n                output.push('\\n');\n\n                if (basebaseIndentString) {\n                    output.push(basebaseIndentString);\n                }\n            }\n        };\n        print.singleSpace = function () {\n            if (output.length && !print._lastCharWhitespace()) {\n                output.push(' ');\n            }\n        };\n\n        print.preserveSingleSpace = function () {\n            if (isAfterSpace) {\n                print.singleSpace();\n            }\n        };\n\n        print.trim = function () {\n            while (print._lastCharWhitespace()) {\n                output.pop();\n            }\n        };\n\n        var output = [];\n        /*_____________________--------------------_____________________*/\n\n        var insideRule = false;\n        var insidePropertyValue = false;\n        var enteringConditionalGroup = false;\n        var top_ch = '';\n        var last_top_ch = '';\n\n        while (true) {\n            var whitespace = skipWhitespace();\n            var isAfterSpace = whitespace !== '';\n            var isAfterNewline = whitespace.indexOf('\\n') !== -1;\n            last_top_ch = top_ch;\n            top_ch = ch;\n\n            if (!ch) {\n                break;\n            } else if (ch === '/' && peek() === '*') {\n                /* css comment */\n                var header = indentLevel === 0;\n\n                if (isAfterNewline || header) {\n                    print.newLine();\n                }\n\n                output.push(eatComment());\n                print.newLine();\n                if (header) {\n                    print.newLine(true);\n                }\n            } else if (ch === '/' && peek() === '/') {\n                // single line comment\n                if (!isAfterNewline && last_top_ch !== '{') {\n                    print.trim();\n                }\n                print.singleSpace();\n                output.push(eatComment());\n                print.newLine();\n            } else if (ch === '@') {\n                print.preserveSingleSpace();\n\n                // deal with less propery mixins @{...}\n                if (peek() === '{') {\n                    output.push(eatString('}'));\n                } else {\n                    output.push(ch);\n\n                    // strip trailing space, if present, for hash property checks\n                    var variableOrRule = peekString(\": ,;{}()[]/='\\\"\");\n\n                    if (variableOrRule.match(/[ :]$/)) {\n                        // we have a variable or pseudo-class, add it and insert one space before continuing\n                        next();\n                        variableOrRule = eatString(\": \").replace(/\\s$/, '');\n                        output.push(variableOrRule);\n                        print.singleSpace();\n                    }\n\n                    variableOrRule = variableOrRule.replace(/\\s$/, '');\n\n                    // might be a nesting at-rule\n                    if (variableOrRule in css_beautify.NESTED_AT_RULE) {\n                        nestedLevel += 1;\n                        if (variableOrRule in css_beautify.CONDITIONAL_GROUP_RULE) {\n                            enteringConditionalGroup = true;\n                        }\n                    }\n                }\n            } else if (ch === '#' && peek() === '{') {\n                print.preserveSingleSpace();\n                output.push(eatString('}'));\n            } else if (ch === '{') {\n                if (peek(true) === '}') {\n                    eatWhitespace();\n                    next();\n                    print.singleSpace();\n                    output.push(\"{}\");\n                    print.newLine();\n                    if (newline_between_rules && indentLevel === 0) {\n                        print.newLine(true);\n                    }\n                } else {\n                    indent();\n                    print[\"{\"](ch);\n                    // when entering conditional groups, only rulesets are allowed\n                    if (enteringConditionalGroup) {\n                        enteringConditionalGroup = false;\n                        insideRule = indentLevel > nestedLevel;\n                    } else {\n                        // otherwise, declarations are also allowed\n                        insideRule = indentLevel >= nestedLevel;\n                    }\n                }\n            } else if (ch === '}') {\n                outdent();\n                print[\"}\"](ch);\n                insideRule = false;\n                insidePropertyValue = false;\n                if (nestedLevel) {\n                    nestedLevel--;\n                }\n                if (newline_between_rules && indentLevel === 0) {\n                    print.newLine(true);\n                }\n            } else if (ch === \":\") {\n                eatWhitespace();\n                if ((insideRule || enteringConditionalGroup) && !(lookBack(\"&\") || foundNestedPseudoClass()) && !lookBack(\"(\")) {\n                    // 'property: value' delimiter\n                    // which could be in a conditional group query\n                    insidePropertyValue = true;\n                    output.push(':');\n                    print.singleSpace();\n                } else {\n                    // sass/less parent reference don't use a space\n                    // sass nested pseudo-class don't use a space\n\n                    // preserve space before pseudoclasses/pseudoelements, as it means \"in any child\"\n                    if (lookBack(\" \") && output[output.length - 1] !== \" \") {\n                        output.push(\" \");\n                    }\n                    if (peek() === \":\") {\n                        // pseudo-element\n                        next();\n                        output.push(\"::\");\n                    } else {\n                        // pseudo-class\n                        output.push(':');\n                    }\n                }\n            } else if (ch === '\"' || ch === '\\'') {\n                print.preserveSingleSpace();\n                output.push(eatString(ch));\n            } else if (ch === ';') {\n                insidePropertyValue = false;\n                output.push(ch);\n                print.newLine();\n            } else if (ch === '(') {\n                // may be a url\n                if (lookBack(\"url\")) {\n                    output.push(ch);\n                    eatWhitespace();\n                    if (next()) {\n                        if (ch !== ')' && ch !== '\"' && ch !== '\\'') {\n                            output.push(eatString(')'));\n                        } else {\n                            pos--;\n                        }\n                    }\n                } else {\n                    parenLevel++;\n                    print.preserveSingleSpace();\n                    output.push(ch);\n                    eatWhitespace();\n                }\n            } else if (ch === ')') {\n                output.push(ch);\n                parenLevel--;\n            } else if (ch === ',') {\n                output.push(ch);\n                eatWhitespace();\n                if (selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {\n                    print.newLine();\n                } else {\n                    print.singleSpace();\n                }\n            } else if ((ch === '>' || ch === '+' || ch === '~') && !insidePropertyValue && parenLevel < 1) {\n                //handle combinator spacing\n                if (space_around_combinator) {\n                    print.singleSpace();\n                    output.push(ch);\n                    print.singleSpace();\n                } else {\n                    output.push(ch);\n                    eatWhitespace();\n                    // squash extra whitespace\n                    if (ch && whiteRe.test(ch)) {\n                        ch = '';\n                    }\n                }\n            } else if (ch === ']') {\n                output.push(ch);\n            } else if (ch === '[') {\n                print.preserveSingleSpace();\n                output.push(ch);\n            } else if (ch === '=') {\n                // no whitespace before or after\n                eatWhitespace();\n                ch = '=';\n                output.push(ch);\n            } else {\n                print.preserveSingleSpace();\n                output.push(ch);\n            }\n        }\n\n        var sweetCode = '';\n        if (basebaseIndentString) {\n            sweetCode += basebaseIndentString;\n        }\n\n        sweetCode += output.join('').replace(/[\\r\\n\\t ]+$/, '');\n\n        // establish end_with_newline\n        if (end_with_newline) {\n            sweetCode += '\\n';\n        }\n\n        if (eol !== '\\n') {\n            sweetCode = sweetCode.replace(/[\\n]/g, eol);\n        }\n\n        return sweetCode;\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n    css_beautify.NESTED_AT_RULE = {\n        \"@page\": true,\n        \"@font-face\": true,\n        \"@keyframes\": true,\n        // also in CONDITIONAL_GROUP_RULE below\n        \"@media\": true,\n        \"@supports\": true,\n        \"@document\": true\n    };\n    css_beautify.CONDITIONAL_GROUP_RULE = {\n        \"@media\": true,\n        \"@supports\": true,\n        \"@document\": true\n    };\n\n    /*global define */\n    if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return {\n                css_beautify: css_beautify\n            };\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== \"undefined\") {\n        // Add support for CommonJS. Just put this file somewhere on your require.paths\n        // and you will be able to `var html_beautify = require(\"beautify\").html_beautify`.\n        exports.css_beautify = css_beautify;\n    } else if (typeof window !== \"undefined\") {\n        // If we're running a web page and don't have either of the above, add our one global\n        window.css_beautify = css_beautify;\n    } else if (typeof global !== \"undefined\") {\n        // If we don't even have window, try global.\n        global.css_beautify = css_beautify;\n    }\n})();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1jc3MuanM/NDM4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBjdXJseTp0cnVlLCBlcWVxZXE6dHJ1ZSwgbGF4YnJlYWs6dHJ1ZSwgbm9lbXB0eTpmYWxzZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxMyBFaW5hciBMaWVsbWFuaXMgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG5cbiBDU1MgQmVhdXRpZmllclxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBXcml0dGVuIGJ5IEhhcnV0eXVuIEFtaXJqYW55YW4sIChhbWlyamFueWFuQGdtYWlsLmNvbSlcblxuICAgIEJhc2VkIG9uIGNvZGUgaW5pdGlhbGx5IGRldmVsb3BlZCBieTogRWluYXIgTGllbG1hbmlzLCA8ZWluYXJAanNiZWF1dGlmaWVyLm9yZz5cbiAgICAgICAgaHR0cDovL2pzYmVhdXRpZmllci5vcmcvXG5cbiAgICBVc2FnZTpcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0KTtcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICAgIFRoZSBvcHRpb25zIGFyZSAoZGVmYXVsdCBpbiBicmFja2V0cyk6XG4gICAgICAgIGluZGVudF9zaXplICg0KSAgICAgICAgICAgICAgICAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICAgICAgaW5kZW50X2NoYXIgKHNwYWNlKSAgICAgICAgICAgICAgICAgICAgIOKAlCBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgICAgIHNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lICh0cnVlKSAgICAgICAtIHNlcGFyYXRlIHNlbGVjdG9ycyB3aXRoIG5ld2xpbmUgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IChlLmcuIFwiYSxcXG5iclwiIG9yIFwiYSwgYnJcIilcbiAgICAgICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgICAgIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAodHJ1ZSkgICAgICAgICAgICAtIGFkZCBhIG5ldyBsaW5lIGFmdGVyIGV2ZXJ5IGNzcyBydWxlXG4gICAgICAgIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgKGZhbHNlKSAtIGVuc3VyZSBzcGFjZSBhcm91bmQgc2VsZWN0b3Igc2VwYXJhdG9yczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz4nLCAnKycsICd+JyAoZS5nLiBcImE+YlwiIC0+IFwiYSA+IGJcIilcbiAgICBlLmdcblxuICAgIGNzc19iZWF1dGlmeShjc3Nfc291cmNlX3RleHQsIHtcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDEsXG4gICAgICAnaW5kZW50X2NoYXInOiAnXFx0JyxcbiAgICAgICdzZWxlY3Rvcl9zZXBhcmF0b3InOiAnICcsXG4gICAgICAnZW5kX3dpdGhfbmV3bGluZSc6IGZhbHNlLFxuICAgICAgJ25ld2xpbmVfYmV0d2Vlbl9ydWxlcyc6IHRydWUsXG4gICAgICAnc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcic6IHRydWVcbiAgICB9KTtcbiovXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN0b2tlbml6YXRpb25cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4L1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcbiAgICAgICAgLy8gSEFDSzogbmV3bGluZSBwYXJzaW5nIGluY29uc2lzdGVudC4gVGhpcyBicnV0ZSBmb3JjZSBub3JtYWxpemVzIHRoZSBpbnB1dC5cbiAgICAgICAgc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dC5yZXBsYWNlKC9cXHJcXG58W1xcclxcdTIwMjhcXHUyMDI5XS9nLCAnXFxuJyk7XG5cbiAgICAgICAgdmFyIGluZGVudFNpemUgPSBvcHRpb25zLmluZGVudF9zaXplIHx8IDQ7XG4gICAgICAgIHZhciBpbmRlbnRDaGFyYWN0ZXIgPSBvcHRpb25zLmluZGVudF9jaGFyIHx8ICcgJztcbiAgICAgICAgdmFyIHNlbGVjdG9yU2VwYXJhdG9yTmV3bGluZSA9IG9wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLnNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lO1xuICAgICAgICB2YXIgZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gICAgICAgIHZhciBuZXdsaW5lX2JldHdlZW5fcnVsZXMgPSBvcHRpb25zLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzO1xuICAgICAgICB2YXIgc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgPSBvcHRpb25zLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMuc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3I7XG4gICAgICAgIHNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IgfHwgKG9wdGlvbnMuc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLnNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IpO1xuICAgICAgICB2YXIgZW9sID0gb3B0aW9ucy5lb2wgPyBvcHRpb25zLmVvbCA6ICdcXG4nO1xuXG4gICAgICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRlbnRTaXplID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbmRlbnRTaXplID0gcGFyc2VJbnQoaW5kZW50U2l6ZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgICAgICAgICAgaW5kZW50Q2hhcmFjdGVyID0gJ1xcdCc7XG4gICAgICAgICAgICBpbmRlbnRTaXplID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVvbCA9IGVvbC5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKTtcblxuICAgICAgICAvLyB0b2tlbml6ZXJcbiAgICAgICAgdmFyIHdoaXRlUmUgPSAvXlxccyskLztcblxuICAgICAgICB2YXIgcG9zID0gLTEsXG4gICAgICAgICAgICBjaDtcbiAgICAgICAgdmFyIHBhcmVuTGV2ZWwgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZV90ZXh0LmNoYXJBdCgrK3Bvcyk7XG4gICAgICAgICAgICByZXR1cm4gY2ggfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwZWVrKHNraXBXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICB2YXIgcHJldl9wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAoc2tpcFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBzb3VyY2VfdGV4dC5jaGFyQXQocG9zICsgMSkgfHwgJyc7XG4gICAgICAgICAgICBwb3MgPSBwcmV2X3BvcyAtIDE7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWF0U3RyaW5nKGVuZENoYXJzKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRDaGFycy5pbmRleE9mKGNoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlX3RleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBlZWtTdHJpbmcoZW5kQ2hhcikge1xuICAgICAgICAgICAgdmFyIHByZXZfcG9zID0gcG9zO1xuICAgICAgICAgICAgdmFyIHN0ciA9IGVhdFN0cmluZyhlbmRDaGFyKTtcbiAgICAgICAgICAgIHBvcyA9IHByZXZfcG9zIC0gMTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlYXRXaGl0ZXNwYWNlKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKHdoaXRlUmUudGVzdChwZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGlmIChjaCAmJiB3aGl0ZVJlLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAod2hpdGVSZS50ZXN0KG5leHQoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWF0Q29tbWVudChzaW5nbGVMaW5lKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICBzaW5nbGVMaW5lID0gcGVlaygpID09PSBcIi9cIjtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNpbmdsZUxpbmUgJiYgY2ggPT09IFwiKlwiICYmIHBlZWsoKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpbmdsZUxpbmUgJiYgY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZV90ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VfdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcykgKyBjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGxvb2tCYWNrKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZV90ZXh0LnN1YnN0cmluZyhwb3MgLSBzdHIubGVuZ3RoLCBwb3MpLnRvTG93ZXJDYXNlKCkgPT09IHN0cjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5lc3RlZCBwc2V1ZG8tY2xhc3MgaWYgd2UgYXJlIGluc2lkZVJ1bGVcbiAgICAgICAgLy8gYW5kIHRoZSBuZXh0IHNwZWNpYWwgY2hhcmFjdGVyIGZvdW5kIG9wZW5zXG4gICAgICAgIC8vIGEgbmV3IGJsb2NrXG4gICAgICAgIGZ1bmN0aW9uIGZvdW5kTmVzdGVkUHNldWRvQ2xhc3MoKSB7XG4gICAgICAgICAgICB2YXIgb3BlblBhcmVuID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwb3MgKyAxOyBpIDwgc291cmNlX3RleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBzb3VyY2VfdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHNldWRvY2xhc3NlcyBjYW4gY29udGFpbiAoKVxuICAgICAgICAgICAgICAgICAgICBvcGVuUGFyZW4gKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5QYXJlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wZW5QYXJlbiAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiO1wiIHx8IGNoID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJpbnRlclxuICAgICAgICB2YXIgYmFzZWJhc2VJbmRlbnRTdHJpbmcgPSBzb3VyY2VfdGV4dC5tYXRjaCgvXltcXHQgXSovKVswXTtcbiAgICAgICAgdmFyIHNpbmdsZUluZGVudCA9IG5ldyBBcnJheShpbmRlbnRTaXplICsgMSkuam9pbihpbmRlbnRDaGFyYWN0ZXIpO1xuICAgICAgICB2YXIgaW5kZW50TGV2ZWwgPSAwO1xuICAgICAgICB2YXIgbmVzdGVkTGV2ZWwgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluZGVudCgpIHtcbiAgICAgICAgICAgIGluZGVudExldmVsKys7XG4gICAgICAgICAgICBiYXNlYmFzZUluZGVudFN0cmluZyArPSBzaW5nbGVJbmRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvdXRkZW50KCkge1xuICAgICAgICAgICAgaW5kZW50TGV2ZWwtLTtcbiAgICAgICAgICAgIGJhc2ViYXNlSW5kZW50U3RyaW5nID0gYmFzZWJhc2VJbmRlbnRTdHJpbmcuc2xpY2UoMCwgLWluZGVudFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaW50ID0ge307XG4gICAgICAgIHByaW50W1wie1wiXSA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgICAgcHJpbnQuc2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoKTtcbiAgICAgICAgICAgIHByaW50Lm5ld0xpbmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJpbnRbXCJ9XCJdID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgICBwcmludC5uZXdMaW5lKCk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChjaCk7XG4gICAgICAgICAgICBwcmludC5uZXdMaW5lKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJpbnQuX2xhc3RDaGFyV2hpdGVzcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGl0ZVJlLnRlc3Qob3V0cHV0W291dHB1dC5sZW5ndGggLSAxXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJpbnQubmV3TGluZSA9IGZ1bmN0aW9uIChrZWVwV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBXaGl0ZXNwYWNlICYmIG91dHB1dFtvdXRwdXQubGVuZ3RoIC0gMV0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnXFxuJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZWJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goYmFzZWJhc2VJbmRlbnRTdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJpbnQuc2luZ2xlU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCAmJiAhcHJpbnQuX2xhc3RDaGFyV2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwcmludC5wcmVzZXJ2ZVNpbmdsZVNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzQWZ0ZXJTcGFjZSkge1xuICAgICAgICAgICAgICAgIHByaW50LnNpbmdsZVNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJpbnQudHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdoaWxlIChwcmludC5fbGFzdENoYXJXaGl0ZXNwYWNlKCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAvKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuICAgICAgICB2YXIgaW5zaWRlUnVsZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gZmFsc2U7XG4gICAgICAgIHZhciB0b3BfY2ggPSAnJztcbiAgICAgICAgdmFyIGxhc3RfdG9wX2NoID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB3aGl0ZXNwYWNlID0gc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgIHZhciBpc0FmdGVyU3BhY2UgPSB3aGl0ZXNwYWNlICE9PSAnJztcbiAgICAgICAgICAgIHZhciBpc0FmdGVyTmV3bGluZSA9IHdoaXRlc3BhY2UuaW5kZXhPZignXFxuJykgIT09IC0xO1xuICAgICAgICAgICAgbGFzdF90b3BfY2ggPSB0b3BfY2g7XG4gICAgICAgICAgICB0b3BfY2ggPSBjaDtcblxuICAgICAgICAgICAgaWYgKCFjaCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nICYmIHBlZWsoKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgLyogY3NzIGNvbW1lbnQgKi9cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gaW5kZW50TGV2ZWwgPT09IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNBZnRlck5ld2xpbmUgfHwgaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50Lm5ld0xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChlYXRDb21tZW50KCkpO1xuICAgICAgICAgICAgICAgIHByaW50Lm5ld0xpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50Lm5ld0xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nICYmIHBlZWsoKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIGxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmICghaXNBZnRlck5ld2xpbmUgJiYgbGFzdF90b3BfY2ggIT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBwcmludC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByaW50LnNpbmdsZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZWF0Q29tbWVudCgpKTtcbiAgICAgICAgICAgICAgICBwcmludC5uZXdMaW5lKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBwcmludC5wcmVzZXJ2ZVNpbmdsZVNwYWNlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggbGVzcyBwcm9wZXJ5IG1peGlucyBAey4uLn1cbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZWF0U3RyaW5nKCd9JykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCB0cmFpbGluZyBzcGFjZSwgaWYgcHJlc2VudCwgZm9yIGhhc2ggcHJvcGVydHkgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZU9yUnVsZSA9IHBlZWtTdHJpbmcoXCI6ICw7e30oKVtdLz0nXFxcIlwiKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUubWF0Y2goL1sgOl0kLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWJsZSBvciBwc2V1ZG8tY2xhc3MsIGFkZCBpdCBhbmQgaW5zZXJ0IG9uZSBzcGFjZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVPclJ1bGUgPSBlYXRTdHJpbmcoXCI6IFwiKS5yZXBsYWNlKC9cXHMkLywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFyaWFibGVPclJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQuc2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlT3JSdWxlID0gdmFyaWFibGVPclJ1bGUucmVwbGFjZSgvXFxzJC8sICcnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtaWdodCBiZSBhIG5lc3RpbmcgYXQtcnVsZVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgaW4gY3NzX2JlYXV0aWZ5Lk5FU1RFRF9BVF9SVUxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRMZXZlbCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlT3JSdWxlIGluIGNzc19iZWF1dGlmeS5DT05ESVRJT05BTF9HUk9VUF9SVUxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcjJyAmJiBwZWVrKCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIHByaW50LnByZXNlcnZlU2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChlYXRTdHJpbmcoJ30nKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVlayh0cnVlKSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBwcmludC5zaW5nbGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICBwcmludC5uZXdMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgaW5kZW50TGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50Lm5ld0xpbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRbXCJ7XCJdKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBlbnRlcmluZyBjb25kaXRpb25hbCBncm91cHMsIG9ubHkgcnVsZXNldHMgYXJlIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVSdWxlID0gaW5kZW50TGV2ZWwgPiBuZXN0ZWRMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgZGVjbGFyYXRpb25zIGFyZSBhbHNvIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVJ1bGUgPSBpbmRlbnRMZXZlbCA+PSBuZXN0ZWRMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG91dGRlbnQoKTtcbiAgICAgICAgICAgICAgICBwcmludFtcIn1cIl0oY2gpO1xuICAgICAgICAgICAgICAgIGluc2lkZVJ1bGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG5lc3RlZExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZExldmVsLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdsaW5lX2JldHdlZW5fcnVsZXMgJiYgaW5kZW50TGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQubmV3TGluZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGluc2lkZVJ1bGUgfHwgZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwKSAmJiAhKGxvb2tCYWNrKFwiJlwiKSB8fCBmb3VuZE5lc3RlZFBzZXVkb0NsYXNzKCkpICYmICFsb29rQmFjayhcIihcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJ3Byb3BlcnR5OiB2YWx1ZScgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGNvdWxkIGJlIGluIGEgY29uZGl0aW9uYWwgZ3JvdXAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIHByaW50LnNpbmdsZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Fzcy9sZXNzIHBhcmVudCByZWZlcmVuY2UgZG9uJ3QgdXNlIGEgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc2FzcyBuZXN0ZWQgcHNldWRvLWNsYXNzIGRvbid0IHVzZSBhIHNwYWNlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgc3BhY2UgYmVmb3JlIHBzZXVkb2NsYXNzZXMvcHNldWRvZWxlbWVudHMsIGFzIGl0IG1lYW5zIFwiaW4gYW55IGNoaWxkXCJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2tCYWNrKFwiIFwiKSAmJiBvdXRwdXRbb3V0cHV0Lmxlbmd0aCAtIDFdICE9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwc2V1ZG8tZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCI6OlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBzZXVkby1jbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJzonKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09ICdcXCcnKSB7XG4gICAgICAgICAgICAgICAgcHJpbnQucHJlc2VydmVTaW5nbGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGVhdFN0cmluZyhjaCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgICBwcmludC5uZXdMaW5lKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXkgYmUgYSB1cmxcbiAgICAgICAgICAgICAgICBpZiAobG9va0JhY2soXCJ1cmxcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2gpO1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCAhPT0gJyknICYmIGNoICE9PSAnXCInICYmIGNoICE9PSAnXFwnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGVhdFN0cmluZygnKScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHByaW50LnByZXNlcnZlU2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2gpO1xuICAgICAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2gpO1xuICAgICAgICAgICAgICAgIHBhcmVuTGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcsJykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgICBlYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yU2VwYXJhdG9yTmV3bGluZSAmJiAhaW5zaWRlUHJvcGVydHlWYWx1ZSAmJiBwYXJlbkxldmVsIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmludC5uZXdMaW5lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQuc2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjaCA9PT0gJz4nIHx8IGNoID09PSAnKycgfHwgY2ggPT09ICd+JykgJiYgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA8IDEpIHtcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBjb21iaW5hdG9yIHNwYWNpbmdcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VfYXJvdW5kX2NvbWJpbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQuc2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2gpO1xuICAgICAgICAgICAgICAgICAgICBwcmludC5zaW5nbGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzcXVhc2ggZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggJiYgd2hpdGVSZS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgIHByaW50LnByZXNlcnZlU2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAvLyBubyB3aGl0ZXNwYWNlIGJlZm9yZSBvciBhZnRlclxuICAgICAgICAgICAgICAgIGVhdFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBjaCA9ICc9JztcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByaW50LnByZXNlcnZlU2luZ2xlU3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3dlZXRDb2RlID0gJyc7XG4gICAgICAgIGlmIChiYXNlYmFzZUluZGVudFN0cmluZykge1xuICAgICAgICAgICAgc3dlZXRDb2RlICs9IGJhc2ViYXNlSW5kZW50U3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dlZXRDb2RlICs9IG91dHB1dC5qb2luKCcnKS5yZXBsYWNlKC9bXFxyXFxuXFx0IF0rJC8sICcnKTtcblxuICAgICAgICAvLyBlc3RhYmxpc2ggZW5kX3dpdGhfbmV3bGluZVxuICAgICAgICBpZiAoZW5kX3dpdGhfbmV3bGluZSkge1xuICAgICAgICAgICAgc3dlZXRDb2RlICs9ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHN3ZWV0Q29kZSA9IHN3ZWV0Q29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0Q29kZTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQXQtcnVsZVxuICAgIGNzc19iZWF1dGlmeS5ORVNURURfQVRfUlVMRSA9IHtcbiAgICAgICAgXCJAcGFnZVwiOiB0cnVlLFxuICAgICAgICBcIkBmb250LWZhY2VcIjogdHJ1ZSxcbiAgICAgICAgXCJAa2V5ZnJhbWVzXCI6IHRydWUsXG4gICAgICAgIC8vIGFsc28gaW4gQ09ORElUSU9OQUxfR1JPVVBfUlVMRSBiZWxvd1xuICAgICAgICBcIkBtZWRpYVwiOiB0cnVlLFxuICAgICAgICBcIkBzdXBwb3J0c1wiOiB0cnVlLFxuICAgICAgICBcIkBkb2N1bWVudFwiOiB0cnVlXG4gICAgfTtcbiAgICBjc3NfYmVhdXRpZnkuQ09ORElUSU9OQUxfR1JPVVBfUlVMRSA9IHtcbiAgICAgICAgXCJAbWVkaWFcIjogdHJ1ZSxcbiAgICAgICAgXCJAc3VwcG9ydHNcIjogdHJ1ZSxcbiAgICAgICAgXCJAZG9jdW1lbnRcIjogdHJ1ZVxuICAgIH07XG5cbiAgICAvKmdsb2JhbCBkZWZpbmUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjc3NfYmVhdXRpZnk6IGNzc19iZWF1dGlmeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMuIEp1c3QgcHV0IHRoaXMgZmlsZSBzb21ld2hlcmUgb24geW91ciByZXF1aXJlLnBhdGhzXG4gICAgICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICAgICAgZXhwb3J0cy5jc3NfYmVhdXRpZnkgPSBjc3NfYmVhdXRpZnk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICAgICAgd2luZG93LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICAgICAgZ2xvYmFsLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbiAgICB9XG59KSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktY3NzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");
},62:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\n    http://jsbeautifier.org/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)   indent <head> and <body> sections,\n    indent_size (default 4)           indentation size,\n    indent_char (default space)       character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false,\n      'extra_liners': ['/html']\n    });\n*/\n\n(function () {\n\n    // function trim(s) {\n    //     return s.replace(/^\\s+|\\s+$/g, '');\n    // }\n\n    function ltrim(s) {\n        return s.replace(/^\\s+/g, '');\n    }\n\n    function rtrim(s) {\n        return s.replace(/\\s+$/g, '');\n    }\n\n    function style_html(html_source, options, js_beautify, css_beautify) {\n        //Wrapper function to invoke all the necessary constructors and deal with the output.\n\n        var multi_parser, indent_inner_html, indent_body_inner_html, indent_head_inner_html, indent_size, indent_character, wrap_line_length, brace_style, unformatted, preserve_newlines, max_preserve_newlines, indent_handlebars, wrap_attributes, wrap_attributes_indent_size, end_with_newline, extra_liners, eol;\n\n        options = options || {};\n\n        // backwards compatibility to 1.3.4\n        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) && options.max_char !== undefined && parseInt(options.max_char, 10) !== 0) {\n            options.wrap_line_length = options.max_char;\n        }\n\n        indent_inner_html = options.indent_inner_html === undefined ? false : options.indent_inner_html;\n        indent_body_inner_html = options.indent_body_inner_html === undefined ? true : options.indent_body_inner_html;\n        indent_head_inner_html = options.indent_head_inner_html === undefined ? true : options.indent_head_inner_html;\n        indent_size = options.indent_size === undefined ? 4 : parseInt(options.indent_size, 10);\n        indent_character = options.indent_char === undefined ? ' ' : options.indent_char;\n        brace_style = options.brace_style === undefined ? 'collapse' : options.brace_style;\n        wrap_line_length = parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);\n        unformatted = options.unformatted || [\n        // https://www.w3.org/TR/html5/dom.html#phrasing-content\n        'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite', 'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript', 'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */'select', 'small', 'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var', 'video', 'wbr', 'text',\n        // prexisting - not sure of full effect of removing, leaving in\n        'acronym', 'address', 'big', 'dt', 'ins', 'small', 'strike', 'tt', 'pre'];\n        preserve_newlines = options.preserve_newlines === undefined ? true : options.preserve_newlines;\n        max_preserve_newlines = preserve_newlines ? isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10) : 0;\n        indent_handlebars = options.indent_handlebars === undefined ? false : options.indent_handlebars;\n        wrap_attributes = options.wrap_attributes === undefined ? 'auto' : options.wrap_attributes;\n        wrap_attributes_indent_size = isNaN(parseInt(options.wrap_attributes_indent_size, 10)) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10);\n        end_with_newline = options.end_with_newline === undefined ? false : options.end_with_newline;\n        extra_liners = typeof options.extra_liners === 'object' && options.extra_liners ? options.extra_liners.concat() : typeof options.extra_liners === 'string' ? options.extra_liners.split(',') : 'head,body,/html'.split(',');\n        eol = options.eol ? options.eol : '\\n';\n\n        if (options.indent_with_tabs) {\n            indent_character = '\\t';\n            indent_size = 1;\n        }\n\n        eol = eol.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n');\n\n        function Parser() {\n\n            this.pos = 0; //Parser position\n            this.token = '';\n            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\n            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\n                parent: 'parent1',\n                parentcount: 1,\n                parent1: ''\n            };\n            this.tag_type = '';\n            this.token_text = this.last_token = this.last_text = this.token_type = '';\n            this.newlines = 0;\n            this.indent_content = indent_inner_html;\n            this.indent_body_inner_html = indent_body_inner_html;\n            this.indent_head_inner_html = indent_head_inner_html;\n\n            this.Utils = { //Uilities made available to the various functions\n                whitespace: \"\\n\\r\\t \".split(''),\n\n                single_token: [\n                // HTLM void elements - aka self-closing tags - aka singletons\n                // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n                'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',\n                // NOTE: Optional tags - are not understood.\n                // https://www.w3.org/TR/html5/syntax.html#optional-tags\n                // The rules for optional tags are too complex for a simple list\n                // Also, the content of these tags should still be indented in many cases.\n                // 'li' is a good exmple.\n\n                // Doctype and xml elements\n                '!doctype', '?xml',\n                // ?php tag\n                '?php',\n                // other tags that were in this list, keeping just in case\n                'basefont', 'isindex'],\n                extra_liners: extra_liners, //for tags that need a line of whitespace before them\n                in_array: function (what, arr) {\n                    for (var i = 0; i < arr.length; i++) {\n                        if (what === arr[i]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n\n            // Return true if the given text is composed entirely of whitespace.\n            this.is_whitespace = function (text) {\n                for (var n = 0; n < text.length; n++) {\n                    if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n\n            this.traverse_whitespace = function () {\n                var input_char = '';\n\n                input_char = this.input.charAt(this.pos);\n                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                    this.newlines = 0;\n                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                        if (preserve_newlines && input_char === '\\n' && this.newlines <= max_preserve_newlines) {\n                            this.newlines += 1;\n                        }\n\n                        this.pos++;\n                        input_char = this.input.charAt(this.pos);\n                    }\n                    return true;\n                }\n                return false;\n            };\n\n            // Append a space to the given content (string array) or, if we are\n            // at the wrap_line_length, append a newline/indentation.\n            // return true if a newline was added, false if a space was added\n            this.space_or_wrap = function (content) {\n                if (this.line_char_count >= this.wrap_line_length) {\n                    //insert a line when the wrap_line_length is reached\n                    this.print_newline(false, content);\n                    this.print_indentation(content);\n                    return true;\n                } else {\n                    this.line_char_count++;\n                    content.push(' ');\n                    return false;\n                }\n            };\n\n            this.get_content = function () {\n                //function to capture regular content between tags\n                var input_char = '',\n                    content = [];\n\n                while (this.input.charAt(this.pos) !== '<') {\n                    if (this.pos >= this.input.length) {\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\n                    }\n\n                    if (this.traverse_whitespace()) {\n                        this.space_or_wrap(content);\n                        continue;\n                    }\n\n                    if (indent_handlebars) {\n                        // Handlebars parsing is complicated.\n                        // {{#foo}} and {{/foo}} are formatted tags.\n                        // {{something}} should get treated as content, except:\n                        // {{else}} specifically behaves like {{#if}} and {{/if}}\n                        var peek3 = this.input.substr(this.pos, 3);\n                        if (peek3 === '{{#' || peek3 === '{{/') {\n                            // These are tags and not content.\n                            break;\n                        } else if (peek3 === '{{!') {\n                            return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];\n                        } else if (this.input.substr(this.pos, 2) === '{{') {\n                            if (this.get_tag(true) === '{{else}}') {\n                                break;\n                            }\n                        }\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n                    this.line_char_count++;\n                    content.push(input_char); //letter at-a-time (or string) inserted to an array\n                }\n                return content.length ? content.join('') : '';\n            };\n\n            this.get_contents_to = function (name) {\n                //get the full content of a script or style to pass to js_beautify\n                if (this.pos === this.input.length) {\n                    return ['', 'TK_EOF'];\n                }\n                var content = '';\n                var reg_match = new RegExp('</' + name + '\\\\s*>', 'igm');\n                reg_match.lastIndex = this.pos;\n                var reg_array = reg_match.exec(this.input);\n                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script\n                if (this.pos < end_script) {\n                    //get everything in between the script tags\n                    content = this.input.substring(this.pos, end_script);\n                    this.pos = end_script;\n                }\n                return content;\n            };\n\n            this.record_tag = function (tag) {\n                //function to record a tag and its parent in this.tags Object\n                if (this.tags[tag + 'count']) {\n                    //check for the existence of this tag type\n                    this.tags[tag + 'count']++;\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n                } else {\n                    //otherwise initialize this tag type\n                    this.tags[tag + 'count'] = 1;\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n                }\n                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\n                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\n            };\n\n            this.retrieve_tag = function (tag) {\n                //function to retrieve the opening tag to the corresponding closer\n                if (this.tags[tag + 'count']) {\n                    //if the openener is not in the Object we ignore it\n                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.\n                    while (temp_parent) {\n                        //till we reach '' (the initial value);\n                        if (tag + this.tags[tag + 'count'] === temp_parent) {\n                            //if this is it use it\n                            break;\n                        }\n                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\n                    }\n                    if (temp_parent) {\n                        //if we caught something\n                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\n                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\n                    }\n                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\n                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\n                    if (this.tags[tag + 'count'] === 1) {\n                        delete this.tags[tag + 'count'];\n                    } else {\n                        this.tags[tag + 'count']--;\n                    }\n                }\n            };\n\n            this.indent_to_tag = function (tag) {\n                // Match the indentation level to the last use of this tag, but don't remove it.\n                if (!this.tags[tag + 'count']) {\n                    return;\n                }\n                var temp_parent = this.tags.parent;\n                while (temp_parent) {\n                    if (tag + this.tags[tag + 'count'] === temp_parent) {\n                        break;\n                    }\n                    temp_parent = this.tags[temp_parent + 'parent'];\n                }\n                if (temp_parent) {\n                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];\n                }\n            };\n\n            this.get_tag = function (peek) {\n                //function to get a full tag and parse its type\n                var input_char = '',\n                    content = [],\n                    comment = '',\n                    space = false,\n                    first_attr = true,\n                    tag_start,\n                    tag_end,\n                    tag_start_char,\n                    orig_pos = this.pos,\n                    orig_line_char_count = this.line_char_count;\n\n                peek = peek !== undefined ? peek : false;\n\n                do {\n                    if (this.pos >= this.input.length) {\n                        if (peek) {\n                            this.pos = orig_pos;\n                            this.line_char_count = orig_line_char_count;\n                        }\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                        //don't want to insert unnecessary space\n                        space = true;\n                        continue;\n                    }\n\n                    if (input_char === \"'\" || input_char === '\"') {\n                        input_char += this.get_unformatted(input_char);\n                        space = true;\n                    }\n\n                    if (input_char === '=') {\n                        //no space before =\n                        space = false;\n                    }\n\n                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {\n                        //no space after = or before >\n                        var wrapped = this.space_or_wrap(content);\n                        var indentAttrs = wrapped && input_char !== '/' && wrap_attributes !== 'force';\n                        space = false;\n                        if (!first_attr && wrap_attributes === 'force' && input_char !== '/') {\n                            this.print_newline(false, content);\n                            this.print_indentation(content);\n                            indentAttrs = true;\n                        }\n                        if (indentAttrs) {\n                            //indent attributes an auto or forced line-wrap\n                            for (var count = 0; count < wrap_attributes_indent_size; count++) {\n                                content.push(indent_character);\n                            }\n                        }\n                        for (var i = 0; i < content.length; i++) {\n                            if (content[i] === ' ') {\n                                first_attr = false;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (indent_handlebars && tag_start_char === '<') {\n                        // When inside an angle-bracket tag, put spaces around\n                        // handlebars not inside of strings.\n                        if (input_char + this.input.charAt(this.pos) === '{{') {\n                            input_char += this.get_unformatted('}}');\n                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {\n                                input_char = ' ' + input_char;\n                            }\n                            space = true;\n                        }\n                    }\n\n                    if (input_char === '<' && !tag_start_char) {\n                        tag_start = this.pos - 1;\n                        tag_start_char = '<';\n                    }\n\n                    if (indent_handlebars && !tag_start_char) {\n                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {\n                            if (input_char === '#' || input_char === '/' || input_char === '!') {\n                                tag_start = this.pos - 3;\n                            } else {\n                                tag_start = this.pos - 2;\n                            }\n                            tag_start_char = '{';\n                        }\n                    }\n\n                    this.line_char_count++;\n                    content.push(input_char); //inserts character at-a-time (or string)\n\n                    if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) {\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        content = [this.get_comment(tag_start)];\n                        break;\n                    }\n\n                    if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') {\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        content = [this.get_comment(tag_start)];\n                        break;\n                    }\n\n                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {\n                        break;\n                    }\n                } while (input_char !== '>');\n\n                var tag_complete = content.join('');\n                var tag_index;\n                var tag_offset;\n\n                if (tag_complete.indexOf(' ') !== -1) {\n                    //if there's whitespace, thats where the tag name ends\n                    tag_index = tag_complete.indexOf(' ');\n                } else if (tag_complete.charAt(0) === '{') {\n                    tag_index = tag_complete.indexOf('}');\n                } else {\n                    //otherwise go with the tag ending\n                    tag_index = tag_complete.indexOf('>');\n                }\n                if (tag_complete.charAt(0) === '<' || !indent_handlebars) {\n                    tag_offset = 1;\n                } else {\n                    tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;\n                }\n                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();\n                if (tag_complete.charAt(tag_complete.length - 2) === '/' || this.Utils.in_array(tag_check, this.Utils.single_token)) {\n                    //if this tag name is a single tag type (either in the list or has a closing /)\n                    if (!peek) {\n                        this.tag_type = 'SINGLE';\n                    }\n                } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {\n                    if (!peek) {\n                        this.indent_to_tag('if');\n                        this.tag_type = 'HANDLEBARS_ELSE';\n                        this.indent_content = true;\n                        this.traverse_whitespace();\n                    }\n                } else if (this.is_unformatted(tag_check, unformatted)) {\n                    // do not reformat the \"unformatted\" tags\n                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function\n                    content.push(comment);\n                    tag_end = this.pos - 1;\n                    this.tag_type = 'SINGLE';\n                } else if (tag_check === 'script' && (tag_complete.search('type') === -1 || tag_complete.search('type') > -1 && tag_complete.search(/\\b(text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect)/) > -1)) {\n                    if (!peek) {\n                        this.record_tag(tag_check);\n                        this.tag_type = 'SCRIPT';\n                    }\n                } else if (tag_check === 'style' && (tag_complete.search('type') === -1 || tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1)) {\n                    if (!peek) {\n                        this.record_tag(tag_check);\n                        this.tag_type = 'STYLE';\n                    }\n                } else if (tag_check.charAt(0) === '!') {\n                    //peek for <! comment\n                    // for comments content is already correct.\n                    if (!peek) {\n                        this.tag_type = 'SINGLE';\n                        this.traverse_whitespace();\n                    }\n                } else if (!peek) {\n                    if (tag_check.charAt(0) === '/') {\n                        //this tag is a double tag so check for tag-ending\n                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\n                        this.tag_type = 'END';\n                    } else {\n                        //otherwise it's a start-tag\n                        this.record_tag(tag_check); //push it on the tag stack\n                        if (tag_check.toLowerCase() !== 'html') {\n                            this.indent_content = true;\n                        }\n                        this.tag_type = 'START';\n                    }\n\n                    // Allow preserving of newlines after a start or end tag\n                    if (this.traverse_whitespace()) {\n                        this.space_or_wrap(content);\n                    }\n\n                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) {\n                        //check if this double needs an extra line\n                        this.print_newline(false, this.output);\n                        if (this.output.length && this.output[this.output.length - 2] !== '\\n') {\n                            this.print_newline(true, this.output);\n                        }\n                    }\n                }\n\n                if (peek) {\n                    this.pos = orig_pos;\n                    this.line_char_count = orig_line_char_count;\n                }\n\n                return content.join(''); //returns fully formatted tag\n            };\n\n            this.get_comment = function (start_pos) {\n                //function to return comment content in its entirety\n                // this is will have very poor perf, but will work for now.\n                var comment = '',\n                    delimiter = '>',\n                    matched = false;\n\n                this.pos = start_pos;\n                var input_char = this.input.charAt(this.pos);\n                this.pos++;\n\n                while (this.pos <= this.input.length) {\n                    comment += input_char;\n\n                    // only need to check for the delimiter if the last chars match\n                    if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) && comment.indexOf(delimiter) !== -1) {\n                        break;\n                    }\n\n                    // only need to search for custom delimiter for the first few characters\n                    if (!matched && comment.length < 10) {\n                        if (comment.indexOf('<![if') === 0) {\n                            //peek for <![if conditional comment\n                            delimiter = '<![endif]>';\n                            matched = true;\n                        } else if (comment.indexOf('<![cdata[') === 0) {\n                            //if it's a <[cdata[ comment...\n                            delimiter = ']]>';\n                            matched = true;\n                        } else if (comment.indexOf('<![') === 0) {\n                            // some other ![ comment? ...\n                            delimiter = ']>';\n                            matched = true;\n                        } else if (comment.indexOf('<!--') === 0) {\n                            // <!-- comment ...\n                            delimiter = '-->';\n                            matched = true;\n                        } else if (comment.indexOf('{{!') === 0) {\n                            // {{! handlebars comment\n                            delimiter = '}}';\n                            matched = true;\n                        } else if (comment.indexOf('<?') === 0) {\n                            // {{! handlebars comment\n                            delimiter = '?>';\n                            matched = true;\n                        } else if (comment.indexOf('<%') === 0) {\n                            // {{! handlebars comment\n                            delimiter = '%>';\n                            matched = true;\n                        }\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n                }\n\n                return comment;\n            };\n\n            function tokenMatcher(delimiter) {\n                var token = '';\n\n                var add = function (str) {\n                    var newToken = token + str.toLowerCase();\n                    token = newToken.length <= delimiter.length ? newToken : newToken.substr(newToken.length - delimiter.length, delimiter.length);\n                };\n\n                var doesNotMatch = function () {\n                    return token.indexOf(delimiter) === -1;\n                };\n\n                return {\n                    add: add,\n                    doesNotMatch: doesNotMatch\n                };\n            }\n\n            this.get_unformatted = function (delimiter, orig_tag) {\n                //function to return unformatted content in its entirety\n                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {\n                    return '';\n                }\n                var input_char = '';\n                var content = '';\n                var space = true;\n\n                var delimiterMatcher = tokenMatcher(delimiter);\n\n                do {\n\n                    if (this.pos >= this.input.length) {\n                        return content;\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                        if (!space) {\n                            this.line_char_count--;\n                            continue;\n                        }\n                        if (input_char === '\\n' || input_char === '\\r') {\n                            content += '\\n';\n                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\n                            for (var i=0; i<this.indent_level; i++) {\n                            content += this.indent_string;\n                            }\n                            space = false; //...and make sure other indentation is erased\n                            */\n                            this.line_char_count = 0;\n                            continue;\n                        }\n                    }\n                    content += input_char;\n                    delimiterMatcher.add(input_char);\n                    this.line_char_count++;\n                    space = true;\n\n                    if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {\n                        // Handlebars expressions in strings should also be unformatted.\n                        content += this.get_unformatted('}}');\n                        // Don't consider when stopping for delimiters.\n                    }\n                } while (delimiterMatcher.doesNotMatch());\n\n                return content;\n            };\n\n            this.get_token = function () {\n                //initial handler for token-retrieval\n                var token;\n\n                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') {\n                    //check if we need to format javascript\n                    var type = this.last_token.substr(7);\n                    token = this.get_contents_to(type);\n                    if (typeof token !== 'string') {\n                        return token;\n                    }\n                    return [token, 'TK_' + type];\n                }\n                if (this.current_mode === 'CONTENT') {\n                    token = this.get_content();\n                    if (typeof token !== 'string') {\n                        return token;\n                    } else {\n                        return [token, 'TK_CONTENT'];\n                    }\n                }\n\n                if (this.current_mode === 'TAG') {\n                    token = this.get_tag();\n                    if (typeof token !== 'string') {\n                        return token;\n                    } else {\n                        var tag_name_type = 'TK_TAG_' + this.tag_type;\n                        return [token, tag_name_type];\n                    }\n                }\n            };\n\n            this.get_full_indent = function (level) {\n                level = this.indent_level + level || 0;\n                if (level < 1) {\n                    return '';\n                }\n\n                return Array(level + 1).join(this.indent_string);\n            };\n\n            this.is_unformatted = function (tag_check, unformatted) {\n                //is this an HTML5 block-level link?\n                if (!this.Utils.in_array(tag_check, unformatted)) {\n                    return false;\n                }\n\n                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {\n                    return true;\n                }\n\n                //at this point we have an  tag; is its first child something we want to remain\n                //unformatted?\n                var next_tag = this.get_tag(true /* peek. */);\n\n                // test next_tag to see if it is just html tag (no external content)\n                var tag = (next_tag || \"\").match(/^\\s*<\\s*\\/?([a-z]*)\\s*[^>]*>\\s*$/);\n\n                // if next_tag comes back but is not an isolated tag, then\n                // let's treat the 'a' tag as having content\n                // and respect the unformatted option\n                if (!tag || this.Utils.in_array(tag, unformatted)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            };\n\n            this.printer = function (js_source, indent_character, indent_size, wrap_line_length, brace_style) {\n                //handles input/output and some other printing functions\n\n                this.input = js_source || ''; //gets the input for the Parser\n\n                // HACK: newline parsing inconsistent. This brute force normalizes the input.\n                this.input = this.input.replace(/\\r\\n|[\\r\\u2028\\u2029]/g, '\\n');\n\n                this.output = [];\n                this.indent_character = indent_character;\n                this.indent_string = '';\n                this.indent_size = indent_size;\n                this.brace_style = brace_style;\n                this.indent_level = 0;\n                this.wrap_line_length = wrap_line_length;\n                this.line_char_count = 0; //count to see if wrap_line_length was exceeded\n\n                for (var i = 0; i < this.indent_size; i++) {\n                    this.indent_string += this.indent_character;\n                }\n\n                this.print_newline = function (force, arr) {\n                    this.line_char_count = 0;\n                    if (!arr || !arr.length) {\n                        return;\n                    }\n                    if (force || arr[arr.length - 1] !== '\\n') {\n                        //we might want the extra line\n                        if (arr[arr.length - 1] !== '\\n') {\n                            arr[arr.length - 1] = rtrim(arr[arr.length - 1]);\n                        }\n                        arr.push('\\n');\n                    }\n                };\n\n                this.print_indentation = function (arr) {\n                    for (var i = 0; i < this.indent_level; i++) {\n                        arr.push(this.indent_string);\n                        this.line_char_count += this.indent_string.length;\n                    }\n                };\n\n                this.print_token = function (text) {\n                    // Avoid printing initial whitespace.\n                    if (this.is_whitespace(text) && !this.output.length) {\n                        return;\n                    }\n                    if (text || text !== '') {\n                        if (this.output.length && this.output[this.output.length - 1] === '\\n') {\n                            this.print_indentation(this.output);\n                            text = ltrim(text);\n                        }\n                    }\n                    this.print_token_raw(text);\n                };\n\n                this.print_token_raw = function (text) {\n                    // If we are going to print newlines, truncate trailing\n                    // whitespace, as the newlines will represent the space.\n                    if (this.newlines > 0) {\n                        text = rtrim(text);\n                    }\n\n                    if (text && text !== '') {\n                        if (text.length > 1 && text.charAt(text.length - 1) === '\\n') {\n                            // unformatted tags can grab newlines as their last character\n                            this.output.push(text.slice(0, -1));\n                            this.print_newline(false, this.output);\n                        } else {\n                            this.output.push(text);\n                        }\n                    }\n\n                    for (var n = 0; n < this.newlines; n++) {\n                        this.print_newline(n > 0, this.output);\n                    }\n                    this.newlines = 0;\n                };\n\n                this.indent = function () {\n                    this.indent_level++;\n                };\n\n                this.unindent = function () {\n                    if (this.indent_level > 0) {\n                        this.indent_level--;\n                    }\n                };\n            };\n            return this;\n        }\n\n        /*_____________________--------------------_____________________*/\n\n        multi_parser = new Parser(); //wrapping functions Parser\n        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values\n\n        while (true) {\n            var t = multi_parser.get_token();\n            multi_parser.token_text = t[0];\n            multi_parser.token_type = t[1];\n\n            if (multi_parser.token_type === 'TK_EOF') {\n                break;\n            }\n\n            switch (multi_parser.token_type) {\n                case 'TK_TAG_START':\n                    multi_parser.print_newline(false, multi_parser.output);\n                    multi_parser.print_token(multi_parser.token_text);\n                    if (multi_parser.indent_content) {\n                        if ((multi_parser.indent_body_inner_html || !multi_parser.token_text.match(/<body(?:.*)>/)) && (multi_parser.indent_head_inner_html || !multi_parser.token_text.match(/<head(?:.*)>/))) {\n\n                            multi_parser.indent();\n                        }\n\n                        multi_parser.indent_content = false;\n                    }\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_STYLE':\n                case 'TK_TAG_SCRIPT':\n                    multi_parser.print_newline(false, multi_parser.output);\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_END':\n                    //Print new line only if the tag has no content and has child\n                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\n                        var tag_name = (multi_parser.token_text.match(/\\w+/) || [])[0];\n                        var tag_extracted_from_last_output = null;\n                        if (multi_parser.output.length) {\n                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\\s*(\\w+)/);\n                        }\n                        if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted)) {\n                            multi_parser.print_newline(false, multi_parser.output);\n                        }\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_SINGLE':\n                    // Don't add a newline before elements that should remain unformatted.\n                    var tag_check = multi_parser.token_text.match(/^\\s*<([a-z-]+)/i);\n                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {\n                        multi_parser.print_newline(false, multi_parser.output);\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_HANDLEBARS_ELSE':\n                    // Don't add a newline if opening {{#if}} tag is on the current line\n                    var foundIfOnCurrentLine = false;\n                    for (var lastCheckedOutput = multi_parser.output.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {\n                        if (multi_parser.output[lastCheckedOutput] === '\\n') {\n                            break;\n                        } else {\n                            if (multi_parser.output[lastCheckedOutput].match(/{{#if/)) {\n                                foundIfOnCurrentLine = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!foundIfOnCurrentLine) {\n                        multi_parser.print_newline(false, multi_parser.output);\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    if (multi_parser.indent_content) {\n                        multi_parser.indent();\n                        multi_parser.indent_content = false;\n                    }\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_HANDLEBARS_COMMENT':\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                case 'TK_CONTENT':\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                case 'TK_STYLE':\n                case 'TK_SCRIPT':\n                    if (multi_parser.token_text !== '') {\n                        multi_parser.print_newline(false, multi_parser.output);\n                        var text = multi_parser.token_text,\n                            _beautifier,\n                            script_indent_level = 1;\n                        if (multi_parser.token_type === 'TK_SCRIPT') {\n                            _beautifier = typeof js_beautify === 'function' && js_beautify;\n                        } else if (multi_parser.token_type === 'TK_STYLE') {\n                            _beautifier = typeof css_beautify === 'function' && css_beautify;\n                        }\n\n                        if (options.indent_scripts === \"keep\") {\n                            script_indent_level = 0;\n                        } else if (options.indent_scripts === \"separate\") {\n                            script_indent_level = -multi_parser.indent_level;\n                        }\n\n                        var indentation = multi_parser.get_full_indent(script_indent_level);\n                        if (_beautifier) {\n\n                            // call the Beautifier if avaliable\n                            var Child_options = function () {\n                                this.eol = '\\n';\n                            };\n                            Child_options.prototype = options;\n                            var child_options = new Child_options();\n                            text = _beautifier(text.replace(/^\\s*/, indentation), child_options);\n                        } else {\n                            // simply indent the string otherwise\n                            var white = text.match(/^\\s*/)[0];\n                            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\n                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);\n                            text = text.replace(/^\\s*/, indentation).replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent).replace(/\\s+$/, '');\n                        }\n                        if (text) {\n                            multi_parser.print_token_raw(text);\n                            multi_parser.print_newline(true, multi_parser.output);\n                        }\n                    }\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                default:\n                    // We should not be getting here but we don't want to drop input on the floor\n                    // Just output the text and move on\n                    if (multi_parser.token_text !== '') {\n                        multi_parser.print_token(multi_parser.token_text);\n                    }\n                    break;\n            }\n            multi_parser.last_token = multi_parser.token_type;\n            multi_parser.last_text = multi_parser.token_text;\n        }\n        var sweet_code = multi_parser.output.join('').replace(/[\\r\\n\\t ]+$/, '');\n\n        // establish end_with_newline\n        if (end_with_newline) {\n            sweet_code += '\\n';\n        }\n\n        if (eol !== '\\n') {\n            sweet_code = sweet_code.replace(/[\\n]/g, eol);\n        }\n\n        return sweet_code;\n    }\n\n    if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(60), __webpack_require__(61)], __WEBPACK_AMD_DEFINE_RESULT__ = function (requireamd) {\n            var js_beautify = __webpack_require__(60);\n            var css_beautify = __webpack_require__(61);\n\n            return {\n                html_beautify: function (html_source, options) {\n                    return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n                }\n            };\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== \"undefined\") {\n        // Add support for CommonJS. Just put this file somewhere on your require.paths\n        // and you will be able to `var html_beautify = require(\"beautify\").html_beautify`.\n        var js_beautify = require('./beautify.js');\n        var css_beautify = require('./beautify-css.js');\n\n        exports.html_beautify = function (html_source, options) {\n            return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n        };\n    } else if (typeof window !== \"undefined\") {\n        // If we're running a web page and don't have either of the above, add our one global\n        window.html_beautify = function (html_source, options) {\n            return style_html(html_source, options, window.js_beautify, window.css_beautify);\n        };\n    } else if (typeof global !== \"undefined\") {\n        // If we don't even have window, try global.\n        global.html_beautify = function (html_source, options) {\n            return style_html(html_source, options, global.js_beautify, global.css_beautify);\n        };\n    }\n})();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzLWJlYXV0aWZ5L2pzL2xpYi9iZWF1dGlmeS1odG1sLmpzPzg5YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgY3VybHk6dHJ1ZSwgZXFlcWVxOnRydWUsIGxheGJyZWFrOnRydWUsIG5vZW1wdHk6ZmFsc2UgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTMgRWluYXIgTGllbG1hbmlzIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cblxuXG4gU3R5bGUgSFRNTFxuLS0tLS0tLS0tLS0tLS0tXG5cbiAgV3JpdHRlbiBieSBOb2NodW0gU29zc29ua28sIChuc29zc29ua29AaG90bWFpbC5jb20pXG5cbiAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBqc2JlYXV0aWZpZXIub3JnPlxuICAgIGh0dHA6Ly9qc2JlYXV0aWZpZXIub3JnL1xuXG4gIFVzYWdlOlxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UpO1xuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9pbm5lcl9odG1sIChkZWZhdWx0IGZhbHNlKSAg4oCUIGluZGVudCA8aGVhZD4gYW5kIDxib2R5PiBzZWN0aW9ucyxcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgMjUwKSAgICAgICAgICAgIC0gIG1heGltdW0gYW1vdW50IG9mIGNoYXJhY3RlcnMgcGVyIGxpbmUgKDAgPSBkaXNhYmxlKVxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cbiAgICB1bmZvcm1hdHRlZCAoZGVmYXVsdHMgdG8gaW5saW5lIHRhZ3MpIC0gbGlzdCBvZiB0YWdzLCB0aGF0IHNob3VsZG4ndCBiZSByZWZvcm1hdHRlZFxuICAgIGluZGVudF9zY3JpcHRzIChkZWZhdWx0IG5vcm1hbCkgIC0gXCJrZWVwXCJ8XCJzZXBhcmF0ZVwifFwibm9ybWFsXCJcbiAgICBwcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB0cnVlKSAtIHdoZXRoZXIgZXhpc3RpbmcgbGluZSBicmVha3MgYmVmb3JlIGVsZW1lbnRzIHNob3VsZCBiZSBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGJlZm9yZSBlbGVtZW50cywgbm90IGluc2lkZSB0YWdzIG9yIGZvciB0ZXh0LlxuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbWF4aW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gYmUgcHJlc2VydmVkIGluIG9uZSBjaHVua1xuICAgIGluZGVudF9oYW5kbGViYXJzIChkZWZhdWx0IGZhbHNlKSAtIGZvcm1hdCBhbmQgaW5kZW50IHt7I2Zvb319IGFuZCB7ey9mb299fVxuICAgIGVuZF93aXRoX25ld2xpbmUgKGZhbHNlKSAgICAgICAgICAtIGVuZCB3aXRoIGEgbmV3bGluZVxuICAgIGV4dHJhX2xpbmVycyAoZGVmYXVsdCBbaGVhZCxib2R5LC9odG1sXSkgLUxpc3Qgb2YgdGFncyB0aGF0IHNob3VsZCBoYXZlIGFuIGV4dHJhIG5ld2xpbmUgYmVmb3JlIHRoZW0uXG5cbiAgICBlLmcuXG5cbiAgICBzdHlsZV9odG1sKGh0bWxfc291cmNlLCB7XG4gICAgICAnaW5kZW50X2lubmVyX2h0bWwnOiBmYWxzZSxcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDIsXG4gICAgICAnaW5kZW50X2NoYXInOiAnICcsXG4gICAgICAnd3JhcF9saW5lX2xlbmd0aCc6IDc4LFxuICAgICAgJ2JyYWNlX3N0eWxlJzogJ2V4cGFuZCcsXG4gICAgICAncHJlc2VydmVfbmV3bGluZXMnOiB0cnVlLFxuICAgICAgJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcyc6IDUsXG4gICAgICAnaW5kZW50X2hhbmRsZWJhcnMnOiBmYWxzZSxcbiAgICAgICdleHRyYV9saW5lcnMnOiBbJy9odG1sJ11cbiAgICB9KTtcbiovXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBmdW5jdGlvbiB0cmltKHMpIHtcbiAgICAvLyAgICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgIC8vIH1cblxuICAgIGZ1bmN0aW9uIGx0cmltKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccysvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ0cmltKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFxzKyQvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgICAgICAgLy9XcmFwcGVyIGZ1bmN0aW9uIHRvIGludm9rZSBhbGwgdGhlIG5lY2Vzc2FyeSBjb25zdHJ1Y3RvcnMgYW5kIGRlYWwgd2l0aCB0aGUgb3V0cHV0LlxuXG4gICAgICAgIHZhciBtdWx0aV9wYXJzZXIsIGluZGVudF9pbm5lcl9odG1sLCBpbmRlbnRfYm9keV9pbm5lcl9odG1sLCBpbmRlbnRfaGVhZF9pbm5lcl9odG1sLCBpbmRlbnRfc2l6ZSwgaW5kZW50X2NoYXJhY3Rlciwgd3JhcF9saW5lX2xlbmd0aCwgYnJhY2Vfc3R5bGUsIHVuZm9ybWF0dGVkLCBwcmVzZXJ2ZV9uZXdsaW5lcywgbWF4X3ByZXNlcnZlX25ld2xpbmVzLCBpbmRlbnRfaGFuZGxlYmFycywgd3JhcF9hdHRyaWJ1dGVzLCB3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUsIGVuZF93aXRoX25ld2xpbmUsIGV4dHJhX2xpbmVycywgZW9sO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIDEuMy40XG4gICAgICAgIGlmICgob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgcGFyc2VJbnQob3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoLCAxMCkgPT09IDApICYmIG9wdGlvbnMubWF4X2NoYXIgIT09IHVuZGVmaW5lZCAmJiBwYXJzZUludChvcHRpb25zLm1heF9jaGFyLCAxMCkgIT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMubWF4X2NoYXI7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRlbnRfaW5uZXJfaHRtbCA9IG9wdGlvbnMuaW5kZW50X2lubmVyX2h0bWwgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy5pbmRlbnRfaW5uZXJfaHRtbDtcbiAgICAgICAgaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9IG9wdGlvbnMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuaW5kZW50X2JvZHlfaW5uZXJfaHRtbDtcbiAgICAgICAgaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9IG9wdGlvbnMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbDtcbiAgICAgICAgaW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplID09PSB1bmRlZmluZWQgPyA0IDogcGFyc2VJbnQob3B0aW9ucy5pbmRlbnRfc2l6ZSwgMTApO1xuICAgICAgICBpbmRlbnRfY2hhcmFjdGVyID0gb3B0aW9ucy5pbmRlbnRfY2hhciA9PT0gdW5kZWZpbmVkID8gJyAnIDogb3B0aW9ucy5pbmRlbnRfY2hhcjtcbiAgICAgICAgYnJhY2Vfc3R5bGUgPSBvcHRpb25zLmJyYWNlX3N0eWxlID09PSB1bmRlZmluZWQgPyAnY29sbGFwc2UnIDogb3B0aW9ucy5icmFjZV9zdHlsZTtcbiAgICAgICAgd3JhcF9saW5lX2xlbmd0aCA9IHBhcnNlSW50KG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aCwgMTApID09PSAwID8gMzI3ODYgOiBwYXJzZUludChvcHRpb25zLndyYXBfbGluZV9sZW5ndGggfHwgMjUwLCAxMCk7XG4gICAgICAgIHVuZm9ybWF0dGVkID0gb3B0aW9ucy51bmZvcm1hdHRlZCB8fCBbXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG4gICAgICAgICdhJywgJ2FiYnInLCAnYXJlYScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjaXRlJywgJ2NvZGUnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZWwnLCAnZGZuJywgJ2VtJywgJ2VtYmVkJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdtYXAnLCAnbWFyaycsICdtYXRoJywgJ21ldGVyJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvdXRwdXQnLCAncHJvZ3Jlc3MnLCAncScsICdydWJ5JywgJ3MnLCAnc2FtcCcsIC8qICdzY3JpcHQnLCAqLydzZWxlY3QnLCAnc21hbGwnLCAnc3BhbicsICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICdzdmcnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGltZScsICd1JywgJ3ZhcicsICd2aWRlbycsICd3YnInLCAndGV4dCcsXG4gICAgICAgIC8vIHByZXhpc3RpbmcgLSBub3Qgc3VyZSBvZiBmdWxsIGVmZmVjdCBvZiByZW1vdmluZywgbGVhdmluZyBpblxuICAgICAgICAnYWNyb255bScsICdhZGRyZXNzJywgJ2JpZycsICdkdCcsICdpbnMnLCAnc21hbGwnLCAnc3RyaWtlJywgJ3R0JywgJ3ByZSddO1xuICAgICAgICBwcmVzZXJ2ZV9uZXdsaW5lcyA9IG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLnByZXNlcnZlX25ld2xpbmVzO1xuICAgICAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgPSBwcmVzZXJ2ZV9uZXdsaW5lcyA/IGlzTmFOKHBhcnNlSW50KG9wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzLCAxMCkpID8gMzI3ODYgOiBwYXJzZUludChvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcywgMTApIDogMDtcbiAgICAgICAgaW5kZW50X2hhbmRsZWJhcnMgPSBvcHRpb25zLmluZGVudF9oYW5kbGViYXJzID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnM7XG4gICAgICAgIHdyYXBfYXR0cmlidXRlcyA9IG9wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgPyAnYXV0bycgOiBvcHRpb25zLndyYXBfYXR0cmlidXRlcztcbiAgICAgICAgd3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplID0gaXNOYU4ocGFyc2VJbnQob3B0aW9ucy53cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUsIDEwKSkgPyBpbmRlbnRfc2l6ZSA6IHBhcnNlSW50KG9wdGlvbnMud3JhcF9hdHRyaWJ1dGVzX2luZGVudF9zaXplLCAxMCk7XG4gICAgICAgIGVuZF93aXRoX25ld2xpbmUgPSBvcHRpb25zLmVuZF93aXRoX25ld2xpbmUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICAgICAgICBleHRyYV9saW5lcnMgPSB0eXBlb2Ygb3B0aW9ucy5leHRyYV9saW5lcnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMuZXh0cmFfbGluZXJzID8gb3B0aW9ucy5leHRyYV9saW5lcnMuY29uY2F0KCkgOiB0eXBlb2Ygb3B0aW9ucy5leHRyYV9saW5lcnMgPT09ICdzdHJpbmcnID8gb3B0aW9ucy5leHRyYV9saW5lcnMuc3BsaXQoJywnKSA6ICdoZWFkLGJvZHksL2h0bWwnLnNwbGl0KCcsJyk7XG4gICAgICAgIGVvbCA9IG9wdGlvbnMuZW9sID8gb3B0aW9ucy5lb2wgOiAnXFxuJztcblxuICAgICAgICBpZiAob3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgICAgICAgICBpbmRlbnRfY2hhcmFjdGVyID0gJ1xcdCc7XG4gICAgICAgICAgICBpbmRlbnRfc2l6ZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBlb2wgPSBlb2wucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJyk7XG5cbiAgICAgICAgZnVuY3Rpb24gUGFyc2VyKCkge1xuXG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7IC8vUGFyc2VyIHBvc2l0aW9uXG4gICAgICAgICAgICB0aGlzLnRva2VuID0gJyc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJzsgLy9yZWZsZWN0cyB0aGUgY3VycmVudCBQYXJzZXIgbW9kZTogVEFHL0NPTlRFTlRcbiAgICAgICAgICAgIHRoaXMudGFncyA9IHsgLy9BbiBvYmplY3QgdG8gaG9sZCB0YWdzLCB0aGVpciBwb3NpdGlvbiwgYW5kIHRoZWlyIHBhcmVudC10YWdzLCBpbml0aWF0ZWQgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgICAgIHBhcmVudDogJ3BhcmVudDEnLFxuICAgICAgICAgICAgICAgIHBhcmVudGNvdW50OiAxLFxuICAgICAgICAgICAgICAgIHBhcmVudDE6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy50b2tlbl90ZXh0ID0gdGhpcy5sYXN0X3Rva2VuID0gdGhpcy5sYXN0X3RleHQgPSB0aGlzLnRva2VuX3R5cGUgPSAnJztcbiAgICAgICAgICAgIHRoaXMubmV3bGluZXMgPSAwO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfY29udGVudCA9IGluZGVudF9pbm5lcl9odG1sO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRfYm9keV9pbm5lcl9odG1sID0gaW5kZW50X2JvZHlfaW5uZXJfaHRtbDtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCA9IGluZGVudF9oZWFkX2lubmVyX2h0bWw7XG5cbiAgICAgICAgICAgIHRoaXMuVXRpbHMgPSB7IC8vVWlsaXRpZXMgbWFkZSBhdmFpbGFibGUgdG8gdGhlIHZhcmlvdXMgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgd2hpdGVzcGFjZTogXCJcXG5cXHJcXHQgXCIuc3BsaXQoJycpLFxuXG4gICAgICAgICAgICAgICAgc2luZ2xlX3Rva2VuOiBbXG4gICAgICAgICAgICAgICAgLy8gSFRMTSB2b2lkIGVsZW1lbnRzIC0gYWthIHNlbGYtY2xvc2luZyB0YWdzIC0gYWthIHNpbmdsZXRvbnNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvc3ludGF4Lmh0bWwjdm9pZC1lbGVtZW50c1xuICAgICAgICAgICAgICAgICdhcmVhJywgJ2Jhc2UnLCAnYnInLCAnY29sJywgJ2VtYmVkJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdrZXlnZW4nLCAnbGluaycsICdtZW51aXRlbScsICdtZXRhJywgJ3BhcmFtJywgJ3NvdXJjZScsICd0cmFjaycsICd3YnInLFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IE9wdGlvbmFsIHRhZ3MgLSBhcmUgbm90IHVuZGVyc3Rvb2QuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3NcbiAgICAgICAgICAgICAgICAvLyBUaGUgcnVsZXMgZm9yIG9wdGlvbmFsIHRhZ3MgYXJlIHRvbyBjb21wbGV4IGZvciBhIHNpbXBsZSBsaXN0XG4gICAgICAgICAgICAgICAgLy8gQWxzbywgdGhlIGNvbnRlbnQgb2YgdGhlc2UgdGFncyBzaG91bGQgc3RpbGwgYmUgaW5kZW50ZWQgaW4gbWFueSBjYXNlcy5cbiAgICAgICAgICAgICAgICAvLyAnbGknIGlzIGEgZ29vZCBleG1wbGUuXG5cbiAgICAgICAgICAgICAgICAvLyBEb2N0eXBlIGFuZCB4bWwgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAnIWRvY3R5cGUnLCAnP3htbCcsXG4gICAgICAgICAgICAgICAgLy8gP3BocCB0YWdcbiAgICAgICAgICAgICAgICAnP3BocCcsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGFncyB0aGF0IHdlcmUgaW4gdGhpcyBsaXN0LCBrZWVwaW5nIGp1c3QgaW4gY2FzZVxuICAgICAgICAgICAgICAgICdiYXNlZm9udCcsICdpc2luZGV4J10sXG4gICAgICAgICAgICAgICAgZXh0cmFfbGluZXJzOiBleHRyYV9saW5lcnMsIC8vZm9yIHRhZ3MgdGhhdCBuZWVkIGEgbGluZSBvZiB3aGl0ZXNwYWNlIGJlZm9yZSB0aGVtXG4gICAgICAgICAgICAgICAgaW5fYXJyYXk6IGZ1bmN0aW9uICh3aGF0LCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aGF0ID09PSBhcnJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIHRleHQgaXMgY29tcG9zZWQgZW50aXJlbHkgb2Ygd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHRoaXMuaXNfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0ZXh0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5VdGlscy5pbl9hcnJheSh0ZXh0LmNoYXJBdChuKSwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLlV0aWxzLmluX2FycmF5KGlucHV0X2NoYXIsIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdsaW5lcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLlV0aWxzLmluX2FycmF5KGlucHV0X2NoYXIsIHRoaXMuVXRpbHMud2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZV9uZXdsaW5lcyAmJiBpbnB1dF9jaGFyID09PSAnXFxuJyAmJiB0aGlzLm5ld2xpbmVzIDw9IG1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3bGluZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEFwcGVuZCBhIHNwYWNlIHRvIHRoZSBnaXZlbiBjb250ZW50IChzdHJpbmcgYXJyYXkpIG9yLCBpZiB3ZSBhcmVcbiAgICAgICAgICAgIC8vIGF0IHRoZSB3cmFwX2xpbmVfbGVuZ3RoLCBhcHBlbmQgYSBuZXdsaW5lL2luZGVudGF0aW9uLlxuICAgICAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgYSBuZXdsaW5lIHdhcyBhZGRlZCwgZmFsc2UgaWYgYSBzcGFjZSB3YXMgYWRkZWRcbiAgICAgICAgICAgIHRoaXMuc3BhY2Vfb3Jfd3JhcCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZV9jaGFyX2NvdW50ID49IHRoaXMud3JhcF9saW5lX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvL2luc2VydCBhIGxpbmUgd2hlbiB0aGUgd3JhcF9saW5lX2xlbmd0aCBpcyByZWFjaGVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfaW5kZW50YXRpb24oY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCgnICcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRfY29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvL2Z1bmN0aW9uIHRvIGNhcHR1cmUgcmVndWxhciBjb250ZW50IGJldHdlZW4gdGFnc1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJycsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcykgIT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYXZlcnNlX3doaXRlc3BhY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFjZV9vcl93cmFwKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWJhcnMgcGFyc2luZyBpcyBjb21wbGljYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHt7I2Zvb319IGFuZCB7ey9mb299fSBhcmUgZm9ybWF0dGVkIHRhZ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7e3NvbWV0aGluZ319IHNob3VsZCBnZXQgdHJlYXRlZCBhcyBjb250ZW50LCBleGNlcHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7e2Vsc2V9fSBzcGVjaWZpY2FsbHkgYmVoYXZlcyBsaWtlIHt7I2lmfX0gYW5kIHt7L2lmfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZWVrMyA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWVrMyA9PT0gJ3t7IycgfHwgcGVlazMgPT09ICd7ey8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRhZ3MgYW5kIG5vdCBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZWVrMyA9PT0gJ3t7IScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2V0X3RhZygpLCAnVEtfVEFHX0hBTkRMRUJBUlNfQ09NTUVOVCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcywgMikgPT09ICd7eycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRfdGFnKHRydWUpID09PSAne3tlbHNlfX0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChpbnB1dF9jaGFyKTsgLy9sZXR0ZXIgYXQtYS10aW1lIChvciBzdHJpbmcpIGluc2VydGVkIHRvIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiAnJztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0X2NvbnRlbnRzX3RvID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgZnVsbCBjb250ZW50IG9mIGEgc2NyaXB0IG9yIHN0eWxlIHRvIHBhc3MgdG8ganNfYmVhdXRpZnlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICB2YXIgcmVnX21hdGNoID0gbmV3IFJlZ0V4cCgnPC8nICsgbmFtZSArICdcXFxccyo+JywgJ2lnbScpO1xuICAgICAgICAgICAgICAgIHJlZ19tYXRjaC5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgICAgICAgICAgICB2YXIgcmVnX2FycmF5ID0gcmVnX21hdGNoLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZF9zY3JpcHQgPSByZWdfYXJyYXkgPyByZWdfYXJyYXkuaW5kZXggOiB0aGlzLmlucHV0Lmxlbmd0aDsgLy9hYnNvbHV0ZSBlbmQgb2Ygc2NyaXB0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zIDwgZW5kX3NjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAvL2dldCBldmVyeXRoaW5nIGluIGJldHdlZW4gdGhlIHNjcmlwdCB0YWdzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmlucHV0LnN1YnN0cmluZyh0aGlzLnBvcywgZW5kX3NjcmlwdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gZW5kX3NjcmlwdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnJlY29yZF90YWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgLy9mdW5jdGlvbiB0byByZWNvcmQgYSB0YWcgYW5kIGl0cyBwYXJlbnQgaW4gdGhpcy50YWdzIE9iamVjdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXSA9IHRoaXMuaW5kZW50X2xldmVsOyAvL2FuZCByZWNvcmQgdGhlIHByZXNlbnQgaW5kZW50IGxldmVsXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgaW5pdGlhbGl6ZSB0aGlzIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnc1t0YWcgKyB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J11dID0gdGhpcy5pbmRlbnRfbGV2ZWw7IC8vYW5kIHJlY29yZCB0aGUgcHJlc2VudCBpbmRlbnQgbGV2ZWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSArICdwYXJlbnQnXSA9IHRoaXMudGFncy5wYXJlbnQ7IC8vc2V0IHRoZSBwYXJlbnQgKGkuZS4gaW4gdGhlIGNhc2Ugb2YgYSBkaXYgdGhpcy50YWdzLmRpdjFwYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnBhcmVudCA9IHRhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXTsgLy9hbmQgbWFrZSB0aGlzIHRoZSBjdXJyZW50IHBhcmVudCAoaS5lLiBpbiB0aGUgY2FzZSBvZiBhIGRpdiAnZGl2MScpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnJldHJpZXZlX3RhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICAvL2Z1bmN0aW9uIHRvIHJldHJpZXZlIHRoZSBvcGVuaW5nIHRhZyB0byB0aGUgY29ycmVzcG9uZGluZyBjbG9zZXJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50YWdzW3RhZyArICdjb3VudCddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIG9wZW5lbmVyIGlzIG5vdCBpbiB0aGUgT2JqZWN0IHdlIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcF9wYXJlbnQgPSB0aGlzLnRhZ3MucGFyZW50OyAvL2NoZWNrIHRvIHNlZSBpZiBpdCdzIGEgY2xvc2FibGUgdGFnLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGlsbCB3ZSByZWFjaCAnJyAodGhlIGluaXRpYWwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9PT0gdGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoaXMgaXMgaXQgdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wX3BhcmVudCA9IHRoaXMudGFnc1t0ZW1wX3BhcmVudCArICdwYXJlbnQnXTsgLy9vdGhlcndpc2Uga2VlcCBvbiBjbGltYmluZyB1cCB0aGUgRE9NIFRyZWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgd2UgY2F1Z2h0IHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXTsgLy9zZXQgdGhlIGluZGVudF9sZXZlbCBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLnBhcmVudCA9IHRoaXMudGFnc1t0ZW1wX3BhcmVudCArICdwYXJlbnQnXTsgLy9hbmQgc2V0IHRoZSBjdXJyZW50IHBhcmVudFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddICsgJ3BhcmVudCddOyAvL2RlbGV0ZSB0aGUgY2xvc2VkIHRhZ3MgcGFyZW50IHJlZmVyZW5jZS4uLlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50YWdzW3RhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXV07IC8vLi4uYW5kIHRoZSB0YWcgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbdGFnICsgJ2NvdW50J10tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuaW5kZW50X3RvX3RhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdGhlIGxhc3QgdXNlIG9mIHRoaXMgdGFnLCBidXQgZG9uJ3QgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50YWdzW3RhZyArICdjb3VudCddKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBfcGFyZW50ID0gdGhpcy50YWdzLnBhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyArIHRoaXMudGFnc1t0YWcgKyAnY291bnQnXSA9PT0gdGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXBfcGFyZW50ID0gdGhpcy50YWdzW3RlbXBfcGFyZW50ICsgJ3BhcmVudCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGVtcF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLnRhZ3NbdGFnICsgdGhpcy50YWdzW3RhZyArICdjb3VudCddXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmdldF90YWcgPSBmdW5jdGlvbiAocGVlaykge1xuICAgICAgICAgICAgICAgIC8vZnVuY3Rpb24gdG8gZ2V0IGEgZnVsbCB0YWcgYW5kIHBhcnNlIGl0cyB0eXBlXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gJycsXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2F0dHIgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0YWdfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHRhZ19lbmQsXG4gICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydF9jaGFyLFxuICAgICAgICAgICAgICAgICAgICBvcmlnX3BvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICBvcmlnX2xpbmVfY2hhcl9jb3VudCA9IHRoaXMubGluZV9jaGFyX2NvdW50O1xuXG4gICAgICAgICAgICAgICAgcGVlayA9IHBlZWsgIT09IHVuZGVmaW5lZCA/IHBlZWsgOiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVlaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gb3JpZ19wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSBvcmlnX2xpbmVfY2hhcl9jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA/IGNvbnRlbnQuam9pbignJykgOiBbJycsICdUS19FT0YnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuVXRpbHMuaW5fYXJyYXkoaW5wdXRfY2hhciwgdGhpcy5VdGlscy53aGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kb24ndCB3YW50IHRvIGluc2VydCB1bm5lY2Vzc2FyeSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gXCInXCIgfHwgaW5wdXRfY2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfY2hhciArPSB0aGlzLmdldF91bmZvcm1hdHRlZChpbnB1dF9jaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm8gc3BhY2UgYmVmb3JlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdICE9PSAnPScgJiYgaW5wdXRfY2hhciAhPT0gJz4nICYmIHNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL25vIHNwYWNlIGFmdGVyID0gb3IgYmVmb3JlID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkID0gdGhpcy5zcGFjZV9vcl93cmFwKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGVudEF0dHJzID0gd3JhcHBlZCAmJiBpbnB1dF9jaGFyICE9PSAnLycgJiYgd3JhcF9hdHRyaWJ1dGVzICE9PSAnZm9yY2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlyc3RfYXR0ciAmJiB3cmFwX2F0dHJpYnV0ZXMgPT09ICdmb3JjZScgJiYgaW5wdXRfY2hhciAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudEF0dHJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRlbnRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaW5kZW50IGF0dHJpYnV0ZXMgYW4gYXV0byBvciBmb3JjZWQgbGluZS13cmFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY291bnQgPSAwOyBjb3VudCA8IHdyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZTsgY291bnQrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goaW5kZW50X2NoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbaV0gPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9hdHRyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRlbnRfaGFuZGxlYmFycyAmJiB0YWdfc3RhcnRfY2hhciA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGluc2lkZSBhbiBhbmdsZS1icmFja2V0IHRhZywgcHV0IHNwYWNlcyBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZWJhcnMgbm90IGluc2lkZSBvZiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgKyB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcykgPT09ICd7eycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyICs9IHRoaXMuZ2V0X3VuZm9ybWF0dGVkKCd9fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gIT09ICcgJyAmJiBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gIT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gJyAnICsgaW5wdXRfY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0X2NoYXIgPT09ICc8JyAmJiAhdGFnX3N0YXJ0X2NoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydCA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydF9jaGFyID0gJzwnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmICF0YWdfc3RhcnRfY2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID49IDIgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID09PSAneycgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDJdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRfY2hhciA9PT0gJyMnIHx8IGlucHV0X2NoYXIgPT09ICcvJyB8fCBpbnB1dF9jaGFyID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0ID0gdGhpcy5wb3MgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19zdGFydCA9IHRoaXMucG9zIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnX3N0YXJ0X2NoYXIgPSAneyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goaW5wdXRfY2hhcik7IC8vaW5zZXJ0cyBjaGFyYWN0ZXIgYXQtYS10aW1lIChvciBzdHJpbmcpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMV0gJiYgKGNvbnRlbnRbMV0gPT09ICchJyB8fCBjb250ZW50WzFdID09PSAnPycgfHwgY29udGVudFsxXSA9PT0gJyUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSdyZSBpbiBhIGNvbW1lbnQsIGRvIHNvbWV0aGluZyBzcGVjaWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB0cmVhdCBhbGwgY29tbWVudHMgYXMgbGl0ZXJhbHMsIGV2ZW4gbW9yZSB0aGFuIHByZWZvcm1hdHRlZCB0YWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zZSB0YWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbdGhpcy5nZXRfY29tbWVudCh0YWdfc3RhcnQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIGNvbnRlbnRbMV0gJiYgY29udGVudFsxXSA9PT0gJ3snICYmIGNvbnRlbnRbMl0gJiYgY29udGVudFsyXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlJ3JlIGluIGEgY29tbWVudCwgZG8gc29tZXRoaW5nIHNwZWNpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGp1c3QgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NlIHRhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFt0aGlzLmdldF9jb21tZW50KHRhZ19zdGFydCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgdGFnX3N0YXJ0X2NoYXIgPT09ICd7JyAmJiBjb250ZW50Lmxlbmd0aCA+IDIgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDJdID09PSAnfScgJiYgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaW5wdXRfY2hhciAhPT0gJz4nKTtcblxuICAgICAgICAgICAgICAgIHZhciB0YWdfY29tcGxldGUgPSBjb250ZW50LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHZhciB0YWdfaW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIHRhZ19vZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFnX2NvbXBsZXRlLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIHdoaXRlc3BhY2UsIHRoYXRzIHdoZXJlIHRoZSB0YWcgbmFtZSBlbmRzXG4gICAgICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCcgJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdfY29tcGxldGUuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnX2luZGV4ID0gdGFnX2NvbXBsZXRlLmluZGV4T2YoJ30nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBnbyB3aXRoIHRoZSB0YWcgZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHRhZ19pbmRleCA9IHRhZ19jb21wbGV0ZS5pbmRleE9mKCc+Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWdfY29tcGxldGUuY2hhckF0KDApID09PSAnPCcgfHwgIWluZGVudF9oYW5kbGViYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ19vZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ19vZmZzZXQgPSB0YWdfY29tcGxldGUuY2hhckF0KDIpID09PSAnIycgPyAzIDogMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhZ19jaGVjayA9IHRhZ19jb21wbGV0ZS5zdWJzdHJpbmcodGFnX29mZnNldCwgdGFnX2luZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0YWdfY29tcGxldGUuY2hhckF0KHRhZ19jb21wbGV0ZS5sZW5ndGggLSAyKSA9PT0gJy8nIHx8IHRoaXMuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrLCB0aGlzLlV0aWxzLnNpbmdsZV90b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGlzIHRhZyBuYW1lIGlzIGEgc2luZ2xlIHRhZyB0eXBlIChlaXRoZXIgaW4gdGhlIGxpc3Qgb3IgaGFzIGEgY2xvc2luZyAvKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBlZWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0lOR0xFJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZW50X2hhbmRsZWJhcnMgJiYgdGFnX2NvbXBsZXRlLmNoYXJBdCgwKSA9PT0gJ3snICYmIHRhZ19jaGVjayA9PT0gJ2Vsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfdG9fdGFnKCdpZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdIQU5ETEVCQVJTX0VMU0UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfY29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYXZlcnNlX3doaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc191bmZvcm1hdHRlZCh0YWdfY2hlY2ssIHVuZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgcmVmb3JtYXQgdGhlIFwidW5mb3JtYXR0ZWRcIiB0YWdzXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSB0aGlzLmdldF91bmZvcm1hdHRlZCgnPC8nICsgdGFnX2NoZWNrICsgJz4nLCB0YWdfY29tcGxldGUpOyAvLy4uLmRlbGVnYXRlIHRvIGdldF91bmZvcm1hdHRlZCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRhZ19lbmQgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU0lOR0xFJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3NjcmlwdCcgJiYgKHRhZ19jb21wbGV0ZS5zZWFyY2goJ3R5cGUnKSA9PT0gLTEgfHwgdGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID4gLTEgJiYgdGFnX2NvbXBsZXRlLnNlYXJjaCgvXFxiKHRleHR8YXBwbGljYXRpb258ZG9qbylcXC8oeC0pPyhqYXZhc2NyaXB0fGVjbWFzY3JpcHR8anNjcmlwdHxsaXZlc2NyaXB0fChsZFxcKyk/anNvbnxtZXRob2R8YXNwZWN0KS8pID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRfdGFnKHRhZ19jaGVjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NDUklQVCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZ19jaGVjayA9PT0gJ3N0eWxlJyAmJiAodGFnX2NvbXBsZXRlLnNlYXJjaCgndHlwZScpID09PSAtMSB8fCB0YWdfY29tcGxldGUuc2VhcmNoKCd0eXBlJykgPiAtMSAmJiB0YWdfY29tcGxldGUuc2VhcmNoKCd0ZXh0L2NzcycpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRfdGFnKHRhZ19jaGVjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ190eXBlID0gJ1NUWUxFJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnX2NoZWNrLmNoYXJBdCgwKSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcGVlayBmb3IgPCEgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY29tbWVudHMgY29udGVudCBpcyBhbHJlYWR5IGNvcnJlY3QuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGVlaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdfdHlwZSA9ICdTSU5HTEUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmF2ZXJzZV93aGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdfY2hlY2suY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyB0YWcgaXMgYSBkb3VibGUgdGFnIHNvIGNoZWNrIGZvciB0YWctZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHJpZXZlX3RhZyh0YWdfY2hlY2suc3Vic3RyaW5nKDEpKTsgLy9yZW1vdmUgaXQgYW5kIGFsbCBhbmNlc3RvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnRU5EJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGl0J3MgYSBzdGFydC10YWdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkX3RhZyh0YWdfY2hlY2spOyAvL3B1c2ggaXQgb24gdGhlIHRhZyBzdGFja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19jaGVjay50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9jb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFnX3R5cGUgPSAnU1RBUlQnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgcHJlc2VydmluZyBvZiBuZXdsaW5lcyBhZnRlciBhIHN0YXJ0IG9yIGVuZCB0YWdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhdmVyc2Vfd2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlX29yX3dyYXAoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheSh0YWdfY2hlY2ssIHRoaXMuVXRpbHMuZXh0cmFfbGluZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiB0aGlzIGRvdWJsZSBuZWVkcyBhbiBleHRyYSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggJiYgdGhpcy5vdXRwdXRbdGhpcy5vdXRwdXQubGVuZ3RoIC0gMl0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKHRydWUsIHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwZWVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gb3JpZ19wb3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gb3JpZ19saW5lX2NoYXJfY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQuam9pbignJyk7IC8vcmV0dXJucyBmdWxseSBmb3JtYXR0ZWQgdGFnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmdldF9jb21tZW50ID0gZnVuY3Rpb24gKHN0YXJ0X3Bvcykge1xuICAgICAgICAgICAgICAgIC8vZnVuY3Rpb24gdG8gcmV0dXJuIGNvbW1lbnQgY29udGVudCBpbiBpdHMgZW50aXJldHlcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHdpbGwgaGF2ZSB2ZXJ5IHBvb3IgcGVyZiwgYnV0IHdpbGwgd29yayBmb3Igbm93LlxuICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gJycsXG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICc+JyxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydF9wb3M7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0X2NoYXIgPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcblxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGlucHV0X2NoYXI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIGNoZWNrIGZvciB0aGUgZGVsaW1pdGVyIGlmIHRoZSBsYXN0IGNoYXJzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmNoYXJBdChjb21tZW50Lmxlbmd0aCAtIDEpID09PSBkZWxpbWl0ZXIuY2hhckF0KGRlbGltaXRlci5sZW5ndGggLSAxKSAmJiBjb21tZW50LmluZGV4T2YoZGVsaW1pdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBuZWVkIHRvIHNlYXJjaCBmb3IgY3VzdG9tIGRlbGltaXRlciBmb3IgdGhlIGZpcnN0IGZldyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCAmJiBjb21tZW50Lmxlbmd0aCA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5pbmRleE9mKCc8IVtpZicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wZWVrIGZvciA8IVtpZiBjb25kaXRpb25hbCBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJzwhW2VuZGlmXT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwhW2NkYXRhWycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGEgPFtjZGF0YVsgY29tbWVudC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICddXT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwhWycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBvdGhlciAhWyBjb21tZW50PyAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnXT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzwhLS0nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwhLS0gY29tbWVudCAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnLS0+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCd7eyEnKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHt7ISBoYW5kbGViYXJzIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSAnfX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tZW50LmluZGV4T2YoJzw/JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB7eyEgaGFuZGxlYmFycyBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJz8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWVudC5pbmRleE9mKCc8JScpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ge3shIGhhbmRsZWJhcnMgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICclPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbnB1dF9jaGFyID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdG9rZW5NYXRjaGVyKGRlbGltaXRlcikge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9ICcnO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Rva2VuID0gdG9rZW4gKyBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBuZXdUb2tlbi5sZW5ndGggPD0gZGVsaW1pdGVyLmxlbmd0aCA/IG5ld1Rva2VuIDogbmV3VG9rZW4uc3Vic3RyKG5ld1Rva2VuLmxlbmd0aCAtIGRlbGltaXRlci5sZW5ndGgsIGRlbGltaXRlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZG9lc05vdE1hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uaW5kZXhPZihkZWxpbWl0ZXIpID09PSAtMTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgICAgICAgICAgICAgIGRvZXNOb3RNYXRjaDogZG9lc05vdE1hdGNoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5nZXRfdW5mb3JtYXR0ZWQgPSBmdW5jdGlvbiAoZGVsaW1pdGVyLCBvcmlnX3RhZykge1xuICAgICAgICAgICAgICAgIC8vZnVuY3Rpb24gdG8gcmV0dXJuIHVuZm9ybWF0dGVkIGNvbnRlbnQgaW4gaXRzIGVudGlyZXR5XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdfdGFnICYmIG9yaWdfdGFnLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihkZWxpbWl0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbnB1dF9jaGFyID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlbGltaXRlck1hdGNoZXIgPSB0b2tlbk1hdGNoZXIoZGVsaW1pdGVyKTtcblxuICAgICAgICAgICAgICAgIGRvIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfY2hhciA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5VdGlscy5pbl9hcnJheShpbnB1dF9jaGFyLCB0aGlzLlV0aWxzLndoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dF9jaGFyID09PSAnXFxuJyB8fCBpbnB1dF9jaGFyID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIERvbid0IGNoYW5nZSB0YWIgaW5kZW50aW9uIGZvciB1bmZvcm1hdHRlZCBibG9ja3MuICBJZiB1c2luZyBjb2RlIGZvciBodG1sIGVkaXRpbmcsIHRoaXMgd2lsbCBncmVhdGx5IGFmZmVjdCA8cHJlPiB0YWdzIGlmIHRoZXkgYXJlIHNwZWNpZmllZCBpbiB0aGUgJ3VuZm9ybWF0dGVkIGFycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmluZGVudF9sZXZlbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCArPSB0aGlzLmluZGVudF9zdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gZmFsc2U7IC8vLi4uYW5kIG1ha2Ugc3VyZSBvdGhlciBpbmRlbnRhdGlvbiBpcyBlcmFzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ICs9IGlucHV0X2NoYXI7XG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlck1hdGNoZXIuYWRkKGlucHV0X2NoYXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVfY2hhcl9jb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGVudF9oYW5kbGViYXJzICYmIGlucHV0X2NoYXIgPT09ICd7JyAmJiBjb250ZW50Lmxlbmd0aCAmJiBjb250ZW50LmNoYXJBdChjb250ZW50Lmxlbmd0aCAtIDIpID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWJhcnMgZXhwcmVzc2lvbnMgaW4gc3RyaW5ncyBzaG91bGQgYWxzbyBiZSB1bmZvcm1hdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5nZXRfdW5mb3JtYXR0ZWQoJ319Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25zaWRlciB3aGVuIHN0b3BwaW5nIGZvciBkZWxpbWl0ZXJzLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoZGVsaW1pdGVyTWF0Y2hlci5kb2VzTm90TWF0Y2goKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0X3Rva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vaW5pdGlhbCBoYW5kbGVyIGZvciB0b2tlbi1yZXRyaWV2YWxcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0X3Rva2VuID09PSAnVEtfVEFHX1NDUklQVCcgfHwgdGhpcy5sYXN0X3Rva2VuID09PSAnVEtfVEFHX1NUWUxFJykge1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHdlIG5lZWQgdG8gZm9ybWF0IGphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxhc3RfdG9rZW4uc3Vic3RyKDcpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X2NvbnRlbnRzX3RvKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdG9rZW4sICdUS18nICsgdHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRfbW9kZSA9PT0gJ0NPTlRFTlQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfY29udGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0b2tlbiwgJ1RLX0NPTlRFTlQnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRfbW9kZSA9PT0gJ1RBRycpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90YWcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWdfbmFtZV90eXBlID0gJ1RLX1RBR18nICsgdGhpcy50YWdfdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdG9rZW4sIHRhZ19uYW1lX3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRfZnVsbF9pbmRlbnQgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMuaW5kZW50X2xldmVsICsgbGV2ZWwgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKHRoaXMuaW5kZW50X3N0cmluZyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmlzX3VuZm9ybWF0dGVkID0gZnVuY3Rpb24gKHRhZ19jaGVjaywgdW5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgICAgICAvL2lzIHRoaXMgYW4gSFRNTDUgYmxvY2stbGV2ZWwgbGluaz9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWdfY2hlY2sudG9Mb3dlckNhc2UoKSAhPT0gJ2EnIHx8ICF0aGlzLlV0aWxzLmluX2FycmF5KCdhJywgdW5mb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vYXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuICB0YWc7IGlzIGl0cyBmaXJzdCBjaGlsZCBzb21ldGhpbmcgd2Ugd2FudCB0byByZW1haW5cbiAgICAgICAgICAgICAgICAvL3VuZm9ybWF0dGVkP1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X3RhZyA9IHRoaXMuZ2V0X3RhZyh0cnVlIC8qIHBlZWsuICovKTtcblxuICAgICAgICAgICAgICAgIC8vIHRlc3QgbmV4dF90YWcgdG8gc2VlIGlmIGl0IGlzIGp1c3QgaHRtbCB0YWcgKG5vIGV4dGVybmFsIGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IChuZXh0X3RhZyB8fCBcIlwiKS5tYXRjaCgvXlxccyo8XFxzKlxcLz8oW2Etel0qKVxccypbXj5dKj5cXHMqJC8pO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgbmV4dF90YWcgY29tZXMgYmFjayBidXQgaXMgbm90IGFuIGlzb2xhdGVkIHRhZywgdGhlblxuICAgICAgICAgICAgICAgIC8vIGxldCdzIHRyZWF0IHRoZSAnYScgdGFnIGFzIGhhdmluZyBjb250ZW50XG4gICAgICAgICAgICAgICAgLy8gYW5kIHJlc3BlY3QgdGhlIHVuZm9ybWF0dGVkIG9wdGlvblxuICAgICAgICAgICAgICAgIGlmICghdGFnIHx8IHRoaXMuVXRpbHMuaW5fYXJyYXkodGFnLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucHJpbnRlciA9IGZ1bmN0aW9uIChqc19zb3VyY2UsIGluZGVudF9jaGFyYWN0ZXIsIGluZGVudF9zaXplLCB3cmFwX2xpbmVfbGVuZ3RoLCBicmFjZV9zdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vaGFuZGxlcyBpbnB1dC9vdXRwdXQgYW5kIHNvbWUgb3RoZXIgcHJpbnRpbmcgZnVuY3Rpb25zXG5cbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0ID0ganNfc291cmNlIHx8ICcnOyAvL2dldHMgdGhlIGlucHV0IGZvciB0aGUgUGFyc2VyXG5cbiAgICAgICAgICAgICAgICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIGlucHV0LlxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmlucHV0LnJlcGxhY2UoL1xcclxcbnxbXFxyXFx1MjAyOFxcdTIwMjldL2csICdcXG4nKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfY2hhcmFjdGVyID0gaW5kZW50X2NoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9zdHJpbmcgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudF9zaXplID0gaW5kZW50X3NpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5icmFjZV9zdHlsZSA9IGJyYWNlX3N0eWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X2xldmVsID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB3cmFwX2xpbmVfbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZV9jaGFyX2NvdW50ID0gMDsgLy9jb3VudCB0byBzZWUgaWYgd3JhcF9saW5lX2xlbmd0aCB3YXMgZXhjZWVkZWRcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmRlbnRfc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50X3N0cmluZyArPSB0aGlzLmluZGVudF9jaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lID0gZnVuY3Rpb24gKGZvcmNlLCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyciB8fCAhYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSB8fCBhcnJbYXJyLmxlbmd0aCAtIDFdICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBtaWdodCB3YW50IHRoZSBleHRyYSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2Fyci5sZW5ndGggLSAxXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aCAtIDFdID0gcnRyaW0oYXJyW2Fyci5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludF9pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGVudF9sZXZlbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLmluZGVudF9zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX2NoYXJfY291bnQgKz0gdGhpcy5pbmRlbnRfc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnByaW50X3Rva2VuID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcHJpbnRpbmcgaW5pdGlhbCB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc193aGl0ZXNwYWNlKHRleHQpICYmICF0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCB8fCB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAmJiB0aGlzLm91dHB1dFt0aGlzLm91dHB1dC5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50X2luZGVudGF0aW9uKHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbHRyaW0odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludF90b2tlbl9yYXcodGV4dCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfdG9rZW5fcmF3ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGdvaW5nIHRvIHByaW50IG5ld2xpbmVzLCB0cnVuY2F0ZSB0cmFpbGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGl0ZXNwYWNlLCBhcyB0aGUgbmV3bGluZXMgd2lsbCByZXByZXNlbnQgdGhlIHNwYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXdsaW5lcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBydHJpbSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ICYmIHRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAxICYmIHRleHQuY2hhckF0KHRleHQubGVuZ3RoIC0gMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5mb3JtYXR0ZWQgdGFncyBjYW4gZ3JhYiBuZXdsaW5lcyBhcyB0aGVpciBsYXN0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0LnB1c2godGV4dC5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dC5wdXNoKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLm5ld2xpbmVzOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShuID4gMCwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3bGluZXMgPSAwO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwrKztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy51bmluZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZW50X2xldmVsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRfbGV2ZWwtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKl9fX19fX19fX19fX19fX19fX19fXy0tLS0tLS0tLS0tLS0tLS0tLS0tX19fX19fX19fX19fX19fX19fX19fKi9cblxuICAgICAgICBtdWx0aV9wYXJzZXIgPSBuZXcgUGFyc2VyKCk7IC8vd3JhcHBpbmcgZnVuY3Rpb25zIFBhcnNlclxuICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRlcihodG1sX3NvdXJjZSwgaW5kZW50X2NoYXJhY3RlciwgaW5kZW50X3NpemUsIHdyYXBfbGluZV9sZW5ndGgsIGJyYWNlX3N0eWxlKTsgLy9pbml0aWFsaXplIHN0YXJ0aW5nIHZhbHVlc1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IG11bHRpX3BhcnNlci5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgIG11bHRpX3BhcnNlci50b2tlbl90ZXh0ID0gdFswXTtcbiAgICAgICAgICAgIG11bHRpX3BhcnNlci50b2tlbl90eXBlID0gdFsxXTtcblxuICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci50b2tlbl90eXBlID09PSAnVEtfRU9GJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKG11bHRpX3BhcnNlci50b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX1NUQVJUJzpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X25ld2xpbmUoZmFsc2UsIG11bHRpX3BhcnNlci5vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG11bHRpX3BhcnNlci5pbmRlbnRfYm9keV9pbm5lcl9odG1sIHx8ICFtdWx0aV9wYXJzZXIudG9rZW5fdGV4dC5tYXRjaCgvPGJvZHkoPzouKik+LykpICYmIChtdWx0aV9wYXJzZXIuaW5kZW50X2hlYWRfaW5uZXJfaHRtbCB8fCAhbXVsdGlfcGFyc2VyLnRva2VuX3RleHQubWF0Y2goLzxoZWFkKD86LiopPi8pKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuaW5kZW50X2NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfU1RZTEUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19TQ1JJUFQnOlxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnQ09OVEVOVCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1RBR19FTkQnOlxuICAgICAgICAgICAgICAgICAgICAvL1ByaW50IG5ldyBsaW5lIG9ubHkgaWYgdGhlIHRhZyBoYXMgbm8gY29udGVudCBhbmQgaGFzIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIubGFzdF90b2tlbiA9PT0gJ1RLX0NPTlRFTlQnICYmIG11bHRpX3BhcnNlci5sYXN0X3RleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX25hbWUgPSAobXVsdGlfcGFyc2VyLnRva2VuX3RleHQubWF0Y2goL1xcdysvKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dCA9IG11bHRpX3BhcnNlci5vdXRwdXRbbXVsdGlfcGFyc2VyLm91dHB1dC5sZW5ndGggLSAxXS5tYXRjaCgvKD86PHx7eyMpXFxzKihcXHcrKS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ19leHRyYWN0ZWRfZnJvbV9sYXN0X291dHB1dCA9PT0gbnVsbCB8fCB0YWdfZXh0cmFjdGVkX2Zyb21fbGFzdF9vdXRwdXRbMV0gIT09IHRhZ19uYW1lICYmICFtdWx0aV9wYXJzZXIuVXRpbHMuaW5fYXJyYXkodGFnX2V4dHJhY3RlZF9mcm9tX2xhc3Rfb3V0cHV0WzFdLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX1NJTkdMRSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBhIG5ld2xpbmUgYmVmb3JlIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlbWFpbiB1bmZvcm1hdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ19jaGVjayA9IG11bHRpX3BhcnNlci50b2tlbl90ZXh0Lm1hdGNoKC9eXFxzKjwoW2Etei1dKykvaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFnX2NoZWNrIHx8ICFtdWx0aV9wYXJzZXIuVXRpbHMuaW5fYXJyYXkodGFnX2NoZWNrWzFdLCB1bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfdG9rZW4obXVsdGlfcGFyc2VyLnRva2VuX3RleHQpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ0NPTlRFTlQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUS19UQUdfSEFORExFQkFSU19FTFNFJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIGEgbmV3bGluZSBpZiBvcGVuaW5nIHt7I2lmfX0gdGFnIGlzIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kSWZPbkN1cnJlbnRMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxhc3RDaGVja2VkT3V0cHV0ID0gbXVsdGlfcGFyc2VyLm91dHB1dC5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLm91dHB1dFtsYXN0Q2hlY2tlZE91dHB1dF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIub3V0cHV0W2xhc3RDaGVja2VkT3V0cHV0XS5tYXRjaCgve3sjaWYvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZElmT25DdXJyZW50TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kSWZPbkN1cnJlbnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZShmYWxzZSwgbXVsdGlfcGFyc2VyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuKG11bHRpX3BhcnNlci50b2tlbl90ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpX3BhcnNlci5pbmRlbnRfY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmluZGVudF9jb250ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmN1cnJlbnRfbW9kZSA9ICdDT05URU5UJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfVEFHX0hBTkRMRUJBUlNfQ09NTUVOVCc6XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnVEFHJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfQ09OVEVOVCc6XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5jdXJyZW50X21vZGUgPSAnVEFHJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVEtfU1RZTEUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1RLX1NDUklQVCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF9uZXdsaW5lKGZhbHNlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbXVsdGlfcGFyc2VyLnRva2VuX3RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JlYXV0aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlfcGFyc2VyLnRva2VuX3R5cGUgPT09ICdUS19TQ1JJUFQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JlYXV0aWZpZXIgPSB0eXBlb2YganNfYmVhdXRpZnkgPT09ICdmdW5jdGlvbicgJiYganNfYmVhdXRpZnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG11bHRpX3BhcnNlci50b2tlbl90eXBlID09PSAnVEtfU1RZTEUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2JlYXV0aWZpZXIgPSB0eXBlb2YgY3NzX2JlYXV0aWZ5ID09PSAnZnVuY3Rpb24nICYmIGNzc19iZWF1dGlmeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwia2VlcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZW50X3NjcmlwdHMgPT09IFwic2VwYXJhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAtbXVsdGlfcGFyc2VyLmluZGVudF9sZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGVudGF0aW9uID0gbXVsdGlfcGFyc2VyLmdldF9mdWxsX2luZGVudChzY3JpcHRfaW5kZW50X2xldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYmVhdXRpZmllcikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0aGUgQmVhdXRpZmllciBpZiBhdmFsaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ2hpbGRfb3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lb2wgPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoaWxkX29wdGlvbnMucHJvdG90eXBlID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRfb3B0aW9ucyA9IG5ldyBDaGlsZF9vcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9iZWF1dGlmaWVyKHRleHQucmVwbGFjZSgvXlxccyovLCBpbmRlbnRhdGlvbiksIGNoaWxkX29wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbHkgaW5kZW50IHRoZSBzdHJpbmcgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdoaXRlID0gdGV4dC5tYXRjaCgvXlxccyovKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2xldmVsID0gd2hpdGUubWF0Y2goL1teXFxuXFxyXSokLylbMF0uc3BsaXQobXVsdGlfcGFyc2VyLmluZGVudF9zdHJpbmcpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlaW5kZW50ID0gbXVsdGlfcGFyc2VyLmdldF9mdWxsX2luZGVudChzY3JpcHRfaW5kZW50X2xldmVsIC0gX2xldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eXFxzKi8sIGluZGVudGF0aW9uKS5yZXBsYWNlKC9cXHJcXG58XFxyfFxcbi9nLCAnXFxuJyArIHJlaW5kZW50KS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlfcGFyc2VyLnByaW50X3Rva2VuX3Jhdyh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIucHJpbnRfbmV3bGluZSh0cnVlLCBtdWx0aV9wYXJzZXIub3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtdWx0aV9wYXJzZXIuY3VycmVudF9tb2RlID0gJ1RBRyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgYmUgZ2V0dGluZyBoZXJlIGJ1dCB3ZSBkb24ndCB3YW50IHRvIGRyb3AgaW5wdXQgb24gdGhlIGZsb29yXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3Qgb3V0cHV0IHRoZSB0ZXh0IGFuZCBtb3ZlIG9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpX3BhcnNlci5wcmludF90b2tlbihtdWx0aV9wYXJzZXIudG9rZW5fdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aV9wYXJzZXIubGFzdF90b2tlbiA9IG11bHRpX3BhcnNlci50b2tlbl90eXBlO1xuICAgICAgICAgICAgbXVsdGlfcGFyc2VyLmxhc3RfdGV4dCA9IG11bHRpX3BhcnNlci50b2tlbl90ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzd2VldF9jb2RlID0gbXVsdGlfcGFyc2VyLm91dHB1dC5qb2luKCcnKS5yZXBsYWNlKC9bXFxyXFxuXFx0IF0rJC8sICcnKTtcblxuICAgICAgICAvLyBlc3RhYmxpc2ggZW5kX3dpdGhfbmV3bGluZVxuICAgICAgICBpZiAoZW5kX3dpdGhfbmV3bGluZSkge1xuICAgICAgICAgICAgc3dlZXRfY29kZSArPSAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgICAgICAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN3ZWV0X2NvZGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcIi4vYmVhdXRpZnlcIiwgXCIuL2JlYXV0aWZ5LWNzc1wiXSwgZnVuY3Rpb24gKHJlcXVpcmVhbWQpIHtcbiAgICAgICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5XCIpO1xuICAgICAgICAgICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5LWNzc1wiKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sX2JlYXV0aWZ5OiBmdW5jdGlvbiAoaHRtbF9zb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUy4gSnVzdCBwdXQgdGhpcyBmaWxlIHNvbWV3aGVyZSBvbiB5b3VyIHJlcXVpcmUucGF0aHNcbiAgICAgICAgLy8gYW5kIHlvdSB3aWxsIGJlIGFibGUgdG8gYHZhciBodG1sX2JlYXV0aWZ5ID0gcmVxdWlyZShcImJlYXV0aWZ5XCIpLmh0bWxfYmVhdXRpZnlgLlxuICAgICAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LmpzJyk7XG4gICAgICAgIHZhciBjc3NfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LWNzcy5qcycpO1xuXG4gICAgICAgIGV4cG9ydHMuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uIChodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxuICAgICAgICB3aW5kb3cuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uIChodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIHdpbmRvdy5qc19iZWF1dGlmeSwgd2luZG93LmNzc19iZWF1dGlmeSk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGV2ZW4gaGF2ZSB3aW5kb3csIHRyeSBnbG9iYWwuXG4gICAgICAgIGdsb2JhbC5odG1sX2JlYXV0aWZ5ID0gZnVuY3Rpb24gKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgZ2xvYmFsLmpzX2JlYXV0aWZ5LCBnbG9iYWwuY3NzX2JlYXV0aWZ5KTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktaHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");
}});
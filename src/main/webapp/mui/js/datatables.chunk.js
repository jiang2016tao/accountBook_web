webpackJsonp([11],{115:function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(_) {!function (t, e) {\n  "use strict";\n  function i(t) {\n    function e(e) {\n      return i.identifier && e[i.identifier] === t[i.identifier];\n    }var i = this;return this.rows.contains(e) ? !1 : (this.rows.push(t), !0);\n  }function s(e) {\n    var i = this.footer ? this.footer.find(e) : t(),\n        s = this.header ? this.header.find(e) : t();return t.merge(i, s);\n  }function o(e) {\n    return e ? t.extend({}, this.cachedParams, { ctx: e }) : this.cachedParams;\n  }function n() {\n    var e = { current: this.current, rowCount: this.rowCount, sort: this.sortDictionary, searchPhrase: this.searchPhrase },\n        i = this.options.post;return i = t.isFunction(i) ? i() : i, this.options.requestHandler(t.extend(!0, e, i));\n  }function r(e) {\n    return "." + t.trim(e).replace(/\\s+/gm, ".");\n  }function l() {\n    var e = this.options.url;return t.isFunction(e) ? e() : e;\n  }function a() {\n    this.element.trigger("initialize" + j), d.call(this), this.selection = this.options.selection && null != this.identifier, p.call(this), g.call(this), R.call(this), k.call(this), v.call(this), u.call(this), this.element.trigger("initialized" + j);\n  }function c() {\n    this.options.highlightRows;\n  }function h(t) {\n    return t.visible;\n  }function d() {\n    var e = this,\n        i = this.element.find("thead > tr").first(),\n        s = !1;i.children().each(function () {\n      var i = t(this),\n          o = i.data(),\n          n = { id: o.columnId, identifier: null == e.identifier && o.identifier || !1, converter: e.options.converters[o.converter || o.type] || e.options.converters.string, text: i.text(), align: o.align || "left", headerAlign: o.headerAlign || "left", cssClass: o.cssClass || "", headerCssClass: o.headerCssClass || "", formatter: e.options.formatters[o.formatter] || null, order: s || "asc" !== o.order && "desc" !== o.order ? null : o.order, searchable: !(o.searchable === !1), sortable: !(o.sortable === !1), visible: !(o.visible === !1), visibleInSelection: !(o.visibleInSelection === !1), width: t.isNumeric(o.width) ? o.width + "px" : "string" == typeof o.width ? o.width : null };e.columns.push(n), null != n.order && (e.sortDictionary[n.id] = n.order), n.identifier && (e.identifier = n.id, e.converter = n.converter), e.options.multiSort || null === n.order || (s = !0);\n    });\n  }function u() {\n    function i(t) {\n      for (var e, i = new RegExp(o.searchPhrase, o.options.caseSensitive ? "g" : "gi"), s = 0; s < o.columns.length; s++) if (e = o.columns[s], e.searchable && e.visible && e.converter.to(t[e.id]).search(i) > -1) return !0;return !1;\n    }function s(t, e) {\n      o.currentRows = t, f.call(o, e), o.options.keepSelection || (o.selectedRows = []), D.call(o, t), b.call(o), y.call(o), o.element._bgBusyAria(!1).trigger("loaded" + j);\n    }var o = this;if (this.element._bgBusyAria(!0).trigger("load" + j), P.call(this), this.options.ajax) {\n      var r = n.call(this),\n          a = l.call(this);if (null == a || "string" != typeof a || 0 === a.length) throw new Error("Url setting must be a none empty string or a function that returns one.");this.xqr && this.xqr.abort();var c = { url: a, data: r, success: function (e) {\n          o.xqr = null, "string" == typeof e && (e = t.parseJSON(e)), e = o.options.responseHandler(e), o.current = e.current, s(e.rows, e.total);\n        }, error: function (t, e) {\n          o.xqr = null, "abort" !== e && (w.call(o), o.element._bgBusyAria(!1).trigger("loaded" + j));\n        } };c = t.extend(this.options.ajaxSettings, c), this.xqr = t.ajax(c);\n    } else {\n      var h = this.searchPhrase.length > 0 ? this.rows.where(i) : this.rows,\n          d = h.length;-1 !== this.rowCount && (h = h.page(this.current, this.rowCount)), e.setTimeout(function () {\n        s(h, d);\n      }, 10);\n    }\n  }function p() {\n    if (!this.options.ajax) {\n      var e = this,\n          s = this.element.find("tbody > tr");s.each(function () {\n        var s = t(this),\n            o = s.children("td"),\n            n = {};t.each(e.columns, function (t, e) {\n          n[e.id] = e.converter.from(o.eq(t).text());\n        }), i.call(e, n);\n      }), f.call(this, this.rows.length), B.call(this);\n    }\n  }function f(t) {\n    this.total = t, this.totalPages = -1 === this.rowCount ? 1 : Math.ceil(this.total / this.rowCount);\n  }function g() {\n    var e = this.options.templates,\n        i = this.element.parent().hasClass(this.options.css.responsiveTable) ? this.element.parent() : this.element;this.element.addClass(this.options.css.table), 0 === this.element.children("tbody").length && this.element.append(e.body), 1 & this.options.navigation && (this.header = t(e.header.resolve(o.call(this, { id: this.element._bgId() + "-header" }))), i.before(this.header)), 2 & this.options.navigation && (this.footer = t(e.footer.resolve(o.call(this, { id: this.element._bgId() + "-footer" }))), i.after(this.footer));\n  }function v() {\n    if (0 !== this.options.navigation) {\n      var e = this.options.css,\n          i = r(e.actions),\n          n = s.call(this, i);if (n.length > 0) {\n        var l = this,\n            a = this.options.templates,\n            c = t(a.actions.resolve(o.call(this)));if (this.options.ajax) {\n          var h = a.icon.resolve(o.call(this, { iconCss: e.iconRefresh })),\n              d = t(a.actionButton.resolve(o.call(this, { content: h, text: this.options.labels.refresh }))).on("click" + j, function (t) {\n            t.stopPropagation(), l.current = 1, u.call(l);\n          });c.append(d);\n        }C.call(this, c), m.call(this, c), I.call(this, n, c);\n      }\n    }\n  }function m(e) {\n    if (this.options.columnSelection && this.columns.length > 1) {\n      var i = this,\n          s = this.options.css,\n          n = this.options.templates,\n          l = n.icon.resolve(o.call(this, { iconCss: s.iconColumns })),\n          a = t(n.actionDropDown.resolve(o.call(this, { content: l }))),\n          c = r(s.dropDownItem),\n          d = r(s.dropDownItemCheckbox),\n          p = r(s.dropDownMenuItems);t.each(this.columns, function (e, l) {\n        if (l.visibleInSelection) {\n          var f = t(n.actionDropDownCheckboxItem.resolve(o.call(i, { name: l.id, label: l.text, checked: l.visible }))).on("click" + j, c, function (e) {\n            e.stopPropagation();var s = t(this),\n                o = s.find(d);if (!o.prop("disabled")) {\n              l.visible = o.prop("checked");var n = i.columns.where(h).length > 1;s.parents(p).find(c + ":has(" + d + ":checked)")._bgEnableAria(n).find(d)._bgEnableField(n), i.element.find("tbody").empty(), R.call(i), u.call(i);\n            }\n          });a.find(r(s.dropDownMenuItems)).append(f);\n        }\n      }), e.append(a);\n    }\n  }function b() {\n    if (0 !== this.options.navigation) {\n      var e = r(this.options.css.infos),\n          i = s.call(this, e);if (i.length > 0) {\n        var n = this.current * this.rowCount,\n            l = t(this.options.templates.infos.resolve(o.call(this, { end: 0 === this.total || -1 === n || n > this.total ? this.total : n, start: 0 === this.total ? 0 : n - this.rowCount + 1, total: this.total })));I.call(this, i, l);\n      }\n    }\n  }function w() {\n    var t = this.element.children("tbody").first(),\n        e = this.options.templates,\n        i = this.columns.where(h).length;this.selection && (i += 1), t.html(e.noResults.resolve(o.call(this, { columns: i })));\n  }function y() {\n    if (0 !== this.options.navigation) {\n      var e = r(this.options.css.pagination),\n          i = s.call(this, e)._bgShowAria(-1 !== this.rowCount);if (-1 !== this.rowCount && i.length > 0) {\n        var n = this.options.templates,\n            l = this.current,\n            a = this.totalPages,\n            c = t(n.pagination.resolve(o.call(this))),\n            h = a - l,\n            d = -1 * (this.options.padding - l),\n            u = h >= this.options.padding ? Math.max(d, 1) : Math.max(d - this.options.padding + h, 1),\n            p = 2 * this.options.padding + 1,\n            f = a >= p ? p : a;x.call(this, c, "first", "<i class=\'zmdi zmdi-more-horiz\'></i>", "first")._bgEnableAria(l > 1), x.call(this, c, "prev", "<i class=\'zmdi zmdi-chevron-left\'></i>", "prev")._bgEnableAria(l > 1);for (var g = 0; f > g; g++) {\n          var v = g + u;x.call(this, c, v, v, "page-" + v)._bgEnableAria()._bgSelectAria(v === l);\n        }0 === f && x.call(this, c, 1, 1, "page-1")._bgEnableAria(!1)._bgSelectAria(), x.call(this, c, "next", "<i class=\'zmdi zmdi-chevron-right\'></i>", "next")._bgEnableAria(a > l), x.call(this, c, "last", "<i class=\'zmdi zmdi-more-horiz\'></i>", "last")._bgEnableAria(a > l), I.call(this, i, c);\n      }\n    }\n  }function x(e, i, s, n) {\n    var l = this,\n        a = this.options.templates,\n        c = this.options.css,\n        h = o.call(this, { css: n, text: s, page: i }),\n        d = t(a.paginationItem.resolve(h)).on("click" + j, r(c.paginationButton), function (e) {\n      e.stopPropagation(), e.preventDefault();var i = t(this),\n          s = i.parent();if (!s.hasClass("active") && !s.hasClass("disabled")) {\n        var o = { first: 1, prev: l.current - 1, next: l.current + 1, last: l.totalPages },\n            n = i.data("page");l.current = o[n] || n, u.call(l);\n      }i.trigger("blur");\n    });return e.append(d), d;\n  }function C(e) {\n    function i(t) {\n      return -1 === t ? s.options.labels.all : t;\n    }var s = this,\n        n = this.options.rowCount;if (t.isArray(n)) {\n      var l = this.options.css,\n          a = this.options.templates,\n          c = t(a.actionDropDown.resolve(o.call(this, { content: i(this.rowCount) }))),\n          h = r(l.dropDownMenu),\n          d = r(l.dropDownMenuText),\n          p = r(l.dropDownMenuItems),\n          f = r(l.dropDownItemButton);t.each(n, function (e, n) {\n        var r = t(a.actionDropDownItem.resolve(o.call(s, { text: i(n), action: n })))._bgSelectAria(n === s.rowCount).on("click" + j, f, function (e) {\n          e.preventDefault();var o = t(this),\n              n = o.data("action");n !== s.rowCount && (s.current = 1, s.rowCount = n, o.parents(p).children().each(function () {\n            var e = t(this),\n                i = e.find(f).data("action");e._bgSelectAria(i === n);\n          }), o.parents(h).find(d).text(i(n)), u.call(s));\n        });c.find(p).append(r);\n      }), e.append(c);\n    }\n  }function D(e) {\n    if (e.length > 0) {\n      var i = this,\n          s = this.options.css,\n          n = this.options.templates,\n          l = this.element.children("tbody").first(),\n          a = !0,\n          c = "";t.each(e, function (e, r) {\n        var l = "",\n            h = \' data-row-id="\' + (null == i.identifier ? e : r[i.identifier]) + \'"\',\n            d = "";if (i.selection) {\n          var u = -1 !== t.inArray(r[i.identifier], i.selectedRows),\n              p = n.select.resolve(o.call(i, { type: "checkbox", value: r[i.identifier], checked: u }));l += n.cell.resolve(o.call(i, { content: p, css: s.selectCell })), a = a && u, u && (d += s.selected, h += \' aria-selected="true"\');\n        }var f = null != r.status && i.options.statusMapping[r.status];f && (d += f), t.each(i.columns, function (e, a) {\n          if (a.visible) {\n            var c = t.isFunction(a.formatter) ? a.formatter.call(i, a, r) : a.converter.to(r[a.id]),\n                h = a.cssClass.length > 0 ? " " + a.cssClass : "";l += n.cell.resolve(o.call(i, { content: null == c || "" === c ? "&nbsp;" : c, css: ("right" === a.align ? s.right : "center" === a.align ? s.center : s.left) + h, style: null == a.width ? "" : "width:" + a.width + ";" }));\n          }\n        }), d.length > 0 && (h += \' class="\' + d + \'"\'), c += n.row.resolve(o.call(i, { attr: h, cells: l }));\n      }), i.element.find("thead " + r(i.options.css.selectBox)).prop("checked", a), l.html(c), A.call(this, l);\n    } else w.call(this);\n  }function A(e) {\n    var i = this,\n        s = r(this.options.css.selectBox);this.selection && e.off("click" + j, s).on("click" + j, s, function (e) {\n      e.stopPropagation();var s = t(this),\n          o = i.converter.from(s.val());s.prop("checked") ? i.select([o]) : i.deselect([o]);\n    }), e.off("click" + j, "> tr").on("click" + j, "> tr", function (e) {\n      e.stopPropagation();var s = t(this),\n          o = null == i.identifier ? s.data("row-id") : i.converter.from(s.data("row-id") + ""),\n          n = null == i.identifier ? i.currentRows[o] : i.currentRows.first(function (t) {\n        return t[i.identifier] === o;\n      });i.selection && i.options.rowSelect && (s.hasClass(i.options.css.selected) ? i.deselect([o]) : i.select([o])), i.element.trigger("click" + j, [i.columns, n]);\n    });\n  }function k() {\n    if (0 !== this.options.navigation) {\n      var i = this.options.css,\n          n = r(i.search),\n          l = s.call(this, n);if (l.length > 0) {\n        var a = this,\n            c = this.options.templates,\n            h = null,\n            d = "",\n            u = r(i.searchField),\n            p = t(c.search.resolve(o.call(this))),\n            f = p.is(u) ? p : p.find(u);f.on("keyup" + j, function (i) {\n          i.stopPropagation();var s = t(this).val();(d !== s || 13 === i.which && "" !== s) && (d = s, (13 === i.which || 0 === s.length || s.length >= a.options.searchSettings.characters) && (e.clearTimeout(h), h = e.setTimeout(function () {\n            S.call(a, s);\n          }, a.options.searchSettings.delay)));\n        }), I.call(this, l, p);\n      }\n    }\n  }function S(t) {\n    this.searchPhrase !== t && (this.current = 1, this.searchPhrase = t, u.call(this));\n  }function R() {\n    var e = this,\n        i = this.element.find("thead > tr"),\n        s = this.options.css,\n        n = this.options.templates,\n        l = "",\n        a = this.options.sorting;if (this.selection) {\n      var c = this.options.multiSelect ? n.select.resolve(o.call(e, { type: "checkbox", value: "all" })) : "";l += n.rawHeaderCell.resolve(o.call(e, { content: c, css: s.selectCell }));\n    }if (t.each(this.columns, function (t, i) {\n      if (i.visible) {\n        var r = e.sortDictionary[i.id],\n            c = a && r && "asc" === r ? s.iconUp : a && r && "desc" === r ? s.iconDown : "",\n            h = n.icon.resolve(o.call(e, { iconCss: c })),\n            d = i.headerAlign,\n            u = i.headerCssClass.length > 0 ? " " + i.headerCssClass : "";l += n.headerCell.resolve(o.call(e, { column: i, icon: h, sortable: a && i.sortable && s.sortable || "", css: ("right" === d ? s.right : "center" === d ? s.center : s.left) + u, style: null == i.width ? "" : "width:" + i.width + ";" }));\n      }\n    }), i.html(l), a) {\n      var h = r(s.sortable);i.off("click" + j, h).on("click" + j, h, function (i) {\n        i.preventDefault(), _.call(e, t(this)), B.call(e), u.call(e);\n      });\n    }if (this.selection && this.options.multiSelect) {\n      var d = r(s.selectBox);i.off("click" + j, d).on("click" + j, d, function (i) {\n        i.stopPropagation(), t(this).prop("checked") ? e.select() : e.deselect();\n      });\n    }\n  }function _(t) {\n    var e = this.options.css,\n        i = r(e.icon),\n        s = t.data("column-id") || t.parents("th").first().data("column-id"),\n        o = this.sortDictionary[s],\n        n = t.find(i);if (this.options.multiSort || (t.parents("tr").first().find(i).removeClass(e.iconDown + " " + e.iconUp), this.sortDictionary = {}), o && "asc" === o) this.sortDictionary[s] = "desc", n.removeClass(e.iconUp).addClass(e.iconDown);else if (o && "desc" === o) {\n      if (this.options.multiSort) {\n        var l = {};for (var a in this.sortDictionary) a !== s && (l[a] = this.sortDictionary[a]);this.sortDictionary = l, n.removeClass(e.iconDown);\n      } else this.sortDictionary[s] = "asc", n.removeClass(e.iconDown).addClass(e.iconUp);\n    } else this.sortDictionary[s] = "asc", n.addClass(e.iconUp);\n  }function I(e, i) {\n    e.each(function (e, s) {\n      t(s).before(i.clone(!0)).remove();\n    });\n  }function P() {\n    var t = this;e.setTimeout(function () {\n      if ("true" === t.element._bgAria("busy")) {\n        var e = t.options.templates,\n            i = t.element.children("thead").first(),\n            s = t.element.children("tbody").first(),\n            n = s.find("tr > td").first(),\n            r = t.element.height() - i.height() - (n.height() + 20),\n            l = t.columns.where(h).length;t.selection && (l += 1), s.html(e.loading.resolve(o.call(t, { columns: l }))), -1 !== t.rowCount && r > 0 && s.find("tr > td").css("padding", "20px 0 " + r + "px");\n      }\n    }, 250);\n  }function B() {\n    function t(i, s, o) {\n      function n(t) {\n        return "asc" === l.order ? t : -1 * t;\n      }o = o || 0;var r = o + 1,\n          l = e[o];return i[l.id] > s[l.id] ? n(1) : i[l.id] < s[l.id] ? n(-1) : e.length > r ? t(i, s, r) : 0;\n    }var e = [];if (!this.options.ajax) {\n      for (var i in this.sortDictionary) (this.options.multiSort || 0 === e.length) && e.push({ id: i, order: this.sortDictionary[i] });e.length > 0 && this.rows.sort(t);\n    }\n  }var j = ".rs.jquery.bootgrid",\n      M = function (e, i) {\n    this.element = t(e), this.origin = this.element.clone(), this.options = t.extend(!0, {}, M.defaults, this.element.data(), i);var s = this.options.rowCount = this.element.data().rowCount || i.rowCount || this.options.rowCount;this.columns = [], this.current = 1, this.currentRows = [], this.identifier = null, this.selection = !1, this.converter = null, this.rowCount = t.isArray(s) ? s[0] : s, this.rows = [], this.searchPhrase = "", this.selectedRows = [], this.sortDictionary = {}, this.total = 0, this.totalPages = 0, this.cachedParams = { lbl: this.options.labels, css: this.options.css, ctx: {} }, this.header = null, this.footer = null, this.xqr = null;\n  };if (M.defaults = { navigation: 3, padding: 2, columnSelection: !0, rowCount: [10, 25, 50, -1], selection: !1, multiSelect: !1, rowSelect: !1, keepSelection: !1, highlightRows: !1, sorting: !0, multiSort: !1, searchSettings: { delay: 250, characters: 1 }, ajax: !1, ajaxSettings: { method: "POST" }, post: {}, url: "", caseSensitive: !0, requestHandler: function (t) {\n      return t;\n    }, responseHandler: function (t) {\n      return t;\n    }, converters: { numeric: { from: function (t) {\n          return +t;\n        }, to: function (t) {\n          return t + "";\n        } }, string: { from: function (t) {\n          return t;\n        }, to: function (t) {\n          return t;\n        } } }, css: { actions: "actions btn-group", center: "text-center", columnHeaderAnchor: "column-header-anchor", columnHeaderText: "text", dropDownItem: "dropdown-item", dropDownItemButton: "dropdown-item-button", dropDownItemCheckbox: "dropdown-item-checkbox", dropDownMenu: "dropdown btn-group", dropDownMenuItems: "dropdown-menu pull-right", dropDownMenuText: "dropdown-text", footer: "bootgrid-footer container-fluid", header: "bootgrid-header container-fluid", icon: "icon glyphicon", iconColumns: "glyphicon-th-list", iconDown: "glyphicon-chevron-down", iconRefresh: "glyphicon-refresh", iconSearch: "glyphicon-search", iconUp: "glyphicon-chevron-up", infos: "infos", left: "text-left", pagination: "pagination", paginationButton: "button", responsiveTable: "table-responsive", right: "text-right", search: "search form-group", searchField: "search-field form-control", selectBox: "select-box", selectCell: "select-cell", selected: "active", sortable: "sortable", table: "bootgrid-table table" }, formatters: {}, labels: { all: "All", infos: "Showing {{ctx.start}} to {{ctx.end}} of {{ctx.total}} entries", loading: "Loading...", noResults: "No results found!", refresh: "Refresh", search: "Search" }, statusMapping: { 0: "success", 1: "info", 2: "warning", 3: "danger" }, templates: { actionButton: \'<button class="btn btn-default" type="button" title="{{ctx.text}}">{{ctx.content}}</button>\', actionDropDown: \'<div class="{{css.dropDownMenu}}"><button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown"><span class="{{css.dropDownMenuText}}">{{ctx.content}}</span> <span class="caret"></span></button><ul class="{{css.dropDownMenuItems}}" role="menu"></ul></div>\', actionDropDownItem: \'<li><a data-action="{{ctx.action}}" class="{{css.dropDownItem}} {{css.dropDownItemButton}}">{{ctx.text}}</a></li>\', actionDropDownCheckboxItem: \'<li><div class="checkbox"><label class="{{css.dropDownItem}}"><input name="{{ctx.name}}" type="checkbox" value="1" class="{{css.dropDownItemCheckbox}}" {{ctx.checked}} /> {{ctx.label}}<i class="input-helper"></i></label></div></li>\', actions: \'<div class="{{css.actions}}"></div>\', body: "<tbody></tbody>", cell: \'<td class="{{ctx.css}}" style="{{ctx.style}}">{{ctx.content}}</td>\', footer: \'<div id="{{ctx.id}}" class="{{css.footer}}"><div class="row"><div class="col-sm-6"><p class="{{css.pagination}}"></p></div><div class="col-sm-6 infoBar"><p class="{{css.infos}}"></p></div></div></div>\', header: \'<div id="{{ctx.id}}" class="{{css.header}}"><div class="row"><div class="col-sm-12 actionBar"><p class="{{css.search}}"></p><p class="{{css.actions}}"></p></div></div></div>\', headerCell: \'<th data-column-id="{{ctx.column.id}}" class="{{ctx.css}}" style="{{ctx.style}}"><a href="javascript:void(0);" class="{{css.columnHeaderAnchor}} {{ctx.sortable}}"><span class="{{css.columnHeaderText}}">{{ctx.column.text}}</span>{{ctx.icon}}</a></th>\', icon: \'<span class="{{css.icon}} {{ctx.iconCss}}"></span>\', infos: \'<div class="{{css.infos}}">{{lbl.infos}}</div>\', loading: \'<tr><td colspan="{{ctx.columns}}" class="loading">{{lbl.loading}}</td></tr>\', noResults: \'<tr><td colspan="{{ctx.columns}}" class="no-results">{{lbl.noResults}}</td></tr>\', pagination: \'<ul class="{{css.pagination}}"></ul>\', paginationItem: \'<li class="{{ctx.css}}"><a data-page="{{ctx.page}}" class="{{css.paginationButton}}">{{ctx.text}}</a></li>\', rawHeaderCell: \'<th class="{{ctx.css}}">{{ctx.content}}</th>\', row: "<tr{{ctx.attr}}>{{ctx.cells}}</tr>", search: \'<div class="{{css.search}}"><div class="input-group"><span class="{{css.icon}} input-group-addon {{css.iconSearch}}"></span> <input type="text" class="{{css.searchField}}" placeholder="{{lbl.search}}" /></div></div>\', select: \'<div class="checkbox"><label><input name="select" type="{{ctx.type}}" class="{{css.selectBox}}" value="{{ctx.value}}" {{ctx.checked}} /><i class="input-helper"></i></label></div>\' } }, M.prototype.append = function (t) {\n    if (this.options.ajax) ;else {\n      for (var e = [], s = 0; s < t.length; s++) i.call(this, t[s]) && e.push(t[s]);B.call(this), c.call(this, e), u.call(this), this.element.trigger("appended" + j, [e]);\n    }return this;\n  }, M.prototype.clear = function () {\n    if (this.options.ajax) ;else {\n      var e = t.extend([], this.rows);this.rows = [], this.current = 1, this.total = 0, u.call(this), this.element.trigger("cleared" + j, [e]);\n    }return this;\n  }, M.prototype.destroy = function () {\n    return t(e).off(j), 1 & this.options.navigation && this.header.remove(), 2 & this.options.navigation && this.footer.remove(), this.element.before(this.origin).remove(), this;\n  }, M.prototype.reload = function () {\n    return this.current = 1, u.call(this), this;\n  }, M.prototype.remove = function (t) {\n    if (null != this.identifier) {\n      if (this.options.ajax) ;else {\n        t = t || this.selectedRows;for (var e, i = [], s = 0; s < t.length; s++) {\n          e = t[s];for (var o = 0; o < this.rows.length; o++) if (this.rows[o][this.identifier] === e) {\n            i.push(this.rows[o]), this.rows.splice(o, 1);break;\n          }\n        }this.current = 1, u.call(this), this.element.trigger("removed" + j, [i]);\n      }\n    }return this;\n  }, M.prototype.search = function (t) {\n    if (t = t || "", this.searchPhrase !== t) {\n      var e = r(this.options.css.searchField),\n          i = s.call(this, e);i.val(t);\n    }return S.call(this, t), this;\n  }, M.prototype.select = function (e) {\n    if (this.selection) {\n      e = e || this.currentRows.propValues(this.identifier);for (var i, s, o = []; e.length > 0 && (this.options.multiSelect || 1 !== o.length);) if (i = e.pop(), -1 === t.inArray(i, this.selectedRows)) for (s = 0; s < this.currentRows.length; s++) if (this.currentRows[s][this.identifier] === i) {\n        o.push(this.currentRows[s]), this.selectedRows.push(i);break;\n      }if (o.length > 0) {\n        var n = r(this.options.css.selectBox),\n            l = this.selectedRows.length >= this.currentRows.length;for (s = 0; !this.options.keepSelection && l && s < this.currentRows.length;) l = -1 !== t.inArray(this.currentRows[s++][this.identifier], this.selectedRows);for (this.element.find("thead " + n).prop("checked", l), this.options.multiSelect || this.element.find("tbody > tr " + n + ":checked").trigger("click" + j), s = 0; s < this.selectedRows.length; s++) this.element.find(\'tbody > tr[data-row-id="\' + this.selectedRows[s] + \'"]\').addClass(this.options.css.selected)._bgAria("selected", "true").find(n).prop("checked", !0);this.element.trigger("selected" + j, [o]);\n      }\n    }return this;\n  }, M.prototype.deselect = function (e) {\n    if (this.selection) {\n      e = e || this.currentRows.propValues(this.identifier);for (var i, s, o, n = []; e.length > 0;) if (i = e.pop(), o = t.inArray(i, this.selectedRows), -1 !== o) for (s = 0; s < this.currentRows.length; s++) if (this.currentRows[s][this.identifier] === i) {\n        n.push(this.currentRows[s]), this.selectedRows.splice(o, 1);break;\n      }if (n.length > 0) {\n        var l = r(this.options.css.selectBox);for (this.element.find("thead " + l).prop("checked", !1), s = 0; s < n.length; s++) this.element.find(\'tbody > tr[data-row-id="\' + n[s][this.identifier] + \'"]\').removeClass(this.options.css.selected)._bgAria("selected", "false").find(l).prop("checked", !1);this.element.trigger("deselected" + j, [n]);\n      }\n    }return this;\n  }, M.prototype.sort = function (e) {\n    var i = e ? t.extend({}, e) : {};return i === this.sortDictionary ? this : (this.sortDictionary = i, R.call(this), B.call(this), u.call(this), this);\n  }, M.prototype.getColumnSettings = function () {\n    return t.merge([], this.columns);\n  }, M.prototype.getCurrentPage = function () {\n    return this.current;\n  }, M.prototype.getCurrentRows = function () {\n    return t.merge([], this.currentRows);\n  }, M.prototype.getRowCount = function () {\n    return this.rowCount;\n  }, M.prototype.getSearchPhrase = function () {\n    return this.searchPhrase;\n  }, M.prototype.getSelectedRows = function () {\n    return t.merge([], this.selectedRows);\n  }, M.prototype.getSortDictionary = function () {\n    return t.extend({}, this.sortDictionary);\n  }, M.prototype.getTotalPageCount = function () {\n    return this.totalPages;\n  }, M.prototype.getTotalRowCount = function () {\n    return this.total;\n  }, t.fn.extend({ _bgAria: function (t, e) {\n      return e ? this.attr("aria-" + t, e) : this.attr("aria-" + t);\n    }, _bgBusyAria: function (t) {\n      return null == t || t ? this._bgAria("busy", "true") : this._bgAria("busy", "false");\n    }, _bgRemoveAria: function (t) {\n      return this.removeAttr("aria-" + t);\n    }, _bgEnableAria: function (t) {\n      return null == t || t ? this.removeClass("disabled")._bgAria("disabled", "false") : this.addClass("disabled")._bgAria("disabled", "true");\n    }, _bgEnableField: function (t) {\n      return null == t || t ? this.removeAttr("disabled") : this.attr("disabled", "disable");\n    }, _bgShowAria: function (t) {\n      return null == t || t ? this.show()._bgAria("hidden", "false") : this.hide()._bgAria("hidden", "true");\n    }, _bgSelectAria: function (t) {\n      return null == t || t ? this.addClass("active")._bgAria("selected", "true") : this.removeClass("active")._bgAria("selected", "false");\n    }, _bgId: function (t) {\n      return t ? this.attr("id", t) : this.attr("id");\n    } }), !String.prototype.resolve) {\n    var T = { checked: function (t) {\n        return "boolean" == typeof t ? t ? \'checked="checked"\' : "" : t;\n      } };String.prototype.resolve = function (e, i) {\n      var s = this;return t.each(e, function (e, o) {\n        if (null != o && "function" != typeof o) if ("object" == typeof o) {\n          var n = i ? t.extend([], i) : [];n.push(e), s = s.resolve(o, n) + "";\n        } else {\n          T && T[e] && "function" == typeof T[e] && (o = T[e](o)), e = i ? i.join(".") + "." + e : e;var r = new RegExp("\\\\{\\\\{" + e + "\\\\}\\\\}", "gm");s = s.replace(r, o.replace ? o.replace(/\\$/gi, "&#36;") : o);\n        }\n      }), s;\n    };\n  }Array.prototype.first || (Array.prototype.first = function (t) {\n    for (var e = 0; e < this.length; e++) {\n      var i = this[e];if (t(i)) return i;\n    }return null;\n  }), Array.prototype.contains || (Array.prototype.contains = function (t) {\n    for (var e = 0; e < this.length; e++) {\n      var i = this[e];if (t(i)) return !0;\n    }return !1;\n  }), Array.prototype.page || (Array.prototype.page = function (t, e) {\n    var i = (t - 1) * e,\n        s = i + e;return this.length > i ? this.length > s ? this.slice(i, s) : this.slice(i) : [];\n  }), Array.prototype.where || (Array.prototype.where = function (t) {\n    for (var e = [], i = 0; i < this.length; i++) {\n      var s = this[i];t(s) && e.push(s);\n    }return e;\n  }), Array.prototype.propValues || (Array.prototype.propValues = function (t) {\n    for (var e = [], i = 0; i < this.length; i++) e.push(this[i][t]);return e;\n  });var E = t.fn.bootgrid;t.fn.bootgrid = function (e) {\n    var i = Array.prototype.slice.call(arguments, 1),\n        s = null,\n        o = this.each(function (o) {\n      var n = t(this),\n          r = n.data(j),\n          l = "object" == typeof e && e;if ((r || "destroy" !== e) && (r || (n.data(j, r = new M(this, l)), a.call(r)), "string" == typeof e)) if (0 === e.indexOf("get") && 0 === o) s = r[e].apply(r, i);else if (0 !== e.indexOf("get")) return r[e].apply(r, i);\n    });return "string" == typeof e && 0 === e.indexOf("get") ? s : o;\n  }, t.fn.bootgrid.Constructor = M, t.fn.bootgrid.noConflict = function () {\n    return t.fn.bootgrid = E, this;\n  }, t(\'[data-toggle="bootgrid"]\').bootgrid();\n}(jQuery, window);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(116)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvYm9vdGdyaWQvanF1ZXJ5LmJvb3RncmlkLnVwZGF0ZWQubWluLmpzPzI2MmMiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uICh0LCBlKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBmdW5jdGlvbiBpKHQpIHtcbiAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgIHJldHVybiBpLmlkZW50aWZpZXIgJiYgZVtpLmlkZW50aWZpZXJdID09PSB0W2kuaWRlbnRpZmllcl07XG4gICAgfXZhciBpID0gdGhpcztyZXR1cm4gdGhpcy5yb3dzLmNvbnRhaW5zKGUpID8gITEgOiAodGhpcy5yb3dzLnB1c2godCksICEwKTtcbiAgfWZ1bmN0aW9uIHMoZSkge1xuICAgIHZhciBpID0gdGhpcy5mb290ZXIgPyB0aGlzLmZvb3Rlci5maW5kKGUpIDogdCgpLFxuICAgICAgICBzID0gdGhpcy5oZWFkZXIgPyB0aGlzLmhlYWRlci5maW5kKGUpIDogdCgpO3JldHVybiB0Lm1lcmdlKGksIHMpO1xuICB9ZnVuY3Rpb24gbyhlKSB7XG4gICAgcmV0dXJuIGUgPyB0LmV4dGVuZCh7fSwgdGhpcy5jYWNoZWRQYXJhbXMsIHsgY3R4OiBlIH0pIDogdGhpcy5jYWNoZWRQYXJhbXM7XG4gIH1mdW5jdGlvbiBuKCkge1xuICAgIHZhciBlID0geyBjdXJyZW50OiB0aGlzLmN1cnJlbnQsIHJvd0NvdW50OiB0aGlzLnJvd0NvdW50LCBzb3J0OiB0aGlzLnNvcnREaWN0aW9uYXJ5LCBzZWFyY2hQaHJhc2U6IHRoaXMuc2VhcmNoUGhyYXNlIH0sXG4gICAgICAgIGkgPSB0aGlzLm9wdGlvbnMucG9zdDtyZXR1cm4gaSA9IHQuaXNGdW5jdGlvbihpKSA/IGkoKSA6IGksIHRoaXMub3B0aW9ucy5yZXF1ZXN0SGFuZGxlcih0LmV4dGVuZCghMCwgZSwgaSkpO1xuICB9ZnVuY3Rpb24gcihlKSB7XG4gICAgcmV0dXJuIFwiLlwiICsgdC50cmltKGUpLnJlcGxhY2UoL1xccysvZ20sIFwiLlwiKTtcbiAgfWZ1bmN0aW9uIGwoKSB7XG4gICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMudXJsO3JldHVybiB0LmlzRnVuY3Rpb24oZSkgPyBlKCkgOiBlO1xuICB9ZnVuY3Rpb24gYSgpIHtcbiAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcihcImluaXRpYWxpemVcIiArIGopLCBkLmNhbGwodGhpcyksIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLnNlbGVjdGlvbiAmJiBudWxsICE9IHRoaXMuaWRlbnRpZmllciwgcC5jYWxsKHRoaXMpLCBnLmNhbGwodGhpcyksIFIuY2FsbCh0aGlzKSwgay5jYWxsKHRoaXMpLCB2LmNhbGwodGhpcyksIHUuY2FsbCh0aGlzKSwgdGhpcy5lbGVtZW50LnRyaWdnZXIoXCJpbml0aWFsaXplZFwiICsgaik7XG4gIH1mdW5jdGlvbiBjKCkge1xuICAgIHRoaXMub3B0aW9ucy5oaWdobGlnaHRSb3dzO1xuICB9ZnVuY3Rpb24gaCh0KSB7XG4gICAgcmV0dXJuIHQudmlzaWJsZTtcbiAgfWZ1bmN0aW9uIGQoKSB7XG4gICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICBpID0gdGhpcy5lbGVtZW50LmZpbmQoXCJ0aGVhZCA+IHRyXCIpLmZpcnN0KCksXG4gICAgICAgIHMgPSAhMTtpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaSA9IHQodGhpcyksXG4gICAgICAgICAgbyA9IGkuZGF0YSgpLFxuICAgICAgICAgIG4gPSB7IGlkOiBvLmNvbHVtbklkLCBpZGVudGlmaWVyOiBudWxsID09IGUuaWRlbnRpZmllciAmJiBvLmlkZW50aWZpZXIgfHwgITEsIGNvbnZlcnRlcjogZS5vcHRpb25zLmNvbnZlcnRlcnNbby5jb252ZXJ0ZXIgfHwgby50eXBlXSB8fCBlLm9wdGlvbnMuY29udmVydGVycy5zdHJpbmcsIHRleHQ6IGkudGV4dCgpLCBhbGlnbjogby5hbGlnbiB8fCBcImxlZnRcIiwgaGVhZGVyQWxpZ246IG8uaGVhZGVyQWxpZ24gfHwgXCJsZWZ0XCIsIGNzc0NsYXNzOiBvLmNzc0NsYXNzIHx8IFwiXCIsIGhlYWRlckNzc0NsYXNzOiBvLmhlYWRlckNzc0NsYXNzIHx8IFwiXCIsIGZvcm1hdHRlcjogZS5vcHRpb25zLmZvcm1hdHRlcnNbby5mb3JtYXR0ZXJdIHx8IG51bGwsIG9yZGVyOiBzIHx8IFwiYXNjXCIgIT09IG8ub3JkZXIgJiYgXCJkZXNjXCIgIT09IG8ub3JkZXIgPyBudWxsIDogby5vcmRlciwgc2VhcmNoYWJsZTogIShvLnNlYXJjaGFibGUgPT09ICExKSwgc29ydGFibGU6ICEoby5zb3J0YWJsZSA9PT0gITEpLCB2aXNpYmxlOiAhKG8udmlzaWJsZSA9PT0gITEpLCB2aXNpYmxlSW5TZWxlY3Rpb246ICEoby52aXNpYmxlSW5TZWxlY3Rpb24gPT09ICExKSwgd2lkdGg6IHQuaXNOdW1lcmljKG8ud2lkdGgpID8gby53aWR0aCArIFwicHhcIiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIG8ud2lkdGggPyBvLndpZHRoIDogbnVsbCB9O2UuY29sdW1ucy5wdXNoKG4pLCBudWxsICE9IG4ub3JkZXIgJiYgKGUuc29ydERpY3Rpb25hcnlbbi5pZF0gPSBuLm9yZGVyKSwgbi5pZGVudGlmaWVyICYmIChlLmlkZW50aWZpZXIgPSBuLmlkLCBlLmNvbnZlcnRlciA9IG4uY29udmVydGVyKSwgZS5vcHRpb25zLm11bHRpU29ydCB8fCBudWxsID09PSBuLm9yZGVyIHx8IChzID0gITApO1xuICAgIH0pO1xuICB9ZnVuY3Rpb24gdSgpIHtcbiAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgIGZvciAodmFyIGUsIGkgPSBuZXcgUmVnRXhwKG8uc2VhcmNoUGhyYXNlLCBvLm9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IFwiZ1wiIDogXCJnaVwiKSwgcyA9IDA7IHMgPCBvLmNvbHVtbnMubGVuZ3RoOyBzKyspIGlmIChlID0gby5jb2x1bW5zW3NdLCBlLnNlYXJjaGFibGUgJiYgZS52aXNpYmxlICYmIGUuY29udmVydGVyLnRvKHRbZS5pZF0pLnNlYXJjaChpKSA+IC0xKSByZXR1cm4gITA7cmV0dXJuICExO1xuICAgIH1mdW5jdGlvbiBzKHQsIGUpIHtcbiAgICAgIG8uY3VycmVudFJvd3MgPSB0LCBmLmNhbGwobywgZSksIG8ub3B0aW9ucy5rZWVwU2VsZWN0aW9uIHx8IChvLnNlbGVjdGVkUm93cyA9IFtdKSwgRC5jYWxsKG8sIHQpLCBiLmNhbGwobyksIHkuY2FsbChvKSwgby5lbGVtZW50Ll9iZ0J1c3lBcmlhKCExKS50cmlnZ2VyKFwibG9hZGVkXCIgKyBqKTtcbiAgICB9dmFyIG8gPSB0aGlzO2lmICh0aGlzLmVsZW1lbnQuX2JnQnVzeUFyaWEoITApLnRyaWdnZXIoXCJsb2FkXCIgKyBqKSwgUC5jYWxsKHRoaXMpLCB0aGlzLm9wdGlvbnMuYWpheCkge1xuICAgICAgdmFyIHIgPSBuLmNhbGwodGhpcyksXG4gICAgICAgICAgYSA9IGwuY2FsbCh0aGlzKTtpZiAobnVsbCA9PSBhIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIGEgfHwgMCA9PT0gYS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIlVybCBzZXR0aW5nIG11c3QgYmUgYSBub25lIGVtcHR5IHN0cmluZyBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBvbmUuXCIpO3RoaXMueHFyICYmIHRoaXMueHFyLmFib3J0KCk7dmFyIGMgPSB7IHVybDogYSwgZGF0YTogciwgc3VjY2VzczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBvLnhxciA9IG51bGwsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgKGUgPSB0LnBhcnNlSlNPTihlKSksIGUgPSBvLm9wdGlvbnMucmVzcG9uc2VIYW5kbGVyKGUpLCBvLmN1cnJlbnQgPSBlLmN1cnJlbnQsIHMoZS5yb3dzLCBlLnRvdGFsKTtcbiAgICAgICAgfSwgZXJyb3I6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgby54cXIgPSBudWxsLCBcImFib3J0XCIgIT09IGUgJiYgKHcuY2FsbChvKSwgby5lbGVtZW50Ll9iZ0J1c3lBcmlhKCExKS50cmlnZ2VyKFwibG9hZGVkXCIgKyBqKSk7XG4gICAgICAgIH0gfTtjID0gdC5leHRlbmQodGhpcy5vcHRpb25zLmFqYXhTZXR0aW5ncywgYyksIHRoaXMueHFyID0gdC5hamF4KGMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaCA9IHRoaXMuc2VhcmNoUGhyYXNlLmxlbmd0aCA+IDAgPyB0aGlzLnJvd3Mud2hlcmUoaSkgOiB0aGlzLnJvd3MsXG4gICAgICAgICAgZCA9IGgubGVuZ3RoOy0xICE9PSB0aGlzLnJvd0NvdW50ICYmIChoID0gaC5wYWdlKHRoaXMuY3VycmVudCwgdGhpcy5yb3dDb3VudCkpLCBlLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzKGgsIGQpO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgfWZ1bmN0aW9uIHAoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWpheCkge1xuICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIHMgPSB0aGlzLmVsZW1lbnQuZmluZChcInRib2R5ID4gdHJcIik7cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHMgPSB0KHRoaXMpLFxuICAgICAgICAgICAgbyA9IHMuY2hpbGRyZW4oXCJ0ZFwiKSxcbiAgICAgICAgICAgIG4gPSB7fTt0LmVhY2goZS5jb2x1bW5zLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIG5bZS5pZF0gPSBlLmNvbnZlcnRlci5mcm9tKG8uZXEodCkudGV4dCgpKTtcbiAgICAgICAgfSksIGkuY2FsbChlLCBuKTtcbiAgICAgIH0pLCBmLmNhbGwodGhpcywgdGhpcy5yb3dzLmxlbmd0aCksIEIuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1mdW5jdGlvbiBmKHQpIHtcbiAgICB0aGlzLnRvdGFsID0gdCwgdGhpcy50b3RhbFBhZ2VzID0gLTEgPT09IHRoaXMucm93Q291bnQgPyAxIDogTWF0aC5jZWlsKHRoaXMudG90YWwgLyB0aGlzLnJvd0NvdW50KTtcbiAgfWZ1bmN0aW9uIGcoKSB7XG4gICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICBpID0gdGhpcy5lbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKHRoaXMub3B0aW9ucy5jc3MucmVzcG9uc2l2ZVRhYmxlKSA/IHRoaXMuZWxlbWVudC5wYXJlbnQoKSA6IHRoaXMuZWxlbWVudDt0aGlzLmVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNzcy50YWJsZSksIDAgPT09IHRoaXMuZWxlbWVudC5jaGlsZHJlbihcInRib2R5XCIpLmxlbmd0aCAmJiB0aGlzLmVsZW1lbnQuYXBwZW5kKGUuYm9keSksIDEgJiB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbiAmJiAodGhpcy5oZWFkZXIgPSB0KGUuaGVhZGVyLnJlc29sdmUoby5jYWxsKHRoaXMsIHsgaWQ6IHRoaXMuZWxlbWVudC5fYmdJZCgpICsgXCItaGVhZGVyXCIgfSkpKSwgaS5iZWZvcmUodGhpcy5oZWFkZXIpKSwgMiAmIHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uICYmICh0aGlzLmZvb3RlciA9IHQoZS5mb290ZXIucmVzb2x2ZShvLmNhbGwodGhpcywgeyBpZDogdGhpcy5lbGVtZW50Ll9iZ0lkKCkgKyBcIi1mb290ZXJcIiB9KSkpLCBpLmFmdGVyKHRoaXMuZm9vdGVyKSk7XG4gIH1mdW5jdGlvbiB2KCkge1xuICAgIGlmICgwICE9PSB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbikge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMuY3NzLFxuICAgICAgICAgIGkgPSByKGUuYWN0aW9ucyksXG4gICAgICAgICAgbiA9IHMuY2FsbCh0aGlzLCBpKTtpZiAobi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICAgICAgYyA9IHQoYS5hY3Rpb25zLnJlc29sdmUoby5jYWxsKHRoaXMpKSk7aWYgKHRoaXMub3B0aW9ucy5hamF4KSB7XG4gICAgICAgICAgdmFyIGggPSBhLmljb24ucmVzb2x2ZShvLmNhbGwodGhpcywgeyBpY29uQ3NzOiBlLmljb25SZWZyZXNoIH0pKSxcbiAgICAgICAgICAgICAgZCA9IHQoYS5hY3Rpb25CdXR0b24ucmVzb2x2ZShvLmNhbGwodGhpcywgeyBjb250ZW50OiBoLCB0ZXh0OiB0aGlzLm9wdGlvbnMubGFiZWxzLnJlZnJlc2ggfSkpKS5vbihcImNsaWNrXCIgKyBqLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC5zdG9wUHJvcGFnYXRpb24oKSwgbC5jdXJyZW50ID0gMSwgdS5jYWxsKGwpO1xuICAgICAgICAgIH0pO2MuYXBwZW5kKGQpO1xuICAgICAgICB9Qy5jYWxsKHRoaXMsIGMpLCBtLmNhbGwodGhpcywgYyksIEkuY2FsbCh0aGlzLCBuLCBjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1mdW5jdGlvbiBtKGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbHVtblNlbGVjdGlvbiAmJiB0aGlzLmNvbHVtbnMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICAgIHMgPSB0aGlzLm9wdGlvbnMuY3NzLFxuICAgICAgICAgIG4gPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICAgIGwgPSBuLmljb24ucmVzb2x2ZShvLmNhbGwodGhpcywgeyBpY29uQ3NzOiBzLmljb25Db2x1bW5zIH0pKSxcbiAgICAgICAgICBhID0gdChuLmFjdGlvbkRyb3BEb3duLnJlc29sdmUoby5jYWxsKHRoaXMsIHsgY29udGVudDogbCB9KSkpLFxuICAgICAgICAgIGMgPSByKHMuZHJvcERvd25JdGVtKSxcbiAgICAgICAgICBkID0gcihzLmRyb3BEb3duSXRlbUNoZWNrYm94KSxcbiAgICAgICAgICBwID0gcihzLmRyb3BEb3duTWVudUl0ZW1zKTt0LmVhY2godGhpcy5jb2x1bW5zLCBmdW5jdGlvbiAoZSwgbCkge1xuICAgICAgICBpZiAobC52aXNpYmxlSW5TZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgZiA9IHQobi5hY3Rpb25Ecm9wRG93bkNoZWNrYm94SXRlbS5yZXNvbHZlKG8uY2FsbChpLCB7IG5hbWU6IGwuaWQsIGxhYmVsOiBsLnRleHQsIGNoZWNrZWQ6IGwudmlzaWJsZSB9KSkpLm9uKFwiY2xpY2tcIiArIGosIGMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO3ZhciBzID0gdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvID0gcy5maW5kKGQpO2lmICghby5wcm9wKFwiZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICAgICAgbC52aXNpYmxlID0gby5wcm9wKFwiY2hlY2tlZFwiKTt2YXIgbiA9IGkuY29sdW1ucy53aGVyZShoKS5sZW5ndGggPiAxO3MucGFyZW50cyhwKS5maW5kKGMgKyBcIjpoYXMoXCIgKyBkICsgXCI6Y2hlY2tlZClcIikuX2JnRW5hYmxlQXJpYShuKS5maW5kKGQpLl9iZ0VuYWJsZUZpZWxkKG4pLCBpLmVsZW1lbnQuZmluZChcInRib2R5XCIpLmVtcHR5KCksIFIuY2FsbChpKSwgdS5jYWxsKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO2EuZmluZChyKHMuZHJvcERvd25NZW51SXRlbXMpKS5hcHBlbmQoZik7XG4gICAgICAgIH1cbiAgICAgIH0pLCBlLmFwcGVuZChhKTtcbiAgICB9XG4gIH1mdW5jdGlvbiBiKCkge1xuICAgIGlmICgwICE9PSB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbikge1xuICAgICAgdmFyIGUgPSByKHRoaXMub3B0aW9ucy5jc3MuaW5mb3MpLFxuICAgICAgICAgIGkgPSBzLmNhbGwodGhpcywgZSk7aWYgKGkubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY3VycmVudCAqIHRoaXMucm93Q291bnQsXG4gICAgICAgICAgICBsID0gdCh0aGlzLm9wdGlvbnMudGVtcGxhdGVzLmluZm9zLnJlc29sdmUoby5jYWxsKHRoaXMsIHsgZW5kOiAwID09PSB0aGlzLnRvdGFsIHx8IC0xID09PSBuIHx8IG4gPiB0aGlzLnRvdGFsID8gdGhpcy50b3RhbCA6IG4sIHN0YXJ0OiAwID09PSB0aGlzLnRvdGFsID8gMCA6IG4gLSB0aGlzLnJvd0NvdW50ICsgMSwgdG90YWw6IHRoaXMudG90YWwgfSkpKTtJLmNhbGwodGhpcywgaSwgbCk7XG4gICAgICB9XG4gICAgfVxuICB9ZnVuY3Rpb24gdygpIHtcbiAgICB2YXIgdCA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbihcInRib2R5XCIpLmZpcnN0KCksXG4gICAgICAgIGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICBpID0gdGhpcy5jb2x1bW5zLndoZXJlKGgpLmxlbmd0aDt0aGlzLnNlbGVjdGlvbiAmJiAoaSArPSAxKSwgdC5odG1sKGUubm9SZXN1bHRzLnJlc29sdmUoby5jYWxsKHRoaXMsIHsgY29sdW1uczogaSB9KSkpO1xuICB9ZnVuY3Rpb24geSgpIHtcbiAgICBpZiAoMCAhPT0gdGhpcy5vcHRpb25zLm5hdmlnYXRpb24pIHtcbiAgICAgIHZhciBlID0gcih0aGlzLm9wdGlvbnMuY3NzLnBhZ2luYXRpb24pLFxuICAgICAgICAgIGkgPSBzLmNhbGwodGhpcywgZSkuX2JnU2hvd0FyaWEoLTEgIT09IHRoaXMucm93Q291bnQpO2lmICgtMSAhPT0gdGhpcy5yb3dDb3VudCAmJiBpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICAgICAgbCA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgICAgIGEgPSB0aGlzLnRvdGFsUGFnZXMsXG4gICAgICAgICAgICBjID0gdChuLnBhZ2luYXRpb24ucmVzb2x2ZShvLmNhbGwodGhpcykpKSxcbiAgICAgICAgICAgIGggPSBhIC0gbCxcbiAgICAgICAgICAgIGQgPSAtMSAqICh0aGlzLm9wdGlvbnMucGFkZGluZyAtIGwpLFxuICAgICAgICAgICAgdSA9IGggPj0gdGhpcy5vcHRpb25zLnBhZGRpbmcgPyBNYXRoLm1heChkLCAxKSA6IE1hdGgubWF4KGQgLSB0aGlzLm9wdGlvbnMucGFkZGluZyArIGgsIDEpLFxuICAgICAgICAgICAgcCA9IDIgKiB0aGlzLm9wdGlvbnMucGFkZGluZyArIDEsXG4gICAgICAgICAgICBmID0gYSA+PSBwID8gcCA6IGE7eC5jYWxsKHRoaXMsIGMsIFwiZmlyc3RcIiwgXCI8aSBjbGFzcz0nem1kaSB6bWRpLW1vcmUtaG9yaXonPjwvaT5cIiwgXCJmaXJzdFwiKS5fYmdFbmFibGVBcmlhKGwgPiAxKSwgeC5jYWxsKHRoaXMsIGMsIFwicHJldlwiLCBcIjxpIGNsYXNzPSd6bWRpIHptZGktY2hldnJvbi1sZWZ0Jz48L2k+XCIsIFwicHJldlwiKS5fYmdFbmFibGVBcmlhKGwgPiAxKTtmb3IgKHZhciBnID0gMDsgZiA+IGc7IGcrKykge1xuICAgICAgICAgIHZhciB2ID0gZyArIHU7eC5jYWxsKHRoaXMsIGMsIHYsIHYsIFwicGFnZS1cIiArIHYpLl9iZ0VuYWJsZUFyaWEoKS5fYmdTZWxlY3RBcmlhKHYgPT09IGwpO1xuICAgICAgICB9MCA9PT0gZiAmJiB4LmNhbGwodGhpcywgYywgMSwgMSwgXCJwYWdlLTFcIikuX2JnRW5hYmxlQXJpYSghMSkuX2JnU2VsZWN0QXJpYSgpLCB4LmNhbGwodGhpcywgYywgXCJuZXh0XCIsIFwiPGkgY2xhc3M9J3ptZGkgem1kaS1jaGV2cm9uLXJpZ2h0Jz48L2k+XCIsIFwibmV4dFwiKS5fYmdFbmFibGVBcmlhKGEgPiBsKSwgeC5jYWxsKHRoaXMsIGMsIFwibGFzdFwiLCBcIjxpIGNsYXNzPSd6bWRpIHptZGktbW9yZS1ob3Jpeic+PC9pPlwiLCBcImxhc3RcIikuX2JnRW5hYmxlQXJpYShhID4gbCksIEkuY2FsbCh0aGlzLCBpLCBjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1mdW5jdGlvbiB4KGUsIGksIHMsIG4pIHtcbiAgICB2YXIgbCA9IHRoaXMsXG4gICAgICAgIGEgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICBjID0gdGhpcy5vcHRpb25zLmNzcyxcbiAgICAgICAgaCA9IG8uY2FsbCh0aGlzLCB7IGNzczogbiwgdGV4dDogcywgcGFnZTogaSB9KSxcbiAgICAgICAgZCA9IHQoYS5wYWdpbmF0aW9uSXRlbS5yZXNvbHZlKGgpKS5vbihcImNsaWNrXCIgKyBqLCByKGMucGFnaW5hdGlvbkJ1dHRvbiksIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnByZXZlbnREZWZhdWx0KCk7dmFyIGkgPSB0KHRoaXMpLFxuICAgICAgICAgIHMgPSBpLnBhcmVudCgpO2lmICghcy5oYXNDbGFzcyhcImFjdGl2ZVwiKSAmJiAhcy5oYXNDbGFzcyhcImRpc2FibGVkXCIpKSB7XG4gICAgICAgIHZhciBvID0geyBmaXJzdDogMSwgcHJldjogbC5jdXJyZW50IC0gMSwgbmV4dDogbC5jdXJyZW50ICsgMSwgbGFzdDogbC50b3RhbFBhZ2VzIH0sXG4gICAgICAgICAgICBuID0gaS5kYXRhKFwicGFnZVwiKTtsLmN1cnJlbnQgPSBvW25dIHx8IG4sIHUuY2FsbChsKTtcbiAgICAgIH1pLnRyaWdnZXIoXCJibHVyXCIpO1xuICAgIH0pO3JldHVybiBlLmFwcGVuZChkKSwgZDtcbiAgfWZ1bmN0aW9uIEMoZSkge1xuICAgIGZ1bmN0aW9uIGkodCkge1xuICAgICAgcmV0dXJuIC0xID09PSB0ID8gcy5vcHRpb25zLmxhYmVscy5hbGwgOiB0O1xuICAgIH12YXIgcyA9IHRoaXMsXG4gICAgICAgIG4gPSB0aGlzLm9wdGlvbnMucm93Q291bnQ7aWYgKHQuaXNBcnJheShuKSkge1xuICAgICAgdmFyIGwgPSB0aGlzLm9wdGlvbnMuY3NzLFxuICAgICAgICAgIGEgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICAgIGMgPSB0KGEuYWN0aW9uRHJvcERvd24ucmVzb2x2ZShvLmNhbGwodGhpcywgeyBjb250ZW50OiBpKHRoaXMucm93Q291bnQpIH0pKSksXG4gICAgICAgICAgaCA9IHIobC5kcm9wRG93bk1lbnUpLFxuICAgICAgICAgIGQgPSByKGwuZHJvcERvd25NZW51VGV4dCksXG4gICAgICAgICAgcCA9IHIobC5kcm9wRG93bk1lbnVJdGVtcyksXG4gICAgICAgICAgZiA9IHIobC5kcm9wRG93bkl0ZW1CdXR0b24pO3QuZWFjaChuLCBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICB2YXIgciA9IHQoYS5hY3Rpb25Ecm9wRG93bkl0ZW0ucmVzb2x2ZShvLmNhbGwocywgeyB0ZXh0OiBpKG4pLCBhY3Rpb246IG4gfSkpKS5fYmdTZWxlY3RBcmlhKG4gPT09IHMucm93Q291bnQpLm9uKFwiY2xpY2tcIiArIGosIGYsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO3ZhciBvID0gdCh0aGlzKSxcbiAgICAgICAgICAgICAgbiA9IG8uZGF0YShcImFjdGlvblwiKTtuICE9PSBzLnJvd0NvdW50ICYmIChzLmN1cnJlbnQgPSAxLCBzLnJvd0NvdW50ID0gbiwgby5wYXJlbnRzKHApLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHQodGhpcyksXG4gICAgICAgICAgICAgICAgaSA9IGUuZmluZChmKS5kYXRhKFwiYWN0aW9uXCIpO2UuX2JnU2VsZWN0QXJpYShpID09PSBuKTtcbiAgICAgICAgICB9KSwgby5wYXJlbnRzKGgpLmZpbmQoZCkudGV4dChpKG4pKSwgdS5jYWxsKHMpKTtcbiAgICAgICAgfSk7Yy5maW5kKHApLmFwcGVuZChyKTtcbiAgICAgIH0pLCBlLmFwcGVuZChjKTtcbiAgICB9XG4gIH1mdW5jdGlvbiBEKGUpIHtcbiAgICBpZiAoZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHRoaXMsXG4gICAgICAgICAgcyA9IHRoaXMub3B0aW9ucy5jc3MsXG4gICAgICAgICAgbiA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZXMsXG4gICAgICAgICAgbCA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbihcInRib2R5XCIpLmZpcnN0KCksXG4gICAgICAgICAgYSA9ICEwLFxuICAgICAgICAgIGMgPSBcIlwiO3QuZWFjaChlLCBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICB2YXIgbCA9IFwiXCIsXG4gICAgICAgICAgICBoID0gJyBkYXRhLXJvdy1pZD1cIicgKyAobnVsbCA9PSBpLmlkZW50aWZpZXIgPyBlIDogcltpLmlkZW50aWZpZXJdKSArICdcIicsXG4gICAgICAgICAgICBkID0gXCJcIjtpZiAoaS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgdSA9IC0xICE9PSB0LmluQXJyYXkocltpLmlkZW50aWZpZXJdLCBpLnNlbGVjdGVkUm93cyksXG4gICAgICAgICAgICAgIHAgPSBuLnNlbGVjdC5yZXNvbHZlKG8uY2FsbChpLCB7IHR5cGU6IFwiY2hlY2tib3hcIiwgdmFsdWU6IHJbaS5pZGVudGlmaWVyXSwgY2hlY2tlZDogdSB9KSk7bCArPSBuLmNlbGwucmVzb2x2ZShvLmNhbGwoaSwgeyBjb250ZW50OiBwLCBjc3M6IHMuc2VsZWN0Q2VsbCB9KSksIGEgPSBhICYmIHUsIHUgJiYgKGQgKz0gcy5zZWxlY3RlZCwgaCArPSAnIGFyaWEtc2VsZWN0ZWQ9XCJ0cnVlXCInKTtcbiAgICAgICAgfXZhciBmID0gbnVsbCAhPSByLnN0YXR1cyAmJiBpLm9wdGlvbnMuc3RhdHVzTWFwcGluZ1tyLnN0YXR1c107ZiAmJiAoZCArPSBmKSwgdC5lYWNoKGkuY29sdW1ucywgZnVuY3Rpb24gKGUsIGEpIHtcbiAgICAgICAgICBpZiAoYS52aXNpYmxlKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHQuaXNGdW5jdGlvbihhLmZvcm1hdHRlcikgPyBhLmZvcm1hdHRlci5jYWxsKGksIGEsIHIpIDogYS5jb252ZXJ0ZXIudG8oclthLmlkXSksXG4gICAgICAgICAgICAgICAgaCA9IGEuY3NzQ2xhc3MubGVuZ3RoID4gMCA/IFwiIFwiICsgYS5jc3NDbGFzcyA6IFwiXCI7bCArPSBuLmNlbGwucmVzb2x2ZShvLmNhbGwoaSwgeyBjb250ZW50OiBudWxsID09IGMgfHwgXCJcIiA9PT0gYyA/IFwiJm5ic3A7XCIgOiBjLCBjc3M6IChcInJpZ2h0XCIgPT09IGEuYWxpZ24gPyBzLnJpZ2h0IDogXCJjZW50ZXJcIiA9PT0gYS5hbGlnbiA/IHMuY2VudGVyIDogcy5sZWZ0KSArIGgsIHN0eWxlOiBudWxsID09IGEud2lkdGggPyBcIlwiIDogXCJ3aWR0aDpcIiArIGEud2lkdGggKyBcIjtcIiB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgZC5sZW5ndGggPiAwICYmIChoICs9ICcgY2xhc3M9XCInICsgZCArICdcIicpLCBjICs9IG4ucm93LnJlc29sdmUoby5jYWxsKGksIHsgYXR0cjogaCwgY2VsbHM6IGwgfSkpO1xuICAgICAgfSksIGkuZWxlbWVudC5maW5kKFwidGhlYWQgXCIgKyByKGkub3B0aW9ucy5jc3Muc2VsZWN0Qm94KSkucHJvcChcImNoZWNrZWRcIiwgYSksIGwuaHRtbChjKSwgQS5jYWxsKHRoaXMsIGwpO1xuICAgIH0gZWxzZSB3LmNhbGwodGhpcyk7XG4gIH1mdW5jdGlvbiBBKGUpIHtcbiAgICB2YXIgaSA9IHRoaXMsXG4gICAgICAgIHMgPSByKHRoaXMub3B0aW9ucy5jc3Muc2VsZWN0Qm94KTt0aGlzLnNlbGVjdGlvbiAmJiBlLm9mZihcImNsaWNrXCIgKyBqLCBzKS5vbihcImNsaWNrXCIgKyBqLCBzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTt2YXIgcyA9IHQodGhpcyksXG4gICAgICAgICAgbyA9IGkuY29udmVydGVyLmZyb20ocy52YWwoKSk7cy5wcm9wKFwiY2hlY2tlZFwiKSA/IGkuc2VsZWN0KFtvXSkgOiBpLmRlc2VsZWN0KFtvXSk7XG4gICAgfSksIGUub2ZmKFwiY2xpY2tcIiArIGosIFwiPiB0clwiKS5vbihcImNsaWNrXCIgKyBqLCBcIj4gdHJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIHMgPSB0KHRoaXMpLFxuICAgICAgICAgIG8gPSBudWxsID09IGkuaWRlbnRpZmllciA/IHMuZGF0YShcInJvdy1pZFwiKSA6IGkuY29udmVydGVyLmZyb20ocy5kYXRhKFwicm93LWlkXCIpICsgXCJcIiksXG4gICAgICAgICAgbiA9IG51bGwgPT0gaS5pZGVudGlmaWVyID8gaS5jdXJyZW50Um93c1tvXSA6IGkuY3VycmVudFJvd3MuZmlyc3QoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRbaS5pZGVudGlmaWVyXSA9PT0gbztcbiAgICAgIH0pO2kuc2VsZWN0aW9uICYmIGkub3B0aW9ucy5yb3dTZWxlY3QgJiYgKHMuaGFzQ2xhc3MoaS5vcHRpb25zLmNzcy5zZWxlY3RlZCkgPyBpLmRlc2VsZWN0KFtvXSkgOiBpLnNlbGVjdChbb10pKSwgaS5lbGVtZW50LnRyaWdnZXIoXCJjbGlja1wiICsgaiwgW2kuY29sdW1ucywgbl0pO1xuICAgIH0pO1xuICB9ZnVuY3Rpb24gaygpIHtcbiAgICBpZiAoMCAhPT0gdGhpcy5vcHRpb25zLm5hdmlnYXRpb24pIHtcbiAgICAgIHZhciBpID0gdGhpcy5vcHRpb25zLmNzcyxcbiAgICAgICAgICBuID0gcihpLnNlYXJjaCksXG4gICAgICAgICAgbCA9IHMuY2FsbCh0aGlzLCBuKTtpZiAobC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICAgICAgaCA9IG51bGwsXG4gICAgICAgICAgICBkID0gXCJcIixcbiAgICAgICAgICAgIHUgPSByKGkuc2VhcmNoRmllbGQpLFxuICAgICAgICAgICAgcCA9IHQoYy5zZWFyY2gucmVzb2x2ZShvLmNhbGwodGhpcykpKSxcbiAgICAgICAgICAgIGYgPSBwLmlzKHUpID8gcCA6IHAuZmluZCh1KTtmLm9uKFwia2V5dXBcIiArIGosIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgaS5zdG9wUHJvcGFnYXRpb24oKTt2YXIgcyA9IHQodGhpcykudmFsKCk7KGQgIT09IHMgfHwgMTMgPT09IGkud2hpY2ggJiYgXCJcIiAhPT0gcykgJiYgKGQgPSBzLCAoMTMgPT09IGkud2hpY2ggfHwgMCA9PT0gcy5sZW5ndGggfHwgcy5sZW5ndGggPj0gYS5vcHRpb25zLnNlYXJjaFNldHRpbmdzLmNoYXJhY3RlcnMpICYmIChlLmNsZWFyVGltZW91dChoKSwgaCA9IGUuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBTLmNhbGwoYSwgcyk7XG4gICAgICAgICAgfSwgYS5vcHRpb25zLnNlYXJjaFNldHRpbmdzLmRlbGF5KSkpO1xuICAgICAgICB9KSwgSS5jYWxsKHRoaXMsIGwsIHApO1xuICAgICAgfVxuICAgIH1cbiAgfWZ1bmN0aW9uIFModCkge1xuICAgIHRoaXMuc2VhcmNoUGhyYXNlICE9PSB0ICYmICh0aGlzLmN1cnJlbnQgPSAxLCB0aGlzLnNlYXJjaFBocmFzZSA9IHQsIHUuY2FsbCh0aGlzKSk7XG4gIH1mdW5jdGlvbiBSKCkge1xuICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgaSA9IHRoaXMuZWxlbWVudC5maW5kKFwidGhlYWQgPiB0clwiKSxcbiAgICAgICAgcyA9IHRoaXMub3B0aW9ucy5jc3MsXG4gICAgICAgIG4gPSB0aGlzLm9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgICBsID0gXCJcIixcbiAgICAgICAgYSA9IHRoaXMub3B0aW9ucy5zb3J0aW5nO2lmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMubXVsdGlTZWxlY3QgPyBuLnNlbGVjdC5yZXNvbHZlKG8uY2FsbChlLCB7IHR5cGU6IFwiY2hlY2tib3hcIiwgdmFsdWU6IFwiYWxsXCIgfSkpIDogXCJcIjtsICs9IG4ucmF3SGVhZGVyQ2VsbC5yZXNvbHZlKG8uY2FsbChlLCB7IGNvbnRlbnQ6IGMsIGNzczogcy5zZWxlY3RDZWxsIH0pKTtcbiAgICB9aWYgKHQuZWFjaCh0aGlzLmNvbHVtbnMsIGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICBpZiAoaS52aXNpYmxlKSB7XG4gICAgICAgIHZhciByID0gZS5zb3J0RGljdGlvbmFyeVtpLmlkXSxcbiAgICAgICAgICAgIGMgPSBhICYmIHIgJiYgXCJhc2NcIiA9PT0gciA/IHMuaWNvblVwIDogYSAmJiByICYmIFwiZGVzY1wiID09PSByID8gcy5pY29uRG93biA6IFwiXCIsXG4gICAgICAgICAgICBoID0gbi5pY29uLnJlc29sdmUoby5jYWxsKGUsIHsgaWNvbkNzczogYyB9KSksXG4gICAgICAgICAgICBkID0gaS5oZWFkZXJBbGlnbixcbiAgICAgICAgICAgIHUgPSBpLmhlYWRlckNzc0NsYXNzLmxlbmd0aCA+IDAgPyBcIiBcIiArIGkuaGVhZGVyQ3NzQ2xhc3MgOiBcIlwiO2wgKz0gbi5oZWFkZXJDZWxsLnJlc29sdmUoby5jYWxsKGUsIHsgY29sdW1uOiBpLCBpY29uOiBoLCBzb3J0YWJsZTogYSAmJiBpLnNvcnRhYmxlICYmIHMuc29ydGFibGUgfHwgXCJcIiwgY3NzOiAoXCJyaWdodFwiID09PSBkID8gcy5yaWdodCA6IFwiY2VudGVyXCIgPT09IGQgPyBzLmNlbnRlciA6IHMubGVmdCkgKyB1LCBzdHlsZTogbnVsbCA9PSBpLndpZHRoID8gXCJcIiA6IFwid2lkdGg6XCIgKyBpLndpZHRoICsgXCI7XCIgfSkpO1xuICAgICAgfVxuICAgIH0pLCBpLmh0bWwobCksIGEpIHtcbiAgICAgIHZhciBoID0gcihzLnNvcnRhYmxlKTtpLm9mZihcImNsaWNrXCIgKyBqLCBoKS5vbihcImNsaWNrXCIgKyBqLCBoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpLnByZXZlbnREZWZhdWx0KCksIF8uY2FsbChlLCB0KHRoaXMpKSwgQi5jYWxsKGUpLCB1LmNhbGwoZSk7XG4gICAgICB9KTtcbiAgICB9aWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMub3B0aW9ucy5tdWx0aVNlbGVjdCkge1xuICAgICAgdmFyIGQgPSByKHMuc2VsZWN0Qm94KTtpLm9mZihcImNsaWNrXCIgKyBqLCBkKS5vbihcImNsaWNrXCIgKyBqLCBkLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpLnN0b3BQcm9wYWdhdGlvbigpLCB0KHRoaXMpLnByb3AoXCJjaGVja2VkXCIpID8gZS5zZWxlY3QoKSA6IGUuZGVzZWxlY3QoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfWZ1bmN0aW9uIF8odCkge1xuICAgIHZhciBlID0gdGhpcy5vcHRpb25zLmNzcyxcbiAgICAgICAgaSA9IHIoZS5pY29uKSxcbiAgICAgICAgcyA9IHQuZGF0YShcImNvbHVtbi1pZFwiKSB8fCB0LnBhcmVudHMoXCJ0aFwiKS5maXJzdCgpLmRhdGEoXCJjb2x1bW4taWRcIiksXG4gICAgICAgIG8gPSB0aGlzLnNvcnREaWN0aW9uYXJ5W3NdLFxuICAgICAgICBuID0gdC5maW5kKGkpO2lmICh0aGlzLm9wdGlvbnMubXVsdGlTb3J0IHx8ICh0LnBhcmVudHMoXCJ0clwiKS5maXJzdCgpLmZpbmQoaSkucmVtb3ZlQ2xhc3MoZS5pY29uRG93biArIFwiIFwiICsgZS5pY29uVXApLCB0aGlzLnNvcnREaWN0aW9uYXJ5ID0ge30pLCBvICYmIFwiYXNjXCIgPT09IG8pIHRoaXMuc29ydERpY3Rpb25hcnlbc10gPSBcImRlc2NcIiwgbi5yZW1vdmVDbGFzcyhlLmljb25VcCkuYWRkQ2xhc3MoZS5pY29uRG93bik7ZWxzZSBpZiAobyAmJiBcImRlc2NcIiA9PT0gbykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tdWx0aVNvcnQpIHtcbiAgICAgICAgdmFyIGwgPSB7fTtmb3IgKHZhciBhIGluIHRoaXMuc29ydERpY3Rpb25hcnkpIGEgIT09IHMgJiYgKGxbYV0gPSB0aGlzLnNvcnREaWN0aW9uYXJ5W2FdKTt0aGlzLnNvcnREaWN0aW9uYXJ5ID0gbCwgbi5yZW1vdmVDbGFzcyhlLmljb25Eb3duKTtcbiAgICAgIH0gZWxzZSB0aGlzLnNvcnREaWN0aW9uYXJ5W3NdID0gXCJhc2NcIiwgbi5yZW1vdmVDbGFzcyhlLmljb25Eb3duKS5hZGRDbGFzcyhlLmljb25VcCk7XG4gICAgfSBlbHNlIHRoaXMuc29ydERpY3Rpb25hcnlbc10gPSBcImFzY1wiLCBuLmFkZENsYXNzKGUuaWNvblVwKTtcbiAgfWZ1bmN0aW9uIEkoZSwgaSkge1xuICAgIGUuZWFjaChmdW5jdGlvbiAoZSwgcykge1xuICAgICAgdChzKS5iZWZvcmUoaS5jbG9uZSghMCkpLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9ZnVuY3Rpb24gUCgpIHtcbiAgICB2YXIgdCA9IHRoaXM7ZS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChcInRydWVcIiA9PT0gdC5lbGVtZW50Ll9iZ0FyaWEoXCJidXN5XCIpKSB7XG4gICAgICAgIHZhciBlID0gdC5vcHRpb25zLnRlbXBsYXRlcyxcbiAgICAgICAgICAgIGkgPSB0LmVsZW1lbnQuY2hpbGRyZW4oXCJ0aGVhZFwiKS5maXJzdCgpLFxuICAgICAgICAgICAgcyA9IHQuZWxlbWVudC5jaGlsZHJlbihcInRib2R5XCIpLmZpcnN0KCksXG4gICAgICAgICAgICBuID0gcy5maW5kKFwidHIgPiB0ZFwiKS5maXJzdCgpLFxuICAgICAgICAgICAgciA9IHQuZWxlbWVudC5oZWlnaHQoKSAtIGkuaGVpZ2h0KCkgLSAobi5oZWlnaHQoKSArIDIwKSxcbiAgICAgICAgICAgIGwgPSB0LmNvbHVtbnMud2hlcmUoaCkubGVuZ3RoO3Quc2VsZWN0aW9uICYmIChsICs9IDEpLCBzLmh0bWwoZS5sb2FkaW5nLnJlc29sdmUoby5jYWxsKHQsIHsgY29sdW1uczogbCB9KSkpLCAtMSAhPT0gdC5yb3dDb3VudCAmJiByID4gMCAmJiBzLmZpbmQoXCJ0ciA+IHRkXCIpLmNzcyhcInBhZGRpbmdcIiwgXCIyMHB4IDAgXCIgKyByICsgXCJweFwiKTtcbiAgICAgIH1cbiAgICB9LCAyNTApO1xuICB9ZnVuY3Rpb24gQigpIHtcbiAgICBmdW5jdGlvbiB0KGksIHMsIG8pIHtcbiAgICAgIGZ1bmN0aW9uIG4odCkge1xuICAgICAgICByZXR1cm4gXCJhc2NcIiA9PT0gbC5vcmRlciA/IHQgOiAtMSAqIHQ7XG4gICAgICB9byA9IG8gfHwgMDt2YXIgciA9IG8gKyAxLFxuICAgICAgICAgIGwgPSBlW29dO3JldHVybiBpW2wuaWRdID4gc1tsLmlkXSA/IG4oMSkgOiBpW2wuaWRdIDwgc1tsLmlkXSA/IG4oLTEpIDogZS5sZW5ndGggPiByID8gdChpLCBzLCByKSA6IDA7XG4gICAgfXZhciBlID0gW107aWYgKCF0aGlzLm9wdGlvbnMuYWpheCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnNvcnREaWN0aW9uYXJ5KSAodGhpcy5vcHRpb25zLm11bHRpU29ydCB8fCAwID09PSBlLmxlbmd0aCkgJiYgZS5wdXNoKHsgaWQ6IGksIG9yZGVyOiB0aGlzLnNvcnREaWN0aW9uYXJ5W2ldIH0pO2UubGVuZ3RoID4gMCAmJiB0aGlzLnJvd3Muc29ydCh0KTtcbiAgICB9XG4gIH12YXIgaiA9IFwiLnJzLmpxdWVyeS5ib290Z3JpZFwiLFxuICAgICAgTSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gdChlKSwgdGhpcy5vcmlnaW4gPSB0aGlzLmVsZW1lbnQuY2xvbmUoKSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoITAsIHt9LCBNLmRlZmF1bHRzLCB0aGlzLmVsZW1lbnQuZGF0YSgpLCBpKTt2YXIgcyA9IHRoaXMub3B0aW9ucy5yb3dDb3VudCA9IHRoaXMuZWxlbWVudC5kYXRhKCkucm93Q291bnQgfHwgaS5yb3dDb3VudCB8fCB0aGlzLm9wdGlvbnMucm93Q291bnQ7dGhpcy5jb2x1bW5zID0gW10sIHRoaXMuY3VycmVudCA9IDEsIHRoaXMuY3VycmVudFJvd3MgPSBbXSwgdGhpcy5pZGVudGlmaWVyID0gbnVsbCwgdGhpcy5zZWxlY3Rpb24gPSAhMSwgdGhpcy5jb252ZXJ0ZXIgPSBudWxsLCB0aGlzLnJvd0NvdW50ID0gdC5pc0FycmF5KHMpID8gc1swXSA6IHMsIHRoaXMucm93cyA9IFtdLCB0aGlzLnNlYXJjaFBocmFzZSA9IFwiXCIsIHRoaXMuc2VsZWN0ZWRSb3dzID0gW10sIHRoaXMuc29ydERpY3Rpb25hcnkgPSB7fSwgdGhpcy50b3RhbCA9IDAsIHRoaXMudG90YWxQYWdlcyA9IDAsIHRoaXMuY2FjaGVkUGFyYW1zID0geyBsYmw6IHRoaXMub3B0aW9ucy5sYWJlbHMsIGNzczogdGhpcy5vcHRpb25zLmNzcywgY3R4OiB7fSB9LCB0aGlzLmhlYWRlciA9IG51bGwsIHRoaXMuZm9vdGVyID0gbnVsbCwgdGhpcy54cXIgPSBudWxsO1xuICB9O2lmIChNLmRlZmF1bHRzID0geyBuYXZpZ2F0aW9uOiAzLCBwYWRkaW5nOiAyLCBjb2x1bW5TZWxlY3Rpb246ICEwLCByb3dDb3VudDogWzEwLCAyNSwgNTAsIC0xXSwgc2VsZWN0aW9uOiAhMSwgbXVsdGlTZWxlY3Q6ICExLCByb3dTZWxlY3Q6ICExLCBrZWVwU2VsZWN0aW9uOiAhMSwgaGlnaGxpZ2h0Um93czogITEsIHNvcnRpbmc6ICEwLCBtdWx0aVNvcnQ6ICExLCBzZWFyY2hTZXR0aW5nczogeyBkZWxheTogMjUwLCBjaGFyYWN0ZXJzOiAxIH0sIGFqYXg6ICExLCBhamF4U2V0dGluZ3M6IHsgbWV0aG9kOiBcIlBPU1RcIiB9LCBwb3N0OiB7fSwgdXJsOiBcIlwiLCBjYXNlU2Vuc2l0aXZlOiAhMCwgcmVxdWVzdEhhbmRsZXI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCByZXNwb25zZUhhbmRsZXI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBjb252ZXJ0ZXJzOiB7IG51bWVyaWM6IHsgZnJvbTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gK3Q7XG4gICAgICAgIH0sIHRvOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICsgXCJcIjtcbiAgICAgICAgfSB9LCBzdHJpbmc6IHsgZnJvbTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSwgdG86IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0gfSB9LCBjc3M6IHsgYWN0aW9uczogXCJhY3Rpb25zIGJ0bi1ncm91cFwiLCBjZW50ZXI6IFwidGV4dC1jZW50ZXJcIiwgY29sdW1uSGVhZGVyQW5jaG9yOiBcImNvbHVtbi1oZWFkZXItYW5jaG9yXCIsIGNvbHVtbkhlYWRlclRleHQ6IFwidGV4dFwiLCBkcm9wRG93bkl0ZW06IFwiZHJvcGRvd24taXRlbVwiLCBkcm9wRG93bkl0ZW1CdXR0b246IFwiZHJvcGRvd24taXRlbS1idXR0b25cIiwgZHJvcERvd25JdGVtQ2hlY2tib3g6IFwiZHJvcGRvd24taXRlbS1jaGVja2JveFwiLCBkcm9wRG93bk1lbnU6IFwiZHJvcGRvd24gYnRuLWdyb3VwXCIsIGRyb3BEb3duTWVudUl0ZW1zOiBcImRyb3Bkb3duLW1lbnUgcHVsbC1yaWdodFwiLCBkcm9wRG93bk1lbnVUZXh0OiBcImRyb3Bkb3duLXRleHRcIiwgZm9vdGVyOiBcImJvb3RncmlkLWZvb3RlciBjb250YWluZXItZmx1aWRcIiwgaGVhZGVyOiBcImJvb3RncmlkLWhlYWRlciBjb250YWluZXItZmx1aWRcIiwgaWNvbjogXCJpY29uIGdseXBoaWNvblwiLCBpY29uQ29sdW1uczogXCJnbHlwaGljb24tdGgtbGlzdFwiLCBpY29uRG93bjogXCJnbHlwaGljb24tY2hldnJvbi1kb3duXCIsIGljb25SZWZyZXNoOiBcImdseXBoaWNvbi1yZWZyZXNoXCIsIGljb25TZWFyY2g6IFwiZ2x5cGhpY29uLXNlYXJjaFwiLCBpY29uVXA6IFwiZ2x5cGhpY29uLWNoZXZyb24tdXBcIiwgaW5mb3M6IFwiaW5mb3NcIiwgbGVmdDogXCJ0ZXh0LWxlZnRcIiwgcGFnaW5hdGlvbjogXCJwYWdpbmF0aW9uXCIsIHBhZ2luYXRpb25CdXR0b246IFwiYnV0dG9uXCIsIHJlc3BvbnNpdmVUYWJsZTogXCJ0YWJsZS1yZXNwb25zaXZlXCIsIHJpZ2h0OiBcInRleHQtcmlnaHRcIiwgc2VhcmNoOiBcInNlYXJjaCBmb3JtLWdyb3VwXCIsIHNlYXJjaEZpZWxkOiBcInNlYXJjaC1maWVsZCBmb3JtLWNvbnRyb2xcIiwgc2VsZWN0Qm94OiBcInNlbGVjdC1ib3hcIiwgc2VsZWN0Q2VsbDogXCJzZWxlY3QtY2VsbFwiLCBzZWxlY3RlZDogXCJhY3RpdmVcIiwgc29ydGFibGU6IFwic29ydGFibGVcIiwgdGFibGU6IFwiYm9vdGdyaWQtdGFibGUgdGFibGVcIiB9LCBmb3JtYXR0ZXJzOiB7fSwgbGFiZWxzOiB7IGFsbDogXCJBbGxcIiwgaW5mb3M6IFwiU2hvd2luZyB7e2N0eC5zdGFydH19IHRvIHt7Y3R4LmVuZH19IG9mIHt7Y3R4LnRvdGFsfX0gZW50cmllc1wiLCBsb2FkaW5nOiBcIkxvYWRpbmcuLi5cIiwgbm9SZXN1bHRzOiBcIk5vIHJlc3VsdHMgZm91bmQhXCIsIHJlZnJlc2g6IFwiUmVmcmVzaFwiLCBzZWFyY2g6IFwiU2VhcmNoXCIgfSwgc3RhdHVzTWFwcGluZzogeyAwOiBcInN1Y2Nlc3NcIiwgMTogXCJpbmZvXCIsIDI6IFwid2FybmluZ1wiLCAzOiBcImRhbmdlclwiIH0sIHRlbXBsYXRlczogeyBhY3Rpb25CdXR0b246ICc8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgdHlwZT1cImJ1dHRvblwiIHRpdGxlPVwie3tjdHgudGV4dH19XCI+e3tjdHguY29udGVudH19PC9idXR0b24+JywgYWN0aW9uRHJvcERvd246ICc8ZGl2IGNsYXNzPVwie3tjc3MuZHJvcERvd25NZW51fX1cIj48YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGRyb3Bkb3duLXRvZ2dsZVwiIHR5cGU9XCJidXR0b25cIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCI+PHNwYW4gY2xhc3M9XCJ7e2Nzcy5kcm9wRG93bk1lbnVUZXh0fX1cIj57e2N0eC5jb250ZW50fX08L3NwYW4+IDxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+PC9idXR0b24+PHVsIGNsYXNzPVwie3tjc3MuZHJvcERvd25NZW51SXRlbXN9fVwiIHJvbGU9XCJtZW51XCI+PC91bD48L2Rpdj4nLCBhY3Rpb25Ecm9wRG93bkl0ZW06ICc8bGk+PGEgZGF0YS1hY3Rpb249XCJ7e2N0eC5hY3Rpb259fVwiIGNsYXNzPVwie3tjc3MuZHJvcERvd25JdGVtfX0ge3tjc3MuZHJvcERvd25JdGVtQnV0dG9ufX1cIj57e2N0eC50ZXh0fX08L2E+PC9saT4nLCBhY3Rpb25Ecm9wRG93bkNoZWNrYm94SXRlbTogJzxsaT48ZGl2IGNsYXNzPVwiY2hlY2tib3hcIj48bGFiZWwgY2xhc3M9XCJ7e2Nzcy5kcm9wRG93bkl0ZW19fVwiPjxpbnB1dCBuYW1lPVwie3tjdHgubmFtZX19XCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCIxXCIgY2xhc3M9XCJ7e2Nzcy5kcm9wRG93bkl0ZW1DaGVja2JveH19XCIge3tjdHguY2hlY2tlZH19IC8+IHt7Y3R4LmxhYmVsfX08aSBjbGFzcz1cImlucHV0LWhlbHBlclwiPjwvaT48L2xhYmVsPjwvZGl2PjwvbGk+JywgYWN0aW9uczogJzxkaXYgY2xhc3M9XCJ7e2Nzcy5hY3Rpb25zfX1cIj48L2Rpdj4nLCBib2R5OiBcIjx0Ym9keT48L3Rib2R5PlwiLCBjZWxsOiAnPHRkIGNsYXNzPVwie3tjdHguY3NzfX1cIiBzdHlsZT1cInt7Y3R4LnN0eWxlfX1cIj57e2N0eC5jb250ZW50fX08L3RkPicsIGZvb3RlcjogJzxkaXYgaWQ9XCJ7e2N0eC5pZH19XCIgY2xhc3M9XCJ7e2Nzcy5mb290ZXJ9fVwiPjxkaXYgY2xhc3M9XCJyb3dcIj48ZGl2IGNsYXNzPVwiY29sLXNtLTZcIj48cCBjbGFzcz1cInt7Y3NzLnBhZ2luYXRpb259fVwiPjwvcD48L2Rpdj48ZGl2IGNsYXNzPVwiY29sLXNtLTYgaW5mb0JhclwiPjxwIGNsYXNzPVwie3tjc3MuaW5mb3N9fVwiPjwvcD48L2Rpdj48L2Rpdj48L2Rpdj4nLCBoZWFkZXI6ICc8ZGl2IGlkPVwie3tjdHguaWR9fVwiIGNsYXNzPVwie3tjc3MuaGVhZGVyfX1cIj48ZGl2IGNsYXNzPVwicm93XCI+PGRpdiBjbGFzcz1cImNvbC1zbS0xMiBhY3Rpb25CYXJcIj48cCBjbGFzcz1cInt7Y3NzLnNlYXJjaH19XCI+PC9wPjxwIGNsYXNzPVwie3tjc3MuYWN0aW9uc319XCI+PC9wPjwvZGl2PjwvZGl2PjwvZGl2PicsIGhlYWRlckNlbGw6ICc8dGggZGF0YS1jb2x1bW4taWQ9XCJ7e2N0eC5jb2x1bW4uaWR9fVwiIGNsYXNzPVwie3tjdHguY3NzfX1cIiBzdHlsZT1cInt7Y3R4LnN0eWxlfX1cIj48YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiIGNsYXNzPVwie3tjc3MuY29sdW1uSGVhZGVyQW5jaG9yfX0ge3tjdHguc29ydGFibGV9fVwiPjxzcGFuIGNsYXNzPVwie3tjc3MuY29sdW1uSGVhZGVyVGV4dH19XCI+e3tjdHguY29sdW1uLnRleHR9fTwvc3Bhbj57e2N0eC5pY29ufX08L2E+PC90aD4nLCBpY29uOiAnPHNwYW4gY2xhc3M9XCJ7e2Nzcy5pY29ufX0ge3tjdHguaWNvbkNzc319XCI+PC9zcGFuPicsIGluZm9zOiAnPGRpdiBjbGFzcz1cInt7Y3NzLmluZm9zfX1cIj57e2xibC5pbmZvc319PC9kaXY+JywgbG9hZGluZzogJzx0cj48dGQgY29sc3Bhbj1cInt7Y3R4LmNvbHVtbnN9fVwiIGNsYXNzPVwibG9hZGluZ1wiPnt7bGJsLmxvYWRpbmd9fTwvdGQ+PC90cj4nLCBub1Jlc3VsdHM6ICc8dHI+PHRkIGNvbHNwYW49XCJ7e2N0eC5jb2x1bW5zfX1cIiBjbGFzcz1cIm5vLXJlc3VsdHNcIj57e2xibC5ub1Jlc3VsdHN9fTwvdGQ+PC90cj4nLCBwYWdpbmF0aW9uOiAnPHVsIGNsYXNzPVwie3tjc3MucGFnaW5hdGlvbn19XCI+PC91bD4nLCBwYWdpbmF0aW9uSXRlbTogJzxsaSBjbGFzcz1cInt7Y3R4LmNzc319XCI+PGEgZGF0YS1wYWdlPVwie3tjdHgucGFnZX19XCIgY2xhc3M9XCJ7e2Nzcy5wYWdpbmF0aW9uQnV0dG9ufX1cIj57e2N0eC50ZXh0fX08L2E+PC9saT4nLCByYXdIZWFkZXJDZWxsOiAnPHRoIGNsYXNzPVwie3tjdHguY3NzfX1cIj57e2N0eC5jb250ZW50fX08L3RoPicsIHJvdzogXCI8dHJ7e2N0eC5hdHRyfX0+e3tjdHguY2VsbHN9fTwvdHI+XCIsIHNlYXJjaDogJzxkaXYgY2xhc3M9XCJ7e2Nzcy5zZWFyY2h9fVwiPjxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cFwiPjxzcGFuIGNsYXNzPVwie3tjc3MuaWNvbn19IGlucHV0LWdyb3VwLWFkZG9uIHt7Y3NzLmljb25TZWFyY2h9fVwiPjwvc3Bhbj4gPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ7e2Nzcy5zZWFyY2hGaWVsZH19XCIgcGxhY2Vob2xkZXI9XCJ7e2xibC5zZWFyY2h9fVwiIC8+PC9kaXY+PC9kaXY+Jywgc2VsZWN0OiAnPGRpdiBjbGFzcz1cImNoZWNrYm94XCI+PGxhYmVsPjxpbnB1dCBuYW1lPVwic2VsZWN0XCIgdHlwZT1cInt7Y3R4LnR5cGV9fVwiIGNsYXNzPVwie3tjc3Muc2VsZWN0Qm94fX1cIiB2YWx1ZT1cInt7Y3R4LnZhbHVlfX1cIiB7e2N0eC5jaGVja2VkfX0gLz48aSBjbGFzcz1cImlucHV0LWhlbHBlclwiPjwvaT48L2xhYmVsPjwvZGl2PicgfSB9LCBNLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAodCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWpheCkgO2Vsc2Uge1xuICAgICAgZm9yICh2YXIgZSA9IFtdLCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspIGkuY2FsbCh0aGlzLCB0W3NdKSAmJiBlLnB1c2godFtzXSk7Qi5jYWxsKHRoaXMpLCBjLmNhbGwodGhpcywgZSksIHUuY2FsbCh0aGlzKSwgdGhpcy5lbGVtZW50LnRyaWdnZXIoXCJhcHBlbmRlZFwiICsgaiwgW2VdKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH0sIE0ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWpheCkgO2Vsc2Uge1xuICAgICAgdmFyIGUgPSB0LmV4dGVuZChbXSwgdGhpcy5yb3dzKTt0aGlzLnJvd3MgPSBbXSwgdGhpcy5jdXJyZW50ID0gMSwgdGhpcy50b3RhbCA9IDAsIHUuY2FsbCh0aGlzKSwgdGhpcy5lbGVtZW50LnRyaWdnZXIoXCJjbGVhcmVkXCIgKyBqLCBbZV0pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfSwgTS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdChlKS5vZmYoaiksIDEgJiB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbiAmJiB0aGlzLmhlYWRlci5yZW1vdmUoKSwgMiAmIHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uICYmIHRoaXMuZm9vdGVyLnJlbW92ZSgpLCB0aGlzLmVsZW1lbnQuYmVmb3JlKHRoaXMub3JpZ2luKS5yZW1vdmUoKSwgdGhpcztcbiAgfSwgTS5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQgPSAxLCB1LmNhbGwodGhpcyksIHRoaXM7XG4gIH0sIE0ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKG51bGwgIT0gdGhpcy5pZGVudGlmaWVyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFqYXgpIDtlbHNlIHtcbiAgICAgICAgdCA9IHQgfHwgdGhpcy5zZWxlY3RlZFJvd3M7Zm9yICh2YXIgZSwgaSA9IFtdLCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICBlID0gdFtzXTtmb3IgKHZhciBvID0gMDsgbyA8IHRoaXMucm93cy5sZW5ndGg7IG8rKykgaWYgKHRoaXMucm93c1tvXVt0aGlzLmlkZW50aWZpZXJdID09PSBlKSB7XG4gICAgICAgICAgICBpLnB1c2godGhpcy5yb3dzW29dKSwgdGhpcy5yb3dzLnNwbGljZShvLCAxKTticmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH10aGlzLmN1cnJlbnQgPSAxLCB1LmNhbGwodGhpcyksIHRoaXMuZWxlbWVudC50cmlnZ2VyKFwicmVtb3ZlZFwiICsgaiwgW2ldKTtcbiAgICAgIH1cbiAgICB9cmV0dXJuIHRoaXM7XG4gIH0sIE0ucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPSB0IHx8IFwiXCIsIHRoaXMuc2VhcmNoUGhyYXNlICE9PSB0KSB7XG4gICAgICB2YXIgZSA9IHIodGhpcy5vcHRpb25zLmNzcy5zZWFyY2hGaWVsZCksXG4gICAgICAgICAgaSA9IHMuY2FsbCh0aGlzLCBlKTtpLnZhbCh0KTtcbiAgICB9cmV0dXJuIFMuY2FsbCh0aGlzLCB0KSwgdGhpcztcbiAgfSwgTS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgIGUgPSBlIHx8IHRoaXMuY3VycmVudFJvd3MucHJvcFZhbHVlcyh0aGlzLmlkZW50aWZpZXIpO2ZvciAodmFyIGksIHMsIG8gPSBbXTsgZS5sZW5ndGggPiAwICYmICh0aGlzLm9wdGlvbnMubXVsdGlTZWxlY3QgfHwgMSAhPT0gby5sZW5ndGgpOykgaWYgKGkgPSBlLnBvcCgpLCAtMSA9PT0gdC5pbkFycmF5KGksIHRoaXMuc2VsZWN0ZWRSb3dzKSkgZm9yIChzID0gMDsgcyA8IHRoaXMuY3VycmVudFJvd3MubGVuZ3RoOyBzKyspIGlmICh0aGlzLmN1cnJlbnRSb3dzW3NdW3RoaXMuaWRlbnRpZmllcl0gPT09IGkpIHtcbiAgICAgICAgby5wdXNoKHRoaXMuY3VycmVudFJvd3Nbc10pLCB0aGlzLnNlbGVjdGVkUm93cy5wdXNoKGkpO2JyZWFrO1xuICAgICAgfWlmIChvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG4gPSByKHRoaXMub3B0aW9ucy5jc3Muc2VsZWN0Qm94KSxcbiAgICAgICAgICAgIGwgPSB0aGlzLnNlbGVjdGVkUm93cy5sZW5ndGggPj0gdGhpcy5jdXJyZW50Um93cy5sZW5ndGg7Zm9yIChzID0gMDsgIXRoaXMub3B0aW9ucy5rZWVwU2VsZWN0aW9uICYmIGwgJiYgcyA8IHRoaXMuY3VycmVudFJvd3MubGVuZ3RoOykgbCA9IC0xICE9PSB0LmluQXJyYXkodGhpcy5jdXJyZW50Um93c1tzKytdW3RoaXMuaWRlbnRpZmllcl0sIHRoaXMuc2VsZWN0ZWRSb3dzKTtmb3IgKHRoaXMuZWxlbWVudC5maW5kKFwidGhlYWQgXCIgKyBuKS5wcm9wKFwiY2hlY2tlZFwiLCBsKSwgdGhpcy5vcHRpb25zLm11bHRpU2VsZWN0IHx8IHRoaXMuZWxlbWVudC5maW5kKFwidGJvZHkgPiB0ciBcIiArIG4gKyBcIjpjaGVja2VkXCIpLnRyaWdnZXIoXCJjbGlja1wiICsgaiksIHMgPSAwOyBzIDwgdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoOyBzKyspIHRoaXMuZWxlbWVudC5maW5kKCd0Ym9keSA+IHRyW2RhdGEtcm93LWlkPVwiJyArIHRoaXMuc2VsZWN0ZWRSb3dzW3NdICsgJ1wiXScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jc3Muc2VsZWN0ZWQpLl9iZ0FyaWEoXCJzZWxlY3RlZFwiLCBcInRydWVcIikuZmluZChuKS5wcm9wKFwiY2hlY2tlZFwiLCAhMCk7dGhpcy5lbGVtZW50LnRyaWdnZXIoXCJzZWxlY3RlZFwiICsgaiwgW29dKTtcbiAgICAgIH1cbiAgICB9cmV0dXJuIHRoaXM7XG4gIH0sIE0ucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgIGUgPSBlIHx8IHRoaXMuY3VycmVudFJvd3MucHJvcFZhbHVlcyh0aGlzLmlkZW50aWZpZXIpO2ZvciAodmFyIGksIHMsIG8sIG4gPSBbXTsgZS5sZW5ndGggPiAwOykgaWYgKGkgPSBlLnBvcCgpLCBvID0gdC5pbkFycmF5KGksIHRoaXMuc2VsZWN0ZWRSb3dzKSwgLTEgIT09IG8pIGZvciAocyA9IDA7IHMgPCB0aGlzLmN1cnJlbnRSb3dzLmxlbmd0aDsgcysrKSBpZiAodGhpcy5jdXJyZW50Um93c1tzXVt0aGlzLmlkZW50aWZpZXJdID09PSBpKSB7XG4gICAgICAgIG4ucHVzaCh0aGlzLmN1cnJlbnRSb3dzW3NdKSwgdGhpcy5zZWxlY3RlZFJvd3Muc3BsaWNlKG8sIDEpO2JyZWFrO1xuICAgICAgfWlmIChuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGwgPSByKHRoaXMub3B0aW9ucy5jc3Muc2VsZWN0Qm94KTtmb3IgKHRoaXMuZWxlbWVudC5maW5kKFwidGhlYWQgXCIgKyBsKS5wcm9wKFwiY2hlY2tlZFwiLCAhMSksIHMgPSAwOyBzIDwgbi5sZW5ndGg7IHMrKykgdGhpcy5lbGVtZW50LmZpbmQoJ3Rib2R5ID4gdHJbZGF0YS1yb3ctaWQ9XCInICsgbltzXVt0aGlzLmlkZW50aWZpZXJdICsgJ1wiXScpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jc3Muc2VsZWN0ZWQpLl9iZ0FyaWEoXCJzZWxlY3RlZFwiLCBcImZhbHNlXCIpLmZpbmQobCkucHJvcChcImNoZWNrZWRcIiwgITEpO3RoaXMuZWxlbWVudC50cmlnZ2VyKFwiZGVzZWxlY3RlZFwiICsgaiwgW25dKTtcbiAgICAgIH1cbiAgICB9cmV0dXJuIHRoaXM7XG4gIH0sIE0ucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpID0gZSA/IHQuZXh0ZW5kKHt9LCBlKSA6IHt9O3JldHVybiBpID09PSB0aGlzLnNvcnREaWN0aW9uYXJ5ID8gdGhpcyA6ICh0aGlzLnNvcnREaWN0aW9uYXJ5ID0gaSwgUi5jYWxsKHRoaXMpLCBCLmNhbGwodGhpcyksIHUuY2FsbCh0aGlzKSwgdGhpcyk7XG4gIH0sIE0ucHJvdG90eXBlLmdldENvbHVtblNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0Lm1lcmdlKFtdLCB0aGlzLmNvbHVtbnMpO1xuICB9LCBNLnByb3RvdHlwZS5nZXRDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9LCBNLnByb3RvdHlwZS5nZXRDdXJyZW50Um93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdC5tZXJnZShbXSwgdGhpcy5jdXJyZW50Um93cyk7XG4gIH0sIE0ucHJvdG90eXBlLmdldFJvd0NvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJvd0NvdW50O1xuICB9LCBNLnByb3RvdHlwZS5nZXRTZWFyY2hQaHJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoUGhyYXNlO1xuICB9LCBNLnByb3RvdHlwZS5nZXRTZWxlY3RlZFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHQubWVyZ2UoW10sIHRoaXMuc2VsZWN0ZWRSb3dzKTtcbiAgfSwgTS5wcm90b3R5cGUuZ2V0U29ydERpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHQuZXh0ZW5kKHt9LCB0aGlzLnNvcnREaWN0aW9uYXJ5KTtcbiAgfSwgTS5wcm90b3R5cGUuZ2V0VG90YWxQYWdlQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxQYWdlcztcbiAgfSwgTS5wcm90b3R5cGUuZ2V0VG90YWxSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbDtcbiAgfSwgdC5mbi5leHRlbmQoeyBfYmdBcmlhOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIGUgPyB0aGlzLmF0dHIoXCJhcmlhLVwiICsgdCwgZSkgOiB0aGlzLmF0dHIoXCJhcmlhLVwiICsgdCk7XG4gICAgfSwgX2JnQnVzeUFyaWE6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbnVsbCA9PSB0IHx8IHQgPyB0aGlzLl9iZ0FyaWEoXCJidXN5XCIsIFwidHJ1ZVwiKSA6IHRoaXMuX2JnQXJpYShcImJ1c3lcIiwgXCJmYWxzZVwiKTtcbiAgICB9LCBfYmdSZW1vdmVBcmlhOiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQXR0cihcImFyaWEtXCIgKyB0KTtcbiAgICB9LCBfYmdFbmFibGVBcmlhOiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG51bGwgPT0gdCB8fCB0ID8gdGhpcy5yZW1vdmVDbGFzcyhcImRpc2FibGVkXCIpLl9iZ0FyaWEoXCJkaXNhYmxlZFwiLCBcImZhbHNlXCIpIDogdGhpcy5hZGRDbGFzcyhcImRpc2FibGVkXCIpLl9iZ0FyaWEoXCJkaXNhYmxlZFwiLCBcInRydWVcIik7XG4gICAgfSwgX2JnRW5hYmxlRmllbGQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbnVsbCA9PSB0IHx8IHQgPyB0aGlzLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKSA6IHRoaXMuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZVwiKTtcbiAgICB9LCBfYmdTaG93QXJpYTogZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBudWxsID09IHQgfHwgdCA/IHRoaXMuc2hvdygpLl9iZ0FyaWEoXCJoaWRkZW5cIiwgXCJmYWxzZVwiKSA6IHRoaXMuaGlkZSgpLl9iZ0FyaWEoXCJoaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIH0sIF9iZ1NlbGVjdEFyaWE6IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbnVsbCA9PSB0IHx8IHQgPyB0aGlzLmFkZENsYXNzKFwiYWN0aXZlXCIpLl9iZ0FyaWEoXCJzZWxlY3RlZFwiLCBcInRydWVcIikgOiB0aGlzLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLl9iZ0FyaWEoXCJzZWxlY3RlZFwiLCBcImZhbHNlXCIpO1xuICAgIH0sIF9iZ0lkOiBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQgPyB0aGlzLmF0dHIoXCJpZFwiLCB0KSA6IHRoaXMuYXR0cihcImlkXCIpO1xuICAgIH0gfSksICFTdHJpbmcucHJvdG90eXBlLnJlc29sdmUpIHtcbiAgICB2YXIgVCA9IHsgY2hlY2tlZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiID09IHR5cGVvZiB0ID8gdCA/ICdjaGVja2VkPVwiY2hlY2tlZFwiJyA6IFwiXCIgOiB0O1xuICAgICAgfSB9O1N0cmluZy5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgcyA9IHRoaXM7cmV0dXJuIHQuZWFjaChlLCBmdW5jdGlvbiAoZSwgbykge1xuICAgICAgICBpZiAobnVsbCAhPSBvICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbykgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIG8pIHtcbiAgICAgICAgICB2YXIgbiA9IGkgPyB0LmV4dGVuZChbXSwgaSkgOiBbXTtuLnB1c2goZSksIHMgPSBzLnJlc29sdmUobywgbikgKyBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFQgJiYgVFtlXSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFRbZV0gJiYgKG8gPSBUW2VdKG8pKSwgZSA9IGkgPyBpLmpvaW4oXCIuXCIpICsgXCIuXCIgKyBlIDogZTt2YXIgciA9IG5ldyBSZWdFeHAoXCJcXFxce1xcXFx7XCIgKyBlICsgXCJcXFxcfVxcXFx9XCIsIFwiZ21cIik7cyA9IHMucmVwbGFjZShyLCBvLnJlcGxhY2UgPyBvLnJlcGxhY2UoL1xcJC9naSwgXCImIzM2O1wiKSA6IG8pO1xuICAgICAgICB9XG4gICAgICB9KSwgcztcbiAgICB9O1xuICB9QXJyYXkucHJvdG90eXBlLmZpcnN0IHx8IChBcnJheS5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAodCkge1xuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdGhpcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGkgPSB0aGlzW2VdO2lmICh0KGkpKSByZXR1cm4gaTtcbiAgICB9cmV0dXJuIG51bGw7XG4gIH0pLCBBcnJheS5wcm90b3R5cGUuY29udGFpbnMgfHwgKEFycmF5LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgaSA9IHRoaXNbZV07aWYgKHQoaSkpIHJldHVybiAhMDtcbiAgICB9cmV0dXJuICExO1xuICB9KSwgQXJyYXkucHJvdG90eXBlLnBhZ2UgfHwgKEFycmF5LnByb3RvdHlwZS5wYWdlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICB2YXIgaSA9ICh0IC0gMSkgKiBlLFxuICAgICAgICBzID0gaSArIGU7cmV0dXJuIHRoaXMubGVuZ3RoID4gaSA/IHRoaXMubGVuZ3RoID4gcyA/IHRoaXMuc2xpY2UoaSwgcykgOiB0aGlzLnNsaWNlKGkpIDogW107XG4gIH0pLCBBcnJheS5wcm90b3R5cGUud2hlcmUgfHwgKEFycmF5LnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgZm9yICh2YXIgZSA9IFtdLCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzID0gdGhpc1tpXTt0KHMpICYmIGUucHVzaChzKTtcbiAgICB9cmV0dXJuIGU7XG4gIH0pLCBBcnJheS5wcm90b3R5cGUucHJvcFZhbHVlcyB8fCAoQXJyYXkucHJvdG90eXBlLnByb3BWYWx1ZXMgPSBmdW5jdGlvbiAodCkge1xuICAgIGZvciAodmFyIGUgPSBbXSwgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSBlLnB1c2godGhpc1tpXVt0XSk7cmV0dXJuIGU7XG4gIH0pO3ZhciBFID0gdC5mbi5ib290Z3JpZDt0LmZuLmJvb3RncmlkID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIHMgPSBudWxsLFxuICAgICAgICBvID0gdGhpcy5lYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgbiA9IHQodGhpcyksXG4gICAgICAgICAgciA9IG4uZGF0YShqKSxcbiAgICAgICAgICBsID0gXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBlO2lmICgociB8fCBcImRlc3Ryb3lcIiAhPT0gZSkgJiYgKHIgfHwgKG4uZGF0YShqLCByID0gbmV3IE0odGhpcywgbCkpLCBhLmNhbGwocikpLCBcInN0cmluZ1wiID09IHR5cGVvZiBlKSkgaWYgKDAgPT09IGUuaW5kZXhPZihcImdldFwiKSAmJiAwID09PSBvKSBzID0gcltlXS5hcHBseShyLCBpKTtlbHNlIGlmICgwICE9PSBlLmluZGV4T2YoXCJnZXRcIikpIHJldHVybiByW2VdLmFwcGx5KHIsIGkpO1xuICAgIH0pO3JldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBlICYmIDAgPT09IGUuaW5kZXhPZihcImdldFwiKSA/IHMgOiBvO1xuICB9LCB0LmZuLmJvb3RncmlkLkNvbnN0cnVjdG9yID0gTSwgdC5mbi5ib290Z3JpZC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0LmZuLmJvb3RncmlkID0gRSwgdGhpcztcbiAgfSwgdCgnW2RhdGEtdG9nZ2xlPVwiYm9vdGdyaWRcIl0nKS5ib290Z3JpZCgpO1xufShqUXVlcnksIHdpbmRvdyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvY29tcG9uZW50cy9ib290Z3JpZC9qcXVlcnkuYm9vdGdyaWQudXBkYXRlZC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDExIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==');
},116:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function () {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype,\n      FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeBind = FuncProto.bind,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function () {};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function (obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function (func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1:\n        return function (value) {\n          return func.call(context, value);\n        };\n      case 2:\n        return function (value, other) {\n          return func.call(context, value, other);\n        };\n      case 3:\n        return function (value, index, collection) {\n          return func.call(context, value, index, collection);\n        };\n      case 4:\n        return function (accumulator, value, index, collection) {\n          return func.call(context, accumulator, value, index, collection);\n        };\n    }\n    return function () {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function (value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function (value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function (keysFunc, undefinedOnly) {\n    return function (obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function (prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor();\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function (key) {\n    return function (obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function (collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function (obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function (obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function (obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function (obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function (obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function (value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function (obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function (obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function (obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function (obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function (value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function (obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function (obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function (obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function (obj, iteratee, context) {\n    var result = -Infinity,\n        lastComputed = -Infinity,\n        value,\n        computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function (value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function (obj, iteratee, context) {\n    var result = Infinity,\n        lastComputed = Infinity,\n        value,\n        computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function (value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function (obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function (obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function (obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function (value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function (left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function (behavior) {\n    return function (obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function (value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function (result, value, key) {\n    if (_.has(result, key)) result[key].push(value);else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function (result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function (result, value, key) {\n    if (_.has(result, key)) result[key]++;else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function (obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function (obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function (obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [],\n        fail = [];\n    _.each(obj, function (value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function (array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function (array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function (array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function (array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function (array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function (input, shallow, strict, startIndex) {\n    var output = [],\n        idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0,\n            len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function (array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function (array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function (array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function () {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function (array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function (array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function (value) {\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function () {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function (array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function (list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function (array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function (array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0,\n        high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function (array, item, idx) {\n      var i = 0,\n          length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function (start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function (sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function (func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function () {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function (func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function () {\n      var position = 0,\n          length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function (obj) {\n    var i,\n        length = arguments.length,\n        key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function (func, hasher) {\n    var memoize = function (key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function (func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function () {\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function (func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function () {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function () {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function (func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function () {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function () {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function (func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function (predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function () {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function (times, func) {\n    return function () {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function (times, func) {\n    var memo;\n    return function () {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function (obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function (obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function (obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function (obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {},\n        currentKey;\n    for (var index = 0; index < length; index++) {\n      currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function (obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function (obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function (obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function (obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj),\n        key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function (object, oiteratee, context) {\n    var result = {},\n        obj = object,\n        iteratee,\n        keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function (value, key, obj) {\n        return key in obj;\n      };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = function (obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function (value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function (prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function (obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function (obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function (object, attrs) {\n    var keys = _.keys(attrs),\n        length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function (a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor,\n          bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a),\n          key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function (a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function (obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function (obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function (obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function (obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (name) {\n    _['is' + name] = function (obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function (obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function (obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function (obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function (obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function (obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function (obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function (obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function (obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function () {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function (value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function (value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.noop = function () {};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function (obj) {\n    return obj == null ? function () {} : function (key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function (attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function (obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function (min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function () {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function (map) {\n    var escaper = function (match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function (string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function (object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function (prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function (match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function (text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function(){__p+=__j.call(arguments,'');};\\n\" + source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function (data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function (obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function (instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function (obj) {\n    _.each(_.functions(obj), function (name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function () {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function () {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function (name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function () {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function () {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function () {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return _;\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanM/ZjUwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguM1xuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXIgcHVzaCA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIHRvU3RyaW5nID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgICAgbmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzLFxuICAgICAgbmF0aXZlQmluZCA9IEZ1bmNQcm90by5iaW5kLFxuICAgICAgbmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24gKCkge307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9O1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24gKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uIChwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3IoKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3RcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBwcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAvLyBpbiB0aGUgbWFpbiBmdW5jdGlvbiB3aWxsIGRlb3B0aW1pemUgdGhlLCBzZWUgIzE5OTEuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbiAob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbiAob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uIChvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbiAob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uIChvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uIChvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksXG4gICAgICAgIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSxcbiAgICAgICAgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbiAob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uIChiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7ZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uIChyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrO2Vsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uIChvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSxcbiAgICAgICAgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbiAoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbiAoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uIChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbiAoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBzdGFydEluZGV4KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICBpZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xuICAgICAgICB2YXIgaiA9IDAsXG4gICAgICAgICAgICBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24gKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24gKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbiAobGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgobGlzdCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLFxuICAgICAgICBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTtlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlbmd0aCA9IGlkeCA+PSAwID8gTWF0aC5taW4oaWR4ICsgMSwgbGVuZ3RoKSA6IGlkeCArIGxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkSW5kZXggJiYgaWR4ICYmIGxlbmd0aCkge1xuICAgICAgICBpZHggPSBzb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpZHhdID09PSBpdGVtID8gaWR4IDogLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICBpZHggPSBwcmVkaWNhdGVGaW5kKHNsaWNlLmNhbGwoYXJyYXksIGksIGxlbmd0aCksIF8uaXNOYU4pO1xuICAgICAgICByZXR1cm4gaWR4ID49IDAgPyBpZHggKyBpIDogLTE7XG4gICAgICB9XG4gICAgICBmb3IgKGlkeCA9IGRpciA+IDAgPyBpIDogbGVuZ3RoIC0gMTsgaWR4ID49IDAgJiYgaWR4IDwgbGVuZ3RoOyBpZHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbiAoc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24gKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24gKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uIChmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24gKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbiAodGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24gKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7IHRvU3RyaW5nOiBudWxsIH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSBfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgY3VycmVudEtleTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbiAob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksXG4gICAgICAgIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24gKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgICBvYmogPSBvYmplY3QsXG4gICAgICAgIGl0ZXJhdGVlLFxuICAgICAgICBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiBvYmo7XG4gICAgICB9O1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uIChvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbiAob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSxcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbiAoYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsXG4gICAgICAgICAgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpICYmICdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSxcbiAgICAgICAgICBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24gKCkge30gOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24gKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZTogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZTogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICsgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICsgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG5cbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDExIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");
},117:function(module,exports){eval('module.exports = "<section id=main> <section id=content> <div class=container> <div class=block-header> <h2>动态数据表格</h2> <small>这里使用的是<code>jquery.bootgrid</code>这个插件，详情请查看<a href=http://www.jquery-bootgrid.com/ >官方网站</a></small> <ul class=actions> <li> <a href=\\"\\"> <i class=\\"zmdi zmdi-trending-up\\"></i> </a> </li> <li> <a href=\\"\\"> <i class=\\"zmdi zmdi-check-all\\"></i> </a> </li> <li class=dropdown> <a href=\\"\\" data-toggle=dropdown> <i class=\\"zmdi zmdi-more-vert\\"></i> </a> <ul class=\\"dropdown-menu dropdown-menu-right\\"> <li> <a href=\\"\\">Refresh</a> </li> <li> <a href=\\"\\">Manage Widgets</a> </li> <li> <a href=\\"\\">Widgets Settings</a> </li> </ul> </li> </ul> </div> <div class=card> <div class=card-header> <h2>Basic Example <small>It\'s just that simple. Turn your simple table into a sophisticated data table and offer your users a nice experience and great features without any effort.</small></h2> </div> <div class=table-responsive> <table id=data-table-basic class=\\"table table-striped\\"> <thead> <tr> <th data-column-id=id data-type=numeric>ID</th> <th data-column-id=sender>Sender</th> <th data-column-id=received data-order=desc>Received</th> </tr> </thead> <tbody> <tr> <td>10238</td> <td>eduardo@pingpong.com</td> <td>14.10.2013</td> </tr> <tr> <td>10243</td> <td>eduardo@pingpong.com</td> <td>19.10.2013</td> </tr> <tr> <td>10248</td> <td>eduardo@pingpong.com</td> <td>24.10.2013</td> </tr> <tr> <td>10253</td> <td>eduardo@pingpong.com</td> <td>29.10.2013</td> </tr> <tr> <td>10234</td> <td>lila@google.com</td> <td>10.10.2013</td> </tr> <tr> <td>10239</td> <td>lila@google.com</td> <td>15.10.2013</td> </tr> <tr> <td>10244</td> <td>lila@google.com</td> <td>20.10.2013</td> </tr> <tr> <td>10249</td> <td>lila@google.com</td> <td>25.10.2013</td> </tr> <tr> <td>10237</td> <td>robert@bingo.com</td> <td>13.10.2013</td> </tr> <tr> <td>10242</td> <td>robert@bingo.com</td> <td>18.10.2013</td> </tr> <tr> <td>10247</td> <td>robert@bingo.com</td> <td>23.10.2013</td> </tr> <tr> <td>10252</td> <td>robert@bingo.com</td> <td>28.10.2013</td> </tr> <tr> <td>10236</td> <td>simon@yahoo.com</td> <td>12.10.2013</td> </tr> <tr> <td>10241</td> <td>simon@yahoo.com</td> <td>17.10.2013</td> </tr> <tr> <td>10246</td> <td>simon@yahoo.com</td> <td>22.10.2013</td> </tr> <tr> <td>10251</td> <td>simon@yahoo.com</td> <td>27.10.2013</td> </tr> <tr> <td>10235</td> <td>tim@microsoft.com</td> <td>11.10.2013</td> </tr> <tr> <td>10240</td> <td>tim@microsoft.com</td> <td>16.10.2013</td> </tr> <tr> <td>10245</td> <td>tim@microsoft.com</td> <td>21.10.2013</td> </tr> <tr> <td>10250</td> <td>tim@microsoft.com</td> <td>26.10.2013</td> </tr> </tbody> </table> </div> </div> <div class=card> <div class=card-header> <h2>Selection Example <small>Ensure that the data attribute [data-identifier=\\"true\\"] is set on one column header.</small></h2> </div> <div class=table-responsive> <table id=data-table-selection class=\\"table table-striped\\"> <thead> <tr> <th data-column-id=id data-type=numeric data-identifier=true>ID</th> <th data-column-id=sender>Sender</th> <th data-column-id=received data-order=desc>Received</th> </tr> </thead> <tbody> <tr> <td>10238</td> <td>eduardo@pingpong.com</td> <td>14.10.2013</td> </tr> <tr> <td>10243</td> <td>eduardo@pingpong.com</td> <td>19.10.2013</td> </tr> <tr> <td>10248</td> <td>eduardo@pingpong.com</td> <td>24.10.2013</td> </tr> <tr> <td>10253</td> <td>eduardo@pingpong.com</td> <td>29.10.2013</td> </tr> <tr> <td>10234</td> <td>lila@google.com</td> <td>10.10.2013</td> </tr> <tr> <td>10239</td> <td>lila@google.com</td> <td>15.10.2013</td> </tr> <tr> <td>10244</td> <td>lila@google.com</td> <td>20.10.2013</td> </tr> <tr> <td>10249</td> <td>lila@google.com</td> <td>25.10.2013</td> </tr> <tr> <td>10237</td> <td>robert@bingo.com</td> <td>13.10.2013</td> </tr> <tr> <td>10242</td> <td>robert@bingo.com</td> <td>18.10.2013</td> </tr> <tr> <td>10247</td> <td>robert@bingo.com</td> <td>23.10.2013</td> </tr> <tr> <td>10252</td> <td>robert@bingo.com</td> <td>28.10.2013</td> </tr> <tr> <td>10236</td> <td>simon@yahoo.com</td> <td>12.10.2013</td> </tr> <tr> <td>10241</td> <td>simon@yahoo.com</td> <td>17.10.2013</td> </tr> <tr> <td>10246</td> <td>simon@yahoo.com</td> <td>22.10.2013</td> </tr> <tr> <td>10251</td> <td>simon@yahoo.com</td> <td>27.10.2013</td> </tr> <tr> <td>10235</td> <td>tim@microsoft.com</td> <td>11.10.2013</td> </tr> <tr> <td>10240</td> <td>tim@microsoft.com</td> <td>16.10.2013</td> </tr> <tr> <td>10245</td> <td>tim@microsoft.com</td> <td>21.10.2013</td> </tr> <tr> <td>10250</td> <td>tim@microsoft.com</td> <td>26.10.2013</td> </tr> </tbody> </table> </div> </div> <div class=card> <div class=card-header> <h2>Selection Example <small>Ensure that the data attribute [data-identifier=\\"true\\"] is set on one column header.</small></h2> </div> <table id=data-table-command class=\\"table table-striped table-vmiddle\\"> <thead> <tr> <th data-column-id=id data-type=numeric>ID</th> <th data-column-id=sender>Sender</th> <th data-column-id=received data-order=desc>Received</th> <th data-column-id=commands data-formatter=commands data-sortable=false>Commands</th> </tr> </thead> <tbody> <tr> <td>10238</td> <td>eduardo@pingpong.com</td> <td>14.10.2013</td> </tr> <tr> <td>10243</td> <td>eduardo@pingpong.com</td> <td>19.10.2013</td> </tr> <tr> <td>10248</td> <td>eduardo@pingpong.com</td> <td>24.10.2013</td> </tr> <tr> <td>10253</td> <td>eduardo@pingpong.com</td> <td>29.10.2013</td> </tr> <tr> <td>10234</td> <td>lila@google.com</td> <td>10.10.2013</td> </tr> <tr> <td>10239</td> <td>lila@google.com</td> <td>15.10.2013</td> </tr> <tr> <td>10244</td> <td>lila@google.com</td> <td>20.10.2013</td> </tr> <tr> <td>10249</td> <td>lila@google.com</td> <td>25.10.2013</td> </tr> <tr> <td>10237</td> <td>robert@bingo.com</td> <td>13.10.2013</td> </tr> <tr> <td>10242</td> <td>robert@bingo.com</td> <td>18.10.2013</td> </tr> <tr> <td>10247</td> <td>robert@bingo.com</td> <td>23.10.2013</td> </tr> <tr> <td>10252</td> <td>robert@bingo.com</td> <td>28.10.2013</td> </tr> <tr> <td>10236</td> <td>simon@yahoo.com</td> <td>12.10.2013</td> </tr> <tr> <td>10241</td> <td>simon@yahoo.com</td> <td>17.10.2013</td> </tr> <tr> <td>10246</td> <td>simon@yahoo.com</td> <td>22.10.2013</td> </tr> <tr> <td>10251</td> <td>simon@yahoo.com</td> <td>27.10.2013</td> </tr> <tr> <td>10235</td> <td>tim@microsoft.com</td> <td>11.10.2013</td> </tr> <tr> <td>10240</td> <td>tim@microsoft.com</td> <td>16.10.2013</td> </tr> <tr> <td>10245</td> <td>tim@microsoft.com</td> <td>21.10.2013</td> </tr> <tr> <td>10250</td> <td>tim@microsoft.com</td> <td>26.10.2013</td> </tr> </tbody> </table> </div> </div> </section> </section> ";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhZ2UvZGVtby90cGwvZGF0YXRhYmxlcy5odG1sP2RhMzQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjxzZWN0aW9uIGlkPW1haW4+IDxzZWN0aW9uIGlkPWNvbnRlbnQ+IDxkaXYgY2xhc3M9Y29udGFpbmVyPiA8ZGl2IGNsYXNzPWJsb2NrLWhlYWRlcj4gPGgyPuWKqOaAgeaVsOaNruihqOagvDwvaDI+IDxzbWFsbD7ov5nph4zkvb/nlKjnmoTmmK88Y29kZT5qcXVlcnkuYm9vdGdyaWQ8L2NvZGU+6L+Z5Liq5o+S5Lu277yM6K+m5oOF6K+35p+l55yLPGEgaHJlZj1odHRwOi8vd3d3LmpxdWVyeS1ib290Z3JpZC5jb20vID7lrpjmlrnnvZHnq5k8L2E+PC9zbWFsbD4gPHVsIGNsYXNzPWFjdGlvbnM+IDxsaT4gPGEgaHJlZj1cXFwiXFxcIj4gPGkgY2xhc3M9XFxcInptZGkgem1kaS10cmVuZGluZy11cFxcXCI+PC9pPiA8L2E+IDwvbGk+IDxsaT4gPGEgaHJlZj1cXFwiXFxcIj4gPGkgY2xhc3M9XFxcInptZGkgem1kaS1jaGVjay1hbGxcXFwiPjwvaT4gPC9hPiA8L2xpPiA8bGkgY2xhc3M9ZHJvcGRvd24+IDxhIGhyZWY9XFxcIlxcXCIgZGF0YS10b2dnbGU9ZHJvcGRvd24+IDxpIGNsYXNzPVxcXCJ6bWRpIHptZGktbW9yZS12ZXJ0XFxcIj48L2k+IDwvYT4gPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51IGRyb3Bkb3duLW1lbnUtcmlnaHRcXFwiPiA8bGk+IDxhIGhyZWY9XFxcIlxcXCI+UmVmcmVzaDwvYT4gPC9saT4gPGxpPiA8YSBocmVmPVxcXCJcXFwiPk1hbmFnZSBXaWRnZXRzPC9hPiA8L2xpPiA8bGk+IDxhIGhyZWY9XFxcIlxcXCI+V2lkZ2V0cyBTZXR0aW5nczwvYT4gPC9saT4gPC91bD4gPC9saT4gPC91bD4gPC9kaXY+IDxkaXYgY2xhc3M9Y2FyZD4gPGRpdiBjbGFzcz1jYXJkLWhlYWRlcj4gPGgyPkJhc2ljIEV4YW1wbGUgPHNtYWxsPkl0J3MganVzdCB0aGF0IHNpbXBsZS4gVHVybiB5b3VyIHNpbXBsZSB0YWJsZSBpbnRvIGEgc29waGlzdGljYXRlZCBkYXRhIHRhYmxlIGFuZCBvZmZlciB5b3VyIHVzZXJzIGEgbmljZSBleHBlcmllbmNlIGFuZCBncmVhdCBmZWF0dXJlcyB3aXRob3V0IGFueSBlZmZvcnQuPC9zbWFsbD48L2gyPiA8L2Rpdj4gPGRpdiBjbGFzcz10YWJsZS1yZXNwb25zaXZlPiA8dGFibGUgaWQ9ZGF0YS10YWJsZS1iYXNpYyBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZFxcXCI+IDx0aGVhZD4gPHRyPiA8dGggZGF0YS1jb2x1bW4taWQ9aWQgZGF0YS10eXBlPW51bWVyaWM+SUQ8L3RoPiA8dGggZGF0YS1jb2x1bW4taWQ9c2VuZGVyPlNlbmRlcjwvdGg+IDx0aCBkYXRhLWNvbHVtbi1pZD1yZWNlaXZlZCBkYXRhLW9yZGVyPWRlc2M+UmVjZWl2ZWQ8L3RoPiA8L3RyPiA8L3RoZWFkPiA8dGJvZHk+IDx0cj4gPHRkPjEwMjM4PC90ZD4gPHRkPmVkdWFyZG9AcGluZ3BvbmcuY29tPC90ZD4gPHRkPjE0LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0MzwvdGQ+IDx0ZD5lZHVhcmRvQHBpbmdwb25nLmNvbTwvdGQ+IDx0ZD4xOS4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDg8L3RkPiA8dGQ+ZWR1YXJkb0BwaW5ncG9uZy5jb208L3RkPiA8dGQ+MjQuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjUzPC90ZD4gPHRkPmVkdWFyZG9AcGluZ3BvbmcuY29tPC90ZD4gPHRkPjI5LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDIzNDwvdGQ+IDx0ZD5saWxhQGdvb2dsZS5jb208L3RkPiA8dGQ+MTAuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjM5PC90ZD4gPHRkPmxpbGFAZ29vZ2xlLmNvbTwvdGQ+IDx0ZD4xNS4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDQ8L3RkPiA8dGQ+bGlsYUBnb29nbGUuY29tPC90ZD4gPHRkPjIwLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0OTwvdGQ+IDx0ZD5saWxhQGdvb2dsZS5jb208L3RkPiA8dGQ+MjUuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjM3PC90ZD4gPHRkPnJvYmVydEBiaW5nby5jb208L3RkPiA8dGQ+MTMuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQyPC90ZD4gPHRkPnJvYmVydEBiaW5nby5jb208L3RkPiA8dGQ+MTguMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQ3PC90ZD4gPHRkPnJvYmVydEBiaW5nby5jb208L3RkPiA8dGQ+MjMuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjUyPC90ZD4gPHRkPnJvYmVydEBiaW5nby5jb208L3RkPiA8dGQ+MjguMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjM2PC90ZD4gPHRkPnNpbW9uQHlhaG9vLmNvbTwvdGQ+IDx0ZD4xMi4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDE8L3RkPiA8dGQ+c2ltb25AeWFob28uY29tPC90ZD4gPHRkPjE3LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0NjwvdGQ+IDx0ZD5zaW1vbkB5YWhvby5jb208L3RkPiA8dGQ+MjIuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjUxPC90ZD4gPHRkPnNpbW9uQHlhaG9vLmNvbTwvdGQ+IDx0ZD4yNy4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyMzU8L3RkPiA8dGQ+dGltQG1pY3Jvc29mdC5jb208L3RkPiA8dGQ+MTEuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQwPC90ZD4gPHRkPnRpbUBtaWNyb3NvZnQuY29tPC90ZD4gPHRkPjE2LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0NTwvdGQ+IDx0ZD50aW1AbWljcm9zb2Z0LmNvbTwvdGQ+IDx0ZD4yMS4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNTA8L3RkPiA8dGQ+dGltQG1pY3Jvc29mdC5jb208L3RkPiA8dGQ+MjYuMTAuMjAxMzwvdGQ+IDwvdHI+IDwvdGJvZHk+IDwvdGFibGU+IDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1jYXJkPiA8ZGl2IGNsYXNzPWNhcmQtaGVhZGVyPiA8aDI+U2VsZWN0aW9uIEV4YW1wbGUgPHNtYWxsPkVuc3VyZSB0aGF0IHRoZSBkYXRhIGF0dHJpYnV0ZSBbZGF0YS1pZGVudGlmaWVyPVxcXCJ0cnVlXFxcIl0gaXMgc2V0IG9uIG9uZSBjb2x1bW4gaGVhZGVyLjwvc21hbGw+PC9oMj4gPC9kaXY+IDxkaXYgY2xhc3M9dGFibGUtcmVzcG9uc2l2ZT4gPHRhYmxlIGlkPWRhdGEtdGFibGUtc2VsZWN0aW9uIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1zdHJpcGVkXFxcIj4gPHRoZWFkPiA8dHI+IDx0aCBkYXRhLWNvbHVtbi1pZD1pZCBkYXRhLXR5cGU9bnVtZXJpYyBkYXRhLWlkZW50aWZpZXI9dHJ1ZT5JRDwvdGg+IDx0aCBkYXRhLWNvbHVtbi1pZD1zZW5kZXI+U2VuZGVyPC90aD4gPHRoIGRhdGEtY29sdW1uLWlkPXJlY2VpdmVkIGRhdGEtb3JkZXI9ZGVzYz5SZWNlaXZlZDwvdGg+IDwvdHI+IDwvdGhlYWQ+IDx0Ym9keT4gPHRyPiA8dGQ+MTAyMzg8L3RkPiA8dGQ+ZWR1YXJkb0BwaW5ncG9uZy5jb208L3RkPiA8dGQ+MTQuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQzPC90ZD4gPHRkPmVkdWFyZG9AcGluZ3BvbmcuY29tPC90ZD4gPHRkPjE5LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0ODwvdGQ+IDx0ZD5lZHVhcmRvQHBpbmdwb25nLmNvbTwvdGQ+IDx0ZD4yNC4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNTM8L3RkPiA8dGQ+ZWR1YXJkb0BwaW5ncG9uZy5jb208L3RkPiA8dGQ+MjkuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjM0PC90ZD4gPHRkPmxpbGFAZ29vZ2xlLmNvbTwvdGQ+IDx0ZD4xMC4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyMzk8L3RkPiA8dGQ+bGlsYUBnb29nbGUuY29tPC90ZD4gPHRkPjE1LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0NDwvdGQ+IDx0ZD5saWxhQGdvb2dsZS5jb208L3RkPiA8dGQ+MjAuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQ5PC90ZD4gPHRkPmxpbGFAZ29vZ2xlLmNvbTwvdGQ+IDx0ZD4yNS4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyMzc8L3RkPiA8dGQ+cm9iZXJ0QGJpbmdvLmNvbTwvdGQ+IDx0ZD4xMy4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDI8L3RkPiA8dGQ+cm9iZXJ0QGJpbmdvLmNvbTwvdGQ+IDx0ZD4xOC4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDc8L3RkPiA8dGQ+cm9iZXJ0QGJpbmdvLmNvbTwvdGQ+IDx0ZD4yMy4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNTI8L3RkPiA8dGQ+cm9iZXJ0QGJpbmdvLmNvbTwvdGQ+IDx0ZD4yOC4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyMzY8L3RkPiA8dGQ+c2ltb25AeWFob28uY29tPC90ZD4gPHRkPjEyLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0MTwvdGQ+IDx0ZD5zaW1vbkB5YWhvby5jb208L3RkPiA8dGQ+MTcuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQ2PC90ZD4gPHRkPnNpbW9uQHlhaG9vLmNvbTwvdGQ+IDx0ZD4yMi4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNTE8L3RkPiA8dGQ+c2ltb25AeWFob28uY29tPC90ZD4gPHRkPjI3LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDIzNTwvdGQ+IDx0ZD50aW1AbWljcm9zb2Z0LmNvbTwvdGQ+IDx0ZD4xMS4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDA8L3RkPiA8dGQ+dGltQG1pY3Jvc29mdC5jb208L3RkPiA8dGQ+MTYuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQ1PC90ZD4gPHRkPnRpbUBtaWNyb3NvZnQuY29tPC90ZD4gPHRkPjIxLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI1MDwvdGQ+IDx0ZD50aW1AbWljcm9zb2Z0LmNvbTwvdGQ+IDx0ZD4yNi4xMC4yMDEzPC90ZD4gPC90cj4gPC90Ym9keT4gPC90YWJsZT4gPC9kaXY+IDwvZGl2PiA8ZGl2IGNsYXNzPWNhcmQ+IDxkaXYgY2xhc3M9Y2FyZC1oZWFkZXI+IDxoMj5TZWxlY3Rpb24gRXhhbXBsZSA8c21hbGw+RW5zdXJlIHRoYXQgdGhlIGRhdGEgYXR0cmlidXRlIFtkYXRhLWlkZW50aWZpZXI9XFxcInRydWVcXFwiXSBpcyBzZXQgb24gb25lIGNvbHVtbiBoZWFkZXIuPC9zbWFsbD48L2gyPiA8L2Rpdj4gPHRhYmxlIGlkPWRhdGEtdGFibGUtY29tbWFuZCBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS12bWlkZGxlXFxcIj4gPHRoZWFkPiA8dHI+IDx0aCBkYXRhLWNvbHVtbi1pZD1pZCBkYXRhLXR5cGU9bnVtZXJpYz5JRDwvdGg+IDx0aCBkYXRhLWNvbHVtbi1pZD1zZW5kZXI+U2VuZGVyPC90aD4gPHRoIGRhdGEtY29sdW1uLWlkPXJlY2VpdmVkIGRhdGEtb3JkZXI9ZGVzYz5SZWNlaXZlZDwvdGg+IDx0aCBkYXRhLWNvbHVtbi1pZD1jb21tYW5kcyBkYXRhLWZvcm1hdHRlcj1jb21tYW5kcyBkYXRhLXNvcnRhYmxlPWZhbHNlPkNvbW1hbmRzPC90aD4gPC90cj4gPC90aGVhZD4gPHRib2R5PiA8dHI+IDx0ZD4xMDIzODwvdGQ+IDx0ZD5lZHVhcmRvQHBpbmdwb25nLmNvbTwvdGQ+IDx0ZD4xNC4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDM8L3RkPiA8dGQ+ZWR1YXJkb0BwaW5ncG9uZy5jb208L3RkPiA8dGQ+MTkuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQ4PC90ZD4gPHRkPmVkdWFyZG9AcGluZ3BvbmcuY29tPC90ZD4gPHRkPjI0LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI1MzwvdGQ+IDx0ZD5lZHVhcmRvQHBpbmdwb25nLmNvbTwvdGQ+IDx0ZD4yOS4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyMzQ8L3RkPiA8dGQ+bGlsYUBnb29nbGUuY29tPC90ZD4gPHRkPjEwLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDIzOTwvdGQ+IDx0ZD5saWxhQGdvb2dsZS5jb208L3RkPiA8dGQ+MTUuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQ0PC90ZD4gPHRkPmxpbGFAZ29vZ2xlLmNvbTwvdGQ+IDx0ZD4yMC4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDk8L3RkPiA8dGQ+bGlsYUBnb29nbGUuY29tPC90ZD4gPHRkPjI1LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDIzNzwvdGQ+IDx0ZD5yb2JlcnRAYmluZ28uY29tPC90ZD4gPHRkPjEzLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0MjwvdGQ+IDx0ZD5yb2JlcnRAYmluZ28uY29tPC90ZD4gPHRkPjE4LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0NzwvdGQ+IDx0ZD5yb2JlcnRAYmluZ28uY29tPC90ZD4gPHRkPjIzLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI1MjwvdGQ+IDx0ZD5yb2JlcnRAYmluZ28uY29tPC90ZD4gPHRkPjI4LjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDIzNjwvdGQ+IDx0ZD5zaW1vbkB5YWhvby5jb208L3RkPiA8dGQ+MTIuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjQxPC90ZD4gPHRkPnNpbW9uQHlhaG9vLmNvbTwvdGQ+IDx0ZD4xNy4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDY8L3RkPiA8dGQ+c2ltb25AeWFob28uY29tPC90ZD4gPHRkPjIyLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI1MTwvdGQ+IDx0ZD5zaW1vbkB5YWhvby5jb208L3RkPiA8dGQ+MjcuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjM1PC90ZD4gPHRkPnRpbUBtaWNyb3NvZnQuY29tPC90ZD4gPHRkPjExLjEwLjIwMTM8L3RkPiA8L3RyPiA8dHI+IDx0ZD4xMDI0MDwvdGQ+IDx0ZD50aW1AbWljcm9zb2Z0LmNvbTwvdGQ+IDx0ZD4xNi4xMC4yMDEzPC90ZD4gPC90cj4gPHRyPiA8dGQ+MTAyNDU8L3RkPiA8dGQ+dGltQG1pY3Jvc29mdC5jb208L3RkPiA8dGQ+MjEuMTAuMjAxMzwvdGQ+IDwvdHI+IDx0cj4gPHRkPjEwMjUwPC90ZD4gPHRkPnRpbUBtaWNyb3NvZnQuY29tPC90ZD4gPHRkPjI2LjEwLjIwMTM8L3RkPiA8L3RyPiA8L3Rib2R5PiA8L3RhYmxlPiA8L2Rpdj4gPC9kaXY+IDwvc2VjdGlvbj4gPC9zZWN0aW9uPiBcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9wYWdlL2RlbW8vdHBsL2RhdGF0YWJsZXMuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMTEiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9')}});